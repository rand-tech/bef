#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
#######################################################################################
# GEF - Multi-Architecture GDB Enhanced Features for Exploiters & Reverse-Engineers
#
# original: by @_hugsy_
# improvement: by @bata_24
#
#######################################################################################
#
# GEF is a kick-ass set of commands for X86, ARM, MIPS, PowerPC and SPARC to
# make GDB cool again for exploit dev. It is aimed to be used mostly by exploit
# devs and reversers, to provides additional features to GDB using the Python
# API to assist during the process of dynamic analysis.
#
# GEF fully relies on GDB API and other Linux-specific sources of information
# (such as /proc/<pid>). As a consequence, some of the features might not work
# on custom or hardened systems such as GrSec.
#
# Since January 2020, GEF solely support GDB compiled with Python3 and was tested on
#   * x86-32 & x86-64
#   * arm v5,v6,v7
#   * aarch64 (armv8)
#   * mips & mips64
#   * powerpc & powerpc64
#   * sparc & sparc64(v9)
#
# For GEF with Python2 (only) support was moved to the GEF-Legacy
# (https://github.com/hugsy/gef-legacy)
#
# To start: in gdb, type `source /path/to/gef.py`
#
#######################################################################################
#
# gef is distributed under the MIT License (MIT)
# Copyright (c) 2013-2022 crazy rabbidz
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

from __future__ import print_function, division, absolute_import

import abc
import binascii
import codecs
import collections
import ctypes
import functools
import getopt
import hashlib
import inspect
import itertools
import os
import platform
import re
import site
import socket
import string
import struct
import subprocess
import sys
import tempfile
import time
import traceback
import configparser
import psutil
import math
import json
import timeout

from functools import lru_cache
from io import StringIO
from urllib.request import urlopen

LEFT_ARROW = " <- "
RIGHT_ARROW = " -> "
DOWN_ARROW = "v"
HORIZONTAL_LINE = "-"
VERTICAL_LINE = "|"
BP_GLYPH = "*"
GEF_PROMPT = "gef> "
GEF_PROMPT_ON = "\001\033[1;32m\002{0:s}\001\033[0m\002".format(GEF_PROMPT)
GEF_PROMPT_OFF = "\001\033[1;31m\002{0:s}\001\033[0m\002".format(GEF_PROMPT)


def http_get(url):
    """Basic HTTP wrapper for GET request. Return the body of the page if HTTP code is OK,
    otherwise return None."""
    try:
        http = urlopen(url)
        if http.getcode() != 200:
            return None
        return http.read()
    except Exception:
        return None


def update_gef(argv):
    """Try to update `gef` to the latest version pushed on GitHub master branch.
    Return 0 on success, 1 on failure. """
    gef_local = os.path.realpath(argv[0])
    hash_gef_local = hashlib.sha512(open(gef_local, "rb").read()).digest()
    gef_remote = "https://raw.githubusercontent.com/bata24/gef/dev/gef.py"
    gef_remote_data = http_get(gef_remote)
    if gef_remote_data is None:
        print("[-] Failed to get remote gef")
        return 1

    hash_gef_remote = hashlib.sha512(gef_remote_data).digest()
    if hash_gef_local == hash_gef_remote:
        print("[-] No update")
    else:
        with open(gef_local, "wb") as f:
            f.write(gef_remote_data)
        print("[+] Updated")
    return 0


try:
    import gdb
except ImportError:
    # if out of gdb, the only action allowed is to update gef.py
    if len(sys.argv) == 2 and sys.argv[1].lower() in ("--update", "--upgrade", "-u"):
        sys.exit(update_gef(sys.argv))
    print("[-] gef cannot run as standalone")
    sys.exit(0)

__gef__                                = None
__commands__                           = []
__functions__                          = []
__aliases__                            = []
__config__                             = {}
__watches__                            = {}
__gef_convenience_vars_index__         = 0
__context_messages__                   = []
__heap_allocated_list__                = []
__heap_freed_list__                    = []
__heap_uaf_watchpoints__               = []
__pie_breakpoints__                    = {}
__pie_counter__                        = 1
__gef_qemu_mode__                      = False
__gef_default_main_arena__             = "main_arena"
__gef_int_stream_buffer__              = None
__gef_redirect_output_fd__             = None

DEFAULT_PAGE_ALIGN_SHIFT               = 12
DEFAULT_PAGE_SIZE                      = 1 << DEFAULT_PAGE_ALIGN_SHIFT
GEF_RC                                 = os.getenv("GEF_RC") or os.path.join(os.getenv("HOME") or "~", ".gef.rc")
GEF_TEMP_DIR                           = os.path.join(tempfile.gettempdir(), "gef")
GEF_MAX_STRING_LENGTH                  = 50

GDB_MIN_VERSION                        = (7, 7)
GDB_VERSION                            = tuple(map(int, re.search(r"(\d+)[^\d]+(\d+)", gdb.VERSION).groups()))

current_elf  = None
current_arch = None

libc_args_definitions = {}

highlight_table = {}
ANSI_SPLIT_RE = r"(\033\[[\d;]*m)"


def reset_all_caches():
    """Free all caches. If an object is cached, it will have a callable attribute `cache_clear`
    which will be invoked to purge the function cache."""
    global __gef_default_main_arena__

    for mod in dir(sys.modules["__main__"]):
        obj = getattr(sys.modules["__main__"], mod)
        if hasattr(obj, "cache_clear"):
            obj.cache_clear()

    __gef_default_main_arena__ = "main_arena"
    return


def highlight_text(text):
    """Highlight text using highlight_table { match -> color } settings.

    If RegEx is enabled it will create a match group around all items in the
    highlight_table and wrap the specified color in the highlight_table
    around those matches.

    If RegEx is disabled, split by ANSI codes and 'colorify' each match found
    within the specified string."""
    if not highlight_table:
        return text

    if get_gef_setting("highlight.regex"):
        for match, color in highlight_table.items():
            text = re.sub("(" + match + ")", Color.colorify("\\1", color), text)
        return text

    ansiSplit = re.split(ANSI_SPLIT_RE, text)

    for match, color in highlight_table.items():
        for index, val in enumerate(ansiSplit):
            found = val.find(match)
            if found > -1:
                ansiSplit[index] = val.replace(match, Color.colorify(match, color))
                break
        text = "".join(ansiSplit)
        ansiSplit = re.split(ANSI_SPLIT_RE, text)

    return "".join(ansiSplit)


def gef_print(x="", *args, **kwargs):
    """Wrapper around print(), using string buffering feature."""
    x = highlight_text(x)
    if __gef_int_stream_buffer__ and not is_debug():
        return __gef_int_stream_buffer__.write(x + kwargs.get("end", "\n"))
    return print(x, *args, **kwargs)


def bufferize(f):
    """Store the content to be printed for a function in memory, and flush it on function exit."""
    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        global __gef_int_stream_buffer__, __gef_redirect_output_fd__

        if __gef_int_stream_buffer__:
            return f(*args, **kwargs)

        __gef_int_stream_buffer__ = StringIO()
        try:
            rv = f(*args, **kwargs)
        finally:
            redirect = get_gef_setting("context.redirect")
            if redirect.startswith("/dev/pts/"):
                if not __gef_redirect_output_fd__:
                    # if the FD has never been open, open it
                    fd = open(redirect, "wt")
                    __gef_redirect_output_fd__ = fd
                elif redirect != __gef_redirect_output_fd__.name:
                    # if the user has changed the redirect setting during runtime, update the state
                    __gef_redirect_output_fd__.close()
                    fd = open(redirect, "wt")
                    __gef_redirect_output_fd__ = fd
                else:
                    # otherwise, keep using it
                    fd = __gef_redirect_output_fd__
            else:
                fd = sys.stdout
                __gef_redirect_output_fd__ = None

            if __gef_redirect_output_fd__ and fd.closed:
                # if the tty was closed, revert back to stdout
                fd = sys.stdout
                __gef_redirect_output_fd__ = None
                set_gef_setting("context.redirect", "")

            fd.write(__gef_int_stream_buffer__.getvalue())
            fd.flush()
            __gef_int_stream_buffer__ = None
        return rv

    return wrapper


class Color:
    """Used to colorify terminal output."""
    colors = {
        "normal"         : "\033[0m",
        "gray"           : "\033[1;38;5;240m",
        "light_gray"     : "\033[0;37m",
        "red"            : "\033[31m",
        "green"          : "\033[32m",
        "yellow"         : "\033[33m",
        "blue"           : "\033[34m",
        "pink"           : "\033[35m",
        "cyan"           : "\033[36m",
        "bold"           : "\033[1m",
        "underline"      : "\033[4m",
        "underline_off"  : "\033[24m",
        "highlight"      : "\033[3m",
        "highlight_off"  : "\033[23m",
        "blink"          : "\033[5m",
        "blink_off"      : "\033[25m",
    }

    @staticmethod
    def redify(msg):
        return Color.colorify(msg, "red")

    @staticmethod
    def greenify(msg):
        return Color.colorify(msg, "green")

    @staticmethod
    def blueify(msg):
        return Color.colorify(msg, "blue")

    @staticmethod
    def yellowify(msg):
        return Color.colorify(msg, "yellow")

    @staticmethod
    def grayify(msg):
        return Color.colorify(msg, "gray")

    @staticmethod
    def light_grayify(msg):
        return Color.colorify(msg, "light_gray")

    @staticmethod
    def pinkify(msg):
        return Color.colorify(msg, "pink")

    @staticmethod
    def cyanify(msg):
        return Color.colorify(msg, "cyan")

    @staticmethod
    def boldify(msg):
        return Color.colorify(msg, "bold")

    @staticmethod
    def underlinify(msg):
        return Color.colorify(msg, "underline")

    @staticmethod
    def highlightify(msg):
        return Color.colorify(msg, "highlight")

    @staticmethod
    def blinkify(msg):
        return Color.colorify(msg, "blink")

    @staticmethod
    def colorify(text, attrs):
        """Color text according to the given attributes."""
        if get_gef_setting("gef.disable_color") is True:
            return text

        colors = Color.colors
        msg = [colors[attr] for attr in attrs.split() if attr in colors]
        msg.append(str(text))
        if colors["highlight"] in msg:
            msg.append(colors["highlight_off"])
        if colors["underline"] in msg:
            msg.append(colors["underline_off"])
        if colors["blink"] in msg:
            msg.append(colors["blink_off"])
        msg.append(colors["normal"])
        return "".join(msg)


class Address:
    """GEF representation of memory addresses."""
    def __init__(self, *args, **kwargs):
        self.value = kwargs.get("value", 0)
        self.section = kwargs.get("section", None)
        self.info = kwargs.get("info", None)
        self.valid = kwargs.get("valid", True)
        return

    def __str__(self):
        value = format_address(self.value)
        if self.is_in_text_segment():
            code_color = get_gef_setting("theme.address_code")
            return Color.colorify(value, code_color)
        if self.is_in_heap_segment():
            heap_color = get_gef_setting("theme.address_heap")
            return Color.colorify(value, heap_color)
        if self.is_in_stack_segment():
            stack_color = get_gef_setting("theme.address_stack")
            return Color.colorify(value, stack_color)
        return value

    def is_in_text_segment(self):
        return (hasattr(self.info, "name") and ".text" in self.info.name) or \
            (hasattr(self.section, "path") and get_filepath() == self.section.path and self.section.is_executable())

    def is_in_stack_segment(self):
        return hasattr(self.section, "path") and "[stack]" == self.section.path

    def is_in_heap_segment(self):
        return hasattr(self.section, "path") and "[heap]" == self.section.path

    def dereference(self):
        addr = align_address(int(self.value))
        derefed = dereference(addr)
        return None if derefed is None else int(derefed)


class Permission:
    """GEF representation of Linux permission."""
    NONE    = 0
    READ    = 1
    WRITE   = 2
    EXECUTE = 4
    ALL     = READ | WRITE | EXECUTE

    def __init__(self, **kwargs):
        self.value = kwargs.get("value", 0)
        return

    def __or__(self, value):
        return self.value | value

    def __and__(self, value):
        return self.value & value

    def __xor__(self, value):
        return self.value ^ value

    def __eq__(self, value):
        return self.value == value

    def __ne__(self, value):
        return self.value != value

    def __str__(self):
        perm_str = ""
        perm_str += "r" if self & Permission.READ else "-"
        perm_str += "w" if self & Permission.WRITE else "-"
        perm_str += "x" if self & Permission.EXECUTE else "-"
        return perm_str

    @staticmethod
    def from_info_sections(*args):
        perm = Permission()
        for arg in args:
            if "READONLY" in arg:
                perm.value += Permission.READ
            if "DATA" in arg:
                perm.value += Permission.WRITE
            if "CODE" in arg:
                perm.value += Permission.EXECUTE
        return perm

    @staticmethod
    def from_process_maps(perm_str):
        perm = Permission()
        if perm_str[0] == "r":
            perm.value += Permission.READ
        if perm_str[1] == "w":
            perm.value += Permission.WRITE
        if perm_str[2] == "x":
            perm.value += Permission.EXECUTE
        return perm


class Section:
    """GEF representation of process memory sections."""
    def __init__(self, *args, **kwargs):
        self.page_start = kwargs.get("page_start")
        self.page_end = kwargs.get("page_end")
        self.offset = kwargs.get("offset")
        self.permission = kwargs.get("permission")
        self.inode = kwargs.get("inode")
        self.path = kwargs.get("path")
        return

    def is_readable(self):
        return self.permission.value and self.permission.value & Permission.READ

    def is_writable(self):
        return self.permission.value and self.permission.value & Permission.WRITE

    def is_executable(self):
        return self.permission.value and self.permission.value & Permission.EXECUTE

    @property
    def size(self):
        if self.page_end is None or self.page_start is None:
            return -1
        return self.page_end - self.page_start

    @property
    def realpath(self):
        return self.path


Zone = collections.namedtuple("Zone", ["name", "zone_start", "zone_end", "filename"])


class Elf:
    """Basic ELF parsing.
    Ref:
    - http://www.skyfree.org/linux/references/ELF_Format.pdf
    - http://refspecs.freestandards.org/elf/elfspec_ppc.pdf
    - http://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi.html"""
    LITTLE_ENDIAN     = 1
    BIG_ENDIAN        = 2

    ELF_32_BITS       = 0x01
    ELF_64_BITS       = 0x02
    ELF_MAGIC         = 0x7f454c46

    X86_64            = 0x3e
    X86_32            = 0x03
    ARM               = 0x28
    MIPS              = 0x08
    POWERPC           = 0x14
    POWERPC64         = 0x15
    SPARC             = 0x02
    SPARC64           = 0x2b
    AARCH64           = 0xb7
    RISCV             = 0xf3
    IA64              = 0x32

    ET_RELOC          = 1
    ET_EXEC           = 2
    ET_DYN            = 3
    ET_CORE           = 4

    OSABI_SYSTEMV     = 0x00
    OSABI_HPUX        = 0x01
    OSABI_NETBSD      = 0x02
    OSABI_LINUX       = 0x03
    OSABI_SOLARIS     = 0x06
    OSABI_AIX         = 0x07
    OSABI_IRIX        = 0x08
    OSABI_FREEBSD     = 0x09
    OSABI_OPENBSD     = 0x0C

    e_magic           = ELF_MAGIC
    e_class           = ELF_32_BITS
    e_endianness      = LITTLE_ENDIAN
    e_eiversion       = None
    e_osabi           = None
    e_abiversion      = None
    e_pad             = None
    e_type            = ET_EXEC
    e_machine         = X86_32
    e_version         = None
    e_entry           = 0x00
    e_phoff           = None
    e_shoff           = None
    e_flags           = None
    e_ehsize          = None
    e_phentsize       = None
    e_phnum           = None
    e_shentsize       = None
    e_shnum           = None
    e_shstrndx        = None

    def __init__(self, elf="", minimalist=False):
        """Instantiate an ELF object. The default behavior is to create the object by parsing the ELF file.
        But in some cases (QEMU-stub), we may just want a simple minimal object with default values."""
        if minimalist:
            return

        if isinstance(elf, str):
            if not os.access(elf, os.R_OK):
                err("'{0}' not found/readable".format(elf))
                err("Failed to get file debug information, most of gef features will not work")
                self.e_magic = None
                return
            self.fd = open(elf, "rb")
            self.addr = None
            self.pos = 0
            self.filename = elf
        elif isinstance(elf, int):
            self.fd = None
            self.addr = elf
            self.pos = 0
            self.filename = None
        else:
            raise

        # off 0x0
        self.e_magic, self.e_class, self.e_endianness, self.e_eiversion = struct.unpack(">IBBB", self.read(7))
        # adjust endianness in bin reading
        endian = "<" if self.e_endianness == Elf.LITTLE_ENDIAN else ">"
        # off 0x7
        self.e_osabi, self.e_abiversion = struct.unpack("{}BB".format(endian), self.read(2))
        # off 0x9
        self.e_pad = self.read(7)
        # off 0x10
        self.e_type, self.e_machine, self.e_version = struct.unpack("{}HHI".format(endian), self.read(8))
        # off 0x18
        if self.e_class == Elf.ELF_64_BITS:
            # if arch 64bits
            self.e_entry, self.e_phoff, self.e_shoff = struct.unpack("{}QQQ".format(endian), self.read(24))
        else:
            # else arch 32bits
            self.e_entry, self.e_phoff, self.e_shoff = struct.unpack("{}III".format(endian), self.read(12))
        self.e_flags, self.e_ehsize, self.e_phentsize, self.e_phnum = struct.unpack("{}IHHH".format(endian), self.read(10))
        self.e_shentsize, self.e_shnum, self.e_shstrndx = struct.unpack("{}HHH".format(endian), self.read(6))
        # phdr
        self.phdrs = []
        for i in range(self.e_phnum):
            self.phdrs.append(Phdr(self, self.e_phoff + self.e_phentsize * i))
        # shdr
        self.shdrs = []
        for i in range(self.e_shnum):
            try:
                self.shdrs.append(Shdr(self, self.e_shoff + self.e_shentsize * i))
            except:
                # Perspective failure. Probably it occurs when parsing ELF loaded into memory.
                # Even if the ELF is loaded, the section header is not loaded. Therefore, it is ignored.
                self.shdrs = []
                break
        else:
            # The existence of multiple SHT_NULLs is assumed to be abnormal, and an error is raised.
            if sum([x.sh_type == Shdr.SHT_NULL for x in self.shdrs]) > 1:
                self.shdrs = []

        if self.fd is not None:
            self.fd.close()
            self.fd = None
        return

    def read(self, size):
        if self.fd is not None:
            v = self.fd.read(size)
        elif self.addr is not None:
            v = read_memory(self.addr + self.pos, size)
        else:
            raise
        self.pos += size
        return v

    def seek(self, off):
        if self.fd is not None:
            self.fd.seek(off, 0)
        elif self.addr is not None:
            self.pos = off
        else:
            raise
        return

    def is_valid(self):
        return self.e_magic == Elf.ELF_MAGIC


class Phdr:
    PT_NULL         = 0
    PT_LOAD         = 1
    PT_DYNAMIC      = 2
    PT_INTERP       = 3
    PT_NOTE         = 4
    PT_SHLIB        = 5
    PT_PHDR         = 6
    PT_TLS          = 7
    PT_LOOS         = 0x60000000
    PT_GNU_EH_FRAME = 0x6474e550
    PT_GNU_STACK    = 0x6474e551
    PT_GNU_RELRO    = 0x6474e552
    PT_LOSUNW       = 0x6ffffffa
    PT_SUNWBSS      = 0x6ffffffa
    PT_SUNWSTACK    = 0x6ffffffb
    PT_HISUNW       = 0x6fffffff
    PT_HIOS         = 0x6fffffff
    PT_LOPROC       = 0x70000000
    PT_HIPROC       = 0x7fffffff

    PF_X            = 1
    PF_W            = 2
    PF_R            = 4

    p_type   = None
    p_flags  = None
    p_offset = None
    p_vaddr  = None
    p_paddr  = None
    p_filesz = None
    p_memsz  = None
    p_align  = None

    def __init__(self, elf, off):
        if elf is None:
            return None
        elf.seek(off)
        endian = "<" if elf.e_endianness == Elf.LITTLE_ENDIAN else ">"
        if elf.e_class == Elf.ELF_64_BITS:
            self.p_type, self.p_flags, self.p_offset = struct.unpack("{}IIQ".format(endian), elf.read(16))
            self.p_vaddr, self.p_paddr = struct.unpack("{}QQ".format(endian), elf.read(16))
            self.p_filesz, self.p_memsz, self.p_align = struct.unpack("{}QQQ".format(endian), elf.read(24))
        else:
            self.p_type, self.p_offset = struct.unpack("{}II".format(endian), elf.read(8))
            self.p_vaddr, self.p_paddr = struct.unpack("{}II".format(endian), elf.read(8))
            self.p_filesz, self.p_memsz, self.p_flags, self.p_align = struct.unpack("{}IIII".format(endian), elf.read(16))


class Shdr:
    SHT_NULL             = 0
    SHT_PROGBITS         = 1
    SHT_SYMTAB           = 2
    SHT_STRTAB           = 3
    SHT_RELA             = 4
    SHT_HASH             = 5
    SHT_DYNAMIC          = 6
    SHT_NOTE             = 7
    SHT_NOBITS           = 8
    SHT_REL              = 9
    SHT_SHLIB            = 10
    SHT_DYNSYM           = 11
    SHT_NUM              = 12
    SHT_INIT_ARRAY       = 14
    SHT_FINI_ARRAY       = 15
    SHT_PREINIT_ARRAY    = 16
    SHT_GROUP            = 17
    SHT_SYMTAB_SHNDX     = 18
    SHT_NUM              = 19
    SHT_LOOS             = 0x60000000
    SHT_GNU_ATTRIBUTES   = 0x6ffffff5
    SHT_GNU_HASH         = 0x6ffffff6
    SHT_GNU_LIBLIST      = 0x6ffffff7
    SHT_CHECKSUM         = 0x6ffffff8
    SHT_LOSUNW           = 0x6ffffffa
    SHT_SUNW_move        = 0x6ffffffa
    SHT_SUNW_COMDAT      = 0x6ffffffb
    SHT_SUNW_syminfo     = 0x6ffffffc
    SHT_GNU_verdef       = 0x6ffffffd
    SHT_GNU_verneed      = 0x6ffffffe
    SHT_GNU_versym       = 0x6fffffff
    SHT_HISUNW           = 0x6fffffff
    SHT_HIOS             = 0x6fffffff
    SHT_LOPROC           = 0x70000000
    SHT_HIPROC           = 0x7fffffff
    SHT_LOUSER           = 0x80000000
    SHT_HIUSER           = 0x8fffffff

    SHF_WRITE            = 1
    SHF_ALLOC            = 2
    SHF_EXECINSTR        = 4
    SHF_MERGE            = 0x10
    SHF_STRINGS          = 0x20
    SHF_INFO_LINK        = 0x40
    SHF_LINK_ORDER       = 0x80
    SHF_OS_NONCONFORMING = 0x100
    SHF_GROUP            = 0x200
    SHF_TLS              = 0x400
    SHF_COMPRESSED       = 0x800
    SHF_RELA_LIVEPATCH   = 0x00100000
    SHF_RO_AFTER_INIT    = 0x00200000
    SHF_ORDERED          = 0x40000000
    SHF_EXCLUDE          = 0x80000000

    sh_name      = None
    sh_type      = None
    sh_flags     = None
    sh_addr      = None
    sh_offset    = None
    sh_size      = None
    sh_link      = None
    sh_info      = None
    sh_addralign = None
    sh_entsize   = None

    def __init__(self, elf, off):
        if elf is None:
            return None
        elf.seek(off)
        endian = "<" if elf.e_endianness == Elf.LITTLE_ENDIAN else ">"
        if elf.e_class == Elf.ELF_64_BITS:
            self.sh_name, self.sh_type, self.sh_flags = struct.unpack("{}IIQ".format(endian), elf.read(16))
            self.sh_addr, self.sh_offset = struct.unpack("{}QQ".format(endian), elf.read(16))
            self.sh_size, self.sh_link, self.sh_info = struct.unpack("{}QII".format(endian), elf.read(16))
            self.sh_addralign, self.sh_entsize = struct.unpack("{}QQ".format(endian), elf.read(16))
        else:
            self.sh_name, self.sh_type, self.sh_flags = struct.unpack("{}III".format(endian), elf.read(12))
            self.sh_addr, self.sh_offset = struct.unpack("{}II".format(endian), elf.read(8))
            self.sh_size, self.sh_link, self.sh_info = struct.unpack("{}III".format(endian), elf.read(12))
            self.sh_addralign, self.sh_entsize = struct.unpack("{}II".format(endian), elf.read(8))

        stroff = elf.e_shoff + elf.e_shentsize * elf.e_shstrndx

        if elf.e_class == Elf.ELF_64_BITS:
            elf.seek(stroff + 16 + 8)
            offset = struct.unpack("{}Q".format(endian), elf.read(8))[0]
        else:
            elf.seek(stroff + 12 + 4)
            offset = struct.unpack("{}I".format(endian), elf.read(4))[0]
        elf.seek(offset + self.sh_name)
        self.sh_name = ""
        while True:
            c = ord(elf.read(1))
            if c == 0:
                break
            self.sh_name += chr(c)
        return


class Instruction:
    """GEF representation of a CPU instruction."""
    def __init__(self, address, location, mnemo, operands, opcodes):
        # example:
        #   address: 0x55555555a7d0
        #   location: "" or "<main+0>"
        #   mnemo: "lea"
        #   operands: ['rcx', '[rip+0x11ee5]        # 0x55555556c69a']
        #   opcodes: b'H\x8d\r\xe5\x1e\x01\x00'
        self.address, self.location, self.mnemonic, self.operands, self.opcodes = address, location, mnemo, operands, opcodes
        return

    # Allow formatting an instruction with {:o} to show opcodes.
    # The number of bytes to display can be configured, e.g. {:4o} to only show 4 bytes of the opcodes
    def __format__(self, format_spec):
        if len(format_spec) == 0 or format_spec[-1] != "o":  # format_spec example: "4o"
            return str(self)

        # format opcode
        if format_spec == "o": # no specifed length
            opcodes_len = len(self.opcodes)
        else:
            opcodes_len = int(format_spec[:-1])
        opcodes_text = "".join("{:02x}".format(b) for b in self.opcodes) # ex:"488d0de51e0100"
        # ex1: spec:"4o", opcodes:01020304   -> 01020304
        # ex2: spec:"4o", opcodes:0102030405 -> 010203..
        if opcodes_len < len(self.opcodes):
            opcodes_text = opcodes_text[:opcodes_len * 2 - 2] + ".."

        # format location
        location = self.smartify_text(self.location)
        if not location:
            location = "<NO_SYMBOL>"
        else:
            r = re.search(r"<(.+)\+(\d+)>", location)
            if r:
                location = "<{}+{:#x}>".format(r.group(1), int(r.group(2)))

        # format operands
        operands = self.smartify_text(", ".join(self.operands))
        r = re.search(r"(.*?)<(.+)\+(\d+)>(.*?)", operands)
        if r:
            operands = "{}<{}+{:#x}>{}".format(r.group(1), r.group(2), int(r.group(3)), r.group(4))

        # resolve symbol
        sym = ""

        # ex: call 0xXXXX
        if sym == "" and (is_x86_32() or is_x86_64() or is_arm64()) and len(self.operands) > 0:
            try:
                reference_addr = self.operands[-1].replace("#", "")
                ret = gdb_get_location_from_symbol(int(reference_addr, 0))
                if ret is None:
                    sym = ""
                elif ret[1] == 0:
                    sym = "<{}>".format(ret[0])
                else:
                    sym = "<{}+{:#x}>".format(ret[0], ret[1])
            except:
                pass

        # ex: lea rax, [rip + 0xXXXX]
        if sym == "" and is_x86_64() and len(self.operands) > 0:
            try:
                m = re.match(r"\[rip \+ (0x\w+)\]", self.operands[-1])
                reference_addr = self.address + len(self.opcodes) + int(m.group(1), 0)
                ret = gdb_get_location_from_symbol(reference_addr)
                if ret is None:
                    sym = ""
                elif ret[1] == 0:
                    sym = "# {:#x} <{}>".format(reference_addr, ret[0])
                else:
                    sym = "# {:#x} <{}+{:#x}>".format(reference_addr, ret[0], ret[1])
            except:
                pass

        # ex: b #0xXXXX
        if sym == "" and is_arm32() and len(self.operands) > 0:
            try:
                m = re.match(r"#(\w+)", self.operands[-1])
                ret = gdb_get_location_from_symbol(int(m.group(1), 0))
                if ret is None:
                    sym = ""
                elif ret[1] == 0:
                    sym = "<{}>".format(ret[0])
                else:
                    sym = "<{}+{:#x}>".format(ret[0], ret[1])
            except:
                pass

        # ex: ldr r0, [pc, #0xXXXX]
        if sym == "" and is_arm32() and len(self.operands) > 1:
            try:
                m = re.match(r"\[pc,#(\w+)\]", ','.join(self.operands[-2:]))
                reference_addr = self.address + len(self.opcodes) + int(m.group(1), 0)
                ret = gdb_get_location_from_symbol(reference_addr)
                if ret is None:
                    sym = ""
                elif ret[1] == 0:
                    sym = "; {:#x} <{}>".format(reference_addr, ret[0])
                else:
                    sym = "; {:#x} <{}+{:#x}>".format(reference_addr, ret[0], ret[1])
            except:
                pass

        # formatting
        fmt = "{:#10x} {:{:d}}   {:20}   {:6} {:s} {:s}"
        return fmt.format(self.address, opcodes_text, opcodes_len * 2, location, self.mnemonic, operands, sym)

    def __str__(self):
        location = self.smartify_text(self.location)
        if not location:
            location = "<NO_SYMBOL>"
        operands = self.smartify_text(", ".join(self.operands))
        fmt = "{:#10x} {:20} {:6} {:s}"
        return fmt.format(self.address, location, self.mnemonic, operands)

    def is_valid(self):
        return "(bad)" not in self.mnemonic

    @staticmethod
    def smartify_text(text):
        smart_cpp_function_name = get_gef_setting("context.smart_cpp_function_name")
        if not smart_cpp_function_name:
            return text

        if text is None:
            return text

        if len(text) == 0:
            return text

        text = re.sub("\bstd::__1::", "", text)

        old_text = text[::]
        while True:
            text = re.sub("\([^(]+?\)", "__MARKER_GEF__", text)
            if text == old_text:
                break
            old_text = text[::]
        text = re.sub("__MARKER_GEF__", "(...)", text)

        if text[0] == "<":
            text_0, text = text[0], text[1:]
        else:
            text_0 = ""
        if text[-1] == ">":
            text_end, text = text[-1], text[:-1]
        else:
            text_end = ""

        while True:
            text = re.sub("\<[^<]+?\>", "__MARKER_GEF__", text)
            if text == old_text:
                break
            old_text = text[::]
        text = re.sub("__MARKER_GEF__", "<...>", text)
        if text_0:
            text = text_0 + text
        if text_end:
            text = text + text_end
        return text


@lru_cache()
def search_for_main_arena():
    global __gef_default_main_arena__
    malloc_hook_addr = parse_address("(void *)&__malloc_hook")

    if is_x86():
        addr = align_address_to_size(malloc_hook_addr + current_arch.ptrsize, 0x20)
    elif is_arch(Elf.AARCH64) or is_arch(Elf.ARM):
        addr = malloc_hook_addr - current_arch.ptrsize * 2 - MallocStateStruct("*0").struct_size
    else:
        raise OSError("Cannot find main_arena for {}".format(current_arch.arch))

    __gef_default_main_arena__ = "*{:#x}".format(addr)
    return addr


class MallocStateStruct:
    """GEF representation of malloc_state from https://github.com/bminor/glibc/blob/glibc-2.28/malloc/malloc.c#L1658"""
    def __init__(self, addr):
        try:
            self.__addr = parse_address("&{}".format(addr))
        except gdb.error:
            self.__addr = search_for_main_arena()

        self.num_fastbins = 10
        self.num_bins = 254

        self.int_size = cached_lookup_type("int").sizeof
        self.size_t = cached_lookup_type("size_t")
        if not self.size_t:
            ptr_type = "unsigned long" if current_arch.ptrsize == 8 else "unsigned int"
            self.size_t = cached_lookup_type(ptr_type)

        # Account for separation of have_fastchunks flag into its own field
        # within the malloc_state struct in GLIBC >= 2.27
        # https://sourceware.org/git/?p=glibc.git;a=commit;h=e956075a5a2044d05ce48b905b10270ed4a63e87
        # Be aware you could see this change backported into GLIBC release
        # branches.
        if get_libc_version() >= (2, 27):
            self.fastbin_offset = align_address_to_size(self.int_size * 3, 8)
        else:
            self.fastbin_offset = self.int_size * 2
        return

    # struct offsets
    @property
    def addr(self):
        return self.__addr

    @property
    def fastbins_addr(self):
        return self.__addr + self.fastbin_offset

    @property
    def top_addr(self):
        return self.fastbins_addr + self.num_fastbins * current_arch.ptrsize

    @property
    def last_remainder_addr(self):
        return self.top_addr + current_arch.ptrsize

    @property
    def bins_addr(self):
        return self.last_remainder_addr + current_arch.ptrsize

    @property
    def next_addr(self):
        return self.bins_addr + self.num_bins * current_arch.ptrsize + self.int_size * 4

    @property
    def next_free_addr(self):
        return self.next_addr + current_arch.ptrsize

    @property
    def system_mem_addr(self):
        return self.next_free_addr + current_arch.ptrsize * 2

    @property
    def struct_size(self):
        return self.system_mem_addr + current_arch.ptrsize * 2 - self.__addr

    # struct members
    @property
    def fastbinsY(self):
        return self.get_size_t_array(self.fastbins_addr, self.num_fastbins)

    @property
    def top(self):
        return self.get_size_t_pointer(self.top_addr)

    @property
    def last_remainder(self):
        return self.get_size_t_pointer(self.last_remainder_addr)

    @property
    def bins(self):
        return self.get_size_t_array(self.bins_addr, self.num_bins)

    @property
    def next(self):
        return self.get_size_t_pointer(self.next_addr)

    @property
    def next_free(self):
        return self.get_size_t_pointer(self.next_free_addr)

    @property
    def system_mem(self):
        return self.get_size_t(self.system_mem_addr)

    # helper methods
    def get_size_t(self, addr):
        return dereference(addr).cast(self.size_t)

    def get_size_t_pointer(self, addr):
        size_t_pointer = self.size_t.pointer()
        return dereference(addr).cast(size_t_pointer)

    def get_size_t_array(self, addr, length):
        size_t_array = self.size_t.array(length)
        return dereference(addr).cast(size_t_array)

    def __getitem__(self, item):
        return getattr(self, item)


class GlibcArena:
    """Glibc arena class
    Ref: https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1671"""
    TCACHE_MAX_BINS = 0x40

    def __init__(self, addr, name=None):
        self.__name = name or __gef_default_main_arena__
        try:
            arena = gdb.parse_and_eval(addr)
            malloc_state_t = cached_lookup_type("struct malloc_state")
            self.__arena = arena.cast(malloc_state_t)
            self.__addr = int(arena.address)
            self.__size = malloc_state_t.sizeof
        except:
            self.__arena = MallocStateStruct(addr)
            self.__addr = self.__arena.addr
            self.__size = self.__arena.struct_size
        try:
            self.top             = int(self.top)
            self.last_remainder  = int(self.last_remainder)
            self.n               = int(self.next)
            self.nfree           = int(self.next_free)
            self.sysmem          = int(self.system_mem)
        except gdb.error as e:
            err("Glibc arena: {}".format(e))
        return

    def __getitem__(self, item):
        return self.__arena[item]

    def __getattr__(self, item):
        return self.__arena[item]

    def __int__(self):
        return self.__addr

    def is_main_arena(self):
        try:
            return self.__name == "main_arena" or self.__addr == parse_address("&main_arena")
        except:
            pass
        try:
            return self.__addr == search_for_main_arena()
        except:
            return None

    @property
    def addr(self):
        return self.__addr

    # arena aligned_size
    @property
    def size(self):
        if current_arch.ptrsize == 4:
            aligned_size = (self.__size + 7) & ~0b111
        else:
            aligned_size = (self.__size + 15) & ~0b1111
        return aligned_size

    @property
    def heap_base(self):
        if self.is_main_arena():
            return HeapBaseFunction.heap_base()
        else:
            return self.addr + self.size

    def tcachebin(self, i):
        """Return head chunk in tcache[i]."""
        if self.heap_base is None:
            return None
        if get_libc_version() < (2, 30):
            addr = dereference(self.heap_base + 0x10 + self.TCACHE_MAX_BINS + i*current_arch.ptrsize)
        else:
            addr = dereference(self.heap_base + 0x10 + 2*self.TCACHE_MAX_BINS + i*current_arch.ptrsize)
        if not addr:
            return None
        return GlibcChunk(int(addr))

    def fastbin(self, i):
        """Return head chunk in fastbinsY[i]."""
        addr = int(self.fastbinsY[i])
        if addr == 0:
            return None
        return GlibcChunk(addr + 2 * current_arch.ptrsize)

    def bin(self, i):
        idx = i * 2
        fd = int(self.bins[idx])
        bw = int(self.bins[idx + 1])
        return fd, bw

    def get_next(self):
        addr_next = int(self.next)
        arena_main = GlibcArena(self.__name)
        if addr_next == arena_main.__addr:
            return None
        return GlibcArena("*{:#x} ".format(addr_next))

    def __str__(self):
        fmt = "Arena (base={:#x}, top={:#x}, last_remainder={:#x}, next={:#x}, next_free={:#x}, system_mem={:#x})"
        return fmt.format(self.__addr, self.top, self.last_remainder, self.n, self.nfree, self.sysmem)

    def tcache_list(self):
        if get_libc_version() < (2, 26):
            info("No Tcache in this version of libc")
            return {}
        if self.heap_base is None:
            return {}

        chunks_all = {}
        for i in range(self.TCACHE_MAX_BINS):
            chunk = self.tcachebin(i)
            chunks = set()
            while True:
                if chunk is None:
                    break
                try:
                    if chunk.address in chunks:
                        break # loop detected
                    chunks.add(chunk.address)
                    next_chunk = chunk.get_fwd_ptr(True)
                    if next_chunk == 0:
                        break
                    chunk = GlibcChunk(next_chunk)
                except gdb.MemoryError:
                    break
            chunks_all[i] = chunks
        return chunks_all

    def fastbin_list(self):
        def fastbin_index(sz):
            return (sz >> 4) - 2 if SIZE_SZ == 8 else (sz >> 3) - 2

        SIZE_SZ = current_arch.ptrsize
        MAX_FAST_SIZE = (80 * SIZE_SZ // 4)
        NFASTBINS = fastbin_index(MAX_FAST_SIZE) - 1
        chunks_all = {}
        for i in range(NFASTBINS):
            chunk = self.fastbin(i)
            chunks = set()
            while True:
                if chunk is None:
                    break
                try:
                    if chunk.address in chunks:
                        break # loop detected
                    chunks.add(chunk.address)
                    next_chunk = chunk.get_fwd_ptr(True)
                    if next_chunk == 0:
                        break
                    chunk = GlibcChunk(next_chunk, from_base=True)
                except gdb.MemoryError:
                    break
            chunks_all[i] = chunks
        return chunks_all

    def bin_list(self, index):
        fw, bk = self.bin(index)
        if bk == 0x00 and fw == 0x00:
            return set() # invalid
        head = GlibcChunk(bk, from_base=True).fwd
        if fw == head:
            return set() # no entry
        chunks = set()
        while fw != head:
            chunk = GlibcChunk(fw, from_base=True)
            chunks.add(chunk.address)
            fw = chunk.fwd
        return chunks

    def unsortedbin_list(self):
        chunks_all = {}
        chunks_all[0] = self.bin_list(0)
        return chunks_all

    def smallbin_list(self):
        chunks_all = {}
        for i in range(1, 63):
            chunks_all[i] = self.bin_list(i)
        return chunks_all

    def largebin_list(self):
        chunks_all = {}
        for i in range(63, 126):
            chunks_all[i] = self.bin_list(i)
        return chunks_all


class GlibcChunk:
    """Glibc chunk class.
    Ref: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/."""
    def __init__(self, addr, from_base=False):
        self.ptrsize = current_arch.ptrsize
        if from_base:
            self.chunk_base_address = addr
            self.address = addr + 2 * self.ptrsize
        else:
            self.chunk_base_address = int(addr - 2 * self.ptrsize)
            self.address = addr

        self.size_addr = int(self.address - self.ptrsize)
        self.prev_size_addr = self.chunk_base_address
        return

    def get_chunk_size(self):
        return read_int_from_memory(self.size_addr) & (~0x07)

    @property
    def size(self):
        return self.get_chunk_size()

    def get_usable_size(self):
        # https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L4537
        cursz = self.get_chunk_size()
        if cursz == 0: return cursz
        if self.has_m_bit(): return cursz - 2 * self.ptrsize
        return cursz - self.ptrsize

    @property
    def usable_size(self):
        return self.get_usable_size()

    def get_prev_chunk_size(self):
        return read_int_from_memory(self.prev_size_addr)

    def get_next_chunk(self):
        addr = self.address + self.get_chunk_size()
        return GlibcChunk(addr)

    # if free-ed functions
    def get_fwd_ptr(self, sll):
        # Not a single-linked-list (sll) or no Safe-Linking support yet
        if not sll or get_libc_version() < (2, 32):
            return read_int_from_memory(self.address)
        # Unmask ("reveal") the Safe-Linking pointer
        else:
            return read_int_from_memory(self.address) ^ (self.address >> 12)

    @property
    def fwd(self):
        return self.get_fwd_ptr(False)

    fd = fwd # for compat

    def get_bkw_ptr(self):
        return read_int_from_memory(self.address + self.ptrsize)

    @property
    def bck(self):
        return self.get_bkw_ptr()

    bk = bck # for compat

    def get_fd_nextsize_ptr(self):
        return read_int_from_memory(self.address + self.ptrsize * 2)

    @property
    def fd_nextsize(self):
        return self.get_fd_nextsize_ptr()

    def get_bk_nextsize_ptr(self):
        return read_int_from_memory(self.address + self.ptrsize * 3)

    @property
    def bk_nextsize(self):
        return self.get_bk_nextsize_ptr()
    # endif free-ed functions

    def has_p_bit(self):
        return read_int_from_memory(self.size_addr) & 0x01

    def has_m_bit(self):
        return read_int_from_memory(self.size_addr) & 0x02

    def has_n_bit(self):
        return read_int_from_memory(self.size_addr) & 0x04

    def is_used(self):
        """Check if the current block is used by:
        - checking the M bit is true
        - or checking that next chunk PREV_INUSE flag is true"""
        if self.has_m_bit():
            return True

        next_chunk = self.get_next_chunk()
        return True if next_chunk.has_p_bit() else False

    def str_chunk_size_flag(self):
        msg = []
        msg.append("PREV_INUSE flag: {}".format(Color.greenify("On") if self.has_p_bit() else Color.redify("Off")))
        msg.append("IS_MMAPPED flag: {}".format(Color.greenify("On") if self.has_m_bit() else Color.redify("Off")))
        msg.append("NON_MAIN_ARENA flag: {}".format(Color.greenify("On") if self.has_n_bit() else Color.redify("Off")))
        return "\n".join(msg)

    def _str_sizes(self):
        msg = []
        failed = False

        try:
            msg.append("Chunk size: {0:d} ({0:#x})".format(self.get_chunk_size()))
            msg.append("Usable size: {0:d} ({0:#x})".format(self.get_usable_size()))
            failed = True
        except gdb.MemoryError:
            msg.append("Chunk size: Cannot read at {:#x} (corrupted?)".format(self.size_addr))

        try:
            msg.append("Previous chunk size: {0:d} ({0:#x})".format(self.get_prev_chunk_size()))
            failed = True
        except gdb.MemoryError:
            msg.append("Previous chunk size: Cannot read at {:#x} (corrupted?)".format(self.chunk_base_address))

        if failed:
            msg.append(self.str_chunk_size_flag())

        return "\n".join(msg)

    def _str_pointers(self):
        fwd = self.address
        bkw = self.address + self.ptrsize

        msg = []
        try:
            msg.append("Forward pointer: {0:#x}".format(self.get_fwd_ptr(False)))
        except gdb.MemoryError:
            msg.append("Forward pointer: {0:#x} (corrupted?)".format(fwd))

        try:
            msg.append("Backward pointer: {0:#x}".format(self.get_bkw_ptr()))
        except gdb.MemoryError:
            msg.append("Backward pointer: {0:#x} (corrupted?)".format(bkw))

        return "\n".join(msg)

    def str_as_alloced(self):
        return self._str_sizes()

    def str_as_freed(self):
        return "{}\n\n{}".format(self._str_sizes(), self._str_pointers())

    def flags_as_string(self):
        flags = []
        if self.has_p_bit():
            flags.append(Color.colorify("PREV_INUSE", "red bold"))
        if self.has_m_bit():
            flags.append(Color.colorify("IS_MMAPPED", "blue bold"))
        if self.has_n_bit():
            flags.append(Color.colorify("NON_MAIN_ARENA", "yellow bold"))
        return "|".join(flags)

    def __str__(self):
        chunk_c = Color.colorify("Chunk", "yellow bold underline")
        size_c = Color.colorify("{:#x}".format(self.get_chunk_size()), "bold pink")
        msg = "{:s}(addr={:#x}, size={:s}, flags={:s})".format(chunk_c, int(self.address), size_c, self.flags_as_string())
        return msg

    def str_large(self):
        chunk_c = Color.colorify("Chunk", "yellow bold underline")
        fmt = "{:s}(addr={:#x}, size={:#x}, flags={:s}, fd_nextsize={:#x}, bk_nextsize={:#x})"
        msg = fmt.format(chunk_c, int(self.address), self.get_chunk_size(), self.flags_as_string(), self.fd_nextsize, self.bk_nextsize)
        return msg

    def psprint(self):
        msg = []
        msg.append(str(self))
        if self.is_used():
            msg.append(self.str_as_alloced())
        else:
            msg.append(self.str_as_freed())
        return "\n".join(msg) + "\n"


pattern_libc_ver = re.compile(rb"glibc (\d+)\.(\d+)")


@lru_cache()
def get_libc_version():
    sections = get_process_maps()
    for section in sections:
        match = re.search(r"libc6?[-_](\d+)\.(\d+)\.so", section.path)
        if match:
            return tuple(int(_) for _ in match.groups())
        if "libc" in section.path:
            try:
                with open(section.path, "rb") as f:
                    data = f.read()
            except OSError:
                continue
            match = re.search(pattern_libc_ver, data)
            if match:
                return tuple(int(_) for _ in match.groups())
    return 0, 0


def get_main_arena():
    try:
        return GlibcArena(__gef_default_main_arena__)
    except Exception as e:
        err("Failed to get the main arena, heap commands may not work properly: {}".format(e))
        return None


def titlify(text, color=None, msg_color=None):
    """Print a centered title."""
    cols = get_terminal_size()[1]
    nb = (cols - len(text) - 2) // 2
    if color is None:
        color = __config__.get("theme.default_title_line")[0]
    if msg_color is None:
        msg_color = __config__.get("theme.default_title_message")[0]

    msg = []
    msg.append(Color.colorify("{} ".format(HORIZONTAL_LINE * nb), color))
    msg.append(Color.colorify(text, msg_color))
    msg.append(Color.colorify(" {}".format(HORIZONTAL_LINE * nb), color))
    return "".join(msg)


def err(msg):
    gef_print("{} {}".format(Color.colorify("[!]", "bold red"), msg))
    return


def warn(msg):
    gef_print("{} {}".format(Color.colorify("[*]", "bold yellow"), msg))
    return


def ok(msg):
    gef_print("{} {}".format(Color.colorify("[+]", "bold green"), msg))
    return


def info(msg):
    gef_print("{} {}".format(Color.colorify("[+]", "bold blue"), msg))
    return


def push_context_message(level, message):
    """Push the message to be displayed the next time the context is invoked."""
    global __context_messages__
    if level not in ("error", "warn", "ok", "info"):
        err("Invalid level '{}', discarding message".format(level))
        return
    __context_messages__.append((level, message))
    return


def show_last_exception():
    """Display the last Python exception."""
    def _show_code_line(fname, idx):
        fname = os.path.expanduser(os.path.expandvars(fname))
        __data = open(fname, "r").read().splitlines()
        return __data[idx - 1] if idx < len(__data) else ""

    gef_print("")
    exc_type, exc_value, exc_traceback = sys.exc_info()

    gef_print(" Exception raised ".center(80, HORIZONTAL_LINE))
    gef_print("{}: {}".format(Color.colorify(exc_type.__name__, "bold underline red"), exc_value))
    gef_print(" Detailed stacktrace ".center(80, HORIZONTAL_LINE))

    for fs in traceback.extract_tb(exc_traceback)[::-1]:
        filename, lineno, method, code = fs

        if not code or not code.strip():
            code = _show_code_line(filename, lineno)

        gef_print("""{} File "{}", line {:d}, in {}()""".format(DOWN_ARROW, Color.yellowify(filename),
                                                                lineno, Color.greenify(method)))
        gef_print("   {}    {}".format(RIGHT_ARROW, code))

    gef_print(" Last 10 GDB commands ".center(80, HORIZONTAL_LINE))
    gdb.execute("show commands")
    gef_print(" Runtime environment ".center(80, HORIZONTAL_LINE))
    gef_print("* GDB: {}".format(gdb.VERSION))
    gef_print("* Python: {:d}.{:d}.{:d} - {:s}".format(sys.version_info.major, sys.version_info.minor,
                                                       sys.version_info.micro, sys.version_info.releaselevel))
    gef_print("* OS: {:s} - {:s} ({:s})".format(platform.system(), platform.release(), platform.machine()))

    gef_print(" lsb_release -a ".center(80, HORIZONTAL_LINE))
    try:
        lsb_release = which("lsb_release")
        gdb.execute("!{} -a".format(lsb_release,))
    except FileNotFoundError as e:
        gef_print("Cannot collect additional debug information: {}".format(e))

    gef_print(HORIZONTAL_LINE*80)
    gef_print("")
    return


def gef_pystring(x):
    """Returns a sanitized version as string of the bytes list given in input."""
    res = str(x, encoding="utf-8")
    substs = [("\n", "\\n"), ("\r", "\\r"), ("\t", "\\t"), ("\v", "\\v"), ("\b", "\\b"), ]
    for x, y in substs:
        res = res.replace(x, y)
    return res


def gef_pybytes(x):
    """Returns an immutable bytes list from the string given as input."""
    return bytes(str(x), encoding="utf-8")


@lru_cache()
def which(program):
    """Locate a command on the filesystem."""
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath = os.path.split(program)[0]
    if fpath:
        if is_exe(program):
            return program
    else:
        env_path = os.getenv("PATH")
        if env_path is None:
            env_path = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
        for path in env_path.split(os.pathsep):
            path = path.strip('"')
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file
    raise FileNotFoundError("Missing file `{:s}`".format(program))


def style_byte(b, color=True):
    style = {
        "nonprintable": "yellow",
        "printable": "white",
        "00": "gray",
        "0a": "blue",
        "ff": "green",
    }
    sbyte = "{:02x}".format(b)
    if not color or get_gef_setting("highlight.regex"):
        return sbyte

    if sbyte in style:
        st = style[sbyte]
    elif chr(b) in (string.ascii_letters + string.digits + string.punctuation + " "):
        st = style.get("printable")
    else:
        st = style.get("nonprintable")
    if st:
        sbyte = Color.colorify(sbyte, st)
    return sbyte


def hexdump(source, length=0x10, separator=".", show_raw=False, show_symbol=True, base=0x00):
    """Return the hexdump of `src` argument.
    @param source *MUST* be of type bytes or bytearray
    @param length is the length of items per line
    @param separator is the default character to use if one byte is not printable
    @param show_raw if True, do not add the line nor the text translation
    @param base is the start address of the block being hexdump
    @return a string with the hexdump"""
    result = []
    align = get_memory_alignment() * 2 + 2 if is_alive() else 18

    for i in range(0, len(source), length):
        chunk = bytearray(source[i : i + length])
        padlen = (0x10 - len(chunk)) * 3
        hexa = " ".join([style_byte(b, color=not show_raw) for b in chunk])

        if show_raw:
            result.append(hexa)
            continue

        text = "".join([chr(b) if 0x20 <= b < 0x7F else separator for b in chunk])
        if show_symbol:
            sym = gdb_get_location_from_symbol(base + i)
            sym = "<{:s}+{:04x}>".format(*sym) if sym else ""
        else:
            sym = ""

        fmt = "{addr:#0{aw}x}{sym}   {data}{pad}   {text}"
        result.append(fmt.format(aw=align, addr=base+i, sym=" "+sym, pad=" "*padlen, data=hexa, text=text))
    return "\n".join(result)


@lru_cache()
def is_debug():
    """Check if debug mode is enabled."""
    return get_gef_setting("gef.debug") is True


context_hidden = False


def hide_context():
    global context_hidden
    context_hidden = True
    return


def unhide_context():
    global context_hidden
    context_hidden = False
    return


def enable_redirect_output(to_file="/dev/null"):
    """Redirect all GDB output to `to_file` parameter. By default, `to_file` redirects to `/dev/null`."""
    gdb.execute("set logging overwrite")
    gdb.execute("set logging file {:s}".format(to_file))
    gdb.execute("set logging redirect on")
    gdb.execute("set logging on")
    return


def disable_redirect_output():
    """Disable the output redirection, if any."""
    gdb.execute("set logging off")
    gdb.execute("set logging redirect off")
    return


@lru_cache()
def get_gef_setting(name):
    """Read global gef settings.
    Return None if not found. A valid config setting can never return None,
    but False, 0 or ""."""
    global __config__
    setting = __config__.get(name, None)
    if not setting:
        return None
    return setting[0]


def set_gef_setting(name, value, _type=None, _desc=None):
    """Set global gef settings.
    Raise ValueError if `name` doesn't exist and `type` and `desc`
    are not provided."""
    global __config__

    if name not in __config__:
        # create new setting
        if _type is None or _desc is None:
            raise ValueError("Setting '{}' is undefined, need to provide type and description".format(name))
        __config__[name] = [_type(value), _type, _desc]
        return

    # set existing setting
    func = __config__[name][1]
    __config__[name][0] = func(value)
    get_gef_setting.cache_clear()
    return


def gef_makedirs(path, mode=0o755):
    """Recursive mkdir() creation. If successful, return the absolute path of the directory created."""
    abspath = os.path.expanduser(path)
    abspath = os.path.realpath(abspath)

    if os.path.isdir(abspath):
        return abspath

    os.makedirs(abspath, mode=mode, exist_ok=True)
    return abspath


@lru_cache(maxsize=512)
def gdb_get_location_from_symbol(address):
    """Retrieve the location of the `address` argument from the symbol table.
    Return a tuple with the name and offset if found, None otherwise."""
    # this is horrible, ugly hack and shitty perf...
    # find a *clean* way to get gdb.Location from an address
    name = None
    sym = gdb.execute("info symbol {:#x}".format(address), to_string=True)
    if sym.startswith("No symbol matches"):
        return None

    i = sym.find(" in section ")
    sym = sym[:i].split()
    if len(sym) >= 3 and sym[-1].isdigit():
        name = ' '.join(sym[:-2])
        offset = int(sym[-1])
    else:
        name = ' '.join(sym)
        offset = 0
    return name, offset


def get_symbol_string(addr, nosymbol_string=""):
    try:
        if isinstance(addr, str):
            addr = re.sub(r"\x1B\[([0-9]{1,2}(;[0-9]{1,2})*)?m", "", addr) # remove color
            addr = int(addr, 16)
        ret = gdb_get_location_from_symbol(addr)
    except:
        return nosymbol_string
    if ret is None:
        return nosymbol_string
    sym_name, sym_offset = ret[0], ret[1]
    sym_name = Instruction.smartify_text(sym_name)
    if sym_offset == 0:
        return " <{}>".format(sym_name)
    else:
        return " <{}+{:#x}>".format(sym_name, sym_offset)


def gdb_disassemble(start_pc, **kwargs):
    """Disassemble instructions from `start_pc` (Integer). Accepts the following named parameters:
    - `end_pc` (Integer) only instructions whose start address fall in the interval from start_pc to end_pc are returned.
    - `count` (Integer) list at most this many disassembled instructions
    If `end_pc` and `count` are not provided, the function will behave as if `count=1`.
    Return an iterator of Instruction objects"""
    frame = gdb.selected_frame()
    arch = frame.architecture()

    for insn in arch.disassemble(start_pc, **kwargs):
        address = insn["addr"]
        asm = insn["asm"].rstrip().split(None, 1)
        if len(asm) > 1:
            mnemo, operands = asm
            operands = operands.split(",")
        else:
            mnemo, operands = asm[0], []

        loc = gdb_get_location_from_symbol(address)
        location = "<{}+{}>".format(*loc) if loc else ""

        if is_arm32() and insn["addr"] & 1:
            opcodes = read_memory(insn["addr"]-1, insn["length"])
        else:
            opcodes = read_memory(insn["addr"], insn["length"])

        yield Instruction(address, location, mnemo, operands, opcodes)


def gdb_get_nth_previous_instruction_address(addr, n):
    """Return the address (Integer) of the `n`-th instruction before `addr`."""
    # fixed-length ABI
    if current_arch.instruction_length:
        return max(0, addr - n * current_arch.instruction_length)

    # variable-length ABI
    cur_insn_addr = gef_current_instruction(addr).address

    # we try to find a good set of previous instructions by "guessing" disassembling backwards
    # the 15 comes from the longest instruction valid size
    for i in range(15 * n, 0, -1):
        try:
            insns = list(gdb_disassemble(addr - i, end_pc=cur_insn_addr))
        except gdb.MemoryError:
            # this is because we can hit an unmapped page trying to read backward
            break

        # 1. check that the disassembled instructions list size can satisfy
        if len(insns) < n + 1: # we expect the current instruction plus the n before it
            continue

        # If the list of instructions is longer than what we need, then we
        # could get lucky and already have more than what we need, so slice down
        insns = insns[-n - 1 :]

        # 2. check that the sequence ends with the current address
        if insns[-1].address != cur_insn_addr:
            continue

        # 3. check all instructions are valid
        if all(insn.is_valid() for insn in insns):
            return insns[0].address

    return None


def gdb_get_nth_next_instruction_address(addr, n):
    """Return the address (Integer) of the `n`-th instruction after `addr`."""
    # fixed-length ABI
    if current_arch.instruction_length:
        return addr + n * current_arch.instruction_length

    # variable-length ABI
    insn = list(gdb_disassemble(addr, count=n))[-1]
    return insn.address


def gef_instruction_n(addr, n):
    """Return the `n`-th instruction after `addr` as an Instruction object."""
    return list(gdb_disassemble(addr, count=n + 1))[n]


def gef_get_instruction_at(addr):
    """Return the full Instruction found at the specified address."""
    insn = next(gef_disassemble(addr, 1))
    return insn


def gef_current_instruction(addr):
    """Return the current instruction as an Instruction object."""
    return gef_instruction_n(addr, 0)


def gef_next_instruction(addr):
    """Return the next instruction as an Instruction object."""
    return gef_instruction_n(addr, 1)


def gef_disassemble(addr, nb_insn, nb_prev=0):
    """Disassemble `nb_insn` instructions after `addr` and `nb_prev` before `addr`.
    Return an iterator of Instruction objects."""
    nb_insn = max(1, nb_insn)

    if nb_prev:
        done = False
        for i in range(nb_prev):
            if done:
                break
            start_addr = gdb_get_nth_previous_instruction_address(addr, nb_prev - i)
            if not start_addr:
                continue
            try:
                for insn in gdb_disassemble(start_addr, count=nb_prev):
                    if insn.address == addr:
                        done = True
                        break
                    yield insn
                done = True
                break
            except:
                pass

    for insn in gdb_disassemble(addr, count=nb_insn):
        yield insn


def capstone_disassemble(location, nb_insn, **kwargs):
    """Disassemble `nb_insn` instructions after `addr` and `nb_prev` before
    `addr` using the Capstone-Engine disassembler, if available.
    Return an iterator of Instruction objects."""
    def cs_insn_to_gef_insn(cs_insn):
        sym_info = gdb_get_location_from_symbol(cs_insn.address)
        loc = "<{}+{}>".format(*sym_info) if sym_info else ""
        ops = [] + cs_insn.op_str.split(", ")
        return Instruction(cs_insn.address, loc, cs_insn.mnemonic, ops, cs_insn.bytes)

    capstone = sys.modules["capstone"]
    arch, mode = get_capstone_arch(arch=kwargs.get("arch", None), mode=kwargs.get("mode", None), endian=kwargs.get("endian", None))
    cs = capstone.Cs(arch, mode)
    cs.detail = True
    skip = int(kwargs.get("skip", 0))

    if "code" in kwargs:
        code = kwargs["code"].replace(" ", "")
        code = binascii.unhexlify(code)
        for insn in cs.disasm(code, location):
            if skip:
                skip -= 1
                continue
            nb_insn -= 1
            yield Instruction(insn.address, "", insn.mnemonic, [] + insn.op_str.split(", "), insn.bytes)
            if nb_insn == 0:
                break
        return
    else:
        pc = current_arch.pc
        nb_prev = int(kwargs.get("nb_prev", 0))
        if nb_prev > 0:
            location = gdb_get_nth_previous_instruction_address(pc, nb_prev)
            nb_insn += nb_prev

        # split raeding by page_size
        used_bytes = 0
        code = b""
        page_start = align_address_to_page(location)
        offset = location - page_start
        read_addr = location
        if is_arm32() and read_addr & 1:
            read_addr -= 1
            offset -= 1
        read_size = gef_getpagesize() - offset
        while True:
            try:
                read_data = read_memory(read_addr, read_size)
            except:
                err("Memory read error at {:#x}-{:#x}".format(read_addr, read_addr+read_size))
                return
            code += bytes(read_data)
            for insn in cs.disasm(code, location):
                if skip:
                    skip -= 1
                    continue
                nb_insn -= 1
                used_bytes += len(insn.bytes)
                yield cs_insn_to_gef_insn(insn)
                if nb_insn == 0:
                    return
            code = code[used_bytes:] # There may be instructions placed across page boundaries.
            location += used_bytes
            used_bytes = 0
            read_addr += read_size # 1st loop is the offset size. 2nd~ loops are the page size.
            read_size = gef_getpagesize()
    return


def gef_execute_external(command, as_list=False, *args, **kwargs):
    """Execute an external command and return the result."""
    res = subprocess.check_output(command, stderr=subprocess.STDOUT, shell=kwargs.get("shell", False))
    return [gef_pystring(_) for _ in res.splitlines()] if as_list else gef_pystring(res)


def gef_execute_gdb_script(commands):
    """Execute the parameter `source` as GDB command. This is done by writing `commands` to
    a temporary file, which is then executed via GDB `source` command. The tempfile is then deleted."""
    fd, fname = tempfile.mkstemp(suffix=".gdb", prefix="gef_")
    with os.fdopen(fd, "w") as f:
        f.write(commands)
        f.flush()
    if os.access(fname, os.R_OK):
        gdb.execute("source {:s}".format(fname))
        os.unlink(fname)
    return


@lru_cache()
def checksec(filename):
    """Check the security property of the ELF binary. The following properties are:
    - Static
    - Stripped
    - Canary
    - NX
    - PIE
    - RELRO
    - Fortify
    - Intel CET
    - RPATH/RUNPATH
    - Clang CFI/SafeStack
    Return a dict() with the different keys mentioned above, and the boolean
    associated whether the protection was found."""
    try:
        readelf = which("readelf")
        objdump = which("objdump")
    except FileNotFoundError as e:
        err("{}".format(e))
        return

    cache = {}
    def __check_security_property(opt, filename, pattern):
        if (opt, filename) in cache:
            lines = cache[(opt, filename)]
        else:
            cmd = [readelf,]
            cmd += opt.split()
            cmd += [filename,]
            lines = gef_execute_external(cmd, as_list=True)
            cache[(opt, filename)] = lines
        for line in lines:
            if re.search(pattern, line):
                return True
        return False

    results = collections.OrderedDict()
    # Static
    results["Static"] = is_static(filename)
    # Stripped
    results["Stripped"] = is_stripped(filename)
    # Canary
    if not is_stripped(filename):
        results["Canary"] = __check_security_property("-rs", filename, r"__stack_chk_fail") is True
        if not results["Canary"]:
            results["Canary"] = __check_security_property("-rs", filename, r"__stack_chk_guard") is True # for non-x86
        if not results["Canary"]:
            results["Canary"] = __check_security_property("-rs", filename, r"__intel_security_cookie") is True # for intel compiler
    else:
        results["Canary"] = None # it means unknown
        if is_x86_64():
            proc = subprocess.Popen([objdump, "-d", filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            for i in range(0x10000):
                if b"%fs:0x28" in proc.stdout.readline():
                    results["Canary"] = True
                    break
            proc.kill()
        elif is_x86_32():
            proc = subprocess.Popen([objdump, "-d", filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            for i in range(0x10000):
                if b"%gs:0x14" in proc.stdout.readline():
                    results["Canary"] = True
                    break
            proc.kill()
    # NX
    has_gnu_stack = __check_security_property("-W -l", filename, r"GNU_STACK") is True
    if has_gnu_stack:
        results["NX"] = __check_security_property("-W -l", filename, r"GNU_STACK.*RWE") is False
    else:
        results["NX"] = False
    # PIE
    results["PIE"] = __check_security_property("-h", filename, r":.*EXEC") is False
    # RELRO
    results["Partial RELRO"] = __check_security_property("-l", filename, r"GNU_RELRO") is True
    results["Full RELRO"] = results["Partial RELRO"] and __check_security_property("-d", filename, r"BIND_NOW") is True
    # Fortify
    if is_stripped(filename):
        results["Fortify"] = None # it means unknown
    elif is_static(filename):
        results["Fortify"] = __check_security_property("-rs", filename, r"__mem(cpy|move)_chk") is True
    else:
        results["Fortify"] = __check_security_property("-rs", filename, r"_chk@GLIBC") is True
    # CET
    if not is_x86():
        results["Intel CET"] = False
    elif not is_stripped(filename) and not is_static(filename):
        results["Intel CET"] = __check_security_property("-S", filename, r"\.plt\.sec") is True
    else: # static or stripped
        objdump = which("objdump")
        cmd = [objdump, "-d", "-j", ".plt", filename] # check only .plt section for speed up
        out = gef_execute_external(cmd, as_list=True)
        results["Intel CET"] = False
        for line in out:
            line = line.strip()
            if not line: continue
            if is_x86_64() and line.endswith("endbr64"):
                results["Intel CET"] = True
                break
            elif is_x86_32() and line.endswith("endbr32"):
                results["Intel CET"] = True
                break
    # RPATH
    results["RPATH"] = __check_security_property("-d", filename, r"\(RPATH\)") is True
    # RUNPATH
    results["RUNPATH"] = __check_security_property("-d", filename, r"\(RUNPATH\)") is True
    # Clang CFI (detected only when `-fno-sanitize-trap=all`)
    results["Clang CFI"] = __check_security_property("-s", filename, r"__ubsan_handle_cfi_") is True
    # Clang SafeStack
    results["Clang SafeStack"] = __check_security_property("-s", filename, r"__safestack_init") is True
    return results


@lru_cache()
def get_arch():
    """Return the binary's architecture."""
    if is_alive():
        arch = gdb.selected_frame().architecture()
        return arch.name()

    arch_str = gdb.execute("show architecture", to_string=True).strip()
    if "The target architecture is set automatically (currently " in arch_str:
        arch_str = arch_str.split("(currently ", 1)[1]
        arch_str = arch_str.split(")", 1)[0]
    elif "The target architecture is assumed to be " in arch_str:
        arch_str = arch_str.replace("The target architecture is assumed to be ", "")
    elif "The target architecture is set to " in arch_str:
        # GDB version >= 10.1
        arch_str = re.findall(r"\"(.+)\"", arch_str)[0]
    else:
        # Unknown, we throw an exception to be safe
        raise RuntimeError("Unknown architecture: {}".format(arch_str))
    return arch_str


@lru_cache()
def get_endian():
    """Return the binary endianness."""
    endian = gdb.execute("show endian", to_string=True).strip().lower()
    if "little endian" in endian:
        return Elf.LITTLE_ENDIAN
    if "big endian" in endian:
        return Elf.BIG_ENDIAN
    raise EnvironmentError("Invalid endianness")


@lru_cache()
def get_entry_point():
    """Return the binary entry point."""
    for line in gdb.execute("info target", to_string=True).split("\n"):
        if "Entry point:" in line:
            return int(line.strip().split(" ")[-1], 16)
    for line in gdb.execute("elf-info", to_string=True).split("\n"):
        if "Entry point" in line:
            return int(line.strip().split(" ")[-1], 16)
    return None


def is_pie(fpath):
    return checksec(fpath)["PIE"]


def is_big_endian():
    return get_endian() == Elf.BIG_ENDIAN


def is_little_endian():
    return not is_big_endian()


def flags_to_human(reg_value, value_table):
    """Return a human readable string showing the flag states."""
    flags = []
    for i in value_table:
        flag_str = Color.boldify(value_table[i].upper()) if reg_value & (1<<i) else value_table[i].lower()
        flags.append(flag_str)
    return "{:#x} [{}]".format(reg_value, " ".join(flags))


class Architecture:
    """Generic metaclass for the architecture supported by GEF."""
    __metaclass__ = abc.ABCMeta

    @abc.abstractproperty
    def all_registers(self):                       pass
    @abc.abstractproperty
    def instruction_length(self):                  pass
    @abc.abstractproperty
    def nop_insn(self):                            pass
    @abc.abstractproperty
    def infloop_insn(self):                        pass
    @abc.abstractproperty
    def trap_insn(self):                           pass
    @abc.abstractproperty
    def ret_insn(self):                            pass
    @abc.abstractproperty
    def return_register(self):                     pass
    @abc.abstractproperty
    def flag_register(self):                       pass
    @abc.abstractproperty
    def flags_table(self):                         pass
    @abc.abstractproperty
    def function_parameters(self):                 pass
    @abc.abstractmethod
    def flag_register_to_human(self, val=None):    pass
    @abc.abstractmethod
    def is_syscall(self, insn):                    pass
    @abc.abstractmethod
    def is_call(self, insn):                       pass
    @abc.abstractmethod
    def is_jump(self, insn):                       pass
    @abc.abstractmethod
    def is_ret(self, insn):                        pass
    @abc.abstractmethod
    def is_conditional_branch(self, insn):         pass
    @abc.abstractmethod
    def is_branch_taken(self, insn):               pass
    @abc.abstractmethod
    def get_ra(self, insn, frame):                 pass

    special_registers = []

    @property
    def pc(self):
        return get_register("$pc")

    @property
    def sp(self):
        return get_register("$sp")

    @property
    def fp(self):
        return get_register("$fp")

    @property
    def ptrsize(self):
        return get_memory_alignment()

    def get_ith_parameter(self, i, in_func=True):
        if i < len(self.function_parameters):
            reg = self.function_parameters[i]
            val = get_register(reg)
            key = reg
            return key, val
        else:
            i -= len(self.function_parameters)
            if in_func and is_x86():
                i += 1 # Account for RA being at the top of the stack
            sp = current_arch.sp
            sz = current_arch.ptrsize
            loc = sp + (i * sz)
            val = read_int_from_memory(loc)
            key = "[sp + {:#x}]".format(i * sz)
            return key, val


class RISCV(Architecture):
    arch = "RISCV"
    mode = "RISCV"

    all_registers = [
        "$zero", "$ra", "$sp", "$gp", "$tp", "$t0", "$t1",
        "$t2", "$fp", "$s1", "$a0", "$a1", "$a2", "$a3",
        "$a4", "$a5", "$a6", "$a7", "$s2", "$s3", "$s4",
        "$s5", "$s6", "$s7", "$s8", "$s9", "$s10", "$s11",
        "$t3", "$t4", "$t5", "$t6",
    ]
    return_register = "$a0"
    function_parameters = ["$a0", "$a1", "$a2", "$a3", "$a4", "$a5", "$a6", "$a7"]
    syscall_register = "$a7"
    syscall_instructions = ["ecall"]

    nop_insn = b"\x01\x00" # c.nop
    infloop_insn = b"\x01\xa0" # c.j self
    trap_insn = b"\x02\x90" # c.ebreak
    ret_insn = b"\x82\x80" # c.ret

    # RISC-V has no flags registers
    flag_register = None
    flag_register_to_human = None
    flags_table = None

    @property
    def instruction_length(self):
        return None

    def is_syscall(self, insn):
        return insn.mnemonic == "ecall"

    def is_call(self, insn):
        return not self.is_ret(insn) and insn.mnemonic in ["jal", "jalr"]

    def is_jump(self, insn):
        return self.is_conditional_branch(self) or (not self.is_ret(insn) and insn.mnemonic in ["jal", "jalr"])

    def is_ret(self, insn):
        mnemo = insn.mnemonic
        if mnemo == "ret":
            return True
        elif (mnemo == "jalr" and insn.operands[0] == "zero" and
              insn.operands[1] == "ra" and insn.operands[2] == 0):
            return True
        elif (mnemo == "c.jalr" and insn.operands[0] == "ra"):
            return True
        return False

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        raise OSError("Architecture {:s} not supported yet".format(cls.arch))

    def is_conditional_branch(self, insn):
        return insn.mnemonic.startswith("b")

    def is_branch_taken(self, insn):
        def long_to_twos_complement(v):
            """Convert a python long value to its two's complement."""
            if is_32bit():
                if v & 0x80000000:
                    return v - 0x100000000
            elif is_64bit():
                if v & 0x8000000000000000:
                    return v - 0x10000000000000000
            else:
                raise OSError("RISC-V: ELF file is not ELF32 or ELF64. This is not currently supported")
            return v

        mnemo = insn.mnemonic
        condition = mnemo[1:]

        if condition.endswith("z"):
            # r2 is the zero register if we are comparing to 0
            rs1 = get_register(insn.operands[0])
            rs2 = get_register("$zero")
            condition = condition[:-1]
        elif len(insn.operands) > 2:
            # r2 is populated with the second operand
            rs1 = get_register(insn.operands[0])
            rs2 = get_register(insn.operands[1])
        else:
            raise OSError("RISC-V: Failed to get rs1 and rs2 for instruction: `{}`".format(insn))

        # If the conditional operation is not unsigned, convert the python long into
        # its two's complement
        if not condition.endswith("u"):
            rs2 = long_to_twos_complement(rs2)
            rs1 = long_to_twos_complement(rs1)
        else:
            condition = condition[:-1]

        if condition == "eq":
            if rs1 == rs2: taken, reason = True, "{}={}".format(rs1, rs2)
            else: taken, reason = False, "{}!={}".format(rs1, rs2)
        elif condition == "ne":
            if rs1 != rs2: taken, reason = True, "{}!={}".format(rs1, rs2)
            else: taken, reason = False, "{}={}".format(rs1, rs2)
        elif condition == "lt":
            if rs1 < rs2: taken, reason = True, "{}<{}".format(rs1, rs2)
            else: taken, reason = False, "{}>={}".format(rs1, rs2)
        elif condition == "ge":
            if rs1 < rs2: taken, reason = True, "{}>={}".format(rs1, rs2)
            else: taken, reason = False, "{}<{}".format(rs1, rs2)
        else:
            raise OSError("RISC-V: Conditional instruction `{:s}` not supported yet".format(insn))

        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$ra")
            elif frame.older():
                ra = frame.older().pc()
        except:
            pass
        return ra


class ARM(Architecture):
    arch = "ARM"

    try:
        gdb.execute("info registers xpsr", to_string=True)
        _mode = "cortex-m"
    except:
        _mode = "normal"

    if _mode == "normal":
        all_registers = [
            "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6",
            "$r7", "$r8", "$r9", "$r10", "$r11", "$r12", "$sp",
            "$lr", "$pc", "$cpsr",
        ]
        flag_register = "$cpsr"
        thumb_bit = 5
    elif _mode == "cortex-m":
        all_registers = [
            "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6",
            "$r7", "$r8", "$r9", "$r10", "$r11", "$r12", "$sp",
            "$lr", "$pc", "$xpsr", "$msp", "$psp",
            "$primask", "$basepri", "$faultmask", "$control",
        ]
        flag_register = "$xpsr"
        thumb_bit = 24
    else:
        raise

    # http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0041c/Caccegih.html
    # return b"\x00\x00\xa0\xe1" # mov r0, r0
    @property
    def nop_insn(self):
        if self.is_thumb():
            return b"\x00\xbf" # nop
        else:
            return b"\x01\x10\xa0\xe1" # mov r1, r1

    @property
    def infloop_insn(self):
        if self.is_thumb():
            return b"\xfe\xe7"
        else:
            return b"\xfe\xff\xff\xea"

    @property
    def trap_insn(self):
        if self.is_thumb():
            return b"\x00\xbe"
        else:
            return b"\x70\x00\x20\xe1"

    @property
    def ret_insn(self):
        if self.is_thumb():
            return b"\xf7\x46"
        else:
            return b"\x0e\xf0\xa0\xe1"

    return_register = "$r0"
    flags_table = {
        31: "negative",
        30: "zero",
        29: "carry",
        28: "overflow",
        7: "interrupt",
        6: "fast",
        thumb_bit: "thumb",
    }
    function_parameters = ["$r0", "$r1", "$r2", "$r3"]
    syscall_register = "$r7"
    syscall_instructions = ["svc 0x0", "swi 0x0", "swi NR"]

    def is_thumb(self):
        """Determine if the machine is currently in THUMB mode."""
        return is_alive() and get_register(self.flag_register) & (1 << self.thumb_bit)

    @property
    def pc(self):
        pc = get_register("$pc")
        if self.is_thumb():
            pc += 1
        return pc

    @property
    def mode(self):
        return "THUMB" if self.is_thumb() else "ARM"

    @property
    def instruction_length(self):
        # Thumb instructions have variable-length (2 or 4-byte)
        return None if self.is_thumb() else 4

    def is_syscall(self, insn):
        return insn.mnemonic in ["svc", "swi"]

    def is_call(self, insn):
        for c in ["bl", "blx"]:
            for cc in ["", "eq", "ne", "lt", "le", "gt", "ge", "vs", "vc", "mi", "pl", "hi", "ls", "cs", "cc", "hs", "lo", "al"]:
                if insn.mnemonic == c + cc:
                    return True
        return False

    def is_jump(self, insn):
        if insn.mnemonic in ["b", "bx"] and insn.operands[-1] == "lr":
            return False
        for c in ["b", "bx"]:
            for cc in ["", "eq", "ne", "lt", "le", "gt", "ge", "vs", "vc", "mi", "pl", "hi", "ls", "cs", "cc", "hs", "lo", "al"]:
                for suffix in ["", ".n", ".w"]:
                    if insn.mnemonic == c + cc + suffix:
                        return True
        return insn.mnemonic in ["mov", "ldr", "add"] and insn.operands[0] == "pc"

    def is_ret(self, insn):
        if insn.mnemonic in ["pop", "ldm", "ldmea", "ldmed", "ldmfa", "ldmfd", "ldmia", "ldmib", "ldmda", "ldmdb",
                             "ldm.w", "ldmea.w", "ldmed.w", "ldmfa.w", "ldmfd.w", "ldmia.w", "ldmib.w", "ldmda.w", "ldmdb.w"]:
            return insn.operands[-1].strip() == "pc}"
        if insn.mnemonic in ["bl", "blx", "b", "bx"]:
            return insn.operands[-1] == "lr"
        if insn.mnemonic in ["ldr", "add"]:
            return insn.operands[0] == "pc"
        if insn.mnemonic == "rfe":
            return True
        return False

    def flag_register_to_human(self, val=None):
        # http://www.botskool.com/user-pages/tutorials/electronics/arm-7-tutorial-part-1
        if val is None:
            reg = self.flag_register
            val = get_register(reg) & 0xffffffff
        mode_str = ["User", "FIQ", "IRQ", "Supervisor", "Monitor", "Abort", "Hypervisor", "Undefined", "System"]
        # encoding: ["mode", PL]
        mode_dic = {
            0b10000: [mode_str[0], 0],
            0b10001: [mode_str[1], 1],
            0b10010: [mode_str[2], 1],
            0b10011: [mode_str[3], 1],
            0b10110: [mode_str[4], 1],
            0b10111: [mode_str[5], 1],
            0b11010: [mode_str[6], 2],
            0b11011: [mode_str[7], 1],
            0b11111: [mode_str[8], 1],
        }
        key = val & 0b11111
        CurrentMode = mode_dic[key][0]
        CurrentPL = mode_dic[key][1]

        scr = get_register("$SCR")
        if scr is not None:
            if (scr & 0b1) == 0:
                mode = " [Mode={:s}({:#07b},PL{:d}), Secure]".format(CurrentMode, key, CurrentPL)
            else:
                mode = " [Mode={:s}({:#07b},PL{:d}), Non-Secure]".format(CurrentMode, key, CurrentPL)
        else:
            mode = " [Mode={:s}({:#07b},PL{:d})]".format(CurrentMode, key, CurrentPL)
        return flags_to_human(val, self.flags_table) + mode

    def is_conditional_branch(self, insn):
        conditions = ["eq", "ne", "lt", "le", "gt", "ge", "vs", "vc", "mi", "pl", "hi", "ls", "cs", "cc", "hs", "lo"]
        return (not insn.mnemonic == "svc") and (insn.mnemonic[-2:] in conditions)

    def is_branch_taken(self, insn):
        mnemo = insn.mnemonic
        # ref: http://www.davespace.co.uk/arm/introduction-to-arm/conditional.html
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        val = get_register(self.flag_register)
        taken, reason = False, ""

        if mnemo.endswith("eq"):
            taken, reason = bool(val&(1<<flags["zero"])), "Z"
        elif mnemo.endswith("ne"):
            taken, reason = not val&(1<<flags["zero"]), "!Z"
        elif mnemo.endswith("lt"):
            taken, reason = bool(val&(1<<flags["negative"])) != bool(val&(1<<flags["overflow"])), "N!=V"
        elif mnemo.endswith("le"):
            taken, reason = val&(1<<flags["zero"]) or bool(val&(1<<flags["negative"])) != bool(val&(1<<flags["overflow"])), "Z || N!=V"
        elif mnemo.endswith("gt"):
            taken, reason = val&(1<<flags["zero"]) == 0 and bool(val&(1<<flags["negative"])) == bool(val&(1<<flags["overflow"])), "!Z && N==V"
        elif mnemo.endswith("ge"):
            taken, reason = bool(val&(1<<flags["negative"])) == bool(val&(1<<flags["overflow"])), "N==V"
        elif mnemo.endswith("vs"):
            taken, reason = bool(val&(1<<flags["overflow"])), "V"
        elif mnemo.endswith("vc"):
            taken, reason = not val&(1<<flags["overflow"]), "!V"
        elif mnemo.endswith("mi"):
            taken, reason = bool(val&(1<<flags["negative"])), "N"
        elif mnemo.endswith("pl"):
            taken, reason = not val&(1<<flags["negative"]), "N==0"
        elif mnemo.endswith("hi"):
            taken, reason = val&(1<<flags["carry"]) and not val&(1<<flags["zero"]), "C && !Z"
        elif mnemo.endswith("ls"):
            taken, reason = not val&(1<<flags["carry"]) or val&(1<<flags["zero"]), "!C || Z"
        elif mnemo.endswith("cs") or mnemo.endswith("hs"):
            taken, reason = val&(1<<flags["carry"]), "C"
        elif mnemo.endswith("cc") or mnemo.endswith("lo"):
            taken, reason = not val&(1<<flags["carry"]), "!C"
        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                # If it's a pop, we have to peek into the stack, otherwise use lr
                if insn.mnemonic == "pop":
                    ra_addr = current_arch.sp + (len(insn.operands)-1) * get_memory_alignment()
                    ra = to_unsigned_long(dereference(ra_addr))
                elif insn.mnemonic == "ldr":
                    return to_unsigned_long(dereference(current_arch.sp))
                else: # 'bx lr' or 'add pc, lr, #0'
                    return get_register("$lr")
            elif frame.older():
                ra = frame.older().pc()
        except:
            pass
        return ra

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 125
        insns = [
            "push {r0-r2, r7}",
            "mov r0, {:d}".format(addr),
            "mov r1, {:d}".format(size),
            "mov r2, {:d}".format(perm),
            "mov r7, {:d}".format(_NR_mprotect),
            "svc 0",
            "pop {r0-r2, r7}",
        ]
        return "; ".join(insns)


class AARCH64(ARM):
    arch = "ARM64"
    mode = "ARM"

    all_registers = [
        "$x0", "$x1", "$x2", "$x3", "$x4", "$x5", "$x6", "$x7",
        "$x8", "$x9", "$x10", "$x11", "$x12", "$x13", "$x14", "$x15",
        "$x16", "$x17", "$x18", "$x19", "$x20", "$x21", "$x22", "$x23",
        "$x24", "$x25", "$x26", "$x27", "$x28", "$x29", "$x30", "$sp",
        "$pc", "$cpsr", "$fpsr", "$fpcr",]
    return_register = "$x0"
    flag_register = "$cpsr"
    flags_table = {
        31: "negative",
        30: "zero",
        29: "carry",
        28: "overflow",
        7: "interrupt",
        6: "fast",
    }
    function_parameters = ["$x0", "$x1", "$x2", "$x3", "$x4", "$x5", "$x6", "$x7"]
    syscall_register = "$x8"
    syscall_instructions = ["svc #0x0"]

    nop_insn = b"\x1f\x20\x03\xd5"
    infloop_insn = b"\x00\x00\x00\x14"
    trap_insn = b"\x00\x00\x20\xd4"
    ret_insn = b"\xc0\x03\x5f\xd6"

    def is_syscall(self, insn):
        return insn.mnemonic == "svc"

    def is_call(self, insn):
        return insn.mnemonic in ["bl", "blr"]

    def is_jump(self, insn):
        return insn.mnemonic in ["b", "br"] or self.is_conditional_branch(insn)

    def is_ret(self, insn):
        return (insn.mnemonic in ["ret", "eret"]) or (insn.mnemonic == "ldp" and "pc" in insn.operands)

    def flag_register_to_human(self, val=None):
        # http://events.linuxfoundation.org/sites/events/files/slides/KoreaLinuxForum-2014.pdf
        if val is None:
            reg = self.flag_register
            val = get_register(reg) & 0xffffffff

        scr = get_register("$SCR_EL3")
        if scr is not None:
            if (scr & 0b1) == 0:
                mode = " [EL={:d},SP={:d}, Secure]".format((val >> 2) & 0b11, val & 0b11)
            else:
                mode = " [EL={:d},SP={:d}, Non-Secure]".format((val >> 2) & 0b11, val & 0b11)
        else:
            mode = " [EL={:d},SP={:d}]".format((val >> 2) & 0b11, val & 0b11)
        return flags_to_human(val, self.flags_table) + mode

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 226
        insns = [
            "str x8, [sp, -16]!",
            "str x0, [sp, -16]!",
            "str x1, [sp, -16]!",
            "str x2, [sp, -16]!",
            "mov x8, {:d}".format(_NR_mprotect),
            "movz x0, {:#x}".format(addr & 0xFFFF),
            "movk x0, {:#x}, lsl 16".format((addr >> 16) & 0xFFFF),
            "movk x0, {:#x}, lsl 32".format((addr >> 32) & 0xFFFF),
            "movk x0, {:#x}, lsl 48".format((addr >> 48) & 0xFFFF),
            "movz x1, {:#x}".format(size & 0xFFFF),
            "movk x1, {:#x}, lsl 16".format((size >> 16) & 0xFFFF),
            "mov x2, {:d}".format(perm),
            "svc 0",
            "ldr x2, [sp], 16",
            "ldr x1, [sp], 16",
            "ldr x0, [sp], 16",
            "ldr x8, [sp], 16",
        ]
        return "; ".join(insns)

    def is_conditional_branch(self, insn):
        # https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf
        # sect. 5.1.1
        mnemo = insn.mnemonic
        branch_mnemos = ["cbnz", "cbz", "tbnz", "tbz"]
        return mnemo.startswith("b.") or mnemo in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo, operands = insn.mnemonic, insn.operands
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        val = get_register(self.flag_register)
        taken, reason = False, ""

        if mnemo in ["cbnz", "cbz", "tbnz", "tbz"]:
            reg = operands[0]
            op = get_register(reg)
            if mnemo == "cbnz":
                if op != 0: taken, reason = True, "{}!=0".format(reg)
                else: taken, reason = False, "{}==0".format(reg)
            elif mnemo == "cbz":
                if op == 0: taken, reason = True, "{}==0".format(reg)
                else: taken, reason = False, "{}!=0".format(reg)
            elif mnemo == "tbnz":
                # operands[1] has one or more white spaces in front, then a #, then the number
                # so we need to eliminate them
                i = int(operands[1].strip().lstrip("#"))
                if (op & 1<<i) != 0: taken, reason = True, "{}&1<<{}!=0".format(reg, i)
                else: taken, reason = False, "{}&1<<{}==0".format(reg, i)
            elif mnemo == "tbz":
                # operands[1] has one or more white spaces in front, then a #, then the number
                # so we need to eliminate them
                i = int(operands[1].strip().lstrip("#"))
                if (op & 1<<i) == 0: taken, reason = True, "{}&1<<{}==0".format(reg, i)
                else: taken, reason = False, "{}&1<<{}!=0".format(reg, i)

        if not reason:
            taken, reason = super().is_branch_taken(insn)
        return taken, reason


class X86(Architecture):
    arch = "X86"
    mode = "32"

    nop_insn = b"\x90"
    infloop_insn = b"\xeb\xfe"
    trap_insn = b"\xcc"
    ret_insn = b"\xc3"
    flag_register = "$eflags"
    special_registers = ["$cs", "$ss", "$ds", "$es", "$fs", "$gs", ]
    gpr_registers = ["$eax", "$ebx", "$ecx", "$edx", "$esp", "$ebp", "$esi", "$edi", "$eip", ]
    all_registers = gpr_registers + [ flag_register, ] + special_registers
    instruction_length = None
    return_register = "$eax"
    function_parameters = ["$esp", ]
    flags_table = {
        21: "identification",
        #20: "virtual_interrupt_pending",
        #19: "virtual_interrupt",
        18: "align",
        17: "virtualx86",
        16: "resume",
        #15: N/A
        14: "nested",
        #12-13: "iopl",
        11: "overflow",
        10: "direction",
        9: "interrupt",
        8: "trap",
        7: "sign",
        6: "zero",
        #5: N/A
        4: "adjust",
        #3: N/A
        2: "parity",
        #1: N/A
        0: "carry",
    }
    syscall_register = "$eax"
    syscall_instructions = ["sysenter", "syscall", "int 0x80"]

    def flag_register_to_human(self, val=None):
        if val is None:
            reg = self.flag_register
            val = get_register(reg) & 0xffffffff
        mode = " [Ring={:d}]".format(get_register("$cs") & 0b11)
        return flags_to_human(val, self.flags_table) + mode

    def is_syscall(self, insn):
        insn_str = insn.mnemonic + " " + ", ".join(insn.operands)
        return insn_str.strip() in self.syscall_instructions

    def is_call(self, insn):
        return insn.mnemonic in ["call", "callq"]

    def is_jump(self, insn):
        return insn.mnemonic == "jmp" or self.is_conditional_branch(insn)

    def is_ret(self, insn):
        return insn.mnemonic in ["ret", "retf", "sysret", "iret"]

    def is_conditional_branch(self, insn):
        branch_mnemos = [
            "ja", "jnbe", "jae", "jnb", "jnc", "jb", "jc", "jnae", "jbe", "jna",
            "jcxz", "jecxz", "jrcxz", "je", "jz", "jg", "jnle", "jge", "jnl",
            "jl", "jnge", "jle", "jng", "jne", "jnz", "jno", "jnp", "jpo", "jns",
            "jo", "jp", "jpe", "js"
        ]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo = insn.mnemonic
        # all kudos to fG! (https://github.com/gdbinit/Gdbinit/blob/master/gdbinit#L1654)
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        val = get_register(self.flag_register)

        taken, reason = False, ""

        if mnemo in ["ja", "jnbe"]:
            taken, reason = not val&(1<<flags["carry"]) and not val&(1<<flags["zero"]), "!C && !Z"
        elif mnemo in ["jae", "jnb", "jnc"]:
            taken, reason = not val&(1<<flags["carry"]), "!C"
        elif mnemo in ["jb", "jc", "jnae"]:
            taken, reason = val&(1<<flags["carry"]), "C"
        elif mnemo in ["jbe", "jna"]:
            taken, reason = val&(1<<flags["carry"]) or val&(1<<flags["zero"]), "C || Z"
        elif mnemo in ["jcxz", "jecxz", "jrcxz"]:
            cx = get_register("$rcx") if self.mode == "64" else get_register("$ecx")
            taken, reason = cx == 0, "!$CX"
        elif mnemo in ["je", "jz"]:
            taken, reason = val&(1<<flags["zero"]), "Z"
        elif mnemo in ["jne", "jnz"]:
            taken, reason = not val&(1<<flags["zero"]), "!Z"
        elif mnemo in ["jg", "jnle"]:
            taken, reason = not val&(1<<flags["zero"]) and bool(val&(1<<flags["overflow"])) == bool(val&(1<<flags["sign"])), "!Z && S==O"
        elif mnemo in ["jge", "jnl"]:
            taken, reason = bool(val&(1<<flags["sign"])) == bool(val&(1<<flags["overflow"])), "S==O"
        elif mnemo in ["jl", "jnge"]:
            taken, reason = val&(1<<flags["overflow"]) != val&(1<<flags["sign"]), "S!=O"
        elif mnemo in ["jle", "jng"]:
            taken, reason = val&(1<<flags["zero"]) or bool(val&(1<<flags["overflow"])) != bool(val&(1<<flags["sign"])), "Z || S!=O"
        elif mnemo in ["jo",]:
            taken, reason = val&(1<<flags["overflow"]), "O"
        elif mnemo in ["jno",]:
            taken, reason = not val&(1<<flags["overflow"]), "!O"
        elif mnemo in ["jpe", "jp"]:
            taken, reason = val&(1<<flags["parity"]), "P"
        elif mnemo in ["jnp", "jpo"]:
            taken, reason = not val&(1<<flags["parity"]), "!P"
        elif mnemo in ["js",]:
            taken, reason = val&(1<<flags["sign"]), "S"
        elif mnemo in ["jns",]:
            taken, reason = not val&(1<<flags["sign"]), "!S"
        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = to_unsigned_long(dereference(current_arch.sp))
            if frame.older():
                ra = frame.older().pc()
        except:
            pass
        return ra

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 125
        insns = [
            "pushad",
            "pushfd",
            "mov eax, {:d}".format(_NR_mprotect),
            "mov ebx, {:d}".format(addr),
            "mov ecx, {:d}".format(size),
            "mov edx, {:d}".format(perm),
            "int 0x80",
            "popfd",
            "popad",
        ]
        return "; ".join(insns)

    def get_ith_parameter(self, i, in_func=True):
        if in_func:
            i += 1 # Account for RA being at the top of the stack
        sp = current_arch.sp
        sz = current_arch.ptrsize
        loc = sp + (i * sz)
        val = read_int_from_memory(loc)
        key = "[sp + {:#x}]".format(i * sz)
        return key, val


class X86_64(X86):
    arch = "X86"
    mode = "64"

    gpr_registers = [
        "$rax", "$rbx", "$rcx", "$rdx", "$rsp", "$rbp", "$rsi", "$rdi", "$rip",
        "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15", ]
    all_registers = gpr_registers + [ X86.flag_register, ] + X86.special_registers
    return_register = "$rax"
    function_parameters = ["$rdi", "$rsi", "$rdx", "$rcx", "$r8", "$r9"]
    syscall_register = "$rax"
    syscall_instructions = ["syscall", "sysenter"]
    # We don't want to inherit x86's stack based param getter
    get_ith_parameter = Architecture.get_ith_parameter

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 10
        insns = [
            "pushfq",
            "push rax",
            "push rdi",
            "push rsi",
            "push rdx",
            "push rcx",
            "push r11",
            "mov rax, {:d}".format(_NR_mprotect),
            "mov rdi, {:d}".format(addr),
            "mov rsi, {:d}".format(size),
            "mov rdx, {:d}".format(perm),
            "syscall",
            "pop r11",
            "pop rcx",
            "pop rdx",
            "pop rsi",
            "pop rdi",
            "pop rax",
            "popfq",
        ]
        return "; ".join(insns)


class PowerPC(Architecture):
    arch = "PPC"
    mode = "PPC32"

    all_registers = [
        "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
        "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15",
        "$r16", "$r17", "$r18", "$r19", "$r20", "$r21", "$r22", "$r23",
        "$r24", "$r25", "$r26", "$r27", "$r28", "$r29", "$r30", "$r31",
        "$pc", "$msr", "$cr", "$lr", "$ctr", "$xer", "$trap",]
    instruction_length = 4
    nop_insn = b"\x60\x00\x00\x00" # http://www.ibm.com/developerworks/library/l-ppc/index.html
    return_register = "$r0"
    flag_register = "$cr"
    flags_table = {
        3: "negative[0]",
        2: "positive[0]",
        1: "equal[0]",
        0: "overflow[0]",
        # cr7
        31: "less[7]",
        30: "greater[7]",
        29: "equal[7]",
        28: "overflow[7]",
    }
    function_parameters = ["$i0", "$i1", "$i2", "$i3", "$i4", "$i5"]
    syscall_register = "$r0"
    syscall_instructions = ["sc"]

    def flag_register_to_human(self, val=None):
        # http://www.cebix.net/downloads/bebox/pem32b.pdf (% 2.1.3)
        if not val:
            reg = self.flag_register
            val = get_register(reg)
        return flags_to_human(val, self.flags_table)

    def is_syscall(self, insn):
        return insn.mnemonic == "sc"

    def is_call(self, insn):
        condition = ["", "lt", "le", "eq", "ge", "gt", "nl", "ne", "ng", "so", "ns", "un", "nu"]
        for c in condition:
            if insn.mnemonic == "b"+c+"l":
                return True
            if insn.mnemonic == "b"+c+"la":
                return True
            if insn.mnemonic == "b"+c+"ctrl":
                return True
            if insn.mnemonic == "b"+c+"lrl":
                return True
        mode = ["dz", "dnzf", "dzt", "dzf", "dnzt", "dnz"]
        for m in mode:
            if insn.mnemonic == "b"+m+"l":
                return True
            if insn.mnemonic == "b"+m+"la":
                return True
            if insn.mnemonic == "b"+m+"lrl":
                return True
        return False

    def is_jump(self, insn):
        condition = ["", "lt", "le", "eq", "ge", "gt", "nl", "ne", "ng", "so", "ns", "un", "nu"]
        for c in condition:
            if insn.mnemonic == "b"+c:
                return True
            if insn.mnemonic == "b"+c+"a":
                return True
            if insn.mnemonic == "b"+c+"ctr":
                return True
        mode = ["dz", "dnzf", "dzt", "dzf", "dnzt", "dnz"]
        for m in mode:
            if insn.mnemonic == "b"+m:
                return True
            if insn.mnemonic == "b"+m+"a":
                return True
        return False

    def is_ret(self, insn):
        condition = ["", "lt", "le", "eq", "ge", "gt", "nl", "ne", "ng", "so", "ns", "un", "nu"]
        for c in condition:
            if insn.mnemonic == "b"+c+"lr":
                return True
            if insn.mnemonic == "b"+c+"lrl":
                return True
        mode = ["dz", "dnzf", "dzt", "dzf", "dnzt", "dnz"]
        for m in mode:
            if insn.mnemonic == "b"+m+"lr":
                return True
            if insn.mnemonic == "b"+m+"lrl":
                return True
        return False

    def is_conditional_branch(self, insn):
        branch_mnemos = ["beq", "bne", "ble", "blt", "bgt", "bge", "bdz", "bdnz", "bdzt", "bdnzt", "bdzf", "bdnzf"]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo = insn.mnemonic
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        val = get_register(self.flag_register)
        taken, reason = False, ""
        if mnemo == "beq":
            taken, reason = val&(1<<flags["equal[7]"]), "E"
        elif mnemo == "bne":
            taken, reason = val&(1<<flags["equal[7]"]) == 0, "!E"
        elif mnemo == "ble":
            taken, reason = val&(1<<flags["equal[7]"]) or val&(1<<flags["less[7]"]), "E || L"
        elif mnemo == "blt":
            taken, reason = val&(1<<flags["less[7]"]), "L"
        elif mnemo == "bge":
            taken, reason = val&(1<<flags["equal[7]"]) or val&(1<<flags["greater[7]"]), "E || G"
        elif mnemo == "bgt":
            taken, reason = val&(1<<flags["greater[7]"]), "G"
        # todo: bdn?z[tf]? are unsupported
        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$lr")
            elif frame.older():
                ra = frame.older().pc()
        except:
            pass
        return ra

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        # Ref: http://www.ibm.com/developerworks/library/l-ppc/index.html
        _NR_mprotect = 125
        insns = [
            "addi 1, 1, -16", # 1 = r1 = sp
            "stw 0, 0(1)",
            "stw 3, 4(1)", # r0 = syscall_code | r3, r4, r5 = args
            "stw 4, 8(1)",
            "stw 5, 12(1)",
            "li 0, {:d}".format(_NR_mprotect),
            "lis 3, {:#x}@h".format(addr),
            "ori 3, 3, {:#x}@l".format(addr),
            "lis 4, {:#x}@h".format(size),
            "ori 4, 4, {:#x}@l".format(size),
            "li 5, {:d}".format(perm),
            "sc",
            "lwz 0, 0(1)",
            "lwz 3, 4(1)",
            "lwz 4, 8(1)",
            "lwz 5, 12(1)",
            "addi 1, 1, 16",
        ]
        return ";".join(insns)


class PowerPC64(PowerPC):
    arch = "PPC"
    mode = "PPC64"


class SPARC(Architecture):
    """ Refs:
    - http://www.cse.scu.edu/~atkinson/teaching/sp05/259/sparc.pdf"""
    arch = "SPARC"
    mode = ""

    all_registers = [
        "$g0", "$g1", "$g2", "$g3", "$g4", "$g5", "$g6", "$g7",
        "$o0", "$o1", "$o2", "$o3", "$o4", "$o5", "$o7",
        "$l0", "$l1", "$l2", "$l3", "$l4", "$l5", "$l6", "$l7",
        "$i0", "$i1", "$i2", "$i3", "$i4", "$i5", "$i7",
        "$pc", "$npc", "$sp ", "$fp ", "$psr",]
    instruction_length = 4
    nop_insn = b"\x00\x00\x00\x00" # sethi 0, %g0
    return_register = "$i0"
    flag_register = "$psr"
    flags_table = {
        23: "negative",
        22: "zero",
        21: "overflow",
        20: "carry",
        7: "supervisor",
        5: "trap",
    }
    function_parameters = ["$o0 ", "$o1 ", "$o2 ", "$o3 ", "$o4 ", "$o5 ", "$o7 ",]
    syscall_register = "%g1"
    syscall_instructions = ["t 0x10"]

    def flag_register_to_human(self, val=None):
        # http://www.gaisler.com/doc/sparcv8.pdf
        reg = self.flag_register
        if not val:
            val = get_register(reg)
        return flags_to_human(val, self.flags_table)

    def is_syscall(self, insn):
        return insn.mnemonic == "t"

    def is_call(self, insn):
        return insn.mnemonic in ["jmpl", "call"]

    def is_jump(self, insn):
        mnemo = insn.mnemonic
        return mnemo.startswith("b") or mnemo.startswith("fb") or mnemo == "jmpl"

    def is_ret(self, insn):
        return insn.mnemonic in ["ret", "retl"]

    def is_conditional_branch(self, insn):
        branch_mnemos = [
            # http://moss.csc.ncsu.edu/~mueller/codeopt/codeopt00/notes/condbranch.html
            "be", "bne", "bg", "bge", "bgeu", "bgu", "bl", "ble", "blu", "bleu",
            "bneg", "bpos", "bvs", "bvc", "bcs", "bcc"
            # https://www.gaisler.com/doc/sparcv8.pdf
            "fbu", "fbg", "fbug", "fbl", "fbul", "fblg", "fbne", "fbe", "fbue", "fbge",
            "fbuge", "fble", "fbule", "fbo",
            # https://docs.oracle.com/cd/E18752_01/html/816-1681/sparcv9-30990.html
            "bpne", "bpe", "bpg", "bple", "bpge", "bpl", "bpgu", "bpleu", "bpcc", "bpcs",
            "bppos", "bpneg", "bpvc", "bpvs", "brz", "brlez", "brlz", "brnz", "brgz", "brgez",
            "fbpu", "fbpg", "fbpug", "fbpl", "fbpul", "fbplg", "fbpne", "fbpe", "fbpue", "fbpge",
            "fbpuge", "fbple", "fbpule", "fbpo",
        ]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo = insn.mnemonic
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        val = get_register(self.flag_register)
        taken, reason = False, ""

        if mnemo in ["be", "bpe"]:
            taken, reason = val&(1<<flags["zero"]), "Z"
        elif mnemo in ["bne", "bpne"]:
            taken, reason = val&(1<<flags["zero"]) == 0, "!Z"
        elif mnemo in ["bg", "bpg"]:
            taken, reason = val&(1<<flags["zero"]) == 0 and (val&(1<<flags["negative"]) == 0 or val&(1<<flags["overflow"]) == 0), "!Z && (!N || !O)"
        elif mnemo in ["bge", "bpge"]:
            taken, reason = val&(1<<flags["negative"]) == 0 or val&(1<<flags["overflow"]) == 0, "!N || !O"
        elif mnemo in ["bgu", "bpgu"]:
            taken, reason = val&(1<<flags["carry"]) == 0 and val&(1<<flags["zero"]) == 0, "!C && !Z"
        elif mnemo in ["bgeu",]:
            taken, reason = val&(1<<flags["carry"]) == 0, "!C"
        elif mnemo in ["bl", "bpl"]:
            taken, reason = val&(1<<flags["negative"]) and val&(1<<flags["overflow"]), "N && O"
        elif mnemo in ["blu",]:
            taken, reason = val&(1<<flags["carry"]), "C"
        elif mnemo in ["ble", "bple"]:
            taken, reason = val&(1<<flags["zero"]) or (val&(1<<flags["negative"]) or val&(1<<flags["overflow"])), "Z || (N || O)"
        elif mnemo in ["bleu", "bpleu"]:
            taken, reason = val&(1<<flags["carry"]) or val&(1<<flags["zero"]), "C || Z"
        elif mnemo in ["bneg", "bpneg"]:
            taken, reason = val&(1<<flags["negative"]), "N"
        elif mnemo in ["bpos", "bppos"]:
            taken, reason = val&(1<<flags["negative"]) == 0, "!N"
        elif mnemo in ["bvs", "bpvs"]:
            taken, reason = val&(1<<flags["overflow"]), "O"
        elif mnemo in ["bvc", "bpvc"]:
            taken, reason = val&(1<<flags["overflow"]) == 0, "!O"
        elif mnemo in ["bcs", "bpcs"]:
            taken, reason = val&(1<<flags["carry"]), "C"
        elif mnemo in ["bcc", "bpcc"]:
            taken, reason = val&(1<<flags["carry"]) == 0, "!C"
        # todo: f* opcode, brn?z/br[lg]e?z are unsupported
        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$o7")
            elif frame.older():
                ra = frame.older().pc()
        except:
            pass
        return ra

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        hi = (addr & 0xffff0000) >> 16
        lo = (addr & 0x0000ffff)
        _NR_mprotect = 125
        insns = ["add %sp, -16, %sp",
                 "st %g1, [ %sp ]", "st %o0, [ %sp + 4 ]",
                 "st %o1, [ %sp + 8 ]", "st %o2, [ %sp + 12 ]",
                 "sethi %hi({}), %o0".format(hi),
                 "or %o0, {}, %o0".format(lo),
                 "clr %o1",
                 "clr %o2",
                 "mov {}, %g1".format(_NR_mprotect),
                 "t 0x10",
                 "ld [ %sp ], %g1", "ld [ %sp + 4 ], %o0",
                 "ld [ %sp + 8 ], %o1", "ld [ %sp + 12 ], %o2",
                 "add %sp, 16, %sp",]
        return "; ".join(insns)


class SPARC64(SPARC):
    """Refs:
    - http://math-atlas.sourceforge.net/devel/assembly/abi_sysV_sparc.pdf
    - https://cr.yp.to/2005-590/sparcv9.pdf"""
    arch = "SPARC"
    mode = "V9"

    all_registers = [
        "$g0", "$g1", "$g2", "$g3", "$g4", "$g5", "$g6", "$g7",
        "$o0", "$o1", "$o2", "$o3", "$o4", "$o5", "$o7",
        "$l0", "$l1", "$l2", "$l3", "$l4", "$l5", "$l6", "$l7",
        "$i0", "$i1", "$i2", "$i3", "$i4", "$i5", "$i7",
        "$pc", "$npc", "$sp", "$fp", "$state", ]

    flag_register = "$state" # sparcv9.pdf, 5.1.5.1 (ccr)
    flags_table = {
        35: "negative",
        34: "zero",
        33: "overflow",
        32: "carry",
    }

    syscall_instructions = ["t 0x6d"]

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        hi = (addr & 0xffff0000) >> 16
        lo = (addr & 0x0000ffff)
        _NR_mprotect = 125
        insns = ["add %sp, -16, %sp",
                 "st %g1, [ %sp ]", "st %o0, [ %sp + 4 ]",
                 "st %o1, [ %sp + 8 ]", "st %o2, [ %sp + 12 ]",
                 "sethi %hi({}), %o0".format(hi),
                 "or %o0, {}, %o0".format(lo),
                 "clr %o1",
                 "clr %o2",
                 "mov {}, %g1".format(_NR_mprotect),
                 "t 0x6d",
                 "ld [ %sp ], %g1", "ld [ %sp + 4 ], %o0",
                 "ld [ %sp + 8 ], %o1", "ld [ %sp + 12 ], %o2",
                 "add %sp, 16, %sp",]
        return "; ".join(insns)


class MIPS(Architecture):
    arch = "MIPS"
    mode = "MIPS32"

    # http://vhouten.home.xs4all.nl/mipsel/r3000-isa.html
    all_registers = [
        "$zero", "$at", "$v0", "$v1", "$a0", "$a1", "$a2", "$a3",
        "$t0", "$t1", "$t2", "$t3", "$t4", "$t5", "$t6", "$t7",
        "$s0", "$s1", "$s2", "$s3", "$s4", "$s5", "$s6", "$s7",
        "$t8", "$t9", "$k0", "$k1", "$s8", "$pc", "$sp", "$hi",
        "$lo", "$fir", "$ra", "$gp", ]
    instruction_length = 4
    nop_insn = b"\x00\x00\x00\x00" # sll $0,$0,0
    return_register = "$v0"
    flag_register = "$fcsr"
    flags_table = {}
    function_parameters = ["$a0", "$a1", "$a2", "$a3"]
    syscall_register = "$v0"
    syscall_instructions = ["syscall"]

    def flag_register_to_human(self, val=None):
        return Color.colorify("No flag register", "yellow underline")

    def is_syscall(self, insn):
        return insn.mnemonic == "syscall"

    def is_call(self, insn):
        return insn.mnemonic in ["bal", "balc", "jal", "jalr", "jalrc", "jalrc.hb", "bgezal", "bgezall", "bltzal", "bltzall"]

    def is_jump(self, insn):
        if self.is_ret(insn):
            return False
        if insn.mnemonic in ["b", "bc", "j", "jr", "jrc", "balrsc", "brsc"]:
            return True
        if self.is_conditional_branch(insn):
            return True
        return False

    def is_ret(self, insn):
        if insn.mnemonic in ["jr", "jrc"] and insn.operands[0] == "ra":
            return True
        if insn.mnemonic in ["deret", "eret", "eretnc"]:
            return True
        if insn.mnemonic in ["restore", "restore.jrc"]:
            return True
        return False

    def is_conditional_branch(self, insn):
        branch_mnemos = ["beq", "bne", "bgtz", "bgez", "bltz", "blez", "beqz", "bnez",
                         "beql", "bnel", "bgtzl", "bgezl", "bltzl", "blezl",
                         "bgezal", "bgezall", "bltzal", "bltzall",
                         "bc1f", "bc1fl", "bc1t", "bc1tl", "bc2f", "bc2fl", "bc2t", "bc2tl",
                         "beqc", "beqic", "beqzc",
                         "bnec", "bneic", "bnezc",
                         "bgec", "bgeic", "bgeiuc", "bgeuc",
                         "bltc", "bltic", "bltiuc", "bltuc",
                         "bbeqzc", "bbnezc"]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo, ops = insn.mnemonic, insn.operands
        taken, reason = False, ""

        def p(a):
            return struct.pack("<I",a&0xffffffff)

        def ui(a):
            return struct.unpack("<i",a)[0]

        def u2i(a):
            return ui(p(a))

        if mnemo in ["beq", "beql", "beqc"]:
            taken, reason = get_register(ops[0]) == get_register(ops[1]), "{0[0]} == {0[1]}".format(ops)
        elif mnemo in ["beqic",]:
            taken, reason = get_register(ops[0]) == int(ops[1], 0), "{0[0]} == {0[1]}".format(ops)
        elif mnemo in ["bne", "bnel", "bnec"]:
            taken, reason = get_register(ops[0]) != get_register(ops[1]), "{0[0]} != {0[1]}".format(ops)
        elif mnemo in ["bneic",]:
            taken, reason = get_register(ops[0]) != int(ops[1], 0), "{0[0]} != {0[1]}".format(ops)
        elif mnemo in ["beqz", "beqzc"]:
            taken, reason = get_register(ops[0]) == 0, "{0[0]} == 0".format(ops)
        elif mnemo in ["bnez", "bnezc"]:
            taken, reason = get_register(ops[0]) != 0, "{0[0]} != 0".format(ops)
        elif mnemo in ["bgtz", "bgtzl"]:
            taken, reason = get_register(ops[0]) > 0, "{0[0]} > 0".format(ops)
        elif mnemo in ["bgez", "bgezl"]:
            taken, reason = get_register(ops[0]) >= 0, "{0[0]} >= 0".format(ops)
        elif mnemo in ["bltz", "bltzl"]:
            taken, reason = get_register(ops[0]) < 0, "{0[0]} < 0".format(ops)
        elif mnemo in ["blez", "blezl"]:
            taken, reason = get_register(ops[0]) <= 0, "{0[0]} <= 0".format(ops)
        elif mnemo in ["bbeqzc",]:
            taken, reason = (get_register(ops[0]) >> int(ops[1], 0) & 1) == 0, "(({0[0]} >> {0[1]}) & 1) == 0".format(ops)
        elif mnemo in ["bbnezc",]:
            taken, reason = (get_register(ops[0]) >> int(ops[1], 0) & 1) == 0, "(({0[0]} >> {0[1]}) & 1) != 0".format(ops)
        elif mnemo in ["bgec",]:
            taken, reason = get_register(ops[0]) >= u2i(get_register(ops[1])), "{0[0]} >= {0[1]}".format(ops)
        elif mnemo in ["bgeic",]:
            taken, reason = get_register(ops[0]) >= u2i(int(ops[1], 0)), "{0[0]} >= {0[1]}".format(ops)
        elif mnemo in ["bgeuc",]:
            taken, reason = get_register(ops[0]) >= get_register(ops[1]), "{0[0]} >= {0[1]}".format(ops)
        elif mnemo in ["bgeiuc",]:
            taken, reason = get_register(ops[0]) >= int(ops[1], 0), "{0[0]} >= {0[1]}".format(ops)
        elif mnemo in ["bltc",]:
            taken, reason = get_register(ops[0]) < u2i(get_register(ops[1])), "{0[0]} < {0[1]}".format(ops)
        elif mnemo in ["bltic",]:
            taken, reason = get_register(ops[0]) < u2i(int(ops[1], 0)), "{0[0]} < {0[1]}".format(ops)
        elif mnemo in ["bltuc",]:
            taken, reason = get_register(ops[0]) < get_register(ops[1]), "{0[0]} < {0[1]}".format(ops)
        elif mnemo in ["bltiuc",]:
            taken, reason = get_register(ops[0]) < int(ops[1], 0), "{0[0]} < {0[1]}".format(ops)
        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$ra")
            elif frame.older():
                ra = frame.older().pc()
        except:
            pass
        return ra

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 4125
        insns = ["addi $sp, $sp, -16",
                 "sw $v0, 0($sp)", "sw $a0, 4($sp)",
                 "sw $a3, 8($sp)", "sw $a3, 12($sp)",
                 "li $v0, {:d}".format(_NR_mprotect),
                 "li $a0, {:d}".format(addr),
                 "li $a1, {:d}".format(size),
                 "li $a2, {:d}".format(perm),
                 "syscall",
                 "lw $v0, 0($sp)", "lw $a1, 4($sp)",
                 "lw $a3, 8($sp)", "lw $a3, 12($sp)",
                 "addi $sp, $sp, 16",]
        return "; ".join(insns)


def write_memory(address, buffer, length=0x10):
    """Write `buffer` at address `address`."""
    if is_qemu_usermode():
        fd = open("/proc/{:d}/mem".format(get_pid()), "wb")
        fd.seek(address)
        ret = fd.write(buffer[:length])
        fd.close()
    else:
        gdb.selected_inferior().write_memory(address, buffer, length)
        ret = length
    return ret


def read_memory(addr, length=0x10):
    """Return a `length` long byte array with the copy of the process memory at `addr`."""
    #import inspect
    #print(' <- '.join([x.function for x in inspect.stack()[1:4]]))
    return gdb.selected_inferior().read_memory(addr, length).tobytes()


def read_int_from_memory(addr):
    """Return an integer read from memory."""
    sz = current_arch.ptrsize
    mem = read_memory(addr, sz)
    unpack = u32 if sz == 4 else u64
    return unpack(mem)


def read_cstring_from_memory(address, max_length=GEF_MAX_STRING_LENGTH):
    """Return a C-string read from memory."""
    length = min((address|(DEFAULT_PAGE_SIZE-1)) - address, max_length+1)
    # original GEF uses gdb.Value().cast("char"),
    # but this is too slow if string is too large.
    # for example 0xcccccccccccccccc....(too long), this is in kernel or firmware commonly.
    # to avoid this, gdb.Value().cast() is removed.
    try:
        res = read_memory(address, length).split(b"\x00")[0]
        ustr = res.decode("utf-8")
        if max_length and len(ustr) > max_length:
            ustr = "{}[...]".format(ustr[:max_length])
        return ustr
    except:
        return None


def read_ascii_string(address):
    """Read an ASCII string from memory"""
    cstr = read_cstring_from_memory(address)
    if isinstance(cstr, str) and cstr and all([x in string.printable for x in cstr]):
        return cstr
    return None


def read_physmem_secure(paddr, size):
    sm_base, sm_size = XSecureMemAddrCommand.get_secure_memory_base_and_size()
    if sm_base is None or sm_size is None:
        return None
    if not (sm_base <= paddr < sm_base+sm_size):
        return None
    sm = XSecureMemAddrCommand.get_secure_memory_qemu_map(sm_base, sm_size)
    if sm is None:
        return None
    out = XSecureMemAddrCommand.read_secure_memory(sm, paddr-sm_base, size)
    return out


def read_physmem(paddr, size):
    def fast_path(paddr, size):
        out = read_memory(paddr, size)
        return out

    def slow_path(paddr, size): # < qemu 4.1.0-rc0
        res = gdb.execute("monitor xp/{:d}xb {:#x}".format(size, paddr), to_string=True)
        out = b""
        for line in res.splitlines():
            data = line.split()[1:]
            out += bytes([int(x,16) for x in  data])
        return out

    if is_arm32() or is_arm64():
        out = read_physmem_secure(paddr, size)
        if out:
            return out

    if not is_supported_physmode():
        return slow_path(paddr, size)

    try:
        orig_mode = get_current_mmu_mode()
        if orig_mode == "virt":
            enable_phys()
        out = fast_path(paddr, size)
        if orig_mode == "virt":
            disable_phys()
    except:
        if orig_mode == "virt":
            disable_phys()
        # fall through to slow path
        out = slow_path(paddr, size)
    return out


def write_physmem_secure(paddr, buffer):
    sm_base, sm_size = XSecureMemAddrCommand.get_secure_memory_base_and_size()
    if sm_base is None or sm_size is None:
        return None
    if not (sm_base <= paddr < sm_base+sm_size):
        return None
    sm = XSecureMemAddrCommand.get_secure_memory_qemu_map(sm_base, sm_size)
    if sm is None:
        return None
    out = WSecureMemAddrCommand.write_secure_memory(sm, paddr-sm_base, buffer)
    return out


def write_physmem(paddr, buffer):
    if is_arm32() or is_arm64():
        ret = write_physmem_secure(paddr, buffer)
        if ret:
            return ret

    if not is_supported_physmode():
        return None

    try:
        orig_mode = get_current_mmu_mode()
        if orig_mode == "virt":
            enable_phys()
        ret = write_memory(paddr, buffer, len(buffer))
        if orig_mode == "virt":
            disable_phys()
    except:
        if orig_mode == "virt":
            disable_phys()
    return ret


def get_current_mmu_mode():
    try:
        response = gdb.execute('maintenance packet qqemu.PhyMemMode', to_string=True, from_tty=False)
        if 'received: "0"' in response:
            return "virt"
        elif 'received: "1"' in response:
            return "phys"
        else:
            return False
    except:
        return False


def is_supported_physmode():
    return get_current_mmu_mode() in ["virt", "phys"]


def enable_phys():
    response = gdb.execute('maintenance packet Qqemu.PhyMemMode:1', to_string=True, from_tty=False)
    response = gdb.execute('maintenance packet qqemu.PhyMemMode', to_string=True, from_tty=False)
    return 'received: "1"' in response


def disable_phys():
    response = gdb.execute('maintenance packet Qqemu.PhyMemMode:0', to_string=True, from_tty=False)
    response = gdb.execute('maintenance packet qqemu.PhyMemMode', to_string=True, from_tty=False)
    return 'received: "0"' in response


def p8(x: int, s: bool = False) -> bytes:
    """Pack one byte respecting the current architecture endianness."""
    return struct.pack("{}B".format(endian_str()), x) if not s else struct.pack("{}b".format(endian_str()), x)


def p16(x: int, s: bool = False) -> bytes:
    """Pack one word respecting the current architecture endianness."""
    return struct.pack("{}H".format(endian_str()), x) if not s else struct.pack("{}h".format(endian_str()), x)


def p32(x: int, s: bool = False) -> bytes:
    """Pack one dword respecting the current architecture endianness."""
    return struct.pack("{}I".format(endian_str()), x) if not s else struct.pack("{}i".format(endian_str()), x)


def p64(x: int, s: bool = False) -> bytes:
    """Pack one qword respecting the current architecture endianness."""
    return struct.pack("{}Q".format(endian_str()), x) if not s else struct.pack("{}q".format(endian_str()), x)


def u8(x: bytes, s: bool = False) -> int:
    """Unpack one byte respecting the current architecture endianness."""
    return struct.unpack("{}B".format(endian_str()), x)[0] if not s else struct.unpack("{}b".format(endian_str()), x)[0]


def u16(x: bytes, s: bool = False) -> int:
    """Unpack one word respecting the current architecture endianness."""
    return struct.unpack("{}H".format(endian_str()), x)[0] if not s else struct.unpack("{}h".format(endian_str()), x)[0]


def u32(x: bytes, s: bool = False) -> int:
    """Unpack one dword respecting the current architecture endianness."""
    return struct.unpack("{}I".format(endian_str()), x)[0] if not s else struct.unpack("{}i".format(endian_str()), x)[0]


def u64(x: bytes, s: bool = False) -> int:
    """Unpack one qword respecting the current architecture endianness."""
    return struct.unpack("{}Q".format(endian_str()), x)[0] if not s else struct.unpack("{}q".format(endian_str()), x)[0]


def is_ascii_string(address):
    """Helper function to determine if the buffer pointed by `address` is an ASCII string (in GDB)"""
    try:
        return read_ascii_string(address) is not None
    except Exception:
        return False


def is_alive():
    """Check if GDB is running."""
    try:
        return gdb.selected_inferior().pid > 0
    except Exception:
        return False
    return False


def only_if_gdb_running(f):
    """Decorator wrapper to check if GDB is running."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if is_alive():
            return f(*args, **kwargs)
        else:
            warn("No debugging session active")

    return wrapper


def only_if_gdb_target_local(f):
    """Decorator wrapper to check if GDB is running locally (target not remote)."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if not is_remote_debug() or is_remote_but_same_host():
            return f(*args, **kwargs)
        else:
            warn("This command cannot work for remote sessions.")

    return wrapper


def only_if_qemu_system(f):
    """Decorator wrapper to check if GDB is connected to qemu-system."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if is_qemu_system():
            return f(*args, **kwargs)
        else:
            warn("This command can work under qemu-system only.")

    return wrapper


def only_if_not_qemu_system(f):
    """Decorator wrapper to check if GDB is connected to qemu-system."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if not is_qemu_system():
            return f(*args, **kwargs)
        else:
            warn("This command cannot work under qemu-system.")

    return wrapper


def perf_enable(f):
    """Decorator wrapper to perf."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        import cProfile, pstats, io
        pr = cProfile.Profile()
        pr.enable()
        ret = f(*args, **kwargs)
        pr.disable()
        s = io.StringIO()
        #sortby = pstats.SortKey.CUMULATIVE
        sortby = pstats.SortKey.TIME
        ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
        ps.print_stats(20)
        print(s.getvalue())
        return ret

    return wrapper


def perf_by_line_enable(f):
    """Decorator wrapper to perf."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        import line_profiler, pstats, io
        pr = line_profiler.LineProfiler()
        pr.add_function(f)
        pr.enable()
        ret = f(*args, **kwargs)
        pr.disable()
        s = io.StringIO()
        pr.print_stats(stream=s)
        print(s.getvalue())
        return ret

    return wrapper


def experimental_feature(f):
    """Decorator to add a warning when a feature is experimental."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        warn("This feature is under development, expect bugs and unstability...")
        return f(*args, **kwargs)

    return wrapper


def only_if_x86_32_64(f):
    """Decorator wrapper to check if the archtecture is x86/x86-64."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if is_x86():
            return f(*args, **kwargs)
        else:
            warn("This command cannot work under this architecture.")

    return wrapper


def only_if_arm_32_64(f):
    """Decorator wrapper to check if the archtecture is ARM/AArch64."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if is_arm32() or is_arm64():
            return f(*args, **kwargs)
        else:
            warn("This command cannot work under this architecture.")

    return wrapper


def only_if_x86_32_64_or_arm_32_64(f):
    """Decorator wrapper to check if the archtecture is x86/x86-64/ARM/AArch64."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if is_x86() or is_arm32() or is_arm64():
            return f(*args, **kwargs)
        else:
            warn("This command cannot work under this architecture.")

    return wrapper


def only_if_gdb_version_higher_than(required_gdb_version):
    """Decorator to check whether current GDB version requirements."""

    def wrapper(f):
        def inner_f(*args, **kwargs):
            if GDB_VERSION >= required_gdb_version:
                f(*args, **kwargs)
            else:
                reason = "GDB >= {} for this command".format(required_gdb_version)
                raise EnvironmentError(reason)
        return inner_f

    return wrapper


def use_stdtype():
    if is_32bit(): return "uint32_t"
    elif is_64bit(): return "uint64_t"
    return "uint16_t"


def use_default_type():
    if is_32bit(): return "unsigned int"
    elif is_64bit(): return "unsigned long"
    return "unsigned short"


def use_golang_type():
    if is_32bit(): return "uint32"
    elif is_64bit(): return "uint64"
    return "uint16"


def use_rust_type():
    if is_32bit(): return "u32"
    elif is_64bit(): return "u64"
    return "u16"


def to_unsigned_long(v):
    """Cast a gdb.Value to unsigned long."""
    if is_32bit():
        mask = (1 << 32) - 1
    else:
        mask = (1 << 64) - 1
    return int(v.cast(gdb.Value(mask).type)) & mask


def get_register(regname):
    """Return a register's value."""
    return get_register_for_selected_frame(id(gdb.selected_frame()), regname)


def get_register_for_selected_frame(selected_frame_id, regname):
    if regname[0] != '$':
        regname = "$" + regname
    try:
        value = gdb.parse_and_eval(regname)
        return to_unsigned_long(value) if value.type.code == gdb.TYPE_CODE_INT else int(value)
    except gdb.error:
        try:
            value = gdb.selected_frame().read_register(regname)
            return int(value)
        except ValueError:
            return None
        except gdb.error:
            return None


def get_path_from_info_proc():
    try:
        response = gdb.execute("info proc", to_string=True)
    except:
        return None
    for x in response.splitlines():
        if x.startswith("exe = "):
            return x.split(" = ")[1].replace("'", "")
    return None


@lru_cache()
def get_os():
    """Return the current OS."""
    return platform.system().lower()


@lru_cache()
def is_pin():
    if not is_remote_debug():
        return False
    response = gdb.execute('maintenance packet qSupported', to_string=True, from_tty=False)
    return 'intel.name=' in response


@lru_cache()
def is_qemu():
    if not is_remote_debug():
        return False
    response = gdb.execute('maintenance packet Qqemu.sstepbits', to_string=True, from_tty=False)
    return 'ENABLE=' in response


@lru_cache()
def is_qemu_usermode():
    if is_qemu() == False:
        return False
    response = gdb.execute('maintenance packet qOffsets', to_string=True, from_tty=False)
    return 'Text=' in response


@lru_cache()
def is_qemu_system():
    if is_qemu() == False:
        return False
    response = gdb.execute('maintenance packet qOffsets', to_string=True, from_tty=False)
    return 'received: ""' in response


@lru_cache()
def get_pid():
    """Return the PID of the debuggee process."""
    def get_filepath():
        response = gdb.execute('info files', to_string=True)
        for line in response.splitlines():
            if line.startswith("Symbols from"):
                return line.split('"')[1]
        return None

    if is_pin():
        filepath = get_filepath()
        if filepath is None:
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return
        gdb_tcp_sess = list(c.raddr for c in psutil.Process().connections())
        if not gdb_tcp_sess:
            err("gdb has no tcp session")
            return
        for process in psutil.process_iter():
            if not process.name() == os.path.basename(filepath):
                continue
            try:
                connections = process.connections()
            except Exception:
                continue
            for c in connections:
                if c.laddr in gdb_tcp_sess:
                    return process.pid
        return None

    elif is_qemu_usermode() or is_qemu_system():
        filepath = "qemu"
        gdb_tcp_sess = list(c.raddr for c in psutil.Process().connections())
        if not gdb_tcp_sess:
            err("gdb has no tcp session")
            return
        for process in psutil.process_iter():
            if not process.name().startswith("qemu"):
                continue
            try:
                connections = process.connections()
            except Exception:
                continue
            for c in connections:
                if c.laddr in gdb_tcp_sess:
                    return process.pid
        return None

    return gdb.selected_inferior().pid


@lru_cache()
def get_filepath():
    """Return the local absolute path of the file currently debugged."""
    filename = gdb.current_progspace().filename

    if is_remote_debug():
        # if no filename specified, try downloading target from /proc
        if filename is None:
            pid = get_pid()
            if pid is None:
                return None
            if pid > 0:
                return download_file("/proc/{:d}/exe".format(pid), use_cache=True)
            return None

        # if target is remote file, download
        elif filename.startswith("target:"):
            fname = filename[len("target:") :]
            return download_file(fname, use_cache=True, local_name=fname)

        elif filename.startswith(".gnu_debugdata for target:"):
            fname = filename[len(".gnu_debugdata for target:") :]
            return download_file(fname, use_cache=True, local_name=fname)

        else:
            return filename
    else:
        if filename is not None:
            return filename
        # inferior probably did not have name, extract cmdline from info proc
        return get_path_from_info_proc()


@lru_cache()
def get_filename():
    """Return the full filename of the file currently debugged."""
    filename = gdb.current_progspace().filename
    if filename is None:
        return None
    return os.path.basename(gdb.current_progspace().filename)


def download_file(target, use_cache=False, local_name=None):
    """Download filename `target` inside the mirror tree inside the get_gef_setting("gef.tempdir").
    The tree architecture must be get_gef_setting("gef.tempdir")/gef/<local_pid>/<remote_filepath>.
    This allow a "chroot-like" tree format."""
    if is_qemu():
        return None

    try:
        local_root = os.path.sep.join([get_gef_setting("gef.tempdir"), str(get_pid())])
        if local_name is None:
            local_path = os.path.sep.join([local_root, os.path.dirname(target)])
            local_name = os.path.sep.join([local_path, os.path.basename(target)])
        else:
            local_path = os.path.sep.join([local_root, os.path.dirname(local_name)])
            local_name = os.path.sep.join([local_path, os.path.basename(local_name)])

        if use_cache and os.access(local_name, os.R_OK):
            return local_name

        gef_makedirs(local_path)
        gdb.execute("remote get {0:s} {1:s}".format(target, local_name)) # Supported:gdbserver Unsupported:qemu

    except gdb.error:
        # gdb-stub compat
        with open(local_name, "w") as f:
            if is_32bit():
                f.write("00000000-ffffffff rwxp 00000000 00:00 0                    {}\n".format(get_filepath()))
            else:
                f.write("0000000000000000-ffffffffffffffff rwxp 00000000 00:00 0                    {}\n".format(get_filepath()))

    except Exception as e:
        err("download_file() failed: {}".format(str(e)))
        local_name = None
    return local_name


def open_file(path, use_cache=False):
    """Attempt to open the given file, if remote debugging is active, download
    it first to the mirror in /tmp/."""
    if is_remote_debug() and not is_remote_but_same_host():
        lpath = download_file(path, use_cache)
        if not lpath:
            raise IOError("cannot open remote path {:s}".format(path))
        path = lpath
    return open(path, "r")


def get_function_length(sym):
    """Attempt to get the length of the raw bytes of a function."""
    dis = gdb.execute("disassemble {:s}".format(sym), to_string=True).splitlines()
    start_addr = int(dis[1].split()[0], 16)
    end_addr = int(dis[-2].split()[0], 16)
    return end_addr - start_addr


def get_process_maps_linux(proc_map_file):
    """Parse the Linux process `/proc/pid/maps` file."""
    for line in open_file(proc_map_file, use_cache=False):
        line = line.strip()
        addr, perm, off, _, rest = line.split(" ", 4)
        rest = rest.split(" ", 1)
        if len(rest) == 1:
            inode = rest[0]
            pathname = ""
        else:
            inode = rest[0]
            pathname = rest[1].lstrip()
        addr_start, addr_end = [int(x, 16) for x in addr.split("-")]
        off = int(off, 16)
        perm = Permission.from_process_maps(perm)
        yield Section(page_start=addr_start, page_end=addr_end, offset=off, permission=perm, inode=inode, path=pathname)
    return


def get_ehdr(addr):
    addr &= ~(gef_getpagesize()-1)
    bound = (1<<32) if is_32bit() else (1<<64)
    for i in range(1024):
        if addr < 0 or addr > bound:
            return None
        try:
            if read_memory(addr, 4) == b'\x7FELF':
                return Elf(addr)
        except gdb.MemoryError:
            return None
        addr -= gef_getpagesize()
    return None


def elf_map(addr, objfile=''):
    elf = get_ehdr(addr)
    if elf is None:
        return []

    # walk phdr
    pages = []
    for phdr in elf.phdrs:
        memsz = phdr.p_memsz
        if not memsz:
            continue

        offset = phdr.p_offset
        flags = phdr.p_flags
        vaddr = phdr.p_vaddr

        memsz += vaddr & (gef_getpagesize()-1)
        memsz = (memsz + (gef_getpagesize()-1)) & ~(gef_getpagesize()-1) # padding
        vaddr &= ~(gef_getpagesize()-1)
        offset &= ~(gef_getpagesize()-1)

        for page_addr in range(vaddr, vaddr+memsz, gef_getpagesize()):
            for i, page in enumerate(pages):
                if page['vaddr'] == page_addr:
                    if page['flags'] & 1: # PF_X
                        flags |= 1
                    pages[i]['flags'] = flags # overwrite, because RELRO
                    break
            else:
                page = {'vaddr': page_addr, 'memsize': gef_getpagesize(), 'flags': flags, 'offset': offset + (page_addr-vaddr)}
                pages.append(page)

    # PIE
    if elf.e_type == Elf.ET_DYN:
        for i in range(len(pages)):
            pages[i]['vaddr'] += elf.addr

    pages = sorted(pages, key=lambda x:x['vaddr'])

    # merge contiguous
    prev = pages[0]
    for page in pages[1:]:
        if (prev['flags'] & 2) == (page['flags'] & 2) and prev['vaddr']+prev['memsize'] == page['vaddr']:
            prev['memsize'] += page['memsize']
            pages.remove(page)
        else:
            prev = page

    # guard page
    gaps = []
    for i in range(len(pages)-1):
        a, b = pages[i:i+2]
        a_end = a['vaddr'] + a['memsize']
        b_begin = b['vaddr']
        if a_end != b_begin:
            gaps.append({'vaddr': a_end, 'memsize': b_begin-a_end, 'flags': 0, 'offset': 0})

    pages += gaps

    sects = []
    for page in pages:
        perm = ""
        perm += "r" if page['flags'] & 4 else "-"
        perm += "w" if page['flags'] & 2 else "-"
        perm += "x" if page['flags'] & 1 else "-"
        perm = Permission.from_process_maps(perm)
        page_start = page['vaddr']
        page_end = page['vaddr'] + page['memsize']
        off = page['offset']
        sect = Section(page_start=page_start, page_end=page_end, offset=off, permission=perm, inode=None, path=objfile)
        sects.append(sect)
    return sects


# get_explored_regions (used qemu-user mode) is too slow,
# Because it repeats read_memory many times to find the upper and lower bounds of the page.
# lru_cache() is not effective because it is cleared every time you stepi.
# Fortunately, memory maps rarely change.
# I decided to make it a cache mechanism independent of lru_cache and introduce a mechanism to forcibly clear it with vmmap.
explored_regions = None


def clear_explored_regions():
    global explored_regions
    explored_regions = None
    return


def get_explored_regions():
    """Return sections from auxv exploring"""

    # return if it is cached
    global explored_regions
    if explored_regions:
        return explored_regions

    def is_exist_page(addr):
        try:
            _ = read_memory(addr, 1)
            return True
        except:
            return False

    def get_region_start_end(addr):
        addr &= ~(gef_getpagesize()-1)
        if not is_exist_page(addr):
            return None, None
        region_start = addr
        region_end = addr + gef_getpagesize()

        end_addrs = [r.page_end for r in regions]
        start_addrs = [r.page_start for r in regions]

        # up search
        while True:
            if region_start - gef_getpagesize() < 0:
                break
            if not is_exist_page(region_start-gef_getpagesize()):
                break
            if region_start in end_addrs:
                break
            region_start -= gef_getpagesize()

        bound = (1<<32) if is_32bit() else (1<<64)
        # down search
        while True:
            if region_end > bound:
                break
            if not is_exist_page(region_end):
                break
            if region_end in start_addrs:
                break
            region_end += gef_getpagesize()
        return region_start, region_end

    def is_in_regions(addr):
        for rg in regions:
            if rg.page_start <= addr < rg.page_end:
                return True
        return False

    def add_regions(addr, label, perm="rwx"):
        if is_in_regions(addr):
            return
        start, end = get_region_start_end(addr)
        if start is None:
            return
        perm = Permission.from_process_maps(perm)
        sect = Section(page_start=start, page_end=end, offset=0, permission=perm, inode=None, path=label)
        regions.append(sect)
        return

    regions = []

    # auxv parse
    auxv = gef_get_auxiliary_values()
    if auxv:
        if "AT_PHDR" in auxv:
            regions += elf_map(auxv["AT_PHDR"], "[code]")
        elif "AT_ENTRY" in auxv:
            regions += elf_map(auxv["AT_ENTRY"], "[code]")
        if "AT_BASE" in auxv:
            regions += elf_map(auxv["AT_BASE"], "[linker]")
        if "AT_SYSINFO_EHDR" in auxv:
            regions += elf_map(auxv["AT_SYSINFO_EHDR"], "[vdso]")
        elif "AT_SYSINFO" in auxv:
            regions += elf_map(auxv["AT_SYSINFO"], "[vdso]")

    # registers
    add_regions(get_register("$sp"), "[stack]", "rw-")
    for regname in current_arch.all_registers:
        add_regions(get_register(regname), "<explored>")

    # walk near stack
    sp = get_register("$sp")
    try:
        data = read_memory(sp & ~(gef_getpagesize()-1), gef_getpagesize())
    except:
        return regions
    unpack = u32 if is_32bit() else u64
    data = [unpack(data[i:i+current_arch.ptrsize]) for i in range(0, len(data), current_arch.ptrsize)]
    data = list(set(data))
    for d in data:
        add_regions(d, "<explored>")

    # walk around known map, because qemu may maps extra regions (?)
    for r in regions:
        add_regions(r.page_start-1, "<explored>", str(r.permission))
        add_regions(r.page_end+1, "<explored>", str(r.permission))

    regions = sorted(regions, key=lambda x:x.page_start)

    # cache globally
    explored_regions = regions.copy()
    return regions


@lru_cache()
def get_process_maps(outer=False):
    """Return the mapped memory sections"""
    if is_qemu_usermode() and not outer:
        return list(get_explored_regions())

    pid = get_pid()
    if pid is None:
        return list(get_info_sections())
    try:
        fpath = "/proc/{:d}/maps".format(pid)
        return list(get_process_maps_linux(fpath))
    except FileNotFoundError as e:
        warn("Failed to read /proc/<PID>/maps, using GDB sections info: {}".format(e))
        return list(get_info_sections())


@lru_cache()
def get_info_sections():
    """Retrieve the debuggee sections."""
    stream = StringIO(gdb.execute("maintenance info sections", to_string=True))

    for line in stream:
        if not line:
            break
        try:
            parts = [x.strip() for x in line.split()]
            addr_start, addr_end = [int(x, 16) for x in parts[1].split("->")]
            off = int(parts[3][:-1], 16)
            path = parts[4]
            inode = ""
            perm = Permission.from_info_sections(parts[5:])
            yield Section(page_start=addr_start, page_end=addr_end, offset=off, permission=perm, inode=inode, path=path)
        except IndexError:
            continue
        except ValueError:
            continue
    return


@lru_cache()
def get_info_files():
    """Retrieve all the files loaded by debuggee."""
    lines = gdb.execute("info files", to_string=True).splitlines()
    infos_files = []
    for line in lines:
        line = line.strip()

        if not line:
            break

        if not line.startswith("0x"):
            continue

        blobs = [x.strip() for x in line.split(" ")]
        addr_start = int(blobs[0], 16)
        addr_end = int(blobs[2], 16)
        section_name = blobs[4]

        if "system-supplied DSO" in line:
            filename = "[vdso]"
        elif len(blobs) == 7:
            filename = blobs[6]
        else:
            filename = get_filepath()

        info = Zone(section_name, addr_start, addr_end, filename)

        infos_files.append(info)

    return infos_files


@lru_cache()
def process_lookup_address(address):
    """Look up for an address in memory.
    Return an Address object if found, None otherwise."""
    if not is_alive():
        err("Process is not running")
        return None

    if is_x86():
        if is_in_x86_kernel(address):
            return None

    for sect in get_process_maps():
        if sect.page_start <= address < sect.page_end:
            return sect

    return None


@lru_cache()
def process_lookup_path(name, perm=Permission.ALL):
    """Look up for a path in the process memory mapping.
    Return a Section object if found, None otherwise."""
    if not is_alive():
        err("Process is not running")
        return None

    for sect in get_process_maps():
        if name in sect.path and sect.permission.value & perm:
            return sect

    return None


@lru_cache()
def process_lookup_path_by_list(names):
    if not is_alive():
        err("Process is not running")
        return None

    for name in names:
        sect = process_lookup_path(name)
        if sect is not None:
            return sect

    return None


@lru_cache()
def file_lookup_name_path(name, path):
    """Look up a file by name and path.
    Return a Zone object if found, None otherwise."""
    for xfile in get_info_files():
        if path == xfile.filename and name == xfile.name:
            return xfile
    return None


@lru_cache()
def file_lookup_address(address):
    """Look up for a file by its address.
    Return a Zone object if found, None otherwise."""
    for info in get_info_files():
        if info.zone_start <= address < info.zone_end:
            return info
    return None


@lru_cache()
def lookup_address(address):
    """Try to find the address in the process address space.
    Return an Address object, with validity flag set based on success."""
    sect = process_lookup_address(address)
    info = file_lookup_address(address)
    if sect is None and info is None:
        # i.e. there is no info on this address
        return Address(value=address, valid=False)
    return Address(value=address, section=sect, info=info)


def xor(data, key):
    """Return `data` xor-ed with `key`."""
    key = key.lstrip("0x")
    key = binascii.unhexlify(key)
    return bytearray([x ^ y for x, y in zip(data, itertools.cycle(key))])


def is_hex(pattern):
    """Return whether provided string is a hexadecimal value."""
    if not pattern.startswith("0x") and not pattern.startswith("0X"):
        return False
    return len(pattern) % 2 == 0 and all(c in string.hexdigits for c in pattern[2:])


def continue_handler(event):
    """GDB event handler for new object continue cases."""
    return


def hook_stop_handler(event):
    """GDB event handler for stop cases."""
    if current_arch is None:
        set_arch(get_arch())
    reset_all_caches()
    gdb.execute("context")
    return


def new_objfile_handler(event):
    """GDB event handler for new object file cases."""
    reset_all_caches()
    set_arch()
    load_libc_args()
    return


def exit_handler(event):
    """GDB event handler for exit cases."""
    global __gef_qemu_mode__
    reset_all_caches()
    __gef_qemu_mode__ = False
    return


def memchanged_handler(event):
    """GDB event handler for mem changes cases."""
    reset_all_caches()


def regchanged_handler(event):
    """GDB event handler for reg changes cases."""
    reset_all_caches()


def load_libc_args():
    # load libc function arguments' definitions
    if not get_gef_setting("context.libc_args"):
        return

    path = get_gef_setting("context.libc_args_path")
    if path is None:
        warn("Config `context.libc_args_path` not set but `context.libc_args` is True. Make sure you have `gef-extras` installed")
        return

    path = os.path.realpath(os.path.expanduser(path))

    if not os.path.isdir(path):
        warn("Config `context.libc_args_path` set but it's not a directory")
        return

    _arch_mode = "{}_{}".format(current_arch.arch.lower(), current_arch.mode)
    _libc_args_file = "{}/{}.json".format(path, _arch_mode)

    global libc_args_definitions

    # current arch and mode already loaded
    if _arch_mode in libc_args_definitions:
        return

    libc_args_definitions[_arch_mode] = {}
    try:
        with open(_libc_args_file) as _libc_args:
            libc_args_definitions[_arch_mode] = json.load(_libc_args)
    except FileNotFoundError as e:
        del(libc_args_definitions[_arch_mode])
        warn("Config context.libc_args is set but definition cannot be loaded: file {} not found".format(_libc_args_file))
    except json.decoder.JSONDecodeError as e:
        del(libc_args_definitions[_arch_mode])
        warn("Config context.libc_args is set but definition cannot be loaded from file {}: {}".format(_libc_args_file, e))
    return


def get_terminal_size():
    """Return the current terminal size."""
    if platform.system() == "Windows":
        from ctypes import windll, create_string_buffer
        hStdErr = -12
        herr = windll.kernel32.GetStdHandle(hStdErr)
        csbi = create_string_buffer(22)
        res = windll.kernel32.GetConsoleScreenBufferInfo(herr, csbi)
        if res:
            _, _, _, _, _, left, top, right, bottom, _, _ = struct.unpack("hhhhHhhhhhh", csbi.raw)
            tty_columns = right - left + 1
            tty_rows = bottom - top + 1
            return tty_rows, tty_columns
        else:
            return 600, 100
    else:
        import fcntl
        import termios
        try:
            tty_rows, tty_columns = struct.unpack("hh", fcntl.ioctl(1, termios.TIOCGWINSZ, "1234"))
            return tty_rows, tty_columns
        except OSError:
            return 600, 100


def get_generic_arch(module, prefix, arch, mode, big_endian, to_string=False):
    """Retrieves architecture and mode from the arguments for use for the holy
    {cap,key}stone/unicorn trinity."""
    if to_string:
        arch = "{:s}.{:s}_ARCH_{:s}".format(module.__name__, prefix, arch)
        if mode:
            mode = "{:s}.{:s}_MODE_{:s}".format(module.__name__, prefix, str(mode))
        else:
            mode = ""
        if is_big_endian():
            mode += " + {:s}.{:s}_MODE_BIG_ENDIAN".format(module.__name__, prefix)
        else:
            mode += " + {:s}.{:s}_MODE_LITTLE_ENDIAN".format(module.__name__, prefix)
    else:
        arch = getattr(module, "{:s}_ARCH_{:s}".format(prefix, arch))
        if mode:
            mode = getattr(module, "{:s}_MODE_{:s}".format(prefix, mode))
        else:
            mode = 0
        if big_endian:
            mode |= getattr(module, "{:s}_MODE_BIG_ENDIAN".format(prefix))
        else:
            mode |= getattr(module, "{:s}_MODE_LITTLE_ENDIAN".format(prefix))
    return arch, mode


def get_generic_running_arch(module, prefix, to_string=False):
    """Retrieves architecture and mode from the current context."""
    if not is_alive():
        return None, None
    if current_arch is not None:
        arch, mode = current_arch.arch, current_arch.mode
    else:
        raise OSError("Emulation not supported for your OS")
    return get_generic_arch(module, prefix, arch, mode, is_big_endian(), to_string)


def get_unicorn_arch(arch=None, mode=None, endian=None, to_string=False):
    unicorn = sys.modules["unicorn"]
    if (arch, mode, endian) == (None, None, None):
        return get_generic_running_arch(unicorn, "UC", to_string)
    return get_generic_arch(unicorn, "UC", arch, mode, endian, to_string)


def get_capstone_arch(arch=None, mode=None, endian=None, to_string=False):
    capstone = sys.modules["capstone"]

    # hacky patch to unify capstone/ppc syntax with keystone & unicorn:
    # CS_MODE_PPC32 does not exist (but UC_MODE_32 & KS_MODE_32 do)
    if is_arch(Elf.POWERPC64):
        raise OSError("Capstone not supported for PPC64 yet.")

    if is_alive() and is_arch(Elf.POWERPC):
        arch = "PPC"
        mode = "32"
        endian = is_big_endian()
        return get_generic_arch(capstone, "CS", arch or current_arch.arch, mode or current_arch.mode, endian or is_big_endian(), to_string)

    if (arch, mode, endian) == (None, None, None):
        return get_generic_running_arch(capstone, "CS", to_string)
    return get_generic_arch(capstone, "CS", arch or current_arch.arch, mode or current_arch.mode, endian or is_big_endian(), to_string)


def get_keystone_arch(arch=None, mode=None, endian=None, to_string=False):
    keystone = sys.modules["keystone"]
    if (arch, mode, endian) == (None, None, None):
        return get_generic_running_arch(keystone, "KS", to_string)
    return get_generic_arch(keystone, "KS", arch, mode, endian, to_string)


def get_unicorn_registers(to_string=False):
    "Return a dict matching the Unicorn identifier for a specific register."
    unicorn = sys.modules["unicorn"]
    regs = {}

    if current_arch is not None:
        arch = current_arch.arch.lower()
    else:
        raise OSError("Oops")

    const = getattr(unicorn, "{}_const".format(arch))
    for reg in current_arch.all_registers:
        regname = "UC_{:s}_REG_{:s}".format(arch.upper(), reg[1:].upper())
        if to_string:
            regs[reg] = "{:s}.{:s}".format(const.__name__, regname)
        else:
            regs[reg] = getattr(const, regname)
    return regs


def keystone_assemble(code, arch, mode, *args, **kwargs):
    """Assembly encoding function based on keystone."""
    keystone = sys.modules["keystone"]
    code = gef_pybytes(code)
    addr = kwargs.get("addr", 0x1000)

    @timeout.timeout(duration=1)
    def ks_asm(code, addr):
        return ks.asm(code, addr)

    try:
        ks = keystone.Ks(arch, mode)
        enc, cnt = ks_asm(code, addr)
    except keystone.KsError as e:
        err("Keystone assembler error: {:s}".format(str(e)))
        return None
    except timeout.TimeoutException:
        err("Keystone assembler timeout error")
        return None

    if cnt == 0:
        return ""

    enc = bytearray(enc)
    if "raw" not in kwargs:
        s = binascii.hexlify(enc)
        enc = b"\\x" + b"\\x".join([s[i : i + 2] for i in range(0, len(s), 2)])
        enc = enc.decode("utf-8")

    return enc


@lru_cache()
def get_elf_headers(filename=None):
    """Return an Elf object with info from `filename`. If not provided, will return
    the currently debugged file."""
    if filename is None:
        filename = get_filepath()
        if filename is None:
            return None

    if filename.startswith("target:"): # local but different mnt namespace
        prefix = "/proc/{}/root".format(get_pid())
        filename = os.path.join(prefix, filename[7:])

    return Elf(filename)


def _ptr_width():
    void = cached_lookup_type("void")
    if void is None:
        uintptr_t = cached_lookup_type("uintptr_t")
        return uintptr_t.sizeof
    else:
        return void.pointer().sizeof


@lru_cache()
def is_64bit():
    """Checks if current target is 64bit."""
    return _ptr_width() == 8


@lru_cache()
def is_32bit():
    """Checks if current target is 32bit."""
    return _ptr_width() == 4


@lru_cache()
def is_x86_64():
    """Checks if current target is x86-64"""
    return get_arch() == "i386:x86-64"


@lru_cache()
def is_x86_32():
    """Checks if current target is an x86-32"""
    return get_arch() == "i386"


@lru_cache()
def is_x86():
    return is_x86_32() or is_x86_64()


@lru_cache()
def is_arm32():
    """Checks if current target is an arm-32"""
    try:
        return current_arch.arch == "ARM"
    except:
        return False


@lru_cache()
def is_arm64():
    """Checks if current target is an aarch64"""
    try:
        return current_arch.arch == "ARM64"
    except:
        return False


@lru_cache()
def is_arch(arch):
    """Checks if current target is specific architecture"""
    elf = current_elf or get_elf_headers()
    return elf and elf.e_machine == arch


@lru_cache()
def is_static(filename=None):
    if filename is None:
        filename = get_filepath()
    file_bin = which("file")
    cmd = [file_bin, filename]
    out = gef_execute_external(cmd)
    return "statically linked" in out


@lru_cache()
def is_stripped(filename=None):
    if filename is None:
        filename = get_filepath()
    file_bin = which("file")
    cmd = [file_bin, filename]
    out = gef_execute_external(cmd)
    return not ("not stripped" in out)


def set_arch(arch=None, default=None):
    """Sets the current architecture.
    If an arch is explicitly specified, use that one, otherwise try to parse it
    out of the current target. If that fails, and default is specified, select and
    set that arch.
    Return the selected arch, or raise an OSError."""
    arches = {
        "ARM": ARM, Elf.ARM: ARM, "ARMV2": ARM, "ARMV3": ARM, "ARMV3M": ARM, "ARMV4": ARM,
        "ARMV4T":ARM, "ARMV5":ARM, "ARMV5T":ARM, "ARMV5TE":ARM, "ARMV6":ARM, "ARMV7": ARM,
        "AARCH64": AARCH64, "ARM64": AARCH64, Elf.AARCH64: AARCH64,
        "X86": X86, Elf.X86_32: X86, "I386": X86, "I386:INTEL": X86, "I8086": X86,
        "X64": X86_64, "AMD64": X86_64,
        "X86_64": X86_64, Elf.X86_64: X86_64,
        "X86-64": X86_64, Elf.X86_64: X86_64,
        "I386:X86_64": X86_64, "I386:X86_64:INTEL": X86_64, "I386:X64_32": X86_64, "I386:X64_32:INTEL": X86_64,
        "I386:X86-64": X86_64, "I386:X86-64:INTEL": X86_64, "I386:X64-32": X86_64, "I386:X64-32:INTEL": X86_64,
        "I386:NACL": X86,
        "I386:X86_64:NACL": X86_64, "I386:X86-64:NACL": X86_64,
        "I386:X64_32:NACL": X86_64, "I386:X64-32:NACL": X86_64,
        "POWERPC": PowerPC, "PPC": PowerPC, Elf.POWERPC: PowerPC,
        "POWERPC64": PowerPC64, "PPC64": PowerPC64, Elf.POWERPC64: PowerPC64,
        "RISCV": RISCV, "RISCV:RV64":RISCV, Elf.RISCV: RISCV,
        "SPARC": SPARC, Elf.SPARC: SPARC,
        "SPARC64": SPARC64, Elf.SPARC64: SPARC64,
        "MIPS": MIPS, Elf.MIPS: MIPS,
    }
    global current_arch, current_elf

    if arch:
        try:
            if isinstance(arch, str):
                current_arch = arches[arch.upper()]()
            else:
                current_arch = arches[arch]()
            return
        except KeyError:
            if isinstance(arch, str):
                raise OSError("Specified arch {:s} is not supported".format(arch.upper()))
            else:
                raise OSError("Specified arch {:d} is not supported".format(arch))
    else:
        if not current_elf:
            elf = get_elf_headers()
            if elf and elf.is_valid():
                current_elf = elf
            else:
                current_elf = None

        try:
            if current_elf:
                current_arch = arches[current_elf.e_machine]()
            else:
                current_arch = arches[get_arch().upper()]()
        except KeyError:
            if default:
                try:
                    current_arch = arches[default.upper()]()
                except KeyError:
                    raise OSError("CPU not supported, neither is default {:s}".format(default.upper()))
            else:
                raise OSError("CPU type is currently not supported: {:s}".format(get_arch().upper()))
        return


@lru_cache()
def cached_lookup_type(_type):
    try:
        return gdb.lookup_type(_type).strip_typedefs()
    except RuntimeError:
        return None


@lru_cache()
def get_memory_alignment(in_bits=False):
    """Try to determine the size of a pointer on this system.
    First, try to parse it out of the ELF header.
    Next, use the size of `size_t`.
    Finally, try the size of $pc.
    If `in_bits` is set to True, the result is returned in bits, otherwise in bytes."""
    if is_32bit():
        return 4 if not in_bits else 32
    elif is_64bit():
        return 8 if not in_bits else 64

    res = cached_lookup_type("size_t")
    if res is not None:
        return res.sizeof if not in_bits else res.sizeof * 8

    try:
        return gdb.parse_and_eval("$pc").type.sizeof
    except:
        pass
    raise EnvironmentError("GEF is running under an unsupported mode")


def clear_screen(tty=""):
    """Clear the screen."""
    if not tty:
        gdb.execute("shell clear -x")
        return

    # Since the tty can be closed at any time, a PermissionError exception can
    # occur when `clear_screen` is called. We handle this scenario properly
    try:
        with open(tty, "wt") as f:
            f.write("\x1b[H\x1b[J")
    except PermissionError:
        __gef_redirect_output_fd__ = None
        set_gef_setting("context.redirect", "")
    return


def format_address(addr):
    """Format the address according to its size."""
    memalign_size = get_memory_alignment()

    if isinstance(addr, str):
        if addr.startswith("0x"):
            return addr
        else:
            return "0x" + addr

    addr = align_address(addr)

    if memalign_size == 4:
        return "{:#010x}".format(addr)

    return "{:#018x}".format(addr)


def format_address_spaces(addr, left=True):
    """Format the address according to its size, but with spaces instead of zeroes."""
    width = get_memory_alignment() * 2 + 2
    addr = align_address(addr)

    if not left:
        return "{:#x}".format(addr).rjust(width)

    return "{:#x}".format(addr).ljust(width)


def align_address(address):
    """Align the provided address to the process's native length."""
    if get_memory_alignment() == 4:
        return address & 0xFFFFFFFF
    return address & 0xFFFFFFFFFFFFFFFF


def align_address_to_size(address, align):
    """Align the address to the given size."""
    return address + ((align - (address % align)) % align)


def align_address_to_page(address):
    """Align the address to a page."""
    a = align_address(address) >> DEFAULT_PAGE_ALIGN_SHIFT
    return a << DEFAULT_PAGE_ALIGN_SHIFT


def parse_address(address):
    """Parse an address and return it as an Integer."""
    if is_hex(address):
        return int(address, 16)
    return to_unsigned_long(gdb.parse_and_eval(address))


def get_ksymaddr(sym):
    # use available symbol
    try:
        return parse_address('&' + sym)
    except:
        pass
    # use ksymaddr-remote
    try:
        res = gdb.execute("ksymaddr-remote --silent --exact {:s}".format(sym), to_string=True)
        return int(res.split()[0], 16)
    except:
        return None

def is_in_x86_kernel(address):
    address = align_address(address)
    memalign = get_memory_alignment(in_bits=True) - 1
    return (address >> memalign) == 0xF


@lru_cache()
def endian_str():
    return "<" if is_little_endian() else ">"


@lru_cache()
def is_remote_debug():
    """"Return True is the current debugging session is running through GDB remote session."""
    res = gdb.execute("maintenance print target-stack", to_string=True)
    return "remote" in res


@lru_cache()
def is_remote_but_same_host():
    for ip, port in list(c.raddr for c in psutil.Process().connections()):
        if ip == "127.0.0.1":
            return True
    return False


def de_bruijn(alphabet, n):
    """De Bruijn sequence for alphabet and subsequences of length n (for compat. w/ pwnlib)."""
    k = len(alphabet)
    a = [0] * k * n
    def db(t, p):
        if t > n:
            if n % p == 0:
                for j in range(1, p + 1):
                    yield alphabet[a[j]]
        else:
            a[t] = a[t - p]
            for c in db(t + 1, p):
                yield c

            for j in range(a[t - p] + 1, k):
                a[t] = j
                for c in db(t + 1, t):
                    yield c
    return db(1, 1)


def generate_cyclic_pattern(length):
    """Create a `length` byte bytearray of a de Bruijn cyclic pattern."""
    charset = bytearray(b"abcdefghijklmnopqrstuvwxyz")
    cycle = get_memory_alignment()
    return bytearray(itertools.islice(de_bruijn(charset, cycle), length))


def safe_parse_and_eval(value):
    """GEF wrapper for gdb.parse_and_eval(): this function returns None instead of raising
    gdb.error if the eval failed."""
    try:
        return gdb.parse_and_eval(value)
    except gdb.error:
        return None


@lru_cache()
def dereference(addr):
    """GEF wrapper for gdb dereference function."""
    try:
        ulong_t = cached_lookup_type(use_stdtype()) or \
                  cached_lookup_type(use_default_type()) or \
                  cached_lookup_type(use_golang_type()) or \
                  cached_lookup_type(use_rust_type())
        unsigned_long_type = ulong_t.pointer()
        res = gdb.Value(addr).cast(unsigned_long_type).dereference()
        # GDB does lazy fetch by default so we need to force access to the value
        res.fetch_lazy()
        return res
    except gdb.MemoryError:
        pass
    return None


def gef_convenience(value):
    """Defines a new convenience value."""
    global __gef_convenience_vars_index__
    var_name = "$_gef{:d}".format(__gef_convenience_vars_index__)
    __gef_convenience_vars_index__ += 1
    gdb.execute("""set {:s} = "{:s}" """.format(var_name, value))
    return var_name


def parse_string_range(s):
    """Parses an address range (e.g. 0x400000-0x401000)"""
    addrs = s.split("-")
    return map(lambda x: int(x, 16), addrs)


AT_CONSTANTS = {
    0  : 'AT_NULL',          # /* End of vector */
    1  : 'AT_IGNORE',        # /* Entry should be ignored */
    2  : 'AT_EXECFD',        # /* File descriptor of program */
    3  : 'AT_PHDR',          # /* Program headers for program */
    4  : 'AT_PHENT',         # /* Size of program header entry */
    5  : 'AT_PHNUM',         # /* Number of program headers */
    6  : 'AT_PAGESZ',        # /* System page size */
    7  : 'AT_BASE',          # /* Base address of interpreter */
    8  : 'AT_FLAGS',         # /* Flags */
    9  : 'AT_ENTRY',         # /* Entry point of program */
    10 : 'AT_NOTELF',        # /* Program is not ELF */
    11 : 'AT_UID',           # /* Real uid */
    12 : 'AT_EUID',          # /* Effective uid */
    13 : 'AT_GID',           # /* Real gid */
    14 : 'AT_EGID',          # /* Effective gid */
    15 : 'AT_PLATFORM',      # /* String identifying platform */
    16 : 'AT_HWCAP',         # /* Machine dependent hints about processor capabilities */
    17 : 'AT_CLKTCK',        # /* Frequency of times() */
    18 : 'AT_FPUCW',
    19 : 'AT_DCACHEBSIZE',
    20 : 'AT_ICACHEBSIZE',
    21 : 'AT_UCACHEBSIZE',
    22 : 'AT_IGNOREPPC',
    23 : 'AT_SECURE',
    24 : 'AT_BASE_PLATFORM', # String identifying real platforms
    25 : 'AT_RANDOM',        # Address of 16 random bytes
    26 : 'AT_HWCAP2',        # extension of AT_HWCAP
    31 : 'AT_EXECFN',        # Filename of executable
    32 : 'AT_SYSINFO',
    33 : 'AT_SYSINFO_EHDR',
    34 : 'AT_L1I_CACHESHAPE',
    35 : 'AT_L1D_CACHESHAPE',
    36 : 'AT_L2_CACHESHAPE',
    37 : 'AT_L3_CACHESHAPE',
}


# get_auxiliary_walk (used qemu-user mode) is too slower,
# Because it repeats read_memory many times to find the auxv value.
# lru_cache() is not effective because it is cleared every time you stepi.
# Fortunately, memory maps rarely change.
# I decided to make it a cache mechanism independent of lru_cache and introduce a mechanism to forcibly clear it with vmmap.
explored_auxv = {}


def clear_explored_auxv():
    global explored_auxv
    explored_auxv = {}
    return


def get_auxiliary_walk(offset=0):
    """Find AUXV by walking stack"""

    # return if it is cached
    global explored_auxv
    if offset in explored_auxv:
        return explored_auxv[offset]

    addr = get_register("$sp") & ~(DEFAULT_PAGE_SIZE-1)

    # check readable or not
    try:
        v = read_memory(addr, 1)
    except:
        return None

    # find stack bottom
    try:
        while True:
            if b"\x7fELF" == read_memory(addr, 4):
                break
            addr += DEFAULT_PAGE_SIZE
    except: # if read error, that is stack bottom
        pass
    current = addr - current_arch.ptrsize*2 - offset

    # find auxv end
    while True:
        a = read_int_from_memory(current)
        b = read_int_from_memory(current + current_arch.ptrsize)
        if a == b == 0:
            break
        current -= current_arch.ptrsize * 2

    # skip dummy null if exist
    for i in range(1024):
        a = read_int_from_memory(current)
        if a == 7: # AT_BASE
            break
        current -= current_arch.ptrsize * 2
    else:
        return None

    # find auxv start
    while read_int_from_memory(current) <= 37: # AT_L3_CACHESHAPE
        current -= current_arch.ptrsize * 2
    current += current_arch.ptrsize * 2

    # parse auxv
    res = {}
    while True:
        key = read_int_from_memory(current)
        val = read_int_from_memory(current + current_arch.ptrsize)
        if not key in AT_CONSTANTS:
            break
        res[AT_CONSTANTS[key]] = val
        if key == 0:
            break
        current += current_arch.ptrsize * 2

    # test
    if "AT_ENTRY" not in res:
        return None
    if "AT_PHDR" not in res:
        return None
    if "AT_RANDOM" not in res:
        return None
    if "AT_BASE" not in res:
        return None
    if "AT_NULL" not in res:
        return None

    # cache_globally
    explored_auxv[offset] = res.copy()
    return res


@lru_cache()
def gef_get_auxiliary_values():
    """Retrieves the auxiliary values of the current execution.
    Returns None if not running, or a dict() of values."""
    if not is_alive():
        return None

    if is_qemu_usermode():
        if is_arm32():
            # sometimes AUXV under qemu-arm is not aligned.
            # for fast search, switch order
            for offset in [current_arch.ptrsize, 0]:
                result = get_auxiliary_walk(offset)
                if result:
                    return result
        else:
            for offset in [0, current_arch.ptrsize]:
                result = get_auxiliary_walk(offset)
                if result:
                    return result
        return None

    try:
        result = gdb.execute("info auxv", to_string=True)
    except:
        return None

    res = {}
    for line in result.splitlines():
        tmp = line.split()
        _type = tmp[1]
        if _type in ("AT_PLATFORM", "AT_EXECFN"):
            m = re.match("^.+?(0x[0-9a-f]+)", line)
            res[_type] = int(m.group(1), base=0)
        else:
            res[_type] = int(tmp[-1], base=0)
    return res


def gef_read_canary():
    """Read the canary of a running process using Auxiliary Vector.
    Return a tuple of (canary, location) if found, None otherwise."""
    auxval = gef_get_auxiliary_values()
    if not auxval:
        return None

    canary_location = auxval["AT_RANDOM"]
    canary = read_int_from_memory(canary_location)
    canary &= ~0xFF
    return canary, canary_location


def gef_get_pie_breakpoint(num):
    global __pie_breakpoints__
    return __pie_breakpoints__[num]


@lru_cache()
def gef_getpagesize():
    """Get the page size from auxiliary values."""
    auxval = gef_get_auxiliary_values()
    if not auxval:
        return DEFAULT_PAGE_SIZE
    return auxval["AT_PAGESZ"]


def only_if_events_supported(event_type):
    """Checks if GDB supports events without crashing."""

    def wrap(f):
        def wrapped_f(*args, **kwargs):
            if getattr(gdb, "events") and getattr(gdb.events, event_type):
                return f(*args, **kwargs)
            warn("GDB events cannot be set")
        return wrapped_f

    return wrap


#
# Event hooking
#

@only_if_events_supported("cont")
def gef_on_continue_hook(func):
    return gdb.events.cont.connect(func)


@only_if_events_supported("cont")
def gef_on_continue_unhook(func):
    return gdb.events.cont.disconnect(func)


@only_if_events_supported("stop")
def gef_on_stop_hook(func):
    return gdb.events.stop.connect(func)


@only_if_events_supported("stop")
def gef_on_stop_unhook(func):
    return gdb.events.stop.disconnect(func)


@only_if_events_supported("exited")
def gef_on_exit_hook(func):
    return gdb.events.exited.connect(func)


@only_if_events_supported("exited")
def gef_on_exit_unhook(func):
    return gdb.events.exited.disconnect(func)


@only_if_events_supported("new_objfile")
def gef_on_new_hook(func):
    return gdb.events.new_objfile.connect(func)


@only_if_events_supported("new_objfile")
def gef_on_new_unhook(func):
    return gdb.events.new_objfile.disconnect(func)


@only_if_events_supported("memory_changed")
def gef_on_memchanged_hook(func):
    return gdb.events.memory_changed.connect(func)


@only_if_events_supported("memory_changed")
def gef_on_memchanged_unhook(func):
    return gdb.events.memory_changed.disconnect(func)


@only_if_events_supported("register_changed")
def gef_on_regchanged_hook(func):
    return gdb.events.register_changed.connect(func)


@only_if_events_supported("register_changed")
def gef_on_regchanged_unhook(func):
    return gdb.events.register_changed.disconnect(func)

#
# Virtual breakpoints
#

class PieVirtualBreakpoint:
    """PIE virtual breakpoint (not real breakpoint)."""
    def __init__(self, set_func, vbp_num, addr):
        # set_func(base): given a base address return a
        # "set breakpoint" gdb command string
        self.set_func = set_func
        self.vbp_num = vbp_num
        # breakpoint num, 0 represents not instantiated yet
        self.bp_num = 0
        self.bp_addr = 0
        # this address might be a symbol, just to know where to break
        if isinstance(addr, int):
            self.addr = hex(addr)
        else:
            self.addr = addr
        return

    def instantiate(self, base):
        if self.bp_num:
            self.destroy()

        try:
            res = gdb.execute(self.set_func(base), to_string=True)
        except gdb.error as e:
            err(e)
            return

        if "Breakpoint" not in res:
            err(res)
            return
        res_list = res.split()
        self.bp_num = res_list[1]
        self.bp_addr = res_list[3]
        return

    def destroy(self):
        if not self.bp_num:
            err("Destroy PIE breakpoint not even set")
            return
        gdb.execute("delete {}".format(self.bp_num))
        self.bp_num = 0
        return

#
# Breakpoints
#

class FormatStringBreakpoint(gdb.Breakpoint):
    """Inspect stack for format string."""
    def __init__(self, spec, num_args):
        super().__init__(spec, type=gdb.BP_BREAKPOINT, internal=False)
        self.num_args = num_args
        self.enabled = True
        return

    def stop(self):
        reset_all_caches()
        msg = []
        ptr, addr = current_arch.get_ith_parameter(self.num_args)
        addr = lookup_address(addr)

        if not addr.valid:
            return False

        if addr.section.permission.value & Permission.WRITE:
            content = read_cstring_from_memory(addr.value)
            name = addr.info.name if addr.info else addr.section.path
            msg.append(Color.colorify("Format string helper", "yellow bold"))
            m = "Possible insecure format string: {:s}('{:s}' {:s} {:#x}: '{:s}')"
            msg.append(m.format(self.location, ptr, RIGHT_ARROW, addr.value, content))
            m = "Reason: Call to '{:s}()' with format string argument in position "
            m += "#{:d} is in page {:#x} ({:s}) that has write permission"
            msg.append(m.format(self.location, self.num_args, addr.section.page_start, name))
            push_context_message("warn", "\n".join(msg))
            return True
        return False


class StubBreakpoint(gdb.Breakpoint):
    """Create a breakpoint to permanently disable a call (fork/alarm/signal/etc.)."""
    def __init__(self, func, retval):
        super().__init__(func, gdb.BP_BREAKPOINT, internal=False)
        self.func = func
        self.retval = retval

        m = "All calls to '{:s}' will be skipped".format(self.func)
        if self.retval is not None:
            m += " (with return value set to {:#x})".format(self.retval)
        info(m)
        return

    def stop(self):
        m = "Ignoring call to '{:s}' ".format(self.func)
        m += "(setting return value to {:#x})".format(self.retval)
        gdb.execute("return (unsigned int){:#x}".format(self.retval))
        ok(m)
        return False


class ChangePermissionBreakpoint(gdb.Breakpoint):
    """When hit, this temporary breakpoint will restore the original code, and position
    $pc correctly."""
    def __init__(self, loc, code, pc):
        super().__init__(loc, gdb.BP_BREAKPOINT, internal=False)
        self.original_code = code
        self.original_pc = pc
        return

    def stop(self):
        info("Restoring original context")
        write_memory(self.original_pc, self.original_code, len(self.original_code))
        info("Restoring $pc")
        gdb.execute("set $pc = {:#x}".format(self.original_pc))
        return True


class TraceMallocBreakpoint(gdb.Breakpoint):
    """Track allocations done with malloc() or calloc()."""
    def __init__(self, name):
        super().__init__(name, gdb.BP_BREAKPOINT, internal=True)
        self.silent = True
        self.name = name
        return

    def stop(self):
        # The first call to malloc calls malloc twice internally, like malloc-> malloc_hook_ini-> malloc.
        # You need to prevent the breakpoint from being set twice.
        if hasattr(self, "retbp") and self.retbp.enabled:
            return False
        reset_all_caches()
        _, size = current_arch.get_ith_parameter(0)
        self.retbp = TraceMallocRetBreakpoint(size, self.name)
        return False


class TraceMallocRetBreakpoint(gdb.FinishBreakpoint):
    """Internal temporary breakpoint to retrieve the return value of malloc()."""
    def __init__(self, size, name):
        super().__init__(gdb.newest_frame(), internal=True)
        self.size = size
        self.name = name
        self.silent = True
        return

    def stop(self):
        global __heap_uaf_watchpoints__, __heap_freed_list__, __heap_allocated_list__

        if self.return_value:
            loc = int(self.return_value)
        else:
            loc = parse_address(current_arch.return_register)

        size = self.size
        ok("{} - {}({})={:#x}".format(Color.colorify("Heap-Analysis", "yellow bold"), self.name, size, loc))
        check_heap_overlap = get_gef_setting("heap-analysis-helper.check_heap_overlap")

        # pop from free-ed list if it was in it
        if __heap_freed_list__:
            idx = 0
            for item in __heap_freed_list__:
                addr = item[0]
                if addr == loc:
                    __heap_freed_list__.remove(item)
                    continue
                idx += 1

        # pop from uaf watchlist
        if __heap_uaf_watchpoints__:
            idx = 0
            for wp in __heap_uaf_watchpoints__:
                wp_addr = wp.address
                if loc <= wp_addr < loc + size:
                    __heap_uaf_watchpoints__.remove(wp)
                    wp.enabled = False
                    continue
                idx += 1

        item = (loc, size)

        if check_heap_overlap:
            # seek all the currently allocated chunks, read their effective size and check for overlap
            msg = []
            align = get_memory_alignment()
            for chunk_addr, _ in __heap_allocated_list__:
                current_chunk = GlibcChunk(chunk_addr)
                current_chunk_size = current_chunk.get_chunk_size()

                if not (chunk_addr <= loc < chunk_addr + current_chunk_size):
                    continue
                offset = loc - chunk_addr - 2*align
                if offset < 0:
                    continue # false positive, discard

                msg.append(Color.colorify("Heap-Analysis", "yellow bold"))
                msg.append("Possible heap overlap detected")
                fmt = "Reason {} new allocated chunk {:#x} (of size {:d}) overlaps in-used chunk {:#x} (of size {:#x})"
                msg.append(fmt.format(RIGHT_ARROW, loc, size, chunk_addr, current_chunk_size))
                msg.append("Writing {0:d} bytes from {1:#x} will reach chunk {2:#x}".format(offset, chunk_addr, loc))
                msg.append("Payload example for chunk {1:#x} (to overwrite {0:#x} headers):".format(loc, chunk_addr))
                msg.append("  data = 'A'*{0:d} + 'B'*{1:d} + 'C'*{1:d}".format(offset, align))
                push_context_message("warn", "\n".join(msg))
                return True

        # add it to alloc-ed list
        __heap_allocated_list__.append(item)
        return False


class TraceReallocBreakpoint(gdb.Breakpoint):
    """Track re-allocations done with realloc()."""
    def __init__(self):
        super().__init__("__libc_realloc", gdb.BP_BREAKPOINT, internal=True)
        self.silent = True
        return

    def stop(self):
        _, ptr = current_arch.get_ith_parameter(0)
        _, size = current_arch.get_ith_parameter(1)
        self.retbp = TraceReallocRetBreakpoint(ptr, size)
        return False


class TraceReallocRetBreakpoint(gdb.FinishBreakpoint):
    """Internal temporary breakpoint to retrieve the return value of realloc()."""
    def __init__(self, ptr, size):
        super().__init__(gdb.newest_frame(), internal=True)
        self.ptr = ptr
        self.size = size
        self.silent = True
        return

    def stop(self):
        global __heap_uaf_watchpoints__, __heap_freed_list__, __heap_allocated_list__

        if self.return_value:
            newloc = int(self.return_value)
        else:
            newloc = parse_address(current_arch.return_register)

        if newloc != self:
            ok("{} - realloc({:#x}, {})={}".format(Color.colorify("Heap-Analysis", "yellow bold"),
                                                   self.ptr, self.size,
                                                   Color.colorify("{:#x}".format(newloc), "green"),))
        else:
            ok("{} - realloc({:#x}, {})={}".format(Color.colorify("Heap-Analysis", "yellow bold"),
                                                   self.ptr, self.size,
                                                   Color.colorify("{:#x}".format(newloc), "red"),))

        item = (newloc, self.size)

        try:
            # check if item was in alloc-ed list
            idx = [x for x, y in __heap_allocated_list__].index(self.ptr)
            # if so pop it out
            item = __heap_allocated_list__.pop(idx)
        except ValueError:
            if is_debug():
                warn("Chunk {:#x} was not in tracking list".format(self.ptr))
        finally:
            # add new item to alloc-ed list
            __heap_allocated_list__.append(item)

        return False


class TraceFreeBreakpoint(gdb.Breakpoint):
    """Track calls to free() and attempts to detect inconsistencies."""
    def __init__(self):
        super().__init__("__libc_free", gdb.BP_BREAKPOINT, internal=True)
        self.silent = True
        return

    def stop(self):
        reset_all_caches()
        _, addr = current_arch.get_ith_parameter(0)
        msg = []
        check_free_null = get_gef_setting("heap-analysis-helper.check_free_null")
        check_double_free = get_gef_setting("heap-analysis-helper.check_double_free")
        check_weird_free = get_gef_setting("heap-analysis-helper.check_weird_free")
        check_uaf = get_gef_setting("heap-analysis-helper.check_uaf")

        ok("{} - free({:#x})".format(Color.colorify("Heap-Analysis", "yellow bold"), addr))
        if addr == 0:
            if check_free_null:
                msg.append(Color.colorify("Heap-Analysis", "yellow bold"))
                msg.append("Attempting to free(NULL) at {:#x}".format(current_arch.pc))
                msg.append("Reason: if NULL page is allocatable, this can lead to code execution.")
                push_context_message("warn", "\n".join(msg))
                return True
            return False

        if addr in [x for (x, y) in __heap_freed_list__]:
            if check_double_free:
                msg.append(Color.colorify("Heap-Analysis", "yellow bold"))
                fmt = "Double-free detected {} free({:#x}) is called at {:#x} but is already in the free-ed list"
                msg.append(fmt.format(RIGHT_ARROW, addr, current_arch.pc))
                msg.append("Execution will likely crash...")
                push_context_message("warn", "\n".join(msg))
                return True
            return False

        # if here, no error
        # 1. move alloc-ed item to free list
        try:
            # pop from alloc-ed list
            idx = [x for x, y in __heap_allocated_list__].index(addr)
            item = __heap_allocated_list__.pop(idx)

        except ValueError:
            if check_weird_free:
                msg.append(Color.colorify("Heap-Analysis", "yellow bold"))
                msg.append("Heap inconsistency detected:")
                msg.append("Attempting to free an unknown value: {:#x}".format(addr))
                push_context_message("warn", "\n".join(msg))
                return True
            return False

        # 2. add it to free-ed list
        __heap_freed_list__.append(item)

        self.retbp = None
        if check_uaf:
            # 3. (opt.) add a watchpoint on pointer
            self.retbp = TraceFreeRetBreakpoint(addr)
        return False


class TraceFreeRetBreakpoint(gdb.FinishBreakpoint):
    """Internal temporary breakpoint to track free()d values."""
    def __init__(self, addr):
        super().__init__(gdb.newest_frame(), internal=True)
        self.silent = True
        self.addr = addr
        return

    def stop(self):
        reset_all_caches()
        wp = UafWatchpoint(self.addr)
        __heap_uaf_watchpoints__.append(wp)
        return False


class UafWatchpoint(gdb.Breakpoint):
    """Custom watchpoints set TraceFreeBreakpoint() to monitor free()d pointers being used."""
    def __init__(self, addr):
        super().__init__("*{:#x}".format(addr), gdb.BP_WATCHPOINT, internal=True)
        self.address = addr
        self.silent = True
        self.enabled = True
        return

    def stop(self):
        """If this method is triggered, we likely have a UaF. Break the execution and report it."""
        reset_all_caches()
        frame = gdb.selected_frame()
        if frame.name() in ("_int_malloc", "malloc_consolidate", "__libc_calloc", ):
            return False

        # software watchpoints stop after the next statement (see
        # https://sourceware.org/gdb/onlinedocs/gdb/Set-Watchpoints.html)
        pc = gdb_get_nth_previous_instruction_address(current_arch.pc, 2)
        insn = gef_current_instruction(pc)
        msg = []
        msg.append(Color.colorify("Heap-Analysis", "yellow bold"))
        msg.append("Possible Use-after-Free in '{:s}': pointer {:#x} was freed, but is attempted to be used at {:#x}"
                   .format(get_filepath(), self.address, pc))
        msg.append("{:#x}   {:s} {:s}".format(insn.address, insn.mnemonic, Color.yellowify(", ".join(insn.operands))))
        push_context_message("warn", "\n".join(msg))
        return True


class EntryBreakBreakpoint(gdb.Breakpoint):
    """Breakpoint used internally to stop execution at the most convenient entry point."""
    def __init__(self, location):
        super().__init__(location, gdb.BP_BREAKPOINT, internal=True, temporary=True)
        self.silent = True
        return

    def stop(self):
        reset_all_caches()
        return True


class NamedBreakpoint(gdb.Breakpoint):
    """Breakpoint which shows a specified name, when hit."""
    def __init__(self, location, name):
        super().__init__(spec=location, type=gdb.BP_BREAKPOINT, internal=False, temporary=False)
        self.name = name
        self.loc = location

        return

    def stop(self):
        reset_all_caches()
        push_context_message("info", "Hit breakpoint {} ({})".format(self.loc, Color.colorify(self.name, "red bold")))
        return True


#
# Commands
#

def register_external_command(obj):
    """Registering function for new GEF (sub-)command to GDB."""
    global __commands__, __gef__
    cls = obj.__class__
    __commands__.append(cls)
    __gef__.load(initial=False)
    __gef__.doc.add_command_to_doc((cls._cmdline_, cls, None))
    __gef__.doc.refresh()
    return cls


def register_command(cls):
    """Decorator for registering new GEF (sub-)command to GDB."""
    global __commands__
    __commands__.append(cls)
    return cls


def register_priority_command(cls):
    """Decorator for registering new command with priority, meaning that it must
    loaded before the other generic commands."""
    global __commands__
    __commands__.insert(0, cls)
    return cls


def register_function(cls):
    """Decorator for registering a new convenience function to GDB."""
    global __functions__
    __functions__.append(cls)
    return cls


class GenericCommand(gdb.Command):
    """This is an abstract class for invoking commands, should not be instantiated."""
    __metaclass__ = abc.ABCMeta

    def __init__(self, *args, **kwargs):
        self.pre_load()
        syntax = Color.yellowify("\nSyntax: ") + self._syntax_
        example = Color.yellowify("\nExample: ") + self._example_ if self._example_ else ""
        aliases = Color.yellowify("\nAliases: ") + str(self._aliases_) if hasattr(self, "_aliases_") else ""
        self.__doc__ = self.__doc__.replace(" "*4, "") + syntax + example + aliases
        self.repeat = False
        self.repeat_count = 0
        self.__last_command = None
        command_type = kwargs.setdefault("command", gdb.COMMAND_OBSCURE)
        complete_type = kwargs.setdefault("complete", gdb.COMPLETE_NONE)
        prefix = kwargs.setdefault("prefix", False)
        super().__init__(self._cmdline_, command_type, complete_type, prefix)
        self.post_load()
        return

    def invoke(self, args, from_tty):
        try:
            argv = gdb.string_to_argv(args)
            self.__set_repeat_count(argv, from_tty)
            bufferize(self.do_invoke)(argv)
        except Exception as e:
            # Note: since we are intercepting cleaning exceptions here, commands preferably should avoid
            # catching generic Exception, but rather specific ones. This is allows a much cleaner use.
            if is_debug():
                show_last_exception()
            else:
                err("Command '{:s}' failed to execute properly, reason: {:s}".format(self._cmdline_, str(e)))
        return

    def usage(self):
        if self._example_:
            err("Syntax\n{}\n\nExample\n{}".format(self._syntax_, self._example_.lstrip()))
        else:
            err("Syntax\n{}".format(self._syntax_))
        return

    @abc.abstractproperty
    def _cmdline_(self): pass

    @abc.abstractproperty
    def _syntax_(self): pass

    @abc.abstractproperty
    def _example_(self): return ""

    @abc.abstractmethod
    def do_invoke(self, argv): pass

    def pre_load(self): pass

    def post_load(self): pass

    def __get_setting_name(self, name):
        def __sanitize_class_name(clsname):
            if " " not in clsname:
                return clsname
            return "-".join(clsname.split())

        class_name = __sanitize_class_name(self.__class__._cmdline_)
        return "{:s}.{:s}".format(class_name, name)

    @property
    def settings(self):
        """Return the list of settings for this command."""
        return [ x.split(".", 1)[1] for x in __config__ if x.startswith("{:s}.".format(self._cmdline_)) ]

    def get_setting(self, name):
        key = self.__get_setting_name(name)
        setting = __config__[key]
        return setting[1](setting[0])

    def has_setting(self, name):
        key = self.__get_setting_name(name)
        return key in __config__

    def add_setting(self, name, value, description=""):
        # make sure settings are always associated to the root command (which derives from GenericCommand)
        if "GenericCommand" not in [x.__name__ for x in self.__class__.__bases__]:
            return
        key = self.__get_setting_name(name)
        __config__[key] = [value, type(value), description]
        get_gef_setting.cache_clear()
        return

    def del_setting(self, name):
        key = self.__get_setting_name(name)
        del __config__[key]
        get_gef_setting.cache_clear()
        return

    def __set_repeat_count(self, argv, from_tty):
        if not from_tty:
            self.repeat = False
            self.repeat_count = 0
            return

        command = gdb.execute("show commands", to_string=True).strip().split("\n")[-1]
        self.repeat = self.__last_command == command
        self.repeat_count = self.repeat_count + 1 if self.repeat else 0
        self.__last_command = command
        return


# Copy/paste this template for new command
# @register_command
# class TemplateCommand(GenericCommand):
#     """TemplateCommand: description here will be seen in the help menu for the command."""
#     _cmdline_ = "template-fake"
#     _syntax_ = "{:s}".format(_cmdline_)
#     _aliases_ = ["tpl-fk",]
#     _category_ = "Misc"
#     def __init__(self):
#        super().__init__(complete=gdb.COMPLETE_FILENAME)
#         return
#     def do_invoke(self, argv):
#         self.dont_repeat()
#         return


@register_command
class PrintFormatCommand(GenericCommand):
    """Print bytes format in high level languages."""
    _cmdline_ = "print-format"
    _syntax_ = "{:s} [-f FORMAT] [-b BITSIZE] [-l LENGTH] [-c] [-h] LOCATION\n".format(_cmdline_)
    _syntax_ += "  -f FORMAT   specifies the output format, avaliable value: py, c, js, asm, hex (default py).\n"
    _syntax_ += "  -b BITSIZE  sepecifies size of bit, avaliable values is 8, 16, 32, 64 (default is 8).\n"
    _syntax_ += "  -l LENGTH   specifies length of array (default is 256).\n"
    _syntax_ += "  -c          The result of data will copied to clipboard\n"
    _syntax_ += "  LOCATION    specifies where the address of bytes is stored."
    _example_ = "{:s} -f py -b 8 -l 256 $rsp".format(_cmdline_)
    _category_ = "Exploit Development"
    _aliases_ = ["pf",]

    bitformat = {8: "<B", 16: "<H", 32: "<I", 64: "<Q"}
    c_type = {8: "char", 16: "short", 32: "int", 64: "long long"}
    asm_type = {8: "db", 16: "dw", 32: "dd", 64: "dq"}

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def clip(self, data):
        if sys.platform == "linux":
            try:
                xclip = which("xclip")
            except FileNotFoundError as e:
                err("{}".format(e))
                return False
            prog = [xclip, "-selection", "clipboard", "-i"] # For linux

        elif sys.platform == "darwin":
            try:
                pbcopy = which("pbcopy")
            except FileNotFoundError as e:
                err("{}".format(e))
                return False
            prog = [pbcopy] # For OSX

        else:
            warn("Can't copy to clipboard, platform not supported")
            return False

        try:
            p = subprocess.Popen(prog, stdin=subprocess.PIPE)
        except Exception:
            warn("Can't copy to clipboard, Something went wrong while copying")
            return False

        p.stdin.write(data)
        p.stdin.close()
        p.wait()
        return True

    def do_invoke(self, argv):
        """Default value for print-format command."""
        self.dont_repeat()
        lang = "py"
        length = 256
        bitlen = 8
        copy_to_clipboard = False
        supported_formats = ["py", "c", "js", "asm", "hex"]

        try:
            opts, args = getopt.getopt(argv, "f:l:b:ch")
            for o, a in opts:
                if o == "-f":
                    lang = a
                elif o == "-l":
                    length = int(gdb.parse_and_eval(a))
                elif o == "-b":
                    bitlen = int(a)
                elif o == "-c":
                    copy_to_clipboard = True
                elif o == "-h":
                    self.usage()
                    return
        except:
            self.usage()
            return

        if not args:
            err("No address specified")
            return

        start_addr = int(gdb.parse_and_eval(args[0]))

        if bitlen not in [8, 16, 32, 64]:
            err("Size of bit must be in 8, 16, 32, or 64")
            return

        if lang == "hex" and bitlen != 8:
            err("hex must be bit == 8")
            return

        if lang not in supported_formats:
            err("Language must be : {}".format(str(supported_formats)))
            return

        size = int(bitlen / 8)
        end_addr = start_addr + length * size
        bf = self.bitformat[bitlen]
        data = []
        out = ""

        for address in range(start_addr, end_addr, size):
            try:
                mem = read_memory(address, size)
            except gdb.error:
                err("Memory read error")
                return None
            value = struct.unpack(bf, mem)[0]
            data += [value]

        sdata = ""
        if lang == "hex":
            for i, x in enumerate(data):
                sdata += "{:02x}".format(x)
                if (i % 16) == 15:
                    sdata += "\n"
        else:
            for i, x in enumerate(data):
                sdata += "{:#0{}x}, ".format(x, bitlen//4 + 2)
                if (i % 8) == 7:
                    sdata += "\n"
        sdata = sdata.rstrip()

        if lang == "py":
            out = "buf = [\n{}\n]".format(sdata)
        elif lang == "c":
            out = "unsigned {0} buf[{1}] = {{\n{2}\n}};".format(self.c_type[bitlen], length, sdata)
        elif lang == "js":
            out = "var buf = [\n{}\n]".format(sdata)
        elif lang == "asm":
            out += "buf {0}\n{1}".format(self.asm_type[bitlen], sdata)
        elif lang == "hex":
            out += "{0}".format(sdata)

        if copy_to_clipboard:
            if self.clip(bytes(out, "utf-8")):
                info("Copied to clipboard")
            else:
                warn("There's a problem while copying")

        gef_print(out)
        return


@register_command
class SmartEvalCommand(GenericCommand):
    """SmartEval: Smart eval (vague approach to mimic WinDBG `?`)."""
    _cmdline_ = "$"
    _syntax_ = "\n"
    _syntax_ += "{:s} EXPR\n".format(_cmdline_)
    _syntax_ += "{:s} ADDRESS1 ADDRESS2".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} $pc+1\n".format(_cmdline_)
    _example_ += "{:s} 0x00007ffff7a10000 0x00007ffff7bce000".format(_cmdline_)
    _category_ = "Misc"
    _aliases_ = ["smart-eval", ]

    def do_invoke(self, argv):
        self.dont_repeat()
        argc = len(argv)
        if argc == 1:
            self.evaluate(argv)
            return

        if argc == 2:
            self.distance(argv)
        return

    def evaluate(self, expr):
        def show_as_int(i):
            off = current_arch.ptrsize*8
            def comp2_x(x):
                return "{:x}".format((x + (1 << off)) % (1 << off))

            def comp2_b(x):
                return "{:b}".format((x + (1 << off)) % (1 << off))

            try:
                s_i = comp2_x(res)
                s_i = s_i.rjust(len(s_i)+1, "0") if len(s_i)%2 else s_i
                gef_print("decimal      : {:d}".format(i))
                gef_print("hex          : 0x" + comp2_x(res))
                gef_print("binary       : 0b" + comp2_b(res))
                gef_print("big-endian   : {}".format(binascii.unhexlify(s_i)))
                gef_print("little-endian: {}".format(binascii.unhexlify(s_i)[::-1]))
            except:
                pass
            return

        parsed_expr = []
        for xp in expr:
            try:
                xp = gdb.parse_and_eval(xp)
                xp = int(xp)
                parsed_expr.append("{:d}".format(xp))
            except gdb.error:
                parsed_expr.append(str(xp))

        try:
            res = eval(" ".join(parsed_expr))
            if type(res) is int:
                show_as_int(res)
            else:
                gef_print("{}".format(res))
        except SyntaxError:
            gef_print(" ".join(parsed_expr))
        return

    def distance(self, args):
        try:
            x = int(args[0], 16) if is_hex(args[0]) else int(args[0])
            y = int(args[1], 16) if is_hex(args[1]) else int(args[1])
            gef_print("{}".format(abs(x - y)))
        except ValueError:
            warn("Distance requires 2 numbers: {} 0 0xffff".format(self._cmdline_))
        return


@register_command
class CanaryCommand(GenericCommand):
    """Shows the canary value of the current process. Apply the techique detailed in
    https://www.elttam.com.au/blog/playing-with-canaries/ to show the canary."""
    _cmdline_ = "canary"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        filepath = get_filepath()
        if filepath is None:
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return

        res = checksec(filepath)
        has_canary = res["Canary"]
        if not has_canary:
            warn("This binary was not compiled with SSP.")
            return

        res = gef_read_canary()
        if not res:
            err("Failed to get the canary")
            return

        canary, location = res
        info("Found AT_RANDOM at {:#x}, reading {} bytes".format(location, current_arch.ptrsize))
        info("The canary of process {:d} is {:s}".format(get_pid(), Color.boldify("{:#x}".format(canary))))

        vmmap = get_process_maps()
        unpack = u32 if current_arch.ptrsize == 4 else u64

        tls = None
        if is_x86_64():
            tls = TlsCommand.getfs()
        elif is_x86_32():
            tls = TlsCommand.getgs()

        for m in vmmap:
            if not (m.permission & Permission.READ) or not (m.permission & Permission.WRITE):
                continue
            if m.path == "[vvar]":
                continue
            data = read_memory(m.page_start, m.page_end - m.page_start)
            for pos in range(0, m.page_end - m.page_start, current_arch.ptrsize):
                addr = m.page_start + pos
                d = data[pos: pos + current_arch.ptrsize]
                if canary != unpack(d):
                    continue
                if m.path == "":
                    if tls and tls <= addr < ((tls+0x1000)&0xfffffffffffff000):
                        path = "tls"
                    else:
                        path = "unknown"
                else:
                    path = m.path
                info("Found at {:#x} in {:s}".format(m.page_start + pos, repr(path)))
        return


@register_command
class PidCommand(GenericCommand):
    """Show pid."""
    _cmdline_ = "pid"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()
        pid = get_pid()
        if pid is None:
            err("Unsupported")
            return
        gef_print(pid)
        return


@register_command
class GetFileCommand(GenericCommand):
    """Show current debugged filename."""
    _cmdline_ = "filename"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()
        gef_print(repr(gdb.current_progspace().filename))
        return


@register_command
class ProcessStatusCommand(GenericCommand):
    """Extends the info given by GDB `info proc`, by giving an exhaustive description of the
    process status (file descriptors, ancestor, descendants, etc.)."""
    _cmdline_ = "process-status"
    _syntax_ = _cmdline_
    _aliases_ = ["status", "procinfo", "pr",]
    _category_ = "Process Information"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_NONE)
        return

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()
        gef_print(titlify("Process information"))
        self.show_info_proc()
        self.show_info_proc2()
        self.show_ancestor()
        self.show_descendants()
        self.show_info_thread()
        self.show_info_proc_ns()
        self.show_fds()
        self.show_connections()
        return

    def get_state_of(self, pid):
        try:
            status = open("/proc/{}/status".format(pid), "r").read()
        except:
            return {}
        res = {}
        for line in status.splitlines():
            key, value = line.split(":", 1)
            res[key.strip()] = value.strip()
        return res

    def get_stat_of(self, pid):
        try:
            stat = open("/proc/{}/stat".format(pid), "r").read()
        except:
            return []
        name = re.search(r"\((.+)\)", stat)
        other = re.sub(r"\(.+\) ", "", stat).split()
        res = [int(other[0]), name, other[1]] + [int(x) for x in other[2:]]
        return res

    def get_cmdline_of(self, pid):
        try:
            cmdline = open("/proc/{}/cmdline".format(pid), "r").read()
        except:
            return ""
        return cmdline.replace("\x00", "\x20").strip()

    def get_process_path_of(self, pid):
        try:
            return os.readlink("/proc/{}/exe".format(pid))
        except:
            return "Not Found"

    def get_process_cwd(self, pid):
        try:
            return os.readlink("/proc/{}/cwd".format(pid))
        except:
            return "Not Found"

    def get_process_root(self, pid):
        try:
            return os.readlink("/proc/{}/root".format(pid))
        except:
            return "Not Found"

    def get_thread_ids(self, pid):
        try:
            tids = os.listdir("/proc/{}/task".format(pid))
            return [int(x) for x in tids]
        except:
            return []

    def get_children_pids(self, pid):
        try:
            ps = which("ps")
        except FileNotFoundError as e:
            err("{}".format(e))
            return []

        cmd = [ps, "-o", "pid", "--ppid", "{}".format(pid), "--noheaders"]
        try:
            return [int(x) for x in gef_execute_external(cmd, as_list=True)]
        except Exception:
            return []

    def get_uid_map(self, pid):
        try:
            uid_map = open("/proc/{}/uid_map".format(pid), "r").read().strip()
        except:
            return []
        slicer = lambda data, n: [data[i:i+n] for i in range(0, len(data), n)]
        return slicer([int(x) for x in uid_map.split()], 3)

    def get_gid_map(self, pid):
        try:
            gid_map = open("/proc/{}/gid_map".format(pid), "r").read().strip()
        except:
            return []
        slicer = lambda data, n: [data[i:i+n] for i in range(0, len(data), n)]
        return slicer([int(x) for x in gid_map.split()], 3)

    def get_tty_str(self, major, minor):
        try:
            file = which("file")
        except FileNotFoundError as e:
            err("{}".format(e))
            return "Not Found"

        if not os.path.exists("/dev"):
            return "Not Found"
        if not os.path.exists("/proc/devices"):
            return "Not Found"

        try:
            devices = open("/proc/devices", "r").read()
        except:
            return "Not found"
        for line in devices.splitlines():
            if not line or line.endswith(":"):
                continue
            n, name = line.strip().split()
            if major == int(n):
                if not name.startswith("/dev"):
                    name = os.path.join("/dev", name)
                break
        else:
            return "Not Found"

        if os.path.islink(name):
            return "Not Found"
        elif os.path.isfile(name):
            res = gef_execute_external([file, name], as_iist=True)
            m = re.search(r"\((\d+)/(\d+)\)", res)
            if m and int(m.group(1)) == major and int(m.group(2)) == minor:
                return name
            else:
                return "Not Found"
        elif os.path.isdir(name):
            for root, dirs, files in os.walk(name, followlinks=False):
                for f in files:
                    path = os.path.join(root, f)
                    if os.path.islink(path):
                        continue
                    res = gef_execute_external([file, path], as_iist=True)
                    m = re.search(r"\((\d+)/(\d+)\)", res)
                    if m and int(m.group(1)) == major and int(m.group(2)) == minor:
                        return path
            return "Not Found"

    def show_info_proc(self):
        info("Process Information")
        pid = get_pid()
        cmdline = self.get_cmdline_of(pid)
        gef_print("  {:32s} {} {}".format("PID", RIGHT_ARROW, pid))
        gef_print("  {:32s} {} {}".format("Executable", RIGHT_ARROW, repr(self.get_process_path_of(pid))))
        gef_print("  {:32s} {} {}".format("Command Line", RIGHT_ARROW, repr(cmdline)))
        gef_print("  {:32s} {} {}".format("Current Working Directory", RIGHT_ARROW, repr(self.get_process_cwd(pid))))
        gef_print("  {:32s} {} {}".format("Root Directory", RIGHT_ARROW, repr(self.get_process_root(pid))))
        return

    def show_info_proc2(self):
        info("Process Information Additional")
        pid = get_pid()
        pgid = self.get_stat_of(pid)[4]
        gef_print("  {:32s} {} {}".format("Process Group ID", RIGHT_ARROW, pgid))
        gef_print("  {:32s} {} {}".format("Process Group ID Executable", RIGHT_ARROW, repr(self.get_process_path_of(pgid))))
        sid = self.get_stat_of(pid)[5]
        gef_print("  {:32s} {} {}".format("Session ID", RIGHT_ARROW, sid))
        gef_print("  {:32s} {} {}".format("Session ID Executable", RIGHT_ARROW, repr(self.get_process_path_of(sid))))
        ttynr = self.get_stat_of(pid)[6]
        major, minor = (ttynr>>8)&0xff, ((ttynr>>20)<<8)|(ttynr&0xff)
        ttystr = self.get_tty_str(major, minor)
        gef_print("  {:32s} {} {} (Major:{} Minor:{} Dev:{})".format("TTY Device Number", RIGHT_ARROW, ttynr, major, minor, repr(ttystr)))
        tpgid = self.get_stat_of(pid)[7]
        gef_print("  {:32s} {} {}".format("TTY Process Group ID", RIGHT_ARROW, tpgid))
        gef_print("  {:32s} {} {}".format("TTY Process Group ID Executable", RIGHT_ARROW, repr(self.get_process_path_of(tpgid))))
        gef_print("  {:32s} {} {}".format("RUID : EUID : SavedUID : FSUID", RIGHT_ARROW, re.sub(r"\s+", " : ",self.get_state_of(pid)['Uid'])))
        gef_print("  {:32s} {} {}".format("RGID : EGID : SavedGID : FSGID", RIGHT_ARROW, re.sub(r"\s+", " : ",self.get_state_of(pid)['Gid'])))
        seccomp_n = self.get_state_of(pid)['Seccomp']
        seccomp_s = {'0':'Disabled', '1':'Strict', '2':'Filter'}
        gef_print("  {:32s} {} {} ({})".format("Seccomp Mode", RIGHT_ARROW, seccomp_n, seccomp_s[seccomp_n]))
        return

    def show_ancestor(self):
        info("Parent Process Information")
        ppid = int(self.get_state_of(get_pid())["PPid"])
        state = self.get_state_of(ppid)
        cmdline = self.get_cmdline_of(ppid)
        gef_print("  {:32s} {} {}".format("Parent PID", RIGHT_ARROW, state["Pid"]))
        gef_print("  {:32s} {} {}".format("Command Line", RIGHT_ARROW, repr(cmdline)))
        return

    def show_descendants(self):
        info("Children Process Information")
        children = self.get_children_pids(get_pid())
        if not children:
            gef_print("  No child process")
            return

        for child_pid in children:
            state = self.get_state_of(child_pid)
            pid = state["Pid"]
            pid_path = self.get_process_path_of(pid)
            pid_cmdline = self.get_cmdline_of(pid)
            gef_print("  {:32s} {} {} (Name: '{}', CmdLine: '{}')".format("PID", RIGHT_ARROW, pid, pid_path, pid_cmdline))
        return

    def show_info_thread(self):
        info("Thread Information")
        pid = get_pid()
        gef_print("  {:32s} {} {}".format("Num of Threads", RIGHT_ARROW, self.get_state_of(pid)['Threads']))
        gef_print("  {:32s} {} {}".format("Thread Group ID", RIGHT_ARROW, self.get_state_of(pid)['Tgid']))
        tids = self.get_thread_ids(pid)
        split = 8
        if len(tids) <= split:
            gef_print("  {:32s} {} {}".format("Thread ID List", RIGHT_ARROW, tids))
        else:
            gef_print("  {:32s} {} {}".format("Thread ID List", RIGHT_ARROW, tids[:split]))
            for i in range(split, len(tids), split):
                gef_print("  {:32s} {} {}".format("", RIGHT_ARROW, tids[i:i+split]))
        return

    def show_info_proc_ns(self):
        info("Process Information in Namespace")
        pid = get_pid()
        if len(self.get_state_of(pid)['NSpid'].split()) == 1:
            gef_print("  No namespace")
            return
        state = self.get_state_of(pid)
        gef_print("  {:32s} {} {}".format("Host PID  : Namespace PID", RIGHT_ARROW, re.sub(r"\s+", " : ", state['NSpid'])))
        gef_print("  {:32s} {} {}".format("Host PGID : Namespace PGID", RIGHT_ARROW, re.sub(r"\s+", " : ", state['NSpgid'])))
        gef_print("  {:32s} {} {}".format("Host SID  : Namespace SID", RIGHT_ARROW, re.sub(r"\s+", " : ", state['NSsid'])))
        gef_print("  {:32s} {} {}".format("Host TGID : Namespace TGID", RIGHT_ARROW, re.sub(r"\s+", " : ", state['NStgid'])))
        for u in self.get_uid_map(pid):
            gef_print("  {:32s} {} [{} : {} : {}]".format("UID_MAP [NS : Host : Range]", RIGHT_ARROW, u[0], u[1], u[2]))
        for g in self.get_gid_map(pid):
            gef_print("  {:32s} {} [{} : {} : {}]".format("GID_MAP [NS : Host : Range]", RIGHT_ARROW, g[0], g[1], g[2]))
        return

    def show_fds(self):
        pid = get_pid()
        path = "/proc/{:d}/fd".format(pid)

        info("File Descriptors:")
        gef_print("  {:32s} {} {}".format("Num of FD slots", RIGHT_ARROW, self.get_state_of(pid)['FDSize']))
        items = os.listdir(path)
        if not items:
            gef_print("  No FD opened")
            return

        for fname in items:
            fullpath = os.path.join(path, fname)
            if os.path.islink(fullpath):
                gef_print("  {:32s} {:s} {:s}".format (fullpath, RIGHT_ARROW, os.readlink(fullpath)))
        return

    def list_sockets(self, pid):
        sockets = []
        path = "/proc/{:d}/fd".format(pid)
        items = os.listdir(path)
        for fname in items:
            fullpath = os.path.join(path, fname)
            if os.path.islink(fullpath) and os.readlink(fullpath).startswith("socket:"):
                p = os.readlink(fullpath).replace("socket:", "")[1:-1]
                sockets.append(int(p))
        return sockets

    def parse_ip_port(self, addr):
        ip, port = addr.split(":")
        return socket.inet_ntoa(struct.pack("<I", int(ip, 16))), int(port, 16)

    def show_connections(self):
        # https://github.com/torvalds/linux/blob/v4.7/include/net/tcp_states.h#L16
        tcp_states_str = {
            0x01: "TCP_ESTABLISHED",
            0x02: "TCP_SYN_SENT",
            0x03: "TCP_SYN_RECV",
            0x04: "TCP_FIN_WAIT1",
            0x05: "TCP_FIN_WAIT2",
            0x06: "TCP_TIME_WAIT",
            0x07: "TCP_CLOSE",
            0x08: "TCP_CLOSE_WAIT",
            0x09: "TCP_LAST_ACK",
            0x0A: "TCP_LISTEN",
            0x0B: "TCP_CLOSING",
            0x0C: "TCP_NEW_SYN_RECV",
        }

        udp_states_str = {
            0x07: "UDP_LISTEN",
        }

        info("Network Connections")
        pid = get_pid()
        sockets = self.list_sockets(pid)
        if not sockets:
            gef_print("  No open connections")
            return

        entries = {}
        entries["TCP"] = [x.split() for x in open("/proc/{:d}/net/tcp".format(pid), "r").readlines()[1:]]
        entries["UDP"]= [x.split() for x in open("/proc/{:d}/net/udp".format(pid), "r").readlines()[1:]]

        for proto in entries:
            for entry in entries[proto]:
                local, remote, state = entry[1:4]
                inode = int(entry[9])
                if inode in sockets:
                    local = self.parse_ip_port(local)
                    remote = self.parse_ip_port(remote)
                    state = int(state, 16)
                    state_str = tcp_states_str[state] if proto == "TCP" else udp_states_str[state]

                    conn_local = "{}:{}".format(local[0], local[1])
                    conn_remote = "{}:{}".format(remote[0], remote[1])
                    gef_print("  {:32s} {} {} ({})".format(conn_local, RIGHT_ARROW, conn_remote, state_str))
        return


@register_priority_command
class GefThemeCommand(GenericCommand):
    """Customize GEF appearance."""
    _cmdline_ = "theme"
    _syntax_ = "{:s} [KEY [VALUE]]".format(_cmdline_)
    _category_ = "GEF Maintenance Command"

    def __init__(self, *args, **kwargs):
        super().__init__(self._cmdline_)
        self.add_setting("context_title_line", "gray", "Color of the borders in context window")
        self.add_setting("context_title_message", "cyan", "Color of the title in context window")
        self.add_setting("default_title_line", "gray", "Default color of borders")
        self.add_setting("default_title_message", "cyan", "Default color of title")
        self.add_setting("table_heading", "blue", "Color of the column headings to tables (e.g. vmmap)")
        self.add_setting("old_context", "gray", "Color to use to show things such as code that is not immediately relevant")
        self.add_setting("disassemble_current_instruction", "green", "Color to use to highlight the current $pc when disassembling")
        self.add_setting("dereference_string", "yellow", "Color of dereferenced string")
        self.add_setting("dereference_code", "gray", "Color of dereferenced code")
        self.add_setting("dereference_base_address", "cyan", "Color of dereferenced address")
        self.add_setting("dereference_register_value", "bold blue" , "Color of dereferenced register")
        self.add_setting("registers_register_name", "blue", "Color of the register name in the register window")
        self.add_setting("registers_value_changed", "bold red", "Color of the changed register in the register window")
        self.add_setting("address_stack", "pink", "Color to use when a stack address is found")
        self.add_setting("address_heap", "green", "Color to use when a heap address is found")
        self.add_setting("address_code", "red", "Color to use when a code address is found")
        self.add_setting("source_current_line", "green", "Color to use for the current code line in the source window")
        return

    def do_invoke(self, args):
        self.dont_repeat()
        argc = len(args)

        if argc == 0:
            for setting in sorted(self.settings):
                value = self.get_setting(setting)
                value = Color.colorify(value, value)
                gef_print("{:40s}: {:s}".format(setting, value))
            return

        setting = args[0]
        if not self.has_setting(setting):
            err("Invalid key")
            return

        if argc == 1:
            value = self.get_setting(setting)
            value = Color.colorify(value, value)
            gef_print("{:40s}: {:s}".format(setting, value))
            return

        val = [x for x in args[1:] if x in Color.colors]
        self.add_setting(setting, " ".join(val))
        return


@register_command
class ChangeFdCommand(GenericCommand):
    """ChangeFdCommand: redirect file descriptor during runtime."""
    _cmdline_ = "hijack-fd"
    _syntax_ = "{:s} FD_NUM NEW_OUTPUT".format(_cmdline_)
    _example_ = "{:s} 2 /tmp/stderr_output.txt".format(_cmdline_)
    _category_ = "Debugging Support"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()
        if len(argv) != 2:
            self.usage()
            return

        if not os.access("/proc/{:d}/fd/{:s}".format(get_pid(), argv[0]), os.R_OK):
            self.usage()
            return

        old_fd = int(argv[0])
        new_output = argv[1]

        if ":" in new_output:
            address = socket.gethostbyname(new_output.split(":")[0])
            port = int(new_output.split(":")[1])

            AF_INET = 2
            SOCK_STREAM = 1
            res = gdb.execute("""call (int)socket({}, {}, 0)""".format(AF_INET, SOCK_STREAM), to_string=True)
            new_fd = self.get_fd_from_result(res)

            # fill in memory with sockaddr_in struct contents
            # we will do this in the stack, since connect() wants a pointer to a struct
            vmmap = get_process_maps()
            stack_addr = [entry.page_start for entry in vmmap if entry.path == "[stack]"][0]
            original_contents = read_memory(stack_addr, 8)

            write_memory(stack_addr, "\x02\x00", 2)
            write_memory(stack_addr + 0x2, struct.pack("<H", socket.htons(port)), 2)
            write_memory(stack_addr + 0x4, socket.inet_aton(address), 4)

            info("Trying to connect to {}".format(new_output))
            res = gdb.execute("""call (int)connect({}, {}, {})""".format(new_fd, stack_addr, 16), to_string=True)

            # recover stack state
            write_memory(stack_addr, original_contents, 8)

            res = self.get_fd_from_result(res)
            if res == -1:
                err("Failed to connect to {}:{}".format(address, port))
                return

            info("Connected to {}".format(new_output))
        else:
            res = gdb.execute("""call (int)open("{:s}", 66, 0666)""".format(new_output), to_string=True)
            new_fd = self.get_fd_from_result(res)

        info("Opened '{:s}' as fd #{:d}".format(new_output, new_fd))
        gdb.execute("""call (int)dup2({:d}, {:d})""".format(new_fd, old_fd), to_string=True)
        info("Duplicated fd #{:d}{:s}#{:d}".format(new_fd, RIGHT_ARROW, old_fd))
        gdb.execute("""call (int)close({:d})""".format(new_fd), to_string=True)
        info("Closed extra fd #{:d}".format(new_fd))
        ok("Success")
        return

    def get_fd_from_result(self, res):
        # Output example: $1 = 3
        res = int(res.split()[2], 0)
        res = gdb.execute("""p/d {}""".format(res), to_string=True)
        res = int(res.split()[2], 0)
        return res


@register_command
class ScanSectionCommand(GenericCommand):
    """Search for addresses that are located in a memory mapping (haystack) that belonging
    to another (needle)."""
    _cmdline_ = "scan"
    _syntax_ = "{:s} HAYSTACK NEEDLE".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} stack binary # scan binary address from stack\n".format(_cmdline_)
    _example_ += "{:s} stack libc # scan libc address from stack\n".format(_cmdline_)
    _example_ += "{:s} stack heap # scan heap address from stack\n".format(_cmdline_)
    _example_ += "{:s} heap libc # scan libc address from heap\n".format(_cmdline_)
    _example_ += "{:s} 0x0000555555772000-0x0000555555774000 libc".format(_cmdline_)
    _category_ = "Show/Modify Memory"
    _aliases_ = ["lookup",]

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()
        if len(argv) != 2:
            self.usage()
            return

        haystack = argv[0]
        needle = argv[1]

        info("Searching for addresses in '{:s}' that point to '{:s}'"
             .format(Color.yellowify(haystack), Color.yellowify(needle)))

        if haystack == "binary":
            haystack = get_filepath()

        if needle == "binary":
            needle = get_filepath()

        needle_sections = []
        haystack_sections = []

        if "0x" in haystack:
            start, end = parse_string_range(haystack)
            haystack_sections.append((start, end, ""))

        if "0x" in needle:
            start, end = parse_string_range(needle)
            needle_sections.append((start, end))

        for sect in get_process_maps():
            if haystack in sect.path:
                haystack_sections.append((sect.page_start, sect.page_end, os.path.basename(sect.path)))
            if needle in sect.path:
                needle_sections.append((sect.page_start, sect.page_end))

        step = current_arch.ptrsize
        unpack = u32 if step == 4 else u64

        for hstart, hend, hname in haystack_sections:
            try:
                mem = read_memory(hstart, hend - hstart)
            except gdb.MemoryError:
                continue

            for i in range(0, len(mem), step):
                target = unpack(mem[i:i+step])
                for nstart, nend in needle_sections:
                    if not (nstart <= target < nend):
                        continue
                    deref = DereferenceCommand.pprint_dereferenced(hstart, int(i / step))
                    if hname != "":
                        name = Color.colorify(hname, "yellow")
                        gef_print("{:s}: {:s}".format(name, deref))
                    else:
                        gef_print(" {:s}".format(deref))
        return


@register_command
class SearchPatternCommand(GenericCommand):
    """SearchPatternCommand: search a pattern in memory. If given an hex value (starting with 0x)
    the command will also try to look for upwards cross-references to this address."""
    _cmdline_ = "search-pattern"
    _syntax_ = "{:s} [-h] PATTERN|--hex=PATTERN [little|big] [section] [--aligned N] [-v] [--disable-utf16]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} AAAAAAAA # search 'AAAAAAAA' from whole memory\n".format(_cmdline_)
    _example_ += "{:s} 0x555555554000 little stack # search 0x555555554000 (6byte) from stack\n".format(_cmdline_)
    _example_ += "{:s} 0x0000555555554000 little stack # search 0x0000555555554000 (8byte) from stack\n".format(_cmdline_)
    _example_ += "{:s} 0x079ee018 little 0x600000-0x601000 # hex must start by '0x' with ** 0-padding **\n".format(_cmdline_)
    _example_ += "{:s} AAAA little binary # 'binary' means executable mapped area itself (supported only usermode)\n".format(_cmdline_)
    _example_ += "{:s} AAAA little heap --aligned 16 # search with aligned\n".format(_cmdline_)
    _example_ += "{:s} --hex=\"00 00 00 00\" little stack # another valid format (invalid char is ignored)\n".format(_cmdline_)
    _example_ += "{:s} AAAA -v # verbose output".format(_cmdline_)
    _category_ = "Show/Modify Memory"
    _aliases_ = ["find",]

    def print_section(self, section):
        if isinstance(section, Address):
            section = section.section

        if section is None:
            return

        title = "In "
        if section.path:
            title += "'{}'".format(Color.blueify(section.path))

        title += "({:#x}-{:#x})".format(section.page_start, section.page_end)
        title += ", permission={}".format(section.permission)
        ok(title)
        return

    def print_loc(self, loc):
        if self.aligned and loc[0] % self.aligned:
            return
        gef_print('''  {:#x} - {:#x} {}  "{}"'''.format(loc[0], loc[1], RIGHT_ARROW, Color.pinkify(loc[2]),))
        return

    def search_pattern_by_address(self, pattern, start_address, end_address):
        """Search a pattern within a range defined by arguments."""
        pattern = gef_pybytes(pattern)
        if is_qemu_system():
            step = gef_getpagesize()
        else:
            step = 0x400 * gef_getpagesize()
        locations = []

        for chunk_addr in range(start_address, end_address, step):
            if chunk_addr + step > end_address:
                chunk_size = end_address - chunk_addr
            else:
                chunk_size = step

            try:
                mem = read_memory(chunk_addr, chunk_size)
            except:
                # cannot access memory this range. It doesn't make sense to try any more
                break

            for match in re.finditer(pattern, mem):
                start = chunk_addr + match.start()
                ustr = gef_pystring(pattern)
                end = start + len(pattern.decode("unicode-escape"))
                locations.append((start, end, ustr))
            del mem
        return locations

    @staticmethod
    def get_process_maps_qemu_system():
        res = get_maps_by_pagewalk("pagewalk -q")
        res = sorted(set(res.splitlines()))
        res = list(filter(lambda line: line.endswith("]"), res))
        res = list(filter(lambda line: not "[+]" in line, res))
        res = list(filter(lambda line: not "*" in line, res))
        for line in res:
            if is_x86() and "ACCESSED" not in line:
                continue
            lines = line.split()
            addr_start, addr_end = [int(x, 16) for x in lines[0].split("-")]
            if is_x86():
                perm = Permission.from_process_maps(lines[5][1:].lower())
            elif is_arm32():
                perm = line.split("/")[-1][:3]
                perm = Permission.from_process_maps(perm.lower())
            elif is_arm64():
                if 0xffff000008010000 <= addr_start < 0xffff000008020000 : # qemu process will be die if touch
                    continue
                if 0xffff000008030000 <= addr_start < 0xffff000008040000 : # qemu process will be die if touch
                    continue
                perm = line.split("/")[-1][:3]
                perm = Permission.from_process_maps(perm.lower())
            yield Section(page_start=addr_start, page_end=addr_end, permission=perm, path="")

    def search_pattern(self, pattern, section_name):
        """Search a pattern within the whole userland memory."""
        if is_qemu_system():
            maps_generator = self.get_process_maps_qemu_system()
        else:
            maps_generator = get_process_maps()

        for section in maps_generator:
            if not section.permission & Permission.READ:
                continue
            if section.path == "[vvar]":
                continue
            if not section_name in section.path:
                continue

            if self.verbose:
                self.print_section(section) # verbose: always print section before search

            start = section.page_start
            end = section.page_end
            ret = self.search_pattern_by_address(pattern, start, end) # search

            if ret:
                if not self.verbose:
                    self.print_section(section) # default: print section if found

            for loc in ret:
                self.print_loc(loc)

            if not is_alive():
                err("The process is dead")
                break
        return

    def isascii(self, string):
        val = codecs.escape_decode(string)[0]
        return all([0x20 <= c < 0x7f for c in val])

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        self.aligned = None
        if "--aligned" in argv:
            idx = argv.index("--aligned")
            self.aligned = int(argv[idx+1])
            argv = argv[:idx] + argv[idx+2:]

        self.disable_utf16 = False
        if "--disable-utf16" in argv:
            self.disable_utf16 = True
            argv.remove("--disable-utf16")

        if len(argv) < 1:
            self.usage()
            return

        # endianness
        if len(argv) >= 2:
            if argv[1].lower() == "big":
                endian = Elf.BIG_ENDIAN
            elif argv[1].lower() == "little":
                endian = Elf.LITTLE_ENDIAN
            else:
                self.usage()
                return
        else:
            endian = get_endian()

        # pattern replace
        pattern = argv[0]
        if pattern.startswith("--hex="): # "--hex=41414141" -> "\x41\x41\x41\x41"
            _pattern = ""
            for c in pattern[6:].lower():
                if c in '0123456789abcdef':
                    _pattern += c
            if len(_pattern) % 2 != 0:
                self.usage()
                return
            pattern = "".join(["\\x"+_pattern[i:i+2] for i in range(0, len(_pattern), 2)])
        elif is_hex(pattern): # "0x41414141" -> "\x41\x41\x41\x41"
            if endian == Elf.BIG_ENDIAN:
                pattern = "".join(["\\x"+pattern[i:i+2] for i in range(2, len(pattern), 2)])
            else:
                pattern = "".join(["\\x"+pattern[i:i+2] for i in range(len(pattern) - 2, 0, -2)])

        # create utf16 pattern
        pattern_utf16 = None
        if not self.disable_utf16 and self.isascii(pattern):
            pattern_utf16 = "".join([x + "\\x00" for x in pattern])

        if len(argv) == 3:
            if re.match(r"(0x)?[0-9a-fA-F]+-(0x)?[0-9a-fA-F]+", argv[2]):
                # specific range -> call search_pattern_by_address directly
                search_area = argv[2]
                info("Searching '{:s}' in {:s}".format(Color.yellowify(pattern), search_area))
                start, end = parse_string_range(search_area)

                loc = lookup_address(start)
                if loc.valid:
                    if self.verbose:
                        self.print_section(loc) # verbose: always print section before search
                else:
                    err("Not found valid memory area")
                    return

                ret = self.search_pattern_by_address(pattern, start, end) # search

                if ret and not self.verbose:
                    self.print_section(loc) # default: print section if found

                for found_loc in ret:
                    self.print_loc(found_loc)

                if pattern_utf16 is not None:
                    info("Searching '{:s}' in {:s}".format(Color.yellowify(pattern_utf16), search_area))
                    ret = self.search_pattern_by_address(pattern_utf16, start, end)
                    for found_loc in ret:
                        self.print_loc(found_loc)
            else:
                # section name -> call search wrapper
                section_name = argv[2]
                if section_name in ["binary", "bin"] and not is_qemu_system():
                    section_name = get_filepath()

                info("Searching '{:s}' in {:s}".format(Color.yellowify(pattern), section_name))
                self.search_pattern(pattern, section_name)

                if pattern_utf16 is not None:
                    info("Searching '{:s}' in {:s}".format(Color.yellowify(pattern_utf16), section_name))
                    self.search_pattern(pattern_utf16, section_name)
        else:
            # whole memory -> call search wrapper
            info("Searching '{:s}' in memory".format(Color.yellowify(pattern)))
            self.search_pattern(pattern, "")
            if pattern_utf16 is not None:
                info("Searching '{:s}' in memory".format(Color.yellowify(pattern_utf16)))
                self.search_pattern(pattern_utf16, "")
        return


@register_command
class DemanglePtrCommand(GenericCommand):
    """Demangle a mangled value by PTR_MANGLE."""
    _cmdline_ = "ptr-demangle"
    _syntax_ = "{:s} VALUE".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    @staticmethod
    def get_cookie():
        if is_x86_64():
            tls = TlsCommand.getfs()
            cookie = read_int_from_memory(tls + 0x30)
        elif is_x86_32():
            tls = TlsCommand.getgs()
            cookie = read_int_from_memory(tls + 0x18)
        elif is_arm32() or is_arm64():
            if is_arm32():
                try:
                    tls = parse_address("(unsigned int)__aeabi_read_tp()")
                except:
                    err("Not found symbol (__aeabi_read_tp)")
                    return None
            else:
                try:
                    tls = get_register("$TPIDR_EL0")
                except:
                    err("Fail reading $TPIDR_EL0 register")
                    return None
            try:
                cookie_ptr = parse_address("&__pointer_chk_guard_local")
            except:
                err("Not found symbol (__pointer_chk_guard_local)")
                return None
            cookie = read_int_from_memory(cookie_ptr)
        return cookie

    @staticmethod
    def decode(value, cookie):
        def ror(val, bits, arch_bits):
            new_val = (val >> bits) | (val << (arch_bits-bits))
            mask = (1 << arch_bits) - 1
            return new_val & mask

        if is_x86_64():
            decoded = ror(value, 17, 64) ^ cookie
        elif is_x86_32():
            decoded = ror(value, 9, 32) ^ cookie
        elif is_arm32() or is_arm64():
            decoded = value ^ cookie
        return decoded

    @only_if_gdb_running
    @only_if_x86_32_64_or_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        cookie = self.get_cookie()
        if cookie is None:
            return
        info("Cookie is {:#x}".format(cookie))

        try:
            target = int(argv[0], 0)
        except:
            self.usage()
            return
        decoded = self.decode(target, cookie)
        color_decoded = Color.colorify("{:#x}".format(decoded), "white bold")
        decoded_sym = get_symbol_string(decoded)
        try:
            read_memory(decoded, 1)
            valid_msg = "valid"
        except gdb.error:
            valid_msg = "invalid"
        info("Decoded value is {:s}{:s} ({:s})".format(color_decoded, decoded_sym, valid_msg))
        return


@register_command
class SearchMangledPtrCommand(GenericCommand):
    """Search a mangled pointer value in memory."""
    _cmdline_ = "search-mangled-ptr"
    _syntax_ = "{:s} [-h] [-v]".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def print_section(self, section):
        if isinstance(section, Address):
            section = section.section

        if section is None:
            return

        title = "In "
        if section.path:
            title += "'{}'".format(Color.blueify(section.path))

        title += "({:#x}-{:#x})".format(section.page_start, section.page_end)
        title += ", permission={}".format(section.permission)
        ok(title)
        return

    def print_loc(self, loc):
        addr, a, b = loc[0], loc[1], loc[2]
        color_b = Color.colorify("{:#x}".format(b), "white bold")
        addr_sym = get_symbol_string(addr)
        b_sym = get_symbol_string(b)
        gef_print("  {:#x}{:s}: {:#x} (-> {:s}{:s})".format(addr, addr_sym, a, color_b, b_sym))
        return

    def search_mangled_ptr(self, start_address, end_address):
        """Search a mangled pointer within a range defined by arguments."""
        def slice_unpack(data, n):
            tmp = [data[i:i+n] for i in range(0, len(data), n)]
            return list(map(u64 if n == 8 else u32, tmp))

        if is_qemu_system():
            step = gef_getpagesize()
        else:
            step = 0x400 * gef_getpagesize()
        locations = []

        for chunk_addr in range(start_address, end_address, step):
            if chunk_addr + step > end_address:
                chunk_size = end_address - chunk_addr
            else:
                chunk_size = step

            try:
                mem = read_memory(chunk_addr, chunk_size)
            except:
                # cannot access memory this range. It doesn't make sense to try any more
                break

            for i, value in enumerate(slice_unpack(mem, current_arch.ptrsize)):
                decoded = DemanglePtrCommand.decode(value, self.cookie)
                try:
                    read_memory(decoded, 1)
                except gdb.error:
                    continue
                addr = chunk_addr + i * current_arch.ptrsize
                locations.append((addr, value, decoded))
            del mem
        return locations

    @only_if_gdb_running
    @only_if_x86_32_64_or_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        # init
        self.cookie = DemanglePtrCommand.get_cookie()
        if self.cookie is None:
            return
        info("Cookie is {:#x}".format(self.cookie))

        # search
        if is_qemu_system():
            maps_generator = self.get_process_maps_qemu_system()
        else:
            maps_generator = get_process_maps()
        for section in maps_generator:
            if not section.permission & Permission.READ:
                continue
            if not section.permission & Permission.WRITE:
                continue
            if self.verbose:
                self.print_section(section) # verbose: always print section before search

            start = section.page_start
            end = section.page_end
            ret = self.search_mangled_ptr(start, end)

            if ret:
                if not self.verbose:
                    self.print_section(section) # default: print section if found

            for loc in ret:
                self.print_loc(loc)

            if not is_alive():
                err("The process is dead")
                break
        return


@register_command
class FlagsCommand(GenericCommand):
    """Edit flags in a human friendly way."""
    _cmdline_ = "edit-flags"
    _syntax_ = "{:s} [(+|-|~)FLAGNAME ...] [-v] [-h]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s}\n".format(_cmdline_)
    _example_ += "{:s} +zero # sets ZERO flag\n".format(_cmdline_)
    _example_ += "{:s} -direction # unsets DIRECTION flag\n".format(_cmdline_)
    _example_ += "{:s} ~sign # toggle SIGN flag\n".format(_cmdline_)
    _example_ += "{:s} -v # print verbose".format(_cmdline_)
    _category_ = "Show/Modify Register"
    _aliases_ = ["flags",]

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        for flag in argv:
            if len(flag) < 2:
                continue

            action = flag[0]
            if action not in ("+", "-", "~"):
                err("Invalid action for flag '{:s}'".format(flag))
                continue

            name = flag[1:].lower()

            if is_x86():
                dic = {
                    "id": "identification",
                    "ac": "align",
                    "vm": "virtualx86",
                    "rf": "resume",
                    "nt": "nested",
                    "of": "overflow",
                    "df": "direction",
                    "if": "interrupt",
                    "tf": "trap",
                    "sf": "sign",
                    "zf": "zero",
                    "af": "adjust",
                    "pf": "parity",
                    "cf": "carry",
                }
                if name in dic:
                    name = dic[name]

            if name not in current_arch.flags_table.values():
                err("Invalid flag name '{:s}'".format(flag[1:]))
                continue

            for off in current_arch.flags_table:
                if current_arch.flags_table[off] == name:
                    old_flag = get_register(current_arch.flag_register)
                    if action == "+":
                        new_flags = old_flag | (1 << off)
                    elif action == "-":
                        new_flags = old_flag & ~(1 << off)
                    else:
                        new_flags = old_flag ^ (1 << off)

                    gdb.execute("set ({:s}) = {:#x}".format(current_arch.flag_register, new_flags))

        gef_print(current_arch.flag_register_to_human())
        if self.verbose:
            if is_x86():
                self.verbose_x86()
            elif is_arm32():
                self.verbose_arm32()
            elif is_arm64():
                self.verbose_arm64()
        return

    def bits_split(self, x, bits=32):
        out = ""
        for i in range(bits):
            if x & (1 << i):
                out = "1" + out
            else:
                out = "0" + out
            if i % 4 == 3:
                out = "_" + out
        return "0b" + out[1:]

    def verbose_x86(self):
        eflags = get_register("$eflags")
        gef_print("{:s}  {:s}".format(self.bits_split(eflags), Color.colorify("MASK", "bold")))

        def c(msg):
            mask = int(msg.split()[0], 16)
            color = ["bold", ""][(eflags & mask)==0]
            return Color.colorify(msg, color)

        gef_print(" "*14 + "|| |||| |||| |||| |||| |||+- " + c("0x000001 [CF]   Carry flag"))
        gef_print(" "*14 + "|| |||| |||| |||| |||| ||+-- " + c("0x000002        Reserved (always 1)"))
        gef_print(" "*14 + "|| |||| |||| |||| |||| |+--- " + c("0x000004 [PF]   Parity flag"))
        gef_print(" "*14 + "|| |||| |||| |||| |||| +---- " + c("0x000008        Reserved (always 0)"))
        gef_print(" "*14 + "|| |||| |||| |||| ||||")
        gef_print(" "*14 + "|| |||| |||| |||| |||+------ " + c("0x000010 [AF]   Adjust flag (for BCD calc)"))
        gef_print(" "*14 + "|| |||| |||| |||| ||+------- " + c("0x000020        Reserved (always 0)"))
        gef_print(" "*14 + "|| |||| |||| |||| |+-------- " + c("0x000040 [ZF]   Zero flag"))
        gef_print(" "*14 + "|| |||| |||| |||| +--------- " + c("0x000080 [SF]   Sign flag"))
        gef_print(" "*14 + "|| |||| |||| ||||")
        gef_print(" "*14 + "|| |||| |||| |||+----------- " + c("0x000100 [TF]   Trap flag (single step)"))
        gef_print(" "*14 + "|| |||| |||| ||+------------ " + c("0x000200 [IF]   Interrupt enable flag"))
        gef_print(" "*14 + "|| |||| |||| |+------------- " + c("0x000400 [DF]   Direction flag"))
        gef_print(" "*14 + "|| |||| |||| +-------------- " + c("0x000800 [OF]   Overflow flag"))
        gef_print(" "*14 + "|| |||| ||||")
        gef_print(" "*14 + "|| |||| ||++---------------- " + c("0x003000 [IOPL] I/O privilege level (2bit)"))
        gef_print(" "*14 + "|| |||| |+------------------ " + c("0x004000 [NT]   Nested task flag"))
        gef_print(" "*14 + "|| |||| +------------------- " + c("0x008000        Reserved (always 0)"))
        gef_print(" "*14 + "|| ||||")
        gef_print(" "*14 + "|| |||+--------------------- " + c("0x010000 [RF]   Resume flag"))
        gef_print(" "*14 + "|| ||+---------------------- " + c("0x020000 [VM]   Virtual 8086 mode flag"))
        gef_print(" "*14 + "|| |+----------------------- " + c("0x040000 [AC]   Alignment check flag"))
        gef_print(" "*14 + "|| +------------------------ " + c("0x080000 [VIF]  Virtual interrupt flag"))
        gef_print(" "*14 + "||")
        gef_print(" "*14 + "|+-------------------------- " + c("0x100000 [VIP]  Virtual interrupt pending"))
        gef_print(" "*14 + "+--------------------------- " + c("0x200000 [ID]   Able to use CPUID instruction"))
        return

    def verbose_arm32(self):
        cpsr = get_register("$cpsr")
        gef_print("{:s}  {:s}".format(self.bits_split(cpsr), Color.colorify("MASK", "bold")))

        def c(msg):
            mask = int(msg.split()[0], 16)
            color = ["bold", ""][(cpsr & mask)==0]
            return Color.colorify(msg, color)

        gef_print("  |||| |||| |||| |||| |||| |||| |||+-++++- " + c("0x0000001f [M]  Mode field (5bit)"))
        gef_print("  |||| |||| |||| |||| |||| |||| |||        " + "  User:0b10000 FIQ:0b10001 IRQ:0b10010")
        gef_print("  |||| |||| |||| |||| |||| |||| |||        " + "  Supervisor:0b10011 Monitor:0b10110 Abort:0b10111")
        gef_print("  |||| |||| |||| |||| |||| |||| |||        " + "  Hyp:0b11010 Undefined:0b11011 System:0b11111")
        gef_print("  |||| |||| |||| |||| |||| |||| |||")
        gef_print("  |||| |||| |||| |||| |||| |||| ||+------- " + c("0x00000020 [T]  Thumb execution state bit"))
        gef_print("  |||| |||| |||| |||| |||| |||| |+-------- " + c("0x00000040 [F]  FIQ mask bit"))
        gef_print("  |||| |||| |||| |||| |||| |||| +--------- " + c("0x00000080 [I]  IRQ mask bit"))
        gef_print("  |||| |||| |||| |||| |||| ||||")
        gef_print("  |||| |||| |||| |||| |||| |||+----------- " + c("0x00000100 [A]  Asynchronous abort mask bit"))
        gef_print("  |||| |||| |||| |||| |||| ||+------------ " + c("0x00000200 [E]  Endianness execution state bit"))
        gef_print("  |||| |++------------++++-++------------- " + c("0x0600fc00 [IT] If-Then execution state bits for Thumb IT instruction"))
        gef_print("  |||| |  | |||| ||||")
        gef_print("  |||| |  | |||| ++++--------------------- " + c("0x000f0000 [GE] Greater than or Equal flags for SIMD instruction"))
        gef_print("  |||| |  | ||||")
        gef_print("  |||| |  | ++++-------------------------- " + c("0x00f00000      Reserved"))
        gef_print("  |||| |  |")
        gef_print("  |||| |  +------------------------------- " + c("0x01000000 [J]  Jazelle bit"))
        gef_print("  |||| +---------------------------------- " + c("0x08000000 [Q]  Cumulative saturation bit"))
        gef_print("  ||||")
        gef_print("  |||+------------------------------------ " + c("0x10000000 [V]  Overflow condition flag"))
        gef_print("  ||+------------------------------------- " + c("0x20000000 [C]  Carry condition flag"))
        gef_print("  |+-------------------------------------- " + c("0x40000000 [Z]  Zero condition flag"))
        gef_print("  +--------------------------------------- " + c("0x80000000 [N]  Negative condition flag"))
        return

    def verbose_arm64(self):
        cpsr = get_register("$cpsr")
        gef_print("{:s}  {:s}".format(self.bits_split(cpsr), Color.colorify("MASK", "bold")))

        def c(msg):
            mask = int(msg.split()[0], 16)
            color = ["bold", ""][(cpsr & mask)==0]
            return Color.colorify(msg, color)

        if ((cpsr >> 4) & 1) == 0: # AArch64 state
            gef_print("  |||| |||| |||| |||| |||| |||| |||| ||++- " + c("0x00000003 [M.SP]  Selected stack pointer (2bit)"))
            gef_print("  |||| |||| |||| |||| |||| |||| |||| ++--- " + c("0x0000000c [M.EL]  Exception level (2bit)"))
            gef_print("  |||| |||| |||| |||| |||| |||| ||||")
            gef_print("  |||| |||| |||| |||| |||| |||| |||+------ " + c("0x00000010 [M.S]   Execution state (AArch64:0, AArch32:1)"))
            gef_print("  |||| |||| |||| |||| |||| |||| ||+------- " + c("0x00000020         Reserved (always 0)"))
            gef_print("  |||| |||| |||| |||| |||| |||| |+-------- " + c("0x00000040 [F]     FIQ interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| |||| +--------- " + c("0x00000080 [I]     IRQ interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| ||||")
            gef_print("  |||| |||| |||| |||| |||| |||+----------- " + c("0x00000100 [A]     SError interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| ||+------------ " + c("0x00000200 [D]     Debug exception mask bit"))
            gef_print("  |||| |||| |||| |||| |||| ++------------- " + c("0x00000c00 [BTYPE] Branch Type Indicator when FEAT_BTI is implemented"))
            gef_print("  |||| |||| |||| |||| ||||")
            gef_print("  |||| |||| |||| |||| |||+---------------- " + c("0x00001000 [SSBS]  Speculative Store Bypass when FEAT_SSBS is implemented"))
            gef_print("  |||| |||| |||| ++++-+++----------------- " + c("0x000fe000         Reserved"))
            gef_print("  |||| |||| ||||")
            gef_print("  |||| |||| |||+-------------------------- " + c("0x00100000 [IL]    Illegal execution state"))
            gef_print("  |||| |||| ||+--------------------------- " + c("0x00200000 [SS]    Software step flag"))
            gef_print("  |||| |||| |+---------------------------- " + c("0x00400000 [PAN]   Privileged Access Never when FEAT_PAN is implemented"))
            gef_print("  |||| |||| +----------------------------- " + c("0x00800000 [UAO]   User Access Override when FEAT_UAO is implemented"))
            gef_print("  |||| ||||")
            gef_print("  |||| |||+------------------------------- " + c("0x01000000 [DIT]   Data Independent Timing when FEAT_DIT is implemented"))
            gef_print("  |||| ||+-------------------------------- " + c("0x02000000 [TCO]   Tag Check Override when FEAT_MTE is implemented"))
            gef_print("  |||| ++--------------------------------- " + c("0x0c000000         Reserved"))
            gef_print("  ||||")
            gef_print("  |||+------------------------------------ " + c("0x10000000 [V]     Overflow condition flag"))
            gef_print("  ||+------------------------------------- " + c("0x20000000 [C]     Carry condition flag"))
            gef_print("  |+-------------------------------------- " + c("0x40000000 [Z]     Zero condition flag"))
            gef_print("  +--------------------------------------- " + c("0x80000000 [N]     Negative condition flag"))
        else: # AArch32 state
            gef_print("  |||| |||| |||| |||| |||| |||| |||| ++++- " + c("0x0000000f [M.A32] AArch32 mode (4bit)"))
            gef_print("  |||| |||| |||| |||| |||| |||| ||||       " + "   User:0b0000 FIQ:0b0001 IRQ:0b0010")
            gef_print("  |||| |||| |||| |||| |||| |||| ||||       " + "   Supervisor:0b0011 Monitor:0b0110 Abort:0b0111")
            gef_print("  |||| |||| |||| |||| |||| |||| ||||       " + "   Hyp:0b1010 Undefined:0b1011 System:0b1111")
            gef_print("  |||| |||| |||| |||| |||| |||| ||||")
            gef_print("  |||| |||| |||| |||| |||| |||| |||+------ " + c("0x00000010 [M.S]   Execution state (AAch64:0, AArch32:1)"))
            gef_print("  |||| |||| |||| |||| |||| |||| ||+------- " + c("0x00000020 [T]     T32 instruction set (Thumb) state bit"))
            gef_print("  |||| |||| |||| |||| |||| |||| |+-------- " + c("0x00000040 [F]     FIQ interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| |||| +--------- " + c("0x00000080 [I]     IRQ interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| ||||")
            gef_print("  |||| |||| |||| |||| |||| |||+----------- " + c("0x00000100 [A]     SError interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| ||+------------ " + c("0x00000200 [E]     Endianness execution state bit"))
            gef_print("  |||| |++------------++++-++------------- " + c("0x0600fc00 [IT]    If-Then execution state bits for Thumb IT instruction"))
            gef_print("  |||| |  | |||| ||||")
            gef_print("  |||| |  | |||| ++++--------------------- " + c("0x000f0000 [GE]    Greater than or Equal flags for SIMD instruction"))
            gef_print("  |||| |  | ||||")
            gef_print("  |||| |  | |||+-------------------------- " + c("0x00100000 [IL]    Illegal execution state"))
            gef_print("  |||| |  | ||+--------------------------- " + c("0x00200000 [SS]    Software step flag"))
            gef_print("  |||| |  | |+---------------------------- " + c("0x00400000 [PAN]   Privileged Access Never when FEAT_PAN is implemented"))
            gef_print("  |||| |  | +----------------------------- " + c("0x00800000 [SSBS]  Speculative Store Bypass when FEAT_SBSS is implemented"))
            gef_print("  |||| |  |")
            gef_print("  |||| |  +------------------------------- " + c("0x01000000 [DIT]   Data Independent Timing when FEAT_DIT is implemented"))
            gef_print("  |||| +---------------------------------- " + c("0x08000000 [Q]     Overflow or saturation flag"))
            gef_print("  ||||")
            gef_print("  |||+------------------------------------ " + c("0x10000000 [V]     Overflow condition flag"))
            gef_print("  ||+------------------------------------- " + c("0x20000000 [C]     Carry condition flag"))
            gef_print("  |+-------------------------------------- " + c("0x40000000 [Z]     Zero condition flag"))
            gef_print("  +--------------------------------------- " + c("0x80000000 [N]     Negative condition flag"))
        return


@register_command
class ChangePermissionCommand(GenericCommand):
    """Change a page permission. By default, it will change it to RWX."""
    _cmdline_ = "set-permission"
    _syntax_ = "{:s} LOCATION [PERMISSION]".format(_cmdline_)
    _example_ = "{:s} $sp 7".format(_cmdline_)
    _category_ = "Debugging Support"
    _aliases_ = ["mprotect",]

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def pre_load(self):
        try:
            __import__("keystone")
        except ImportError:
            msg = "Missing `keystone-engine` package, install with: `pip install keystone-engine`."
            raise ImportWarning(msg)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) not in (1, 2):
            err("Incorrect syntax")
            self.usage()
            return

        if len(argv) == 2:
            perm = int(argv[1])
        else:
            perm = Permission.READ | Permission.WRITE | Permission.EXECUTE

        loc = safe_parse_and_eval(argv[0])
        if loc is None:
            err("Invalid address")
            return

        loc = to_unsigned_long(loc)
        sect = process_lookup_address(loc)
        if sect is None:
            err("Unmapped address")
            return

        size = sect.page_end - sect.page_start
        original_pc = current_arch.pc

        info("Generating sys_mprotect({:#x}, {:#x}, '{:s}') stub for arch {:s}"
             .format(sect.page_start, size, str(Permission(value=perm)), get_arch()))
        stub = self.get_stub_by_arch(sect.page_start, size, perm)
        if stub is None:
            err("Failed to generate mprotect opcodes")
            return

        info("Saving original code")
        original_code = read_memory(original_pc, len(stub))

        bp_loc = "*{:#x}".format(original_pc + len(stub))
        info("Setting a restore breakpoint at {:s}".format(bp_loc))
        ChangePermissionBreakpoint(bp_loc, original_code, original_pc)

        info("Overwriting current memory at {:#x} ({:d} bytes)".format(loc, len(stub)))
        write_memory(original_pc, stub, len(stub))

        info("Resuming execution")
        gdb.execute("continue")
        return

    def get_stub_by_arch(self, addr, size, perm):
        code = current_arch.mprotect_asm(addr, size, perm)
        arch, mode = get_keystone_arch()
        raw_insns = keystone_assemble(code, arch, mode, raw=True)
        return raw_insns


@register_command
class UnicornEmulateCommand(GenericCommand):
    """Use Unicorn-Engine to emulate the behavior of the binary, without affecting the GDB runtime.
    By default the command will emulate only the next instruction, but location and number of
    instruction can be changed via arguments to the command line. By default, it will emulate
    the next instruction from current PC."""
    _cmdline_ = "unicorn-emulate"
    _syntax_ = "{:s} [-h] [-f LOCATION] [-t LOCATION] [-n NB_INSTRUCTION] [-s] [-o PATH]\n".format(_cmdline_)
    _syntax_ += "  -f LOCATION            specifies the start address of the emulated run (default $pc).\n"
    _syntax_ += "  -t LOCATION            specifies the end address of the emulated run.\n"
    _syntax_ += "  -s                     do not execute the script once generated.\n"
    _syntax_ += "  -o /PATH/TO/SCRIPT.py  writes the persistent Unicorn script into this file.\n"
    _syntax_ += "  -n NB_INSTRUCTION      indicates the number of instructions to execute (mutually exclusive with `-t` and `-g`).\n"
    _syntax_ += "  -g NB_GADGET           indicates the number of gadgets to execute (mutually exclusive with `-t` and `-n`).\n"
    _syntax_ += "  -v                     displays the registers for each instruction.\n"
    _syntax_ += "  -q                     quiet execution.\n"
    _syntax_ += "Additional options can be setup via `gef config unicorn-emulate`\n"
    _syntax_ += "\n"
    _syntax_ += "NOTE\n"
    _syntax_ += "* unicorn does not support some instructions (ex: xsavec, xrstor, vpbroadcastb, etc)\n"
    _syntax_ += "* unicorn does not emulate ARM kernel-provided-user-helpers like $pc=0xffff0fe0, 0xffff0fc0, etc.\n"
    _syntax_ += "  see: https://www.kernel.org/doc/Documentation/arm/kernel_user_helpers.txt\n"
    _example_ = "\n"
    _example_ += "{:s} -n 5 # from $pc to 5 later asm\n".format(_cmdline_)
    _example_ += "{:s} -g 4 # from $pc to the point where 4 instructions are executed\n".format(_cmdline_)
    _example_ += "{:s} -f 0x8056770c -t 0x805678a4 -o /tmp/my-gef-emulation.py # from/to specific address with saving script".format(_cmdline_)
    _category_ = "Debugging Support"
    _aliases_ = ["emulate",]

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def pre_load(self):
        try:
            __import__("unicorn")
        except ImportError:
            msg = "Missing `unicorn` package for Python. Install with `pip install unicorn`."
            raise ImportWarning(msg)

        try:
            __import__("capstone")
        except ImportError:
            msg = "Missing `capstone` package for Python. Install with `pip install capstone`."
            raise ImportWarning(msg)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        start_insn = None
        end_insn = -1
        nb_insn = -1
        nb_gadget = -1
        to_file = None
        skip_emulation = None
        verbose = None
        quiet = None
        try:
            opts = getopt.getopt(argv, "f:t:n:g:so:vqh")[0]
            for o, a in opts:
                if o == "-f":
                    start_insn = int(a, 16)

                elif o == "-t":
                    end_insn = int(a, 16)
                    nb_insn = -1
                    nb_gadget = -1

                elif o == "-n":
                    end_insn = -1
                    nb_insn = int(a)
                    nb_gadget = -1

                elif o == "-g":
                    end_insn = -1
                    nb_insn = -1
                    nb_gadget = int(a)

                elif o == "-s":
                    skip_emulation = True

                elif o == "-o":
                    to_file = a

                elif o == "-v":
                    verbose = True

                elif o == "-q":
                    quiet = True

                elif o == "-h":
                    self.usage()
                    return
        except:
            self.usage()
            return

        if start_insn is None:
            start_insn = current_arch.pc

        thumb_mode = None
        if is_arm32():
            thumb_mode = start_insn & 1

        if end_insn < 0 and nb_insn < 0 and nb_gadget < 0:
            err("No stop condition (-t|-n|-g) defined.")
            return

        kwargs = {
            "skip_emulation": skip_emulation,
            "to_file": to_file,
            "verbose": verbose,
            "nb_gadget": nb_gadget,
            "quiet": quiet,
            "thumb_mode": thumb_mode,
        }

        if end_insn > 0:
            self.run_unicorn(start_insn, end_insn, **kwargs)

        elif nb_insn > 0:
            end_insn = self.get_unicorn_end_addr(start_insn, nb_insn)
            self.run_unicorn(start_insn, end_insn, **kwargs)

        elif nb_gadget > 0:
            end_insn = 0x0
            self.run_unicorn(start_insn, end_insn, **kwargs)

        else:
            raise Exception("Should never be here")
        return

    def get_unicorn_end_addr(self, start_addr, nb):
        dis = list(gef_disassemble(start_addr, nb + 1))
        last_insn = dis[-1]
        return last_insn.address

    def run_unicorn(self, start_insn_addr, end_insn_addr, *args, **kwargs):
        verbose = kwargs.get("verbose", False)
        quiet = kwargs.get("quiet", False)
        nb_gadget = kwargs.get("nb_gadget", -1)
        skip_emulation = kwargs.get("skip_emulation", False)
        to_file = kwargs.get("to_file", None)
        thumb_mode = kwargs.get("thumb_mode", None)

        arch, mode = get_unicorn_arch(to_string=True)
        unicorn_registers = get_unicorn_registers(to_string=True)
        cs_arch, cs_mode = get_capstone_arch(to_string=True)
        fname = str(get_filename())
        emulate_segmentation_block = ""
        context_segmentation_block = ""

        if to_file:
            tmp_filename = to_file
            to_file = open(to_file, "w")
            tmp_fd = to_file.fileno()
        else:
            tmp_fd, tmp_filename = tempfile.mkstemp(suffix=".py", prefix="gef-uc-")

        pythonbin = which("python3")

        content  = "#!{pythonbin} -i\n".format(pythonbin=pythonbin)
        content += "#\n"
        content += "# Emulation script for \"{fname}\" from {start:#x} to {end:#x}\n".format(fname=fname, start=start_insn_addr, end=end_insn_addr)
        content += "#\n"
        content += "# Powered by gef, unicorn-engine, and capstone-engine\n"
        content += "#\n"
        content += "# @_hugsy_\n"
        content += "#\n"
        content += "from __future__ import print_function\n"
        content += "import collections\n"
        content += "import capstone, unicorn\n"
        content += "import sys, traceback\n"
        content += "\n"

        content += "registers = collections.OrderedDict({{{regs}}})\n".format(
            regs=",".join(["\n    '%s': %s" % (k.strip(), unicorn_registers[k]) for k in unicorn_registers])+"\n"
        )
        content += "uc = None\n"
        content += "verbose = {verbose}\n".format(verbose=str(verbose))
        content += "quiet = {quiet}\n".format(quiet=str(quiet))
        content += "nb_gadget = {nb_gadget}\n".format(nb_gadget=nb_gadget)
        content += "syscall_register = '{syscall_reg}'\n".format(syscall_reg=current_arch.syscall_register)
        content += "count = 0\n"
        if is_arm32():
            content += "enable_thumb = {thumb_mode}\n".format(thumb_mode=int(thumb_mode))
            content += "\n"
            content += "def thumb_check(emu, insn):\n"
            content += "    global enable_thumb\n"
            content += "    if insn.mnemonic in ['blx', 'bx']:\n"
            content += "        enable_thumb = emu.reg_read(registers['$'+insn.op_str]) & 1\n"
            content += "    return\n"

            # hack: unicorn can handle if thumb or not, but capstone can't. we have to handle it manually for capstone.
            # since CS_MODE_ARM is 0x0, it can be ignored. we represent status of thumb: CS_MODE_THUMB * (0 or 1).
            endian = cs_mode.split(" + ")[-1]
            cs_mode = "capstone.CS_MODE_THUMB * enable_thumb + " + endian

        content += "\n"
        content += "def disassemble(code, addr):\n"
        content += "    cs = capstone.Cs({cs_arch}, {cs_mode})\n".format(cs_arch=cs_arch, cs_mode=cs_mode)
        content += "    for i in cs.disasm(code, addr):\n"
        content += "        return i\n"
        content += "\n"
        content += "def code_hook(emu, address, size, user_data):\n"
        content += "    global count\n"
        content += "    if not quiet:\n"
        # min() is the workaround since unicorn passes 0xf1f1f1f1 as size if opcode is unsupported.
        # The execution will be failed, but the information of the error message increases.
        content += "        code = emu.mem_read(address, min(size, 0x10))\n"
        content += "        insn = disassemble(code, address)\n"
        content += "        code_hex = code[:insn.size].hex()\n"
        content += "        if verbose:\n"
        content += "            print_regs(emu, registers)\n"
        content += "        print('>>> {:d} {:#x}: {:24s} {:s} {:s}'.format(count, insn.address, code_hex, insn.mnemonic, insn.op_str))\n"
        if is_arm32():
            content += "        thumb_check(emu, insn)\n"
        content += "    count += 1\n"
        content += "    if 0 <= nb_gadget and count >= nb_gadget:\n"
        content += "        emu.emu_stop()\n"
        content += "    return\n"
        content += "\n"
        content += "def mem_invalid_hook(uc, access, address, size, value, user_data):\n"
        content += "    if access == unicorn.UC_MEM_WRITE_UNMAPPED:\n"
        content += "        print('  --> Invalid memory access; addr:{:#x}, size:{:#x}, value:{:#x}'.format(address, size, value))\n"
        content += "    elif access == unicorn.UC_MEM_READ_UNMAPPED:\n"
        content += "        print('  --> Invalid memory access; addr:{:#x}, size:{:#x}'.format(address, size))\n"
        content += "    return\n"
        content += "\n"
        content += "def intr_hook(emu, intno, data):\n"
        content += "    print('  --> interrupt={:d}'.format(intno))\n"
        content += "    return\n"
        content += "\n"
        content += "def syscall_hook(emu, user_data):\n"
        content += "    sysno = emu.reg_read(registers[syscall_register])\n"
        content += "    print('  --> syscall={:d} (not emulated)'.format(sysno))\n"
        content += "    return\n"
        content += "\n"
        content += "def print_regs(emu, regs):\n"
        content += "    for i, r in enumerate(regs):\n"
        content += "        print('{{:7s}} = {{:#0{ptrsize}x}}  '.format(r, emu.reg_read(regs[r])), end='')\n".format(ptrsize=current_arch.ptrsize * 2 + 2)
        content += "        if (i % 4 == 3) or (i == len(regs)-1): print('')\n"
        content += "    return\n"

        if is_x86():
            # need to handle segmentation (and pagination) via MSR
            content += "\n"
            content += "# from https://github.com/unicorn-engine/unicorn/blob/master/tests/regress/x86_64_msr.py\n"
            content += "SCRATCH_ADDR = 0xf000\n"
            content += "FSMSR = 0xC0000100\n"
            content += "GSMSR = 0xC0000101\n"
            content += "\n"
            content += "def set_msr(uc, msr, value, scratch=SCRATCH_ADDR):\n"
            content += "    buf = b'\\x0f\\x30' # x86: wrmsr\n"
            content += "    uc.mem_map(scratch, 0x1000)\n"
            content += "    uc.mem_write(scratch, buf)\n"
            content += "    uc.reg_write(unicorn.x86_const.UC_X86_REG_RAX, value & 0xFFFFFFFF)\n"
            content += "    uc.reg_write(unicorn.x86_const.UC_X86_REG_RDX, (value >> 32) & 0xFFFFFFFF)\n"
            content += "    uc.reg_write(unicorn.x86_const.UC_X86_REG_RCX, msr & 0xFFFFFFFF)\n"
            content += "    uc.emu_start(scratch, scratch+len(buf), count=1)\n"
            content += "    uc.mem_unmap(scratch, 0x1000)\n"
            content += "    return\n"
            content += "\n"
            content += "def set_gs(uc, addr):\n"
            content += "    return set_msr(uc, GSMSR, addr)\n"
            content += "\n"
            content += "def set_fs(uc, addr):\n"
            content += "    return set_msr(uc, FSMSR, addr)\n"

        content += "\n"
        content += "def reset():\n"
        content += "    emu = unicorn.Uc({arch}, {mode})\n".format(arch=arch, mode=mode)

        if is_x86():
            content += "\n"
            content += "    set_fs(emu, {FS:#x})\n".format(FS=TlsCommand.getfs() if is_x86_64() else 0)
            content += "    set_gs(emu, {GS:#x})\n".format(GS=TlsCommand.getgs() if is_x86_32() else 0)

        if verbose:
            info("Duplicating registers")

        if is_arm32() or is_arm64():
            # need first. because other register values may be broken when $cpsr is set
            gregval = get_register("$cpsr")
            content += "    emu.reg_write({}, {:#x})\n".format(unicorn_registers["$cpsr"], gregval)
        for r in current_arch.all_registers:
            if is_x86_64() and r == "$fs":
                continue
            if is_x86_32() and r == "$gs":
                continue
            if (is_arm32() or is_arm64()) and r == "$cpsr":
                continue
            gregval = get_register(r)
            content += "    emu.reg_write({}, {:#x})\n".format(unicorn_registers[r], gregval)
        content += "\n"

        vmmap = get_process_maps()
        if not vmmap:
            warn("An error occurred when reading memory map.")
            return

        if verbose:
            info("Duplicating memory map")

        for sect in vmmap:
            if sect.path == "[vvar]":
                # this section is for GDB only, skip it
                continue

            page_start = sect.page_start
            page_end = sect.page_end
            size = sect.size
            perm = sect.permission

            content += "    # Mapping {}: {:#x}-{:#x}\n".format(sect.path, page_start, page_end)
            content += "    emu.mem_map({:#x}, {:#x}, {})\n".format(page_start, size, oct(perm.value))

            if perm & Permission.READ:
                code = read_memory(page_start, size)
                loc = "/tmp/gef-{}-{:#x}.raw".format(fname, page_start)
                with open(loc, "wb") as f:
                    f.write(bytes(code))

                content += "    emu.mem_write({:#x}, open('{}', 'rb').read())\n".format(page_start, loc)
                content += "\n"

        content += "    emu.hook_add(unicorn.UC_HOOK_CODE, code_hook)\n"
        content += "    emu.hook_add(unicorn.UC_HOOK_INTR, intr_hook)\n"
        if is_x86_64():
            content += "    emu.hook_add(unicorn.UC_HOOK_INSN, syscall_hook, None, 1, 0, unicorn.x86_const.UC_X86_INS_SYSCALL)\n"
            content += "    emu.hook_add(unicorn.UC_HOOK_MEM_READ_UNMAPPED | unicorn.UC_HOOK_MEM_WRITE_UNMAPPED, mem_invalid_hook)\n"
        content += "    return emu\n"

        content += "\n"
        content += "def emulate(emu, start_addr, end_addr):\n"
        content += "    print('========================= Initial registers =========================')\n"
        content += "    print_regs(emu, registers)\n"
        content += "\n"
        content += "    try:\n"
        content += "        print('========================= Starting emulation =========================')\n"
        content += "        emu.emu_start(start_addr, end_addr)\n"
        content += "    except:\n"
        content += "        emu.emu_stop()\n"
        content += "        print('========================= Emulation failed =========================')\n"
        content += "        traceback.print_exc(file=sys.stdout)\n"
        content += "\n"
        content += "    print('========================= Final registers =========================')\n"
        content += "    print_regs(emu, registers)\n"
        content += "    return\n"
        content += "\n"
        content += "\n"
        content += "uc = reset()\n"
        content += "emulate(uc, {start:#x}, {end:#x})\n".format(start=start_insn_addr, end=end_insn_addr)
        content += "\n"
        content += "# unicorn-engine script generated by gef\n"

        os.write(tmp_fd, gef_pybytes(content))
        os.close(tmp_fd)

        if kwargs.get("to_file", None):
            info("Unicorn script generated as '{}'".format(tmp_filename))
            os.chmod(tmp_filename, 0o700)

        if skip_emulation:
            return

        if nb_gadget == -1:
            ok("Starting emulation: {:#x} {} {:#x}".format(start_insn_addr, RIGHT_ARROW, end_insn_addr))
        else:
            ok("Starting emulation: {:#x} {} after {:d} instructions are executed".format(start_insn_addr, RIGHT_ARROW, nb_gadget))

        pythonbin = which("python3")
        try:
            res = gef_execute_external([pythonbin, tmp_filename], as_list=True)
            gef_print("\n".join(res))
        except subprocess.CalledProcessError as e:
            gef_print(e.output.decode("utf-8").rstrip())

        if not kwargs.get("to_file", None):
            os.unlink(tmp_filename)
        return


@register_command
class StubCommand(GenericCommand):
    """Stub out the specified function. This function is useful when needing to skip one
    function to be called and disrupt your runtime flow (ex. fork)."""
    _cmdline_ = "stub"
    _syntax_ = "{:s} [-h] [-r RETVAL] [LOCATION]\n".format(_cmdline_)
    _syntax_ += "  LOCATION   address/symbol to stub out\n"
    _syntax_ += "  -r RETVAL  Set the return value"
    _example_ = "{:s} -r 0 fork".format(_cmdline_)
    _category_ = "Debugging Support"
    _aliases_ = ["deactive",]

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        try:
            opts, args = getopt.getopt(argv, "r:")
            retval = 0
            for o, a in opts:
                if o == "-r":
                    retval = int(a, 0)
        except getopt.GetoptError:
            self.usage()
            return

        loc = args[0] if args else "*{:#x}".format(current_arch.pc)
        StubBreakpoint(loc, retval)
        return


@register_command
class CapstoneDisassembleCommand(GenericCommand):
    """Use capstone disassembly framework to disassemble code."""
    _cmdline_ = "capstone-disassemble"
    _syntax_ = "{:s} [-h] [LOCATION] [[length=LENGTH] [OPCODES] [option=VALUE]] ".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} $pc length=50 # dump from $pc up to 50 lines later\n".format(_cmdline_)
    _example_ += "{:s} $pc length=50 OPCODES # show opcodes\n".format(_cmdline_)
    _example_ += "{:s} $pc length=50 OPCODES arch=ARM mode=ARM # specify arch and mode\n".format(_cmdline_)
    _example_ += "{:s} OPCODES code=\"9090\" # disassemble specific byte patterns ".format(_cmdline_)
    _category_ = "Assemble"
    _aliases_ = ["cs-dis",]

    def pre_load(self):
        try:
            __import__("capstone")
        except ImportError:
            msg = "Missing `capstone` package for Python. Install with `pip install capstone`."
            raise ImportWarning(msg)
        return

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        self.valid_arch_modes = {
            "ARM" : ["ARM", "THUMB"],
            "ARM64" : [],
            "MIPS" : ["MIPS32", "MIPS64"],
            "PPC" : ["PPC32", "PPC64"],
            "SPARC" : ["SPARC32"],
            "X86" : ["16", "32", "64"],
        }
        return

    def help(self):
        self.usage()
        gef_print("\nAvailable architectures/modes:")
        # for updates, see https://github.com/keystone-engine/keystone/blob/master/include/keystone/keystone.h
        for arch in self.valid_arch_modes:
            gef_print(" - {} ".format(arch))
            gef_print("  * {}".format(" / ".join(self.valid_arch_modes[arch])))
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        location = None
        show_opcodes = False

        if "-h" in argv:
            self.help()
            return

        try:
            kwargs = {}
            for arg in argv:
                if "=" in arg:
                    key, value = arg.split("=", 1)
                    kwargs[key] = value

                elif "opcodes".startswith(arg.lower()):
                    show_opcodes = True

                elif location is None:
                    location = parse_address(arg)
        except:
            self.help()
            return

        if "code" in kwargs:
            location = 0
        else:
            location = location or current_arch.pc
        length = int(kwargs.get("length", get_gef_setting("context.nb_lines_code")))

        try:
            for insn in capstone_disassemble(location, length, skip=length*self.repeat_count, **kwargs):
                insn_fmt = "{:12o}" if show_opcodes else "{}"
                text_insn = insn_fmt.format(insn)
                msg = ""

                if insn.address == current_arch.pc:
                    msg = Color.colorify("{}  {}".format(RIGHT_ARROW, text_insn), "bold red")
                    reason = self.capstone_analyze_pc(insn, length)[0]
                    if reason:
                        gef_print(msg)
                        gef_print(reason)
                        break
                else:
                    msg = "{} {}".format(" "*5, text_insn)

                gef_print(msg)
        except AttributeError:
            err("Maybe unsupported architecture")
        except gdb.error:
            pass
        return

    def capstone_analyze_pc(self, insn, nb_insn):
        if current_arch.is_conditional_branch(insn):
            is_taken, reason = current_arch.is_branch_taken(insn)
            if is_taken:
                reason = "[Reason: {:s}]".format(reason) if reason else ""
                msg = Color.colorify("\tTAKEN {:s}".format(reason), "bold green")
            else:
                reason = "[Reason: !({:s})]".format(reason) if reason else ""
                msg = Color.colorify("\tNOT taken {:s}".format(reason), "bold red")
            return (is_taken, msg)

        if current_arch.is_call(insn):
            try:
                target_address = int(insn.operands[-1].split()[0], 16)
                msg = []
                for i, new_insn in enumerate(capstone_disassemble(target_address, nb_insn)):
                    msg.append("   {}  {}".format (DOWN_ARROW if i == 0 else " ", str(new_insn)))
                return (True, "\n".join(msg))
            except:
                pass

        return (False, "")


@register_command
class GlibcHeapCommand(GenericCommand):
    """Base command to get information about the Glibc heap structure."""
    _cmdline_ = "heap"
    _syntax_ = "{:s} (chunk|chunks|bins|arenas|binsize-info)".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(prefix=True)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()
        self.usage()
        return


@register_command
class GlibcHeapArenaCommand(GenericCommand):
    """Display information on a heap chunk."""
    _cmdline_ = "heap arenas"
    _syntax_ = _cmdline_
    _aliases_ = ["arena",]
    _category_ = "Heap"

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        try:
            arena = GlibcArena(__gef_default_main_arena__)
        except gdb.error:
            err("Could not find Glibc main arena")
            return

        while True:
            gef_print("{}".format(arena))
            arena = arena.get_next()
            if arena is None:
                break

        info("additionally, you can see struct member by following")
        gef_print("p ((struct malloc_state*) ADDRESS)[0]")
        gef_print("p ((struct _heap_info*) ADDRESS)[0]")
        return


@register_command
class GlibcHeapBinSizeInfoCommand(GenericCommand):
    """Display heap bin size info."""
    _cmdline_ = "heap binsize-info"
    _syntax_ = _cmdline_
    _category_ = "Heap"

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        gef_print(titlify("tcache size"))
        if is_64bit():
            for i in range(64):
                gef_print("tcache[{:2d}]: {:#x}".format(i, i*0x10 + 0x20))
        elif is_32bit():
            gef_print("MALLOC_ALIGNMENT is changed from libc 2.26,")
            gef_print("for 32 bit arch, tcache 0x8 align is no longer used.")
            for i in range(64):
                gef_print("tcache[{:2d}]: {:#x}".format(i, i*0x10 + 0x10))

        gef_print(titlify("fastbin size"))
        if is_64bit():
            for i in range(7):
                gef_print("fastbins[{:d}]: {:#x}".format(i, i*0x10 + 0x20))
        elif is_32bit():
            gef_print("MALLOC_ALIGNMENT is changed from libc 2.26.")
            gef_print("for 32 bit arch, fastbin exists every 8 bytes, but only used every 16 bytes.")
            gef_print("fastbins[0]: 0x10")
            gef_print("fastbins[1]: 0x18 # unused")
            gef_print("fastbins[2]: 0x20")
            gef_print("fastbins[3]: 0x28 # unused")
            gef_print("fastbins[4]: 0x30")
            gef_print("fastbins[5]: 0x38 # unused")
            gef_print("fastbins[6]: 0x40")

        gef_print(titlify("unsorted_bin / small_bin / large_bin size"))
        gef_print("bins[{:3d}]: unsorted_bin".format(0))
        if is_64bit():
            for i in range(1, 63):
                gef_print("bins[{:3d}]: small_bins[{:3d}]: {:#x}".format( i*2, i, (i-1) * 0x10 + 0x20))
            gef_print("bins[126]: large_bins[ 63]: 0x400 - 0x430")
            gef_print("bins[128]: large_bins[ 64]: 0x440 - 0x470")
            gef_print("bins[130]: large_bins[ 65]: 0x480 - 0x4b0")
            gef_print("bins[132]: large_bins[ 66]: 0x4c0 - 0x4f0")
            gef_print("bins[134]: large_bins[ 67]: 0x500 - 0x530")
            gef_print("bins[136]: large_bins[ 68]: 0x540 - 0x570")
            gef_print("bins[138]: large_bins[ 69]: 0x580 - 0x5b0")
            gef_print("bins[140]: large_bins[ 70]: 0x5c0 - 0x5f0")
            gef_print("bins[142]: large_bins[ 71]: 0x600 - 0x630")
            gef_print("bins[144]: large_bins[ 72]: 0x640 - 0x670")
            gef_print("bins[146]: large_bins[ 73]: 0x680 - 0x6b0")
            gef_print("bins[148]: large_bins[ 74]: 0x6c0 - 0x6f0")
            gef_print("bins[150]: large_bins[ 75]: 0x700 - 0x730")
            gef_print("bins[152]: large_bins[ 76]: 0x740 - 0x770")
            gef_print("bins[154]: large_bins[ 77]: 0x780 - 0x7b0")
            gef_print("bins[156]: large_bins[ 78]: 0x7c0 - 0x7f0")
            gef_print("bins[158]: large_bins[ 79]: 0x800 - 0x830")
            gef_print("bins[160]: large_bins[ 80]: 0x840 - 0x870")
            gef_print("bins[162]: large_bins[ 81]: 0x880 - 0x8b0")
            gef_print("bins[164]: large_bins[ 82]: 0x8c0 - 0x8f0")
            gef_print("bins[166]: large_bins[ 83]: 0x900 - 0x930")
            gef_print("bins[168]: large_bins[ 84]: 0x940 - 0x970")
            gef_print("bins[170]: large_bins[ 85]: 0x980 - 0x9b0")
            gef_print("bins[172]: large_bins[ 86]: 0x9c0 - 0x9f0")
            gef_print("bins[174]: large_bins[ 87]: 0xa00 - 0xa30")
            gef_print("bins[176]: large_bins[ 88]: 0xa40 - 0xa70")
            gef_print("bins[178]: large_bins[ 89]: 0xa80 - 0xab0")
            gef_print("bins[180]: large_bins[ 90]: 0xac0 - 0xaf0")
            gef_print("bins[182]: large_bins[ 91]: 0xb00 - 0xb30")
            gef_print("bins[184]: large_bins[ 92]: 0xb40 - 0xb70")
            gef_print("bins[186]: large_bins[ 93]: 0xb80 - 0xbb0")
            gef_print("bins[188]: large_bins[ 94]: 0xbc0 - 0xbf0")
            gef_print("bins[190]: large_bins[ 95]: 0xc00 - 0xc30")
            gef_print("bins[192]: large_bins[ 96]: 0xc40 - 0xdf0")
        elif is_32bit():
            for i in range(1, 63):
                gef_print("bins[{:3d}]: small_bins[{:3d}]: {:#x}".format( i*2, i, (i-1) * 0x10 + 0x10))
            gef_print("bins[126]: large_bins[ 63]: 0x3f0")
            gef_print("bins[128]: large_bins[ 64]: 0x400 - 0x430")
            gef_print("bins[130]: large_bins[ 65]: 0x440 - 0x470")
            gef_print("bins[132]: large_bins[ 66]: 0x480 - 0x4b0")
            gef_print("bins[134]: large_bins[ 67]: 0x4c0 - 0x4f0")
            gef_print("bins[136]: large_bins[ 68]: 0x500 - 0x530")
            gef_print("bins[138]: large_bins[ 69]: 0x540 - 0x570")
            gef_print("bins[140]: large_bins[ 70]: 0x580 - 0x5b0")
            gef_print("bins[142]: large_bins[ 71]: 0x5c0 - 0x5f0")
            gef_print("bins[144]: large_bins[ 72]: 0x600 - 0x630")
            gef_print("bins[146]: large_bins[ 73]: 0x640 - 0x670")
            gef_print("bins[148]: large_bins[ 74]: 0x680 - 0x6b0")
            gef_print("bins[150]: large_bins[ 75]: 0x6c0 - 0x6f0")
            gef_print("bins[152]: large_bins[ 76]: 0x700 - 0x730")
            gef_print("bins[154]: large_bins[ 77]: 0x740 - 0x770")
            gef_print("bins[156]: large_bins[ 78]: 0x780 - 0x7b0")
            gef_print("bins[158]: large_bins[ 79]: 0x7c0 - 0x7f0")
            gef_print("bins[160]: large_bins[ 80]: 0x800 - 0x830")
            gef_print("bins[162]: large_bins[ 81]: 0x840 - 0x870")
            gef_print("bins[164]: large_bins[ 82]: 0x880 - 0x8b0")
            gef_print("bins[166]: large_bins[ 83]: 0x8c0 - 0x8f0")
            gef_print("bins[168]: large_bins[ 84]: 0x900 - 0x930")
            gef_print("bins[170]: large_bins[ 85]: 0x940 - 0x970")
            gef_print("bins[172]: large_bins[ 86]: 0x980 - 0x9b0")
            gef_print("bins[174]: large_bins[ 87]: 0x9c0 - 0x9f0")
            gef_print("bins[176]: large_bins[ 88]: 0xa00 - 0xa30")
            gef_print("bins[178]: large_bins[ 89]: 0xa40 - 0xa70")
            gef_print("bins[180]: large_bins[ 90]: 0xa80 - 0xab0")
            gef_print("bins[182]: large_bins[ 91]: 0xac0 - 0xaf0")
            gef_print("bins[184]: large_bins[ 92]: 0xb00 - 0xb30")
            gef_print("bins[186]: large_bins[ 93]: 0xb40 - 0xb70")
            gef_print("bins[190]: large_bins[ 95]: 0xb80 - 0xbf0")
            gef_print("bins[192]: large_bins[ 96]: 0xc00 - 0xdf0")
        gef_print("bins[194]: large_bins[ 97]: 0xe00 - 0xff0")
        gef_print("bins[196]: large_bins[ 98]: 0x1000 - 0x11f0")
        gef_print("bins[198]: large_bins[ 99]: 0x1200 - 0x13f0")
        gef_print("bins[200]: large_bins[100]: 0x1400 - 0x15f0")
        gef_print("bins[202]: large_bins[101]: 0x1600 - 0x17f0")
        gef_print("bins[204]: large_bins[102]: 0x1800 - 0x19f0")
        gef_print("bins[206]: large_bins[103]: 0x1a00 - 0x1bf0")
        gef_print("bins[208]: large_bins[104]: 0x1c00 - 0x1df0")
        gef_print("bins[210]: large_bins[105]: 0x1e00 - 0x1ff0")
        gef_print("bins[212]: large_bins[106]: 0x2000 - 0x21f0")
        gef_print("bins[214]: large_bins[107]: 0x2200 - 0x23f0")
        gef_print("bins[216]: large_bins[108]: 0x2400 - 0x25f0")
        gef_print("bins[218]: large_bins[109]: 0x2600 - 0x27f0")
        gef_print("bins[220]: large_bins[110]: 0x2800 - 0x29f0")
        gef_print("bins[222]: large_bins[111]: 0x2a00 - 0x2ff0")
        gef_print("bins[224]: large_bins[112]: 0x3000 - 0x3ff0")
        gef_print("bins[226]: large_bins[113]: 0x4000 - 0x4ff0")
        gef_print("bins[228]: large_bins[114]: 0x5000 - 0x5ff0")
        gef_print("bins[230]: large_bins[115]: 0x6000 - 0x6ff0")
        gef_print("bins[232]: large_bins[116]: 0x7000 - 0x7ff0")
        gef_print("bins[234]: large_bins[117]: 0x8000 - 0x8ff0")
        gef_print("bins[236]: large_bins[118]: 0x9000 - 0x9ff0")
        gef_print("bins[238]: large_bins[119]: 0xa000 - 0xfff0")
        gef_print("bins[240]: large_bins[120]: 0x10000 - 0x17ff0")
        gef_print("bins[242]: large_bins[121]: 0x18000 - 0x1fff0")
        gef_print("bins[244]: large_bins[122]: 0x20000 - 0x27ff0")
        gef_print("bins[246]: large_bins[123]: 0x28000 - 0x3fff0")
        gef_print("bins[248]: large_bins[124]: 0x40000 - 0x7fff0")
        gef_print("bins[250]: large_bins[125]:")
        gef_print("bins[252]: large_bins[126]:")
        return


@register_command
class GlibcHeapChunkCommand(GenericCommand):
    """Display information on a heap chunk.
    See https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1123."""
    _cmdline_ = "heap chunk"
    _syntax_ = "{:s} LOCATION".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if not argv:
            err("Missing chunk address")
            self.usage()
            return

        if get_main_arena() is None:
            return

        addr = parse_address(argv[0])
        chunk = GlibcChunk(addr)
        gef_print(chunk.psprint())
        return


@register_command
class GlibcHeapChunksCommand(GenericCommand):
    """Display information all heap chunks."""
    _cmdline_ = "heap chunks"
    _syntax_ = "{:s} [LOCATION] [-a ARENA_ADDRESS]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s}\n".format(_cmdline_)
    _example_ += "{:s} -a 0x7ffff0000020".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        self.add_setting("peek_nb_byte", 16, "Hexdump N first byte(s) inside the chunk data (0 to disable)")
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        # parse arena
        if "-a" in argv:
            idx = argv.index("-a")
            self.arena = GlibcArena("*{:s}".format(argv[idx + 1]))
            argv = argv[:idx] + argv[idx+2:]
        else:
            self.arena = get_main_arena()
        if self.arena is None:
            err("No valid arena")
            return
        if self.arena.heap_base is None:
            err("Heap is not initialized")
            return

        # parse start address
        if len(argv) == 1:
            self.dump_start = int(argv[0], 16)
            argv = None
        elif len(argv) == 0:
            self.dump_start = self.arena.heap_base
            # specific pattern
            if current_arch.ptrsize == 4 and self.arena.is_main_arena():
                self.dump_start += 8
        else:
            self.usage()
            return

        self.print_heap_chunks()
        return

    def print_heap_chunks(self):
        nb = self.get_setting("peek_nb_byte")
        current_chunk = GlibcChunk(self.dump_start, from_base=True)
        tcache_list = self.arena.tcache_list()
        fastbin_list = self.arena.fastbin_list()
        unsortedbin_list = self.arena.unsortedbin_list()
        smallbin_list = self.arena.smallbin_list()
        largebin_list = self.arena.largebin_list()
        while True:
            if current_chunk.chunk_base_address == self.arena.top:
                gef_print("{} {} {}".format(str(current_chunk), LEFT_ARROW, Color.greenify("top chunk")))
                break
            if current_chunk.chunk_base_address > self.arena.top:
                break
            if current_chunk.size == 0:
                # EOF
                break
            line = str(current_chunk)
            if nb:
                line += "\n    [" + hexdump(read_memory(current_chunk.address, nb), nb, base=current_chunk.address) + "]"
                for k, v in tcache_list.items():
                    if current_chunk.address in v:
                        line += " {} {}".format(LEFT_ARROW, Color.greenify("tcache[{}]".format(k)))
                for k, v in fastbin_list.items():
                    if current_chunk.address in v:
                        line += " {} {}".format(LEFT_ARROW, Color.greenify("fastbin[{}]".format(k)))
                for k, v in unsortedbin_list.items():
                    if current_chunk.address in v:
                        line += " {} {}".format(LEFT_ARROW, Color.greenify("unsortedbin"))
                for k, v in smallbin_list.items():
                    if current_chunk.address in v:
                        line += " {} {}".format(LEFT_ARROW, Color.greenify("smallbin[{}]".format(k)))
                for k, v in largebin_list.items():
                    if current_chunk.address in v:
                        line += " {} {}".format(LEFT_ARROW, Color.greenify("largebin[{}]".format(k)))
            gef_print(line)
            next_chunk = current_chunk.get_next_chunk()
            if next_chunk is None:
                break
            next_chunk_addr = Address(value=next_chunk.address)
            if not next_chunk_addr.valid:
                # corrupted
                break
            current_chunk = next_chunk
        return


@register_command
class GlibcHeapBinsCommand(GenericCommand):
    """Display information on the bins on an arena (default: main_arena).
    See https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1123."""
    _bin_types_ = ["tcache", "fast", "unsorted", "small", "large"]
    _cmdline_ = "heap bins"
    _syntax_ = "{:s} [{:s}] [-a ARENA_ADDRESS] [-v]".format(_cmdline_, "|".join(_bin_types_))
    _example_ = "\n"
    _example_ += "{:s}\n".format(_cmdline_)
    _example_ += "{:s} fast\n".format(_cmdline_)
    _example_ += "{:s} fast -a 0x7ffff0000020".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(prefix=True, complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        # parse arena
        arena_addr = None
        if "-a" in argv:
            idx = argv.index("-a")
            arena_addr = int(argv[-1], 16)
            argv = argv[:idx] + argv[idx+2:]

        verbose = ""
        if "-v" in argv:
            verbose = "-v"
            argv.remove("-v")

        if not argv:
            for bin_t in GlibcHeapBinsCommand._bin_types_:
                if arena_addr:
                    gdb.execute("heap bins {:s} -a {:#x} {:s}".format(bin_t, arena_addr, verbose))
                else:
                    gdb.execute("heap bins {:s} {:s}".format(bin_t, verbose))
            return

        bin_t = argv[0]
        if bin_t not in GlibcHeapBinsCommand._bin_types_:
            self.usage()
            return

        gdb.execute("heap bins {} {:s}".format(bin_t, verbose))
        return

    @staticmethod
    def pprint_bin(arena_addr, index, _type="", verbose=False):
        arena = GlibcArena(arena_addr)
        fw, bk = arena.bin(index)

        if bk == 0x00 and fw == 0x00:
            warn("Invalid backward and forward bin pointers(fw==bk==NULL)")
            return -1

        nb_chunk = 0
        head = GlibcChunk(bk, from_base=True).fwd
        if fw == head and not verbose:
            return nb_chunk

        ok("{:s}bins[idx={:d}]: fw={:#x}, bk={:#x}".format(_type, index, fw, bk))

        m = []
        while fw != head:
            chunk = GlibcChunk(fw, from_base=True)
            if _type == "large_":
                m.append("{:s} {:s}".format(RIGHT_ARROW, chunk.str_large()))
            else:
                m.append("{:s} {:s}".format(RIGHT_ARROW, str(chunk)))
            fw = chunk.fwd
            nb_chunk += 1

        if m:
            gef_print("\n".join(m))
        return nb_chunk


@register_command
class GlibcHeapTcachebinsCommand(GenericCommand):
    """Display information on the Tcachebins on an arena (default: main_arena).
    See https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc."""
    _cmdline_ = "heap bins tcache"
    _syntax_ = "{:s} [-a ARENA_ADDRESS] [-v]".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        if argv and "-a" != argv[0]:
            self.usage()
            return

        # Determine if we are using libc with tcache built in (2.26+)
        if get_libc_version() < (2, 26):
            info("No Tcache in this version of libc")
            return

        arena = GlibcArena("*{:s}".format(argv[1])) if len(argv) == 2 else get_main_arena()

        if arena is None:
            err("Invalid Glibc arena")
            return

        # Get tcache_perthread_struct for this arena
        if arena.heap_base is None:
            err("No heap section")
            return
        tcache_perthread_struct = arena.heap_base + 0x10
        arena_addr = "*{:s}".format(argv[1]) if len(argv) == 2 else __gef_default_main_arena__
        gef_print(titlify("Tcachebins for arena '{:s}'".format(arena_addr)))
        for i in range(GlibcArena.TCACHE_MAX_BINS):
            if get_libc_version() < (2, 30):
                count = ord(read_memory(tcache_perthread_struct + i, 1))
            else:
                count = u16(read_memory(tcache_perthread_struct + 2 * i, 2))
            chunk = arena.tcachebin(i)
            chunks = set()
            m = []

            # Only print the entry if there are valid chunks. Don't trust count
            while True:
                if chunk is None:
                    break
                try:
                    m.append("{:s} {:s} ".format(RIGHT_ARROW, str(chunk)))
                    if chunk.address in chunks:
                        m.append("{:s} [loop detected]".format(RIGHT_ARROW))
                        break

                    chunks.add(chunk.address)

                    next_chunk = chunk.get_fwd_ptr(True)
                    if next_chunk == 0:
                        break

                    chunk = GlibcChunk(next_chunk)
                except gdb.MemoryError:
                    m.append("{:s} [Corrupted chunk at {:#x}]".format(LEFT_ARROW, chunk.address))
                    break
            if m or verbose:
                gef_print("Tcachebins[idx={:d}, size={:#x}] count={:d}\n".format(i, (current_arch.ptrsize)*4 + i*0x10, count), end="")
                if m:
                    gef_print("\n".join(m))
        return


@register_command
class GlibcHeapFastbinsYCommand(GenericCommand):
    """Display information on the fastbinsY on an arena (default: main_arena).
    See: https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1123."""
    _cmdline_ = "heap bins fast"
    _syntax_ = "{:s} [-a ARENA_ADDRESS]".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        verbose = False
        if "-v" in argv:
            verbose = True # no effect
            argv.remove("-v")

        if argv and "-a" != argv[0]:
            self.usage()
            return

        def fastbin_index(sz):
            return (sz >> 4) - 2 if SIZE_SZ == 8 else (sz >> 3) - 2

        SIZE_SZ = current_arch.ptrsize
        MAX_FAST_SIZE = 80 * SIZE_SZ // 4
        NFASTBINS = fastbin_index(MAX_FAST_SIZE) - 1

        arena = GlibcArena("*{:s}".format(argv[1])) if len(argv) == 2 else get_main_arena()

        if arena is None:
            err("Invalid Glibc arena")
            return

        arena_addr = "*{:s}".format(argv[1]) if len(argv) == 2 else __gef_default_main_arena__
        gef_print(titlify("Fastbins for arena '{:s}'".format(arena_addr)))
        for i in range(NFASTBINS):
            gef_print("Fastbins[idx={:d}, size={:#x}] ".format(i, (i+2)*SIZE_SZ*2), end="")
            chunk = arena.fastbin(i)
            chunks = set()

            while True:
                if chunk is None:
                    break

                try:
                    gef_print("\n{:s} {:s} ".format(RIGHT_ARROW, str(chunk)), end="")
                    if chunk.address in chunks:
                        gef_print("{:s} [loop detected]".format(RIGHT_ARROW), end="")
                        break

                    if fastbin_index(chunk.get_chunk_size()) != i:
                        gef_print("[incorrect fastbin_index] ", end="")

                    chunks.add(chunk.address)

                    next_chunk = chunk.get_fwd_ptr(True)
                    if next_chunk == 0:
                        break

                    chunk = GlibcChunk(next_chunk, from_base=True)
                except gdb.MemoryError:
                    gef_print("{:s} [Corrupted chunk at {:#x}]".format(LEFT_ARROW, chunk.address), end="")
                    break
            gef_print()
        return


@register_command
class GlibcHeapUnsortedBinsCommand(GenericCommand):
    """Display information on the Unsorted Bins of an arena (default: main_arena).
    See: https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1689."""
    _cmdline_ = "heap bins unsorted"
    _syntax_ = "{:s} [-a ARENA_ADDRESS]".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        if argv and "-a" != argv[0]:
            self.usage()
            return

        if get_main_arena() is None:
            err("Invalid Glibc arena")
            return

        arena_addr = "*{:s}".format(argv[1]) if len(argv) == 2 else __gef_default_main_arena__
        gef_print(titlify("Unsorted Bin for arena '{:s}'".format(arena_addr)))
        nb_chunk = GlibcHeapBinsCommand.pprint_bin(arena_addr, 0, "unsorted_", verbose)
        if nb_chunk >= 0:
            info("Found {:d} chunks in unsorted bin.".format(nb_chunk))
        return


@register_command
class GlibcHeapSmallBinsCommand(GenericCommand):
    """Convenience command for viewing small bins."""
    _cmdline_ = "heap bins small"
    _syntax_ = "{:s} [-a ARENA_ADDRESS] [-v]".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        if argv and "-a" != argv[0]:
            self.usage()
            return

        if get_main_arena() is None:
            err("Invalid Glibc arena")
            return

        arena_addr = "*{:s}".format(argv[1]) if len(argv) == 2 else __gef_default_main_arena__
        gef_print(titlify("Small Bins for arena '{:s}'".format(arena_addr)))
        bins = {}
        for i in range(1, 63):
            nb_chunk = GlibcHeapBinsCommand.pprint_bin(arena_addr, i, "small_", verbose)
            if nb_chunk < 0:
                break
            if nb_chunk > 0:
                bins[i] = nb_chunk
        info("Found {:d} chunks in {:d} small non-empty bins.".format(sum(bins.values()), len(bins)))
        return


@register_command
class GlibcHeapLargeBinsCommand(GenericCommand):
    """Convenience command for viewing large bins."""
    _cmdline_ = "heap bins large"
    _syntax_ = "{:s} [-a ARENA_ADDRESS] [-v]".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        if argv and "-a" != argv[0]:
            self.usage()
            return

        if get_main_arena() is None:
            err("Invalid Glibc arena")
            return

        arena_addr = "*{:s}".format(argv[1]) if len(argv) == 2 else __gef_default_main_arena__
        gef_print(titlify("Large Bins for arena '{:s}'".format(arena_addr)))
        bins = {}
        for i in range(63, 126):
            nb_chunk = GlibcHeapBinsCommand.pprint_bin(arena_addr, i, "large_", verbose)
            if nb_chunk < 0:
                break
            if nb_chunk > 0:
                bins[i] = nb_chunk
        info("Found {:d} chunks in {:d} large non-empty bins.".format(sum(bins.values()), len(bins)))
        return


@register_command
class DetailRegistersCommand(GenericCommand):
    """Display full details on one, many or all registers value from current architecture."""
    _cmdline_ = "registers"
    _syntax_ = "{:s} [[Register1][Register2] ... [RegisterN]]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s}\n".format(_cmdline_)
    _example_ += "{:s} $eax $eip $esp".format(_cmdline_)
    _category_ = "Show/Modify Register"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        unchanged_color = get_gef_setting("theme.registers_register_name")
        changed_color = get_gef_setting("theme.registers_value_changed")
        string_color = get_gef_setting("theme.dereference_string")
        max_recursion = get_gef_setting("dereference.max_recursion") or 4

        if argv:
            argv = [arg if arg.startswith("$") else "$" + arg for arg in argv]
            regs = [reg for reg in current_arch.all_registers if reg in argv]
            if not regs:
                warn("No matching registers found")
        else:
            regs = current_arch.all_registers

        memsize = current_arch.ptrsize
        endian = endian_str()
        charset = string.printable
        widest = max(map(len, current_arch.all_registers))
        special_line = ""

        for regname in regs:
            reg = gdb.parse_and_eval(regname)
            if reg.type.code == gdb.TYPE_CODE_VOID:
                continue

            padreg = regname.ljust(widest, " ")

            if str(reg) == "<unavailable>":
                line = "{}: ".format(Color.colorify(padreg, unchanged_color))
                line += Color.colorify("no value", "yellow underline")
                gef_print(line)
                continue

            # colorling
            value = align_address(int(reg))
            old_value = ContextCommand.old_registers.get(regname, 0)
            if value == old_value:
                color = unchanged_color
            else:
                color = changed_color

            # Special (e.g. segment) registers go on their own line
            if regname in current_arch.special_registers:
                special_line += "{}: ".format(Color.colorify(regname, color))
                special_line += "{:#04x} ".format(get_register(regname))
                continue

            # reg name
            line = "{}: ".format(Color.colorify(padreg, color))

            # flag register
            if regname == current_arch.flag_register:
                line += current_arch.flag_register_to_human()
                gef_print(line)
                continue

            # register value with aligned width
            sym = get_symbol_string(value)
            addr = lookup_address(align_address(int(value)))
            if sym or addr.valid:
                line += str(addr) + sym # 0x0000000041414141 <foo> # 0-pad colored value with symbol if exists
            else:
                line += format_address_spaces(value) # 0x41414141________ # non-colored value with padding space

            # dereference values
            # addrs: [Address(rax), Address(deref_of_rax), Address(deref_of_deref_of_rax), ..., str(msg)]
            addrs = dereference_from(value)
            if len(addrs) > 1: # skip first element because it is register value itself
                sep = " {:s} ".format(RIGHT_ARROW)
                for addr in addrs[1:]:
                    if isinstance(addr, Address):
                        line += sep + str(addr) + get_symbol_string(addr.value)
                    else:
                        line += sep + addr # actually this is msg

            # add "..." or not
            if max_recursion <= len(addrs) and isinstance(addrs[-1], Address):
                subseq_addrs = dereference_from(addrs[-1].value)
                if len(subseq_addrs) > 1:
                    line += sep + "..."

            # last dereference values list is ascii or not
            if isinstance(addrs[-1], Address):
                try:
                    fmt = "{}{}".format(endian, "I" if memsize == 4 else "Q")
                    val = gef_pystring(struct.pack(fmt, addrs[-1].value))
                    if all([_ in charset for _ in val]):
                        line += ' ("{:s}"?)'.format(Color.colorify(val, string_color))
                except ValueError:
                    pass

            gef_print(line)

        if special_line:
            gef_print(special_line)
        return


@register_command
class RopperCommand(GenericCommand):
    """Ropper (http://scoding.de/ropper) plugin."""
    _cmdline_ = "ropper"
    _syntax_ = "{:s} [-h] [ROPPER_OPTIONS]".format(_cmdline_)
    _category_ = "Exploit Development"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_NONE)
        return

    def pre_load(self):
        try:
            __import__("ropper")
        except ImportError:
            msg = "Missing `ropper` package for Python, install with: `pip install ropper`."
            raise ImportWarning(msg)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        ropper = sys.modules["ropper"]
        if "-h" in argv:
            os.system("ropper --help")
            os.system("ropper --help-examples")
            return

        if "--file" not in argv:
            path = get_filepath()
            if path is None:
                err("Missing info about file. Please set: `file /path/to/target_binary`")
                return
            argv.append("--file")
            argv.append(path)
            if is_qemu_usermode():
                sect = next(filter(lambda x: x.path == "[code]", get_process_maps()))
            else:
                sect = next(filter(lambda x: x.path == path, get_process_maps()))
            argv.append("-I")
            argv.append("{:#x}".format(sect.page_start))

        # ropper set up own autocompleter after which gdb/gef autocomplete don't work
        # due to fork/waitpid, child will be broken but parent will not change
        pid = os.fork()
        if pid == 0:
            try:
                ropper.start(argv)
            except:
                pass
            os._exit(0)
        else:
            os.waitpid(pid, 0)
        return


@register_command
class RpCommand(GenericCommand):
    """Exec `rp++`."""
    _cmdline_ = "rp"
    _syntax_ = "{:s} bin|libc|FILENAME|kernel [-f|--filter REGEXP] [-r|--rop ROP_N] [--no-print] [...]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} bin -f 'pop r[abcd]x'\n".format(_cmdline_)
    _example_ += "{:s} libc -f '(xchg|mov) [re]sp, \\\\w+' -f 'ret'\n".format(_cmdline_)
    _example_ += "{:s} kernel # under qemu-system (x86/x64) only".format(_cmdline_)
    _category_ = "Exploit Development"

    def exec_rp(self, ropN):
        out = "rop{}_{}.txt".format(ropN, os.path.basename(self.path))
        cmd = f"{self.rp} --file='{self.path}' --rop={ropN} --unique > {out}"
        gef_print(titlify(cmd))
        if not os.path.exists(out):
            os.system(cmd)
        return out

    def apply_filter(self, out, filter_patterns, base_address):
        if not os.path.exists(out):
            err(f"{out} is not found")
            return
        lines = open(out, "r").read()

        _, tmp_path = tempfile.mkstemp()
        fp = open(tmp_path, "w")
        for line in lines.splitlines():
            line = re.sub(r"\x1B\[([0-9]{1,2}(;[0-9]{1,2})*)?m", "", line) # remove color

            match = True
            for pat in filter_patterns:
                if not re.search(pat, line):
                    match = False
                    break

            if match:
                if line.startswith("0x"):
                    x = line.split(":")
                    addr, gadget = int(x[0], 16), ':'.join(x[1:])
                    addr -= base_address # fix address
                    x = Color.redify("{:#08x}".format(addr)) + ":" + ':'.join(x[1:]) # repaint color
                else:
                    x = line
                fp.write(x + "\n")
        fp.close()
        return tmp_path

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if is_x86():
            try:
                self.rp = which("rp-lin-x64")
            except FileNotFoundError as e1:
                try:
                    self.rp = which("rp-lin-x86")
                except FileNotFoundError as e2:
                    err("{}".format(e1))
                    err("{}".format(e2))
                    return
        else:
            err("Unsupported")
            return

        try:
            less = which("less")
        except FileNotFoundError as e:
            err("{}".format(e))
            return

        try:
            ropN = 3
            while "-r" in argv:
                idx = argv.index("-r")
                ropN = int(argv[idx + 1])
                argv = argv[:idx] + argv[idx+2:]
            while "--rop" in argv:
                idx = argv.index("--rop")
                ropN = int(argv[idx + 1])
                argv = argv[:idx] + argv[idx+2:]
        except:
            self.usage()
            return

        try:
            filter_patterns = []
            while "-f" in argv:
                idx = argv.index("-f")
                pattern = argv[idx + 1]
                filter_patterns.append(pattern)
                argv = argv[:idx] + argv[idx+2:]
            while "--filter" in argv:
                idx = argv.index("--filter")
                pattern = argv[idx + 1]
                filter_patterns.append(pattern)
                argv = argv[:idx] + argv[idx+2:]
        except:
            self.usage()
            return

        do_print = True
        if "--no-print" in argv:
            do_print = False
            argv.remove("--no-print")

        if len(argv) != 1:
            self.usage()
            return

        if is_qemu_system():
            if argv[0] == "kernel":
                # dump kernel then apply vmlinux-to-elf
                dump_mem_file = "/tmp/gef-dump-memory.raw"
                self.path = symboled_vmlinux_file = "/tmp/gef-dump-memory.elf"
                addrs = VmlinuxToElfApplyCommand().dump_kernel_elf(dump_mem_file, symboled_vmlinux_file)
                if addrs is None:
                    err("Failed to get symboled ELF")
                    return
                base_address = addrs["kbase"]
            else:
                self.usage()
                return
        else:
            if argv[0] == "libc":
                libc = process_lookup_path_by_list(("libc-2.", "libc.so.6"))
                if libc is None:
                    err("libc is not found")
                    return
                self.path = libc.path
            elif argv[0] == "bin":
                binary = get_filepath()
                if binary is None:
                    err("binary is not found")
                    return
                self.path = binary
            else:
                if not os.path.exists(argv[0]):
                    err("{} is not found".format(argv[0]))
                    return
                self.path = argv[0]
            base_address = 0

        # invoke rp++
        out = self.exec_rp(ropN)

        # filtering
        tmp_path = self.apply_filter(out, filter_patterns, base_address)
        if tmp_path is None:
            return

        # print
        if do_print:
            os.system(f"{less} -R {tmp_path}")
            os.unlink(tmp_path)
        return


@register_command
class AssembleCommand(GenericCommand):
    """Inline code assemble by keystone. Architecture can be set in GEF runtime config (default x86-64). """
    _cmdline_ = "asm"
    _syntax_ = "{:s} [-h] [-a ARCH] [-m MODE] [-e] [-s] [-l LOCATION] instruction;[instruction;...instruction;]\n".format(_cmdline_)
    _syntax_ += "  -a ARCH      specify the architecture\n"
    _syntax_ += "  -m MODE      specify the mode\n"
    _syntax_ += "  -e           use big-endian\n"
    _syntax_ += "  -s           output like shellcode style\n"
    _syntax_ += "  -l LOCATION  write to memory address"
    # for updates, see https://github.com/keystone-engine/keystone/blob/master/include/keystone/keystone.h
    _example_ = "\n"
    _example_ += '{:s} -a X86 -m 64 "mov rax, qword ptr [rax] ; inc rax ;"\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 32 "mov eax, dword ptr [eax] ; inc eax ;"\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 16 "mov ax, word ptr [ax] ; inc ax"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m ARM    "sub r1, r2, r3"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m ARM -e "sub r1, r2, r3"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m THUMB  "movs r4, #0xf0"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM64         "ldr w1, [sp, #0x8]"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS32    "and $9, $6, $7"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS32 -e "and $9, $6, $7"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS64    "and $9, $6, $7"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS64 -e "and $9, $6, $7"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m PPC32 -e "add 1, 2, 3"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m PPC64    "add 1, 2, 3"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m PPC64 -e "add 1, 2, 3"\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m SPARC32    "add %g1, %g2, %g3"\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m SPARC32 -e "add %g1, %g2, %g3"\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m SPARC64 -e "add %g1, %g2, %g3"\n'.format(_cmdline_)
    _example_ += '{:s} -a SYSTEMZ -e "a %r0, 4095(%r15,%r1)"'.format(_cmdline_)
    _category_ = "Assemble"

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        self.valid_arch_modes = {
            "ARM": ["ARM", "THUMB"],
            "ARM64": [],
            "MIPS": ["MIPS32", "MIPS64",],
            "PPC": ["PPC32", "PPC64",],
            "SPARC": ["SPARC32", "SPARC64",],
            "SYSTEMZ": [],
            "X86": ["16", "32", "64"],
        }
        return

    def pre_load(self):
        try:
            __import__("keystone")
        except ImportError:
            msg = "Missing `keystone-engine` package for Python, install with: `pip install keystone-engine`."
            raise ImportWarning(msg)
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        arch_s, mode_s, big_endian, as_shellcode, overwrite_location = None, None, False, False, None
        try:
            opts, args = getopt.getopt(argv, "a:m:l:esh")
            for o, a in opts:
                if o == "-a":
                    arch_s = a.upper()
                if o == "-m":
                    mode_s = a.upper()
                if o == "-e":
                    big_endian = True
                if o == "-s":
                    as_shellcode = True
                if o == "-l":
                    overwrite_location = int(gdb.parse_and_eval(a))
                if o == "-h":
                    self.usage()
                    return
        except:
            self.usage()
            return

        if not args:
            self.usage()
            return

        if (arch_s, mode_s) == (None, None):
            if is_alive():
                if is_arm64():
                    arch_s, mode_s = current_arch.arch, 0
                else:
                    arch_s, mode_s = current_arch.arch, current_arch.mode
                endian_s = "big" if is_big_endian() else "little"
                arch, mode = get_keystone_arch(arch=arch_s, mode=mode_s, endian=is_big_endian())
            else:
                # if not alive, defaults to x86-64
                arch_s = "X86"
                mode_s = "64"
                endian_s = "little"
                arch, mode = get_keystone_arch(arch=arch_s, mode=mode_s, endian=False)
        elif not arch_s:
            err("An architecture (-a) must be provided")
            return
        elif not arch_s in ["ARM64", "SYSTEMZ"] and not mode_s:
            err("A mode (-m) must be provided")
            return
        else:
            arch, mode = get_keystone_arch(arch=arch_s, mode=mode_s, endian=big_endian)
            endian_s = "big" if big_endian else "little"

        insns = " ".join(args)
        insns = [x.strip() for x in insns.split(";") if x is not None and x.strip() != ""]

        arch_mode_s = ":".join([str(arch_s), str(mode_s)])
        info("Assembling {} instruction{} for {} ({} endian)".format(len(insns), "s" if len(insns)>1 else "", arch_mode_s, endian_s))

        if as_shellcode:
            gef_print("""sc="" """)

        raw = b""
        for insn in insns:
            res = keystone_assemble(insn, arch, mode, raw=True)
            if not res:
                gef_print("(Invalid)")
                continue

            if overwrite_location:
                raw += res
                continue

            s = binascii.hexlify(res)
            res = b"\\x" + b"\\x".join([s[i:i + 2] for i in range(0, len(s), 2)])
            res = res.decode("utf-8")

            if as_shellcode:
                res = """sc+="{0:s}" """.format(res)

            gef_print("{0:60s} # {1}".format(res, insn))

        if overwrite_location:
            l = len(raw)
            info("Overwriting {:d} bytes at {:s}".format(l, format_address(overwrite_location)))
            write_memory(overwrite_location, raw, l)
        return


@register_command
class DisassembleCommand(GenericCommand):
    """Inline code disassemble by capstone. Architecture can be set in GEF runtime config (default x86-64). """
    _cmdline_ = "dasm"
    _syntax_ = "{:s} [-h] [-a ARCH] [-m MODE] [-e] hex-byte-code\n".format(_cmdline_)
    _syntax_ += "  -a ARCH      specify the architecture\n"
    _syntax_ += "  -m MODE      specify the mode\n"
    _syntax_ += "  -e           use big-endian"
    _example_ = "\n"
    _example_ += '{:s} -a X86 -m 64 "488b00 48ffc0"\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 32 "8b00 40"\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 16 "8b00 40"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m ARM    "031042e0"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m ARM -e "e0421003"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m THUMB  "f024"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM64 -m ARM  "e10b40b9"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS32    "2448c700"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS32 -e "00c74824"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS64    "2448c700"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS64 -e "00c74824"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m 32 -e "7c221a14"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m 64    "141a227c"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m 64 -e "7c221a14"\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m V9    "02400086"\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m V9 -e "86004002"'.format(_cmdline_)
    _category_ = "Assemble"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        self.valid_arch_modes = {
            "ARM" : ["ARM", "THUMB"],
            "ARM64" : [],
            "MIPS" : ["MIPS32", "MIPS64"],
            "PPC" : ["PPC32", "PPC64"],
            "SPARC" : ["SPARC32"],
            "X86" : ["16", "32", "64"],
        }
        return

    def pre_load(self):
        try:
            __import__("capstone")
        except ImportError:
            msg = "Missing `capstone` package for Python. Install with `pip install capstone`."
            raise ImportWarning(msg)
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        arch_s, mode_s, big_endian = None, None, False
        try:
            opts, args = getopt.getopt(argv, "a:m:eh")
            for o, a in opts:
                if o == "-a":
                    arch_s = a.upper()
                if o == "-m":
                    mode_s = a.upper()
                if o == "-e":
                    big_endian = True
                if o == "-h":
                    self.usage()
                    return
        except:
            self.usage()
            return

        if not args:
            self.usage()
            return

        if (arch_s, mode_s) == (None, None):
            if is_alive():
                if is_arm64():
                    arch_s, mode_s = current_arch.arch, 0
                else:
                    arch_s, mode_s = current_arch.arch, current_arch.mode
                endian_s = "big" if is_big_endian() else "little"
                arch, mode = get_capstone_arch(arch=arch_s, mode=mode_s, endian=is_big_endian())
            else:
                # if not alive, defaults to x86-64
                arch_s = "X86"
                mode_s = "64"
                endian_s = "little"
                arch, mode = get_capstone_arch(arch=arch_s, mode=mode_s, endian=False)
        elif not arch_s:
            err("An architecture (-a) must be provided")
            return
        elif not arch_s in ["SPARC"] and not mode_s:
            err("A mode (-m) must be provided")
            return
        else:
            arch, mode = get_capstone_arch(arch=arch_s, mode=mode_s, endian=big_endian)
            endian_s = "big" if big_endian else "little"

        insns = " ".join(args)
        insns = insns.replace(" ", "").replace("\t", "")
        try:
            insns = binascii.unhexlify(insns)
        except:
            err("Invalid format")
            return

        arch_mode_s = ":".join([str(arch_s), str(mode_s)])
        info("Disassembling {} bytes for {} ({} endian)".format(len(insns), arch_mode_s, endian_s))

        capstone = sys.modules["capstone"]
        cs = capstone.Cs(arch, mode)
        cs.detail = True

        for insn in cs.disasm(insns, 0x0):
            b = binascii.hexlify(insn.bytes).decode("utf-8")
            gef_print("{:>#6x}:\t{:<10s}\t{:s}\t{:s}".format(insn.address, b, insn.mnemonic, insn.op_str))
        return


@register_command
class AsmListCommand(GenericCommand):
    """List up general instructions by capstone.(x64/x86 only) """
    _cmdline_ = "asm-list"
    _syntax_ = "{:s} [-h] [-a ARCH] [-m MODE] [-e] [-n NBYTE] [-f INCLUDE] [-v EXCLUDE] [-s]\n".format(_cmdline_)
    _syntax_ += "  -a ARCH      specify the architecture\n"
    _syntax_ += "  -m MODE      specify the mode\n"
    _syntax_ += "  -e           use big-endian (for future update)\n"
    _syntax_ += "  -s           use simple mode; exclude x87 fpu, SSE, etc.\n"
    _syntax_ += "  -n NBYE      filter by asm byte length\n"
    _syntax_ += "  -f INCLUDE   filter by string\n"
    _syntax_ += "  -v EXCLUDE   filter by string"
    _example_ = "\n"
    _example_ += '{:s} -a X86 -m 64\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 32\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 16\n'.format(_cmdline_)
    _example_ += '  F0 (LOCK prefix) is ignored\n'
    _example_ += '  F2/F3 (REPNE/REP prefix) are ignored\n'
    _example_ += '  2E/36/3E/26/64/65 (CS/SS/DS/ES/FS/GS override prefix) are ignored\n'
    _example_ += '  2E/3E (branch hint prefix) are ignored\n'
    _example_ += '  66 (operand size prefix) is included\n'
    _example_ += '  67 (address size prefix) is ignored\n'
    _example_ += '  40-4F (REX prefix) are ignored\n'
    _example_ += '  C4/C5 (VEX prefix) are ignored\n'
    _example_ += '  8F (XOP prefix) is ignored\n'
    _example_ += '  62 (EVEX prefix) is ignored'
    _category_ = "Assemble"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        self.valid_arch_modes = {
            "X86" : ["16", "32", "64"],
        }
        return

    def pre_load(self):
        try:
            __import__("capstone")
        except ImportError:
            msg = "Missing `capstone` package for Python. Install with `pip install capstone`."
            raise ImportWarning(msg)
        return

    def listup_x86(self, arch, mode):
        DISP64 = "1122334455667788"
        DISP32 = "11223344"
        DISP16 = "1122"
        DISP8  = "11"

        @lru_cache()
        def get_typical_bytecodes_modrm(_reg):
            bytecodes = []
            for (mod, reg, rm) in itertools.product([0b00, 0b01, 0b10, 0b11], _reg, [0b000]):
                modrm = "%02X" % ((mod << 6) | (reg << 3) | rm)
                if mod == 0b00:
                    if rm == 0b101: # special case; [REG + disp32]
                        bytecode = modrm + DISP32
                    elif rm == 0b100: # use sib; [INDEX * SCALE + BASE]
                        for sib in filter(lambda x:x&0b111 != 0b101, range(256)):
                            bytecode = modrm + "%02X" % sib
                    else: # [REG]
                        bytecode = modrm
                elif mod == 0b01:
                    if rm == 0b100: # use sib; [INDEX * SCALE + BASE + disp8]
                        bytecode = []
                        for sib in filter(lambda x:x&0b111 != 0b101, range(256)):
                            b = modrm + ("%02X" % sib) + DISP8
                            bytecode.append(b)
                    else: # [REG + disp8]
                        bytecode = modrm + DISP8
                elif mod == 0b10:
                    if rm == 0b100: # use sib; [INDEX * SCALE + BASE + disp32]
                        bytecode = []
                        for sib in filter(lambda x:x&0b111 != 0b101, range(256)):
                            b = modrm + ("%02X" % sib) + DISP32
                            bytecode.append(b)
                    else: # [REG + disp32]
                        bytecode = modrm + DISP32
                elif mod == 0b11: # REG
                    bytecode = modrm
                bytecodes.append(bytecode)
            return bytecodes

        @lru_cache()
        def get_typical_bytecodes(opcodes):
            bytecodes = []
            for i, operand in enumerate(opcodes.split()):
                if operand in ["ib", "cb"]:
                    bytecode = [DISP8]
                elif operand in ["iw", "cw"]:
                    bytecode = [DISP16]
                elif operand in ["id", "cd"]:
                    bytecode = [DISP32]
                elif operand in ["iq"]:
                    bytecode = [DISP64]
                elif operand in ["/0", "/1", "/2", "/3", "/4", "/5", "/6", "/7"]:
                    bytecode = get_typical_bytecodes_modrm(tuple([int(operand[1])]))
                elif operand == "/r":
                    bytecode = get_typical_bytecodes_modrm(tuple([0]))
                elif operand.endswith(("+r", "+i")):
                    b = int(operand.split("+")[0], 16)
                    bytecode = ["%02X" % (b + x) for x in range(8)]
                else:
                    bytecode = [operand]
                bytecodes.append(bytecode)
            return [''.join(b) for b in itertools.product(*bytecodes)]

        # download defines
        url = 'https://raw.githubusercontent.com/bata24/gef/dev/asmdb/x86data.js'
        x86 = http_get(url)
        x86 = x86.split(b"// ${JSON:BEGIN}")[1].split(b"// ${JSON:END}")[0]
        x86 = json.loads(x86)

        x86_insns = x86["instructions"]
        # [opcode_str, unused, unused, opcodes, attr]
        x86_insns.append(["icebp", "", "", "F1", "Undocumented"])
        x86_insns.append(["salc", "", "", "D6", "Undocumented"])
        #x86_insns.append(["umov", "", "", "0F 10 /r", "Undocumented"]) # used by another opcode
        #x86_insns.append(["umov", "", "", "0F 11 /r", "Undocumented"]) # used by another opcode
        #x86_insns.append(["umov", "", "", "0F 12 /r", "Undocumented"]) # used by another opcode
        #x86_insns.append(["umov", "", "", "0F 13 /r", "Undocumented"]) # used by another opcode
        #x86_insns.append(["loadall", "", "", "0F 05", "Undocumented"]) # used by another opcode
        #x86_insns.append(["loadall", "", "", "0F 07", "Undocumented"]) # used by another opcode
        #x86_insns.append(["xbts", "", "", "0F A6", "Undocumented"]) # removed now
        #x86_insns.append(["ibts", "", "", "0F A7", "Undocumented"]) # removed now

        capstone = sys.modules["capstone"]
        cs = capstone.Cs(arch, mode)
        valid_patterns = []
        seen_patterns = []
        for insn in x86_insns:
            opcode_str = insn[0].split("/")[0]
            opcodes = insn[3]
            attr = insn[4].split()

            # filter ignore prefix pattern
            if "REX.W" in opcodes.split():
                continue
            if "VEX" in opcodes.split()[0].split("."):
                continue
            if "EVEX" in opcodes.split()[0].split("."):
                continue
            if "XOP" in opcodes.split()[0].split("."):
                continue

            # ex: "FF /2" -> ["FF10", "FF5011", ...]
            bytecodes = get_typical_bytecodes(opcodes)

            # check it is valid or not
            for hex_code in bytecodes:
                # dup check
                if hex_code in seen_patterns:
                    continue
                # disasm
                code = bytes.fromhex(hex_code)
                try:
                    asm = cs.disasm(code, 0).__next__()
                except:
                    continue
                opstr = asm.mnemonic + " " + asm.op_str
                # add
                valid_patterns.append([hex_code, opstr, opcodes, attr])
                seen_patterns.append(hex_code)
        return valid_patterns

    def do_invoke(self, argv):
        self.dont_repeat()

        try:
            less = which("less")
        except FileNotFoundError as e:
            err("{}".format(e))
            return

        arch_s, mode_s, big_endian = None, None, False
        nbyte = None
        filter_include = []
        filter_exclude = []
        try:
            opts, args = getopt.getopt(argv, "a:m:n:f:v:eh")
            for o, a in opts:
                if o == "-a":
                    arch_s = a.upper()
                if o == "-m":
                    mode_s = a.upper()
                if o == "-e":
                    big_endian = True
                if o == "-n":
                    nbyte = int(a)
                if o == "-f":
                    filter_include.append(a)
                if o == "-v":
                    filter_exclude.append(a)
                if o == "-h":
                    self.usage()
                    return
        except:
            self.usage()
            return

        if (arch_s, mode_s) == (None, None):
            if is_alive():
                if is_arm64():
                    arch_s, mode_s = current_arch.arch, 0
                else:
                    arch_s, mode_s = current_arch.arch, current_arch.mode
                endian_s = "big" if is_big_endian() else "little"
                arch, mode = get_capstone_arch(arch=arch_s, mode=mode_s, endian=is_big_endian())
            else:
                # if not alive, defaults to x86-64
                arch_s = "X86"
                mode_s = "64"
                endian_s = "little"
                arch, mode = get_capstone_arch(arch=arch_s, mode=mode_s, endian=False)
        elif not arch_s:
            err("An architecture (-a) must be provided")
            return
        elif not mode_s:
            err("A mode (-m) must be provided")
            return
        else:
            arch, mode = get_capstone_arch(arch=arch_s, mode=mode_s, endian=big_endian)
            endian_s = "big" if big_endian else "little"

        # list up bytecode pattern
        if arch_s == "X86":
            patterns = self.listup_x86(arch, mode)
        else:
            err("Unsupported")
            return

        # filter and print
        fmt = "{:22s} {:60s} {:22s} {}\n"
        legend = ["Hex code", "Assembly code", "Opcode", "Attributes"]
        text = Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading"))
        for hex_code, opstr, opcodes, attr in patterns:
            # byte length filter
            if nbyte is not None and nbyte * 2 != len(hex_code):
                continue

            # keyword filter
            line = "{:22s} {:60s} {:22s} {}".format(hex_code, opstr, opcodes, ','.join(attr))
            if any([f not in line for f in filter_include]):
                continue
            if any([f in line for f in filter_exclude]):
                continue

            # not filtered
            text += line + "\n"

        _, tmp_path = tempfile.mkstemp()
        open(tmp_path, "w").write(text.rstrip())
        os.system(f"{less} -R {tmp_path}")
        os.unlink(tmp_path)
        return


@register_command
class ProcessListingCommand(GenericCommand):
    """List and filter process. If a PATTERN is given as argument, results shown will be grepped
    by this pattern."""
    _cmdline_ = "process-search"
    _syntax_ = "{:s} [REGEX_PATTERN]".format(_cmdline_)
    _example_ = "{:s} gdb.*".format(_cmdline_)
    _category_ = "Misc"
    _aliases_ = ["ps",]

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        ps = which("ps")
        self.add_setting("ps_command", "{:s} auxww".format(ps), "`ps` command to get process information")
        return

    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        do_attach = False
        smart_scan = False

        try:
            opts, args = getopt.getopt(argv, "as")
            for o, _ in opts:
                if o == "-a":
                    do_attach = True
                if o == "-s":
                    smart_scan = True
        except:
            self.usage()
            return

        pattern = re.compile("^.*$") if not args else re.compile(args[0])

        for process in self.get_processes():
            pid = int(process["pid"])
            command = process["command"]
            process["user"] = process["user"].ljust(8)

            if not re.search(pattern, command):
                continue

            if smart_scan:
                if command.startswith("[") and command.endswith("]"): continue
                if command.startswith("socat "): continue
                if command.startswith("grep "): continue
                if command.startswith("gdb "): continue

            if args and do_attach:
                ok("Attaching to process='{:s}' pid={:d}".format(process["command"], pid))
                gdb.execute("attach {:d}".format(pid))
                return None

            line = [process[i] for i in ("pid", "user", "cpu", "mem", "tty", "command")]
            gef_print("\t".join(line))
        return None

    def get_processes(self):
        output = gef_execute_external(self.get_setting("ps_command").split(), True)
        names = [x.lower().replace("%", "") for x in output[0].split()]

        for line in output[1:]:
            fields = line.split()
            t = {}

            for i, name in enumerate(names):
                if i == len(names) - 1:
                    t[name] = " ".join(fields[i:])
                else:
                    t[name] = fields[i]
            yield t
        return


@register_command
class ElfInfoCommand(GenericCommand):
    """Display a limited subset of ELF header information. If no argument is provided, the command will
    show information about the current ELF being debugged."""
    _cmdline_ = "elf-info"
    _syntax_ = "{:s} [-h] [-r] [FILE|ADDRESS]".format(_cmdline_)
    _example_ =  "{:s}                # parse binary itself\n".format(_cmdline_)
    _example_ += "{:s} /bin/ls        # parse binary specified\n".format(_cmdline_)
    _example_ += "{:s} 0x555555554000 # parse memory\n".format(_cmdline_)
    _example_ += "{:s} -r /bin/ls     # show `readelf -a FILE | less`".format(_cmdline_)
    _category_ = "Process Information"

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        # http://www.sco.com/developers/gabi/latest/ch4.eheader.html
        classes = {
            Elf.ELF_32_BITS   : "32-bit",
            Elf.ELF_64_BITS   : "64-bit",
        }

        endianness = {
            Elf.LITTLE_ENDIAN : "Little-Endian",
            Elf.BIG_ENDIAN    : "Big-Endian",
        }

        osabi = {
            Elf.OSABI_SYSTEMV : "System V",
            Elf.OSABI_HPUX    : "HP-UX",
            Elf.OSABI_NETBSD  : "NetBSD",
            Elf.OSABI_LINUX   : "Linux",
            Elf.OSABI_SOLARIS : "Solaris",
            Elf.OSABI_AIX     : "AIX",
            Elf.OSABI_IRIX    : "IRIX",
            Elf.OSABI_FREEBSD : "FreeBSD",
            Elf.OSABI_OPENBSD : "OpenBSD",
        }

        types = {
            Elf.ET_RELOC      : "Relocatable",
            Elf.ET_EXEC       : "Executable",
            Elf.ET_DYN        : "Shared",
            Elf.ET_CORE       : "Core"
        }

        machines = {
            Elf.X86_64        : "x86-64",
            Elf.X86_32        : "x86",
            Elf.ARM           : "ARM",
            Elf.MIPS          : "MIPS",
            Elf.POWERPC       : "PowerPC",
            Elf.POWERPC64     : "PowerPC64",
            Elf.SPARC         : "SPARC",
            Elf.SPARC64       : "SPARC64",
            Elf.AARCH64       : "AArch64",
            Elf.RISCV         : "RISC-V",
            Elf.IA64          : "IA-64",
        }

        if "-h" in argv:
            self.usage()
            return

        use_readelf = False
        if "-r" in argv:
            argv.remove("-r")
            use_readelf = True

        if argv == []:
            if is_qemu_system():
                err("Argument-less calls are unsupported under qemu-system.")
                return

            filename = get_filepath()
            if filename is None:
                self.usage()
                return
            if use_readelf:
                os.system("readelf -a '{:s}' | less".format(filename))
                return
            elf = get_elf_headers(filename)

        else:
            filename = argv[0]
            if os.path.exists(filename):
                if use_readelf:
                    os.system("readelf -a '{:s}' | less".format(filename))
                    return
                elf = get_elf_headers(filename)
            elif use_readelf:
                self.usage()
                return
            else:
                try:
                    addr = int(argv[0], 0)
                    elf = Elf(addr)
                except:
                    self.usage()
                    return

        if elf is None or not elf.is_valid():
            return

        data = [
            ("Magic", "{0!s}".format(hexdump(struct.pack(">I", elf.e_magic), show_raw=True))),
            ("Class", "{0:#x} - {1}".format(elf.e_class, classes[elf.e_class])),
            ("Endianness", "{0:#x} - {1}".format(elf.e_endianness, endianness[elf.e_endianness])),
            ("ELF Version", "{:#x}".format(elf.e_version)),
            ("OS ABI", "{0:#x} - {1}".format(elf.e_osabi, osabi[elf.e_osabi])),
            ("ABI Version", "{:#x}".format(elf.e_abiversion)),
            ("Type", "{0:#x} - {1}".format(elf.e_type, types[elf.e_type])),
            ("Machine", "{0:#x} - {1}".format(elf.e_machine, machines[elf.e_machine])),
            ("Version", "{:#x}".format(elf.e_eiversion)),
            ("Entry point", "{}".format(format_address(elf.e_entry))),
            ("Program Header Table" , "{}".format(format_address(elf.e_phoff))),
            ("Program Header Entry Size" , "{0} ({0:#x})".format(elf.e_phentsize)),
            ("Number of Program Headers" , "{}".format(elf.e_phnum)),
            ("Section Header Table" , "{}".format(format_address(elf.e_shoff))),
            ("Section Header Entry Size" , "{0} ({0:#x})".format(elf.e_shentsize)),
            ("Number of Section Headers" , "{}".format(elf.e_shnum)),
            ("ELF Header Size" , "{0} ({0:#x})".format(elf.e_ehsize)),
            ("Section Header String Table Index" , "{}".format(elf.e_shstrndx)),
        ]

        gef_print(titlify("ELF Header"))
        for title, content in data:
            gef_print("{:<34s}: {}".format(title, content))

        ptype = {
            Phdr.PT_NULL:         "NULL",
            Phdr.PT_LOAD:         "LOAD",
            Phdr.PT_DYNAMIC:      "DYNAMIC",
            Phdr.PT_INTERP:       "INTERP",
            Phdr.PT_NOTE:         "NOTE",
            Phdr.PT_SHLIB:        "SHLIB",
            Phdr.PT_PHDR:         "PHDR",
            Phdr.PT_TLS:          "TLS",
            Phdr.PT_LOOS:         "LOOS",
            Phdr.PT_GNU_EH_FRAME: "GNU_EH_FLAME",
            Phdr.PT_GNU_STACK:    "GNU_STACK",
            Phdr.PT_GNU_RELRO:    "GNU_RELRO",
            Phdr.PT_LOSUNW:       "LOSUNW",
            Phdr.PT_SUNWBSS:      "SUNWBSS",
            Phdr.PT_SUNWSTACK:    "SUNWSTACK",
            Phdr.PT_HISUNW:       "HISUNW",
            Phdr.PT_HIOS:         "HIOS",
            Phdr.PT_LOPROC:       "LOPROC",
            Phdr.PT_HIPROC:       "HIPROC",
        }

        pflags = {
            0:                             "---",
            Phdr.PF_X:                     "--X",
            Phdr.PF_W:                     "-W-",
            Phdr.PF_R:                     "R--",
            Phdr.PF_W|Phdr.PF_X:           "-WX",
            Phdr.PF_R|Phdr.PF_X:           "R-X",
            Phdr.PF_R|Phdr.PF_W:           "RW-",
            Phdr.PF_R|Phdr.PF_W|Phdr.PF_X: "RWX",
        }

        gef_print(titlify("Program Header"))
        fmt = "  [{:>2s}] {:12s} {:>10s} {:>10s} {:>10s} {:>10s} {:>10s} {:5s} {:>8s}"
        legend = ["#", "Type", "Offset", "Virtaddr", "Physaddr", "FileSiz", "MemSiz", "Flags", "Align"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for i, p in enumerate(elf.phdrs):
            p_type = ptype[p.p_type] if p.p_type in ptype else "UNKNOWN"
            p_flags = pflags[p.p_flags] if p.p_flags in pflags else "???"
            fmt = "  [{:2d}] {:12s} {:#10x} {:#10x} {:#10x} {:#10x} {:#10x} {:5s} {:#8x}"
            gef_print(fmt.format(i, p_type, p.p_offset, p.p_vaddr, p.p_paddr, p.p_filesz, p.p_memsz, p_flags, p.p_align))

        stype = {
            Shdr.SHT_NULL:          "NULL",
            Shdr.SHT_PROGBITS:      "PROGBITS",
            Shdr.SHT_SYMTAB:        "SYMTAB",
            Shdr.SHT_STRTAB:        "STRTAB",
            Shdr.SHT_RELA:          "RELA",
            Shdr.SHT_HASH:          "HASH",
            Shdr.SHT_DYNAMIC:       "DYNAMIC",
            Shdr.SHT_NOTE:          "NOTE",
            Shdr.SHT_NOBITS:        "NOBITS",
            Shdr.SHT_REL:           "REL",
            Shdr.SHT_SHLIB:         "SHLIB",
            Shdr.SHT_DYNSYM:        "DYNSYM",
            Shdr.SHT_NUM:           "NUM",
            Shdr.SHT_INIT_ARRAY:    "INIT_ARRAY",
            Shdr.SHT_FINI_ARRAY:    "FINI_ARRAY",
            Shdr.SHT_PREINIT_ARRAY: "PREINIT_ARRAY",
            Shdr.SHT_GROUP:         "GROUP",
            Shdr.SHT_SYMTAB_SHNDX:  "SYMTAB_SHNDX",
            Shdr.SHT_NUM:           "NUM",
            Shdr.SHT_LOOS:          "LOOS",
            Shdr.SHT_GNU_ATTRIBUTES:"GNU_ATTRIBUTES",
            Shdr.SHT_GNU_HASH:      "GNU_HASH",
            Shdr.SHT_GNU_LIBLIST:   "GNU_LIBLIST",
            Shdr.SHT_CHECKSUM:      "CHECKSUM",
            Shdr.SHT_LOSUNW:        "LOSUNW",
            Shdr.SHT_SUNW_move:     "SUNW_move",
            Shdr.SHT_SUNW_COMDAT:   "SUNW_COMDAT",
            Shdr.SHT_SUNW_syminfo:  "SUNW_syminfo",
            Shdr.SHT_GNU_verdef:    "GNU_verdef",
            Shdr.SHT_GNU_verneed:   "GNU_verneed",
            Shdr.SHT_GNU_versym:    "GNU_versym",
            Shdr.SHT_HISUNW:        "HISUNW",
            Shdr.SHT_HIOS:          "HIOS",
            Shdr.SHT_LOPROC:        "LOPROC",
            Shdr.SHT_HIPROC:        "HIPROC",
            Shdr.SHT_LOUSER:        "LOUSER",
            Shdr.SHT_HIUSER:        "HIUSER",
        }

        gef_print(titlify("Section Header"))
        if not elf.shdrs:
            gef_print("Not loaded")
        else:
            fmt = "  [{:>2s}] {:20s} {:>15s} {:>10s} {:>10s} {:>10s} {:>10s} {:5s} {:4s} {:4s} {:>8s}"
            legend = ["#", "Name", "Type", "Address", "Offset", "Size", "EntSiz", "Flags", "Link", "Info", "Align"]
            gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
            for i, s in enumerate(elf.shdrs):
                sh_type = stype[s.sh_type] if s.sh_type in stype else "UNKNOWN"
                sh_flags = ""
                if s.sh_flags & Shdr.SHF_WRITE:            sh_flags += "W"
                if s.sh_flags & Shdr.SHF_ALLOC:            sh_flags += "A"
                if s.sh_flags & Shdr.SHF_EXECINSTR:        sh_flags += "X"
                if s.sh_flags & Shdr.SHF_MERGE:            sh_flags += "M"
                if s.sh_flags & Shdr.SHF_STRINGS:          sh_flags += "S"
                if s.sh_flags & Shdr.SHF_INFO_LINK:        sh_flags += "I"
                if s.sh_flags & Shdr.SHF_LINK_ORDER:       sh_flags += "L"
                if s.sh_flags & Shdr.SHF_OS_NONCONFORMING: sh_flags += "O"
                if s.sh_flags & Shdr.SHF_GROUP:            sh_flags += "G"
                if s.sh_flags & Shdr.SHF_TLS:              sh_flags += "T"
                if s.sh_flags & Shdr.SHF_EXCLUDE:          sh_flags += "E"
                if s.sh_flags & Shdr.SHF_COMPRESSED:       sh_flags += "C"

                fmt = "  [{:2d}] {:20s} {:>15s} {:#10x} {:#10x} {:#10x} {:#10x} {:5s} {:#4x} {:#4x} {:#8x}"
                gef_print(fmt.format(i, s.sh_name, sh_type, s.sh_addr, s.sh_offset, s.sh_size,
                                     s.sh_entsize, sh_flags, s.sh_link, s.sh_info, s.sh_addralign))
        return


@register_command
class DwarfExceptionHandlerInfoCommand(GenericCommand):
    """Dump the DWARF exception handler informations"""
    _cmdline_ = "dwarf-exception-handler"
    _syntax_ = "{:s} [-f FILENAME] [-x]".format(_cmdline_)
    _example_ = "{:s} # parse loaded binary\n".format(_cmdline_)
    _example_ += "{:s} -f /path/to/binary # parse specific binary\n".format(_cmdline_)
    _example_ += "{:s} -x # with hexdump\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "Simplified DWARF Exception structure:\n"
    _example_ += "\n"
    _example_ += "\n"
    _example_ += "[OLD IMPLEMENTATION]\n"
    _example_ += " libgcc_s.so bss area                  ELF Program Header (for .eh_frame_hdr)\n"
    _example_ += "+--------------------------+      +-->+----------------+\n"
    _example_ += "| ...                      |      |   | p_type         |\n"
    _example_ += "| frame_hdr_cache_head     |---+  |   | p_flags        |\n"
    _example_ += "+-frame_hdr_cache_entry----+ <-+  |   | p_offset       |\n"
    _example_ += "| pc_low                   |      |   | p_vaddr        |----+\n"
    _example_ += "| pc_high                  |      |   | p_paddr        |    |\n"
    _example_ += "| load_base                |      |   | p_filesz       |    |\n"
    _example_ += "| p_eh_frame_hdr           |------+   | p_memsz        |    |\n"
    _example_ += "| p_dynamic                |          | p_align        |    |             [NEW IMPLEMENTATION]\n"
    _example_ += "| link                     |---+      +----------------+    |              _dlfo_main@ld.so rodata area\n"
    _example_ += "+-frame_hdr_cache_entry----+ <-+                            |              _dlfo_nodelete_mappings@ld.so rodata area\n"
    _example_ += "| pc_low                   |                                |             +-------------+\n"
    _example_ += "| pc_high                  |                                |             | map_start   |\n"
    _example_ += "| load_base                |                                |             | map_end     |\n"
    _example_ += "| p_eh_frame_hdr           |                                |             | map         |\n"
    _example_ += "| p_dynamic                |                                |<------------| eh_frame    |\n"
    _example_ += "| link                     |                                |             | (eh_dbase)  |\n"
    _example_ += "+--------------------------+                                |             | (eh_count)  |\n"
    _example_ += "The frame_hdr_cache_head and frame_hdr_cache_entry are      |             +-------------+\n"
    _example_ += "initialized the first time they are called.                 |\n"
    _example_ += "                                                            |\n"
    _example_ += "                              +-----------------------------+\n"
    _example_ += "                              |\n"
    _example_ += ".eh_frame_hdr                 |      .eh_frame                                               .gcc_except_table          \n"
    _example_ += "+-------------------------+ <-+  +-> +-CIE---------------------+ <-+                     +-> +-LSDA--------------------+\n"
    _example_ += "| version                 |      |   | length                  |   |                     |   | lpstart_enc             |\n"
    _example_ += "| eh_frame_ptr_enc        |      |   | cie_id (=0)             |   |                     |   | ttype_enc               |\n"
    _example_ += "| fde_count_enc           |      |   | version                 |   |                     |   | ttype_off               |\n"
    _example_ += "| table_enc               |      |   | augmentation_string     |   |                     |   | call_site_encoding      |\n"
    _example_ += "| eh_frame_ptr            |------+   | code_alignment_factor   |   |                     |   | call_site_table_len     |\n"
    _example_ += "| fde_count               |          | data_alignment_factor   |   |                     |   |+-CallSite--------------+|\n"
    _example_ += "| Table[0] initial_loc    |          | return_address_register |   |                     |   || call_site_start       || try_start\n"
    _example_ += "| Table[0] fde            |---+      | augmentation_len        |   |                     |   || call_site_length      || try_end\n"
    _example_ += "| Table[1] initial_loc    |   |      | augmentation_data[0]    |   |                     |   || landing_pad           || catch_start\n"
    _example_ += "| Table[1] fde            |   |      | ...                     |---(augmentation=='P')-+ |   || action                ||---+\n"
    _example_ += "| ...                     |   |      | ...                     |   |                   | |   |+-CallSite--------------+|   |\n"
    _example_ += "| Table[N] initial_loc    |   |      | augmentation_data[N]    |   |                   | |   || ...                   ||   |\n"
    _example_ += "| Table[N] fde            |   |      | program                 |   |                   | |   |+-ActionTable-----------+| <-+\n"
    _example_ += "+-------------------------+   +----> +-FDE---------------------+   |                   | |   || ar_filter             ||---+\n"
    _example_ += "                                     | length                  |   |                   | |   || ar_disp               ||   |\n"
    _example_ += "                                     | cie_pointer (!=0)       |---+                   | |   |+-ActionTable-----------+|   |\n"
    _example_ += "                                     | pc_begin                | try_catch_base        | |   || ...                   ||   |\n"
    _example_ += "                                     | pc_range                |                       | |   |+-TTypeTable------------+|   |\n"
    _example_ += "                                     | augmentation_len        |                       | |   || ...(stored upwards)   ||   |\n"
    _example_ += "                                     | augmentation_data[0]    |                       | |   |+-TTypeTable------------+| <-+\n"
    _example_ += "                                     | ...                     |---(augmentation=='L')-|-+   || ttype                 ||---> type_info\n"
    _example_ += "                                     | augmentation_data[N]    |                       |     |+-----------------------+|\n"
    _example_ += "                                     | program                 |                       |     +-LSDA--------------------+\n"
    _example_ += "                                     +-CIE---------------------+       +---------------+     | ...                     |\n"
    _example_ += "                                     | ...                     |       |                     +-------------------------+\n"
    _example_ += "                                     +-FDE---------------------+       |\n"
    _example_ += "                                     | ...                     |       |\n"
    _example_ += "                                     +-------------------------+       |\n"
    _example_ += "                                                                       +----> personality_routine(=__gxx_personality_v0@libstdc++.so)"
    _category_ = "Process Information"

    # FDE data encoding
    DW_EH_PE_ptr = 0x00
    DW_EH_PE_uleb128 = 0x01
    DW_EH_PE_udata2 = 0x02
    DW_EH_PE_udata4 = 0x03
    DW_EH_PE_udata8 = 0x04
    DW_EH_PE_signed = 0x08
    DW_EH_PE_sleb128 = 0x09
    DW_EH_PE_sdata2 = 0x0a
    DW_EH_PE_sdata4 = 0x0b
    DW_EH_PE_sdata8 = 0x0c
    # FDE flags
    DW_EH_PE_absptr = 0x00
    DW_EH_PE_pcrel = 0x10
    DW_EH_PE_textrel = 0x20
    DW_EH_PE_datarel = 0x30
    DW_EH_PE_funcrel = 0x40
    DW_EH_PE_aligned = 0x50
    DW_EH_PE_indirect = 0x80
    DW_EH_PE_omit = 0xff

    def format_entry(self, sec, entries):
        out = []
        out.append(titlify(sec["name"]))

        # hexdump
        if self.hexdump:
            out.append(hexdump(sec["data"], show_symbol=False, base=sec["offset"]))

        # print details
        fmt = "[{:<8}|+{:<6}] {:<23s} {:<30s}: {:<18s}  |  {:s}"
        legend = ["FileOff", "Offset", "Raw bytes", "Name", "Value", "Extra Information"]
        out.append(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))

        for entry in entries:
            if len(entry) == 1:
                out.append("[!] "+ entry[0])

            elif len(entry) == 3: # separation
                pos, name, extra = entry
                if extra:
                    extra_s = "  |  {:s}".format(extra)
                else:
                    extra_s = ""
                out.append(titlify("[{:#06x}] {:4s}{:s}".format(pos, name, extra), color="red", msg_color="red"))

            elif len(entry) == 5: # data
                pos, raw_data, name, value, extra = entry

                pos_s = "[{:#08x}|+{:#06x}]".format(sec["offset"] + pos, pos)

                if raw_data is None:
                    raw_data_s = ""
                elif isinstance(raw_data, int):
                    raw_data_s = "{:02x}".format(raw_data)
                elif isinstance(raw_data, bytes):
                    raw_data_s = ' '.join(["{:02x}".format(x) for x in raw_data])
                else:
                    raise

                if isinstance(value, str):
                    value_s = value
                elif isinstance(value, int):
                    value_s = "{:#018x}".format(value)
                elif isinstance(value, list):
                    value_s = ' '.join(["{:#018x}".format(x) for x in value])

                if value is not None:
                    out.append("{:s} {:<23s} {:<30s}: {:<18s}  |  {:s}".format(pos_s, raw_data_s, name, value_s, extra))
                else:
                    out.append("{:s} {:<23s} {:<50s}  |  {:s}".format(pos_s, raw_data_s, name, extra))
        return out

    def get_uleb128(self, data, pos):
        acc = 0
        i = 0
        while True:
            if i == 10:
                return pos, 0xffffffffffffffff
            pos, b = self.read_1ubyte(data, pos)
            acc |= (b & 0x7f) << (i * 7)
            if (b & 0x80) == 0:
                return pos, acc
            i += 1

    def get_sleb128(self, data, pos):
        orig_pos = pos
        pos, acc = self.get_uleb128(data, pos)
        length = pos - orig_pos
        sleb_sign_mask = 1 << (length * 7 - 1)
        if (acc & sleb_sign_mask) == 0:
            return pos, acc
        else:
            sleb_value_mask = sleb_sign_mask - 1
            sleb_value = acc & sleb_value_mask
            bit_len = len("{:b}".format(sleb_value))
            real_sign_mask = 1 << bit_len
            real_value_mask = real_sign_mask - 1
            return pos, -1 * (((~sleb_value) & real_value_mask) + 1)

    def read_1ubyte(self, data, pos):
        acc = data[pos]
        return pos + 1, acc

    def read_1sbyte(self, data, pos):
        def pB(a): return struct.pack("<B",a&0xff)
        def ub(a): return struct.unpack("<b",a)[0]
        def u2i(a): return ub(pB(a))
        acc = data[pos]
        return pos + 1, u2i(acc)

    def read_2ubyte(self, data, pos):
        acc = (data[pos+1] << 8) | data[pos]
        return pos + 2, acc

    def read_2sbyte(self, data, pos):
        def pH(a): return struct.pack("<H",a&0xffff)
        def uh(a): return struct.unpack("<h",a)[0]
        def u2i(a): return uh(pH(a))
        acc = (data[pos+1] << 8) | data[pos]
        return pos + 2, u2i(acc)

    def read_4ubyte(self, data, pos):
        acc = (data[pos+3] << 24) | (data[pos+2] << 16) | (data[pos+1] << 8) | data[pos]
        return pos + 4, acc

    def read_4sbyte(self, data, pos):
        def pI(a): return struct.pack("<I",a&0xffffffff)
        def ui(a): return struct.unpack("<i",a)[0]
        def u2i(a): return ui(pI(a))
        acc = (data[pos+3] << 24) | (data[pos+2] << 16) | (data[pos+1] << 8) | data[pos]
        return pos + 4, u2i(acc)

    def read_8ubyte(self, data, pos):
        acc = (data[pos+7] << 56) | (data[pos+6] << 48) | (data[pos+5] << 40) | (data[pos+4] << 32)
        acc |= (data[pos+3] << 24) | (data[pos+2] << 16) | (data[pos+1] << 8) | data[pos]
        return pos + 8, acc

    def read_8sbyte(self, data, pos):
        def pQ(a): return struct.pack("<Q",a&0xffffffffffffffff)
        def uq(a): return struct.unpack("<q",a)[0]
        def u2i(a): return uq(pQ(a))
        acc = (data[pos+7] << 56) | (data[pos+6] << 48) | (data[pos+5] << 40) | (data[pos+4] << 32)
        acc |= (data[pos+3] << 24) | (data[pos+2] << 16) | (data[pos+1] << 8) | data[pos]
        return pos + 8, u2i(acc)

    def read_encoded(self, encoding, data, pos):
        if (encoding & 0xf) == self.DW_EH_PE_ptr:
            if self.elf.e_class == Elf.ELF_32_BITS:
                pos, res = self.read_4ubyte(data, pos)
            else:
                pos, res = self.read_8ubyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_uleb128:
            pos, res = self.get_uleb128(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_sleb128:
            pos, res = self.get_sleb128(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_udata2:
            pos, res = self.read_2ubyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_udata4:
            pos, res = self.read_4ubyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_udata8:
            pos, res = self.read_8ubyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_sdata2:
            pos, res = self.read_2sbyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_sdata4:
            pos, res = self.read_4sbyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_sdata8:
            pos, res = self.read_8sbyte(data, pos)
        else:
            raise
        return pos, res

    def get_encoding_str(self, fde_encoding):
        if fde_encoding == self.DW_EH_PE_omit:
            return "omit"
        s = []
        if (fde_encoding & 0xf) == self.DW_EH_PE_ptr:
            s.append("ptr")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_uleb128:
            s.append("uleb128")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_sleb128:
            s.append("sleb128")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_udata2:
            s.append("udata2")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_sdata2:
            s.append("sdata2")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_udata4:
            s.append("udata4")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_sdata4:
            s.append("sdata4")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_udata8:
            s.append("udata8")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_sdata8:
            s.append("sdata8")
        if (fde_encoding & 0x70) == self.DW_EH_PE_absptr:
            s.append("absptr")
        elif (fde_encoding & 0x70) == self.DW_EH_PE_pcrel:
            s.append("pcrel")
        elif (fde_encoding & 0x70) == self.DW_EH_PE_textrel:
            s.append("textrel")
        elif (fde_encoding & 0x70) == self.DW_EH_PE_datarel:
            s.append("datarel")
        elif (fde_encoding & 0x70) == self.DW_EH_PE_funcrel:
            s.append("funcrel")
        elif (fde_encoding & 0x70) == self.DW_EH_PE_aligned:
            s.append("aligned")
        if (fde_encoding & 0x80) == self.DW_EH_PE_indirect:
            s.append("indirect")
        return ','.join(s)

    def encoded_ptr_size(self, encoding, ptr_size):
        if (encoding & 0xf) == self.DW_EH_PE_ptr:
            return ptr_size
        elif (encoding & 0xf) in [self.DW_EH_PE_udata2, self.DW_EH_PE_sdata2]:
            return 2
        elif (encoding & 0xf) in [self.DW_EH_PE_udata4, self.DW_EH_PE_sdata4]:
            return 4
        elif (encoding & 0xf) in [self.DW_EH_PE_udata8, self.DW_EH_PE_sdata8]:
            return 8
        elif encoding == self.DW_EH_PE_omit:
            return 0
        err("Unsupported pointer encoding: {:#x}, assuming pointer size of {:d}.".format(encoding, ptr_size))
        return 0

    def parse_eh_frame_hdr(self, eh_frame_hdr):
        section_addr = eh_frame_hdr["offset"]
        data = eh_frame_hdr["data"]
        shdr = [s for s in self.elf.shdrs if s.sh_name == ".eh_frame_hdr"][0]
        load_base = [phdr for phdr in self.elf.phdrs if phdr.p_type == Phdr.PT_LOAD][0].p_vaddr

        entries = []
        pos = 0

        try:
            new_pos, version = self.read_1ubyte(data, pos)
            entries.append([pos, data[pos:new_pos], "version", version, ""])
            pos = new_pos

            new_pos, eh_frame_ptr_enc = self.read_1ubyte(data, pos)
            encoding_str = self.get_encoding_str(eh_frame_ptr_enc)
            entries.append([pos, data[pos:new_pos], "eh_frame_ptr_enc", eh_frame_ptr_enc, "encoding: {:s}".format(encoding_str)])
            pos = new_pos

            new_pos, fde_count_enc = self.read_1ubyte(data, pos)
            encoding_str = self.get_encoding_str(fde_count_enc)
            entries.append([pos, data[pos:new_pos], "fde_count_enc", fde_count_enc, "encoding: {:s}".format(encoding_str)])
            pos = new_pos

            new_pos, table_enc = self.read_1ubyte(data, pos)
            encoding_str = self.get_encoding_str(table_enc)
            entries.append([pos, data[pos:new_pos], "table_enc", table_enc, "encoding: {:s}".format(encoding_str)])
            pos = new_pos

            eh_frame_ptr = 0
            if eh_frame_ptr_enc != self.DW_EH_PE_omit:
                new_pos, eh_frame_ptr = self.read_encoded(eh_frame_ptr_enc, data, pos)
                if (eh_frame_ptr_enc & 0x70) == self.DW_EH_PE_pcrel:
                    elf_offset = shdr.sh_offset + 4 + eh_frame_ptr
                    if self.is_pie:
                        extra_s = "vma: $codebase+{:#x}".format(load_base + elf_offset)
                    else:
                        extra_s = "vma: {:#x}".format(load_base + elf_offset)
                    entries.append([pos, data[pos:new_pos], "eh_frame_ptr", elf_offset, extra_s])
                else:
                    entries.append([pos, data[pos:new_pos], "eh_frame_ptr", eh_frame_ptr, ""])
                pos = new_pos

            fde_count = 0
            if fde_count_enc != self.DW_EH_PE_omit:
                new_pos, fde_count = self.read_encoded(fde_count_enc, data, pos)
                entries.append([pos, data[pos:new_pos], "fde_count", fde_count, ""])
                pos = new_pos

            table_cnt = 0
            if table_enc == (self.DW_EH_PE_datarel | self.DW_EH_PE_sdata4):
                while fde_count and data[pos:]:
                    entries.append([pos, "Table[{:4d}]".format(table_cnt), ""])

                    new_pos, initial_loc = self.read_4sbyte(data, pos)
                    initial_offset = shdr.sh_offset + initial_loc
                    if self.is_pie:
                        extra_s = "vma: $codebase+{:#x}".format(load_base + initial_offset)
                    else:
                        extra_s = "vma: {:#x}".format(load_base + initial_offset)
                    entries.append([pos, data[pos:new_pos], "initial_loc", initial_offset, extra_s])
                    pos = new_pos

                    new_pos, fde_offset = self.read_4sbyte(data, pos)
                    fde_offset_adjusted = fde_offset - (eh_frame_ptr + 4)
                    if self.is_pie:
                        extra_s = "vma: $codebase+{:#x}".format(load_base + shdr.sh_offset + fde_offset)
                    else:
                        extra_s = "vma: {:#x}".format(load_base + shdr.sh_offset + fde_offset)
                    entries.append([pos, data[pos:new_pos], "fde", fde_offset_adjusted, extra_s])
                    pos = new_pos

                    table_cnt += 1
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            entries.append(["Parse Error\n{}".format(exc_value)])
        return entries

    def parse_eh_frame(self, eh_frame):
        section_addr = eh_frame["offset"]
        data = eh_frame["data"]
        shdr = [s for s in self.elf.shdrs if s.sh_name == ".eh_frame"][0]
        load_base = [phdr for phdr in self.elf.phdrs if phdr.p_type == Phdr.PT_LOAD][0].p_vaddr

        cies = []
        entries = []
        pos = 0

        try:
            while data[pos:]:
                offset = pos
                tmp_entries = []

                # parse length
                new_pos, unit_length = self.read_4ubyte(data, pos)
                length = 4 # default
                tmp_entries.append([pos, data[pos:new_pos], "length", unit_length, ""])
                pos = new_pos
                if unit_length == 0xffffffff:
                    new_pos, unit_length = self.read_8ubyte(data, pos)
                    length = 8
                    tmp_entries.append([pos, data[pos:new_pos], "extended_length", unit_length, ""])
                    pos = new_pos
                if unit_length == 0:
                    entries.append([offset, "Zero terminator", ""])
                    entries += tmp_entries
                    tmp_entries = []
                    continue

                ptr_size = 4 if self.elf.e_class == Elf.ELF_32_BITS else 8
                start = pos # use later
                cie_end = pos + unit_length

                # parse cie_id / cie_pointer
                if length == 4:
                    new_pos, cie_id = self.read_4ubyte(data, pos)
                else:
                    new_pos, cie_id = self.read_8ubyte(data, pos)
                if cie_id == 0:
                    tmp_entries.append([pos, data[pos:new_pos], "cie_id", cie_id, "type: CIE"])
                else:
                    extra_s = "type: FDE, Associated_CIE: {:#x}(={:#x}-{:#x})".format(start-cie_id, start, cie_id)
                    tmp_entries.append([pos, data[pos:new_pos], "cie_pointer", cie_id, extra_s])
                pos = new_pos

                version = 2
                fde_encoding = 0
                lsda_encoding = 0
                initial_location = 0
                vma_base = 0

                if cie_id == 0:  # CIE parsing
                    entries.append([offset, "CIE", ""])
                    entries += tmp_entries
                    tmp_entries = []

                    # parse version
                    new_pos, version = self.read_1ubyte(data, pos)
                    entries.append([pos, data[pos:new_pos], "version", version, ""])
                    pos = new_pos

                    # parse augmentation string
                    orig_pos = pos
                    augmentation = ""
                    while data[pos]:
                        augmentation += chr(data[pos])
                        pos += 1
                    pos += 1 # skip NUL
                    entries.append([orig_pos, data[orig_pos:pos], "augmentation_string", '"{:s}"'.format(augmentation), ""])

                    # parse ptr_size, segment_size
                    segment_size = 0
                    if version >= 4:
                        new_pos, ptr_size = self.raed_1ubyte(data, pos)
                        entries.append([pos, data[pos:new_pos], "ptr_size", ptr_size, ""])
                        pos = new_pos
                        new_pos, segment_size = self.read_1ubyte(data, pos)
                        entries.append([pos, data[pos:new_pos], "segment_size", segment_size, ""])
                        pos = new_pos

                    # parse code/data alignment factor
                    new_pos, code_alignment_factor = self.get_uleb128(data, pos)
                    entries.append([pos, data[pos:new_pos], "code_alignment_factor", code_alignment_factor, ""])
                    pos = new_pos
                    new_pos, data_alignment_factor = self.get_sleb128(data, pos)
                    entries.append([pos, data[pos:new_pos], "data_alignment_factor", data_alignment_factor, ""])
                    pos = new_pos

                    # parse augmentation data
                    if augmentation == "eh":
                        if self.elf.e_class == Elf.ELF_32_BITS:
                            new_pos, adjust = self.read_4ubyte(data, pos)
                        else:
                            new_pos, adjust = self.read_8ubyte(data, pos)
                        entries.append([pos, data[pos:new_pos], "eh_data", adjust, ""])
                        pos = new_pos

                    if version == 1:
                        new_pos, return_address_register = self.read_1ubyte(data, pos)
                        entries.append([pos, data[pos:new_pos], "return_address_register", return_address_register, ""])
                        pos = new_pos
                    else:
                        new_pos, return_address_register = self.get_uleb128(data, pos)
                        entries.append([pos, data[pos:new_pos], "return_address_register", return_address_register, ""])
                        pos = new_pos

                    if augmentation[0] == "z":
                        new_pos, augmentation_len = self.get_uleb128(data, pos)
                        entries.append([pos, data[pos:new_pos], "augmentation_len", augmentation_len, ""])
                        pos = new_pos

                        for cp in augmentation[1:]:
                            if cp == "R":
                                new_pos, fde_encoding = self.read_1ubyte(data, pos)
                                encoding_str = self.get_encoding_str(fde_encoding)
                                entries.append([pos, data[pos:new_pos], "augmentation_data(R)", fde_encoding, "FDE address encoding: {:s}".format(encoding_str)])
                                pos = new_pos
                            elif cp == "L":
                                new_pos, lsda_encoding = self.read_1ubyte(data, pos)
                                encoding_str = self.get_encoding_str(lsda_encoding)
                                entries.append([pos, data[pos:new_pos], "augmentation_data(L)", lsda_encoding, "LSDA pointer encoding: {:s}".format(encoding_str)])
                                pos = new_pos
                            elif cp == "P":
                                new_pos, p_encoding = self.read_1ubyte(data, pos)
                                encoding_str = self.get_encoding_str(p_encoding)
                                entries.append([pos, data[pos:new_pos], "augmentation_data(P)", p_encoding, "Personality pointer encoding: {:s}".format(encoding_str)])
                                pos = new_pos
                                new_pos, p_addr= self.read_encoded(p_encoding, data, pos)
                                if (p_encoding & 0x70) == self.DW_EH_PE_pcrel:
                                    p_addr += shdr.sh_offset + pos
                                    if self.is_pie:
                                        extra_s = "Personality pointer address: $codebase+{:#x}".format(load_base + p_addr)
                                    else:
                                        extra_s = "Personality pointer address: {:#x}".format(load_base + p_addr)
                                else:
                                    extra_s = "Personality pointer address"
                                entries.append([pos, data[pos:new_pos], "augmentation_data(P)", p_addr, extra_s])
                                pos = new_pos
                            else: # unknown
                                new_pos, x = self.read_1ubyte(data, pos)
                                entries.append([pos, data[pos:new_pos], "augmentation_data({:s})".format(cp), x, ""])
                                pos = new_pos
                    if ptr_size == 4 or ptr_size == 8:
                        cie = {}
                        cie["cie_offset"] = offset
                        cie["augmentation"] = augmentation
                        cie["fde_encoding"] = fde_encoding
                        cie["lsda_encoding"] = lsda_encoding
                        cie["address_size"] = ptr_size
                        cie["code_alignment_factor"] = code_alignment_factor
                        cie["data_alignment_factor"] = data_alignment_factor
                        cies.append(cie)

                else: # FDE parsing
                    cie = [x for x in cies if start - cie_id == x["cie_offset"]][0]

                    entries.append([offset, "FDE", ""])
                    entries += tmp_entries # unit_length, cie_pointer
                    tmp_entries = []

                    ptr_size = self.encoded_ptr_size(cie["fde_encoding"], cie["address_size"])
                    base = pos

                    # parse pc_begin
                    if ptr_size == 4:
                        new_pos, initial_location = self.read_4ubyte(data, pos)
                    elif ptr_size == 8:
                        new_pos, initial_location = self.read_8ubyte(data, pos)
                    if (cie["fde_encoding"] & 0x70) == self.DW_EH_PE_pcrel:
                        vma_base = shdr.sh_offset + base + initial_location
                        if ptr_size == 4:
                            vma_base &= 0xffffffff
                        elif ptr_size == 8:
                            vma_base &= 0xffffffffffffffff
                        if self.is_pie:
                            extra_s = "pc_begin vma: $codebase+{:#x}".format(load_base + vma_base)
                        else:
                            extra_s = "pc_begin vma: {:#x}".format(load_base + vma_base)
                        entries.append([pos, data[pos:new_pos], "pc_begin", vma_base, extra_s])
                    else:
                        entries.append([pos, data[pos:new_pos], "pc_begin", initial_location, ""])
                    pos = new_pos

                    # parse pc_range
                    if ptr_size == 4:
                        new_pos, pc_range = self.read_4ubyte(data, pos)
                    elif ptr_size == 8:
                        new_pos, pc_range = self.read_8ubyte(data, pos)
                    if (cie["fde_encoding"] & 0x70) == self.DW_EH_PE_pcrel:
                        end_off = vma_base + pc_range
                    else:
                        end_off = initial_location + pc_range
                    if ptr_size == 4:
                        end_off &= 0xffffffff
                    elif ptr_size == 8:
                        end_off &= 0xffffffffffffffff
                    if self.is_pie:
                        extra_s = "pc_end vma: $codebase+{:#x}".format(load_base + end_off)
                    else:
                        extra_s = "pc_end vma: {:#x}".format(load_base + end_off)
                    entries.append([pos, data[pos:new_pos], "pc_range", pc_range, extra_s])
                    pos = new_pos

                    # parse augmentation
                    if cie["augmentation"][0] == "z":
                        new_pos, augmentation_len = self.get_uleb128(data, pos)
                        entries.append([pos, data[pos:new_pos], "augmentation_len", augmentation_len, ""])
                        pos = new_pos

                        aug_end = pos + augmentation_len
                        if augmentation_len:
                            for cp in cie["augmentation"][1:]:
                                if cp == "L":
                                    new_pos, lsda_pointer = self.read_encoded(cie["lsda_encoding"], data, pos)
                                    if (cie["lsda_encoding"] & 0x70) == self.DW_EH_PE_pcrel:
                                        lsda_pointer += shdr.sh_offset + pos
                                        if self.is_pie:
                                            extra_s = "LSDA pointer vma: $codebase+{:#x}".format(load_base + lsda_pointer)
                                        else:
                                            extra_s = "LSDA pointer vma: {:#x}".format(load_base + lsda_pointer)
                                        entries.append([pos, data[pos:new_pos], "augmentation_data(L)", lsda_pointer, extra_s])
                                    else:
                                        entries.append([pos, data[pos:new_pos], "augmentation_data(L)", lsda_pointer, "LSDA pointer"])
                                    pos = new_pos
                            if pos < aug_end:
                                entries.append([pos, data[pos:aug_end], "?", "", ""])
                            pos = aug_end

                # common
                entries += self.parse_cfa_program(data, pos, cie_end, vma_base, version, cie)
                pos = cie_end
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            entries.append(["Parse Error\n{}".format(exc_value)])
        return entries

    DW_CFA_advance_loc = 0x40
    DW_CFA_offset = 0x80
    DW_CFA_restore = 0xc0
    DW_CFA_nop = 0x00
    DW_CFA_set_loc = 0x01
    DW_CFA_advance_loc1 = 0x02
    DW_CFA_advance_loc2 = 0x03
    DW_CFA_advance_loc4 = 0x04
    DW_CFA_offset_extended = 0x05
    DW_CFA_restore_extended = 0x06
    DW_CFA_undefined = 0x07
    DW_CFA_same_value = 0x08
    DW_CFA_register = 0x09
    DW_CFA_remember_state = 0x0a
    DW_CFA_restore_state = 0x0b
    DW_CFA_def_cfa = 0x0c
    DW_CFA_def_cfa_register = 0x0d
    DW_CFA_def_cfa_offset = 0x0e
    DW_CFA_def_cfa_expression = 0x0f
    DW_CFA_expression = 0x10
    DW_CFA_offset_extended_sf = 0x11
    DW_CFA_def_cfa_sf = 0x12
    DW_CFA_def_cfa_offset_sf = 0x13
    DW_CFA_val_offset = 0x14
    DW_CFA_val_offset_sf = 0x15
    DW_CFA_val_expression = 0x16
    DW_CFA_low_user = 0x1c
    DW_CFA_MIPS_advance_loc8 = 0x1d
    DW_CFA_GNU_window_save = 0x2d
    DW_CFA_AARCH64_negate_ra_state = 0x2d # dup
    DW_CFA_GNU_args_size = 0x2e
    DW_CFA_GNU_negative_offset_extended = 0x2f
    DW_CFA_high_user = 0x3f

    def get_register_name(self, reg):
        if self.elf.e_machine == Elf.X86_64:
            REG_LIST = [
                "rax", "rdx", "rcx", "rbx", "rsi", "rdi", "rbp", "rsp",
                "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
                "rip", "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6",
                "xmm7", "xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14",
                "xmm15", "st0", "st1", "st2", "st3", "st4", "st5", "st6", "st7",
                "mm0", "mm1", "mm2", "mm3", "mm4", "mm5", "mm6", "mm7",
                "rflags", "es", "cs", "ss", "ds", "fs", "gs", "???",
                "???", "fs.base", "gs.base", "???", "???", "tr", "ldtr", "mxcsr",
                "fcw", "fsw",
            ]
        elif self.elf.e_machine == Elf.X86_32:
            REG_LIST = [
                "eax", "ecx", "edx", "rbx", "esp", "ebp", "esi", "edi",
                "eip", "eflags", "trapno", "st0", "st1", "st2", "st3", "st4",
                "st5", "st6", "st7", "???", "???", "xmm0", "xmm1", "xmm2",
                "xmm3", "xmm4", "xmm5", "xmm6", "xmm7", "mm0", "mm1", "mm2",
                "mm3", "mm4", "mm5", "mm6", "mm7", "fctrl", "fstat", "mxcsr",
                "es", "cs", "ss", "ds", "fs", "gs",
            ]
        elif self.elf.e_machine == Elf.ARM:
            REG_LIST = [
                "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
                "r8", "r9", "r10", "r11", "r12", "sp", "lr", "pc",
                "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
            ] + ["???"]*40 + [
                "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7",
                "s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15",
                "s16", "s17", "s18", "s19", "s20", "s21", "s22", "s23",
                "s24", "s25", "s26", "s27", "s28", "s29", "s30", "s31",
                "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
                "wcgr0", "wcgr1", "wcgr2", "wcgr3", "wcgr4", "wcgr5", "wcgr6", "wcgr7",
                "wr0", "wr1", "wr2", "wr3", "wr4", "wr5", "wr6", "wr7",
                "wr8", "wr9", "wr10", "wr11", "wr12", "wr13", "wr14", "wr15",
                "spsr", "spsr_fiq", "spsr_irq", "spsr_abt", "spsr_und", "spsr_svc",
            ] + ["???"]*10 + [
                "r8_usr", "r9_usr", "r10_usr", "r11_usr", "r12_usr", "r13_usr", "r14_usr", "r8_fiq",
                "r9_fiq", "r10_fiq", "r11_fiq", "r12_fiq", "r13_fiq", "r14_fiq", "r13_irq", "r14_irq",
                "r13_abt", "r14_abt", "r13_und", "r14_und", "r13_svc", "r14_svc",
            ] + ["???"]*26 + [
                "wc0", "wc1", "wc2", "wc3", "wc4", "wc5", "wc6", "wc7",
            ]
        elif self.elf.e_machine == Elf.AARCH64:
            REG_LIST = [
                "x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7",
                "x8", "x9", "x10", "x11", "x12", "x13", "x14", "x15",
                "x16", "x17", "x18", "x19", "x20", "x21", "x22", "x23",
                "x24", "x25", "x26", "x27", "x28", "x29", "x30", "sp",
                "???", "elr",
            ] + ["???"]*30 + [
                "v0", "v1", "v2", "v3", "v4", "v5", "v6", "v7",
                "v8", "v9", "v10", "v11", "v12", "v13", "v14", "v15",
                "v16", "v17", "v18", "v19", "v20", "v21", "v22", "v23",
                "v24", "v25", "v26", "v27", "v28", "v29", "v30", "v31",
            ]
        else:
            # other arch is unimplemented
            return "r{:d}".format(reg)

        if reg < len(REG_LIST):
            return REG_LIST[reg]
        return "???"

    def parse_cfa_program(self, data, pos, pos_end, vma_base, version, cie):
        encoding = cie["fde_encoding"]
        ptr_size = cie["address_size"]
        code_align = cie["code_alignment_factor"]
        data_align = cie["data_alignment_factor"]
        pc = vma_base
        indent = " "*4

        entries = []
        entries.append([pos, b"", "program", None, ""])
        try:
            while pos < pos_end:
                new_pos, opcode = self.read_1ubyte(data, pos)

                if opcode < self.DW_CFA_advance_loc:
                    if opcode == self.DW_CFA_nop:
                        entries.append([pos, data[pos:new_pos], indent+"nop", None, ""])
                    elif opcode == self.DW_CFA_set_loc:
                        new_pos, op1 = self.read_encoded(encoding, data, new_pos)
                        pc = vma_base + op1
                        entries.append([pos, data[pos:new_pos], indent+"set_loc {:#x} to {:#x}".format(op1, pc), None, ""])
                    elif opcode == self.DW_CFA_advance_loc1:
                        op1 = data[new_pos]
                        new_pos += 1
                        pc += op1 * code_align
                        entries.append([pos, data[pos:new_pos], indent+"advance_loc1 {:#x} to {:#x}".format(op1, pc), None, ""])
                    elif opcode == self.DW_CFA_advance_loc2:
                        new_pos, op1 = self.read_2ubyte(data, new_pos)
                        pc += op1 * code_align
                        entries.append([pos, data[pos:new_pos], indent+"advance_loc2 {:#x} to {:#x}".format(op1, pc), None, ""])
                    elif opcode == self.DW_CFA_advance_loc4:
                        new_pos, op1 = self.read_4ubyte(data, new_pos)
                        pc += op1 * code_align
                        entries.append([pos, data[pos:new_pos], indent+"advance_loc4 {:#x} to {:#x}".format(op1, pc), None, ""])
                    elif opcode == self.DW_CFA_offset_extended:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent+"offset_extended r{:d} ({:s}) at cfa{:+#x}".format(op1, regname, ep2 * data_align), None, ""])
                    elif opcode == self.DW_CFA_restore_extended:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent+"restore_extended r{:d} ({:s})".fomart(op1, regname), None, ""])
                    elif opcode == self.DW_CFA_undefined:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent+"undefined r{:d} ({:s})".format(op1, regname), None, ""])
                    elif opcode == self.DW_CFA_same_value:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent+"same_value r{:d} ({:s})".format(op1, regname), None, ""])
                    elif opcode == self.DW_CFA_register:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname1 = self.get_register_name(op1)
                        regname2 = self.get_register_name(op2)
                        entries.append([pos, data[pos:new_pos], indent+"register r{:d} ({:s}) in r{:d} ({:s})".format(op1, op2, regname1, regname2), None, ""])
                    elif opcode == self.DW_CFA_remember_state:
                        entries.append([pos, data[pos:new_pos], indent+"remember_state", None, ""])
                    elif opcode == self.DW_CFA_restore_state:
                        entries.append([pos, data[pos:new_pos], indent+"restore_state", None, ""])
                    elif opcode == self.DW_CFA_def_cfa:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent+"def_cfa r{:d} ({:s}) at offset {:#x}".format(op1, regname, op2), None, ""])
                    elif opcode == self.DW_CFA_def_cfa_register:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent+"def_cfa_register r{:d} ({:s})".format(op1, regname), None, ""])
                    elif opcode == self.DW_CFA_def_cfa_offset:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        entries.append([pos, data[pos:new_pos], indent+"def_cfa_offset {:#x}".format(op1), None, ""])
                    elif opcode == self.DW_CFA_def_cfa_expression:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        entries.append([pos, data[pos:new_pos], indent+"def_cfa_expression {:#x}".format(op1), None, ""])
                        entries += self.parse_ops(version, ptr_size, op1, data, new_pos)
                        new_pos += op1
                    elif opcode == self.DW_CFA_expression:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent+"expression r{:d} ({:s})".format(op1, regname), None, ""])
                        entries += self.parse_ops(version, ptr_size, op2, data, new_pos)
                        new_pos += op2
                    elif opcode == self.DW_CFA_offset_extended_sf:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent+"offset_extended_sf r{:d} ({:s}) at cfa{:+#x}".format(op1, regname, op2 * data_align), None, ""])
                    elif opcode == self.DW_CFA_def_cfa_sf:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent+"def_cfa_sf r{:d} ({:s}) at offset {:#x}".format(op1, regname, op2 * data_align), None, ""])
                    elif opcode == self.DW_CFA_def_cfa_offset_sf:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        entries.append([pos, data[pos:new_pos], indent+"def_cfa_offset_sf {:#x}".format(op1 * data_align), None, ""])
                    elif opcode == self.DW_CFA_val_offset:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        entries.append([pos, data[pos:new_pos], indent+"val_offset {:#x} at offset {:#x}".format(op1, op2 * data_align), None, ""])
                    elif opcode == self.DW_CFA_val_offset_sf:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        entries.append([pos, data[pos:new_pos], indent+"val_offset_sf {:#x} at offset {:#x}".format(op1, op2 * data_align), None, ""])
                    elif opcode == self.DW_CFA_val_expression:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent+"val_expression r{:d} ({:s})".format(op1, regname), None, ""])
                        entries += self.parse_ops(version, ptr_size, op2, data, new_pos)
                        new_pos += op2
                    elif opcode == self.DW_CFA_MIPS_advance_loc8:
                        new_pos, op1 = self.read_8ubyte(data, new_pos)
                        pc += op1 * code_align
                        entries.append([pos, data[pos:new_pos], indent+"MIPS_advance_loc8 {:#x} to {:#x}".format(op1, pc), None, ""])
                    elif opcode == self.DW_CFA_GNU_window_save:
                        if self.elf.e_machine == Elf.AARCH64:
                            entries.append([pos, data[pos:new_pos], indent+"AARCH64_negate_ra_state", None, ""])
                        else:
                            entries.append([pos, data[pos:new_pos], indent+"GNU_window_save", None, ""])
                    elif opcode == self.DW_CFA_GNU_args_size:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        entries.append([pos, data[pos:new_pos], indent+"args_size {:#x}".format(op1), None, ""])
                    else:
                        entries.append([pos, data[pos:new_pos], indent+"??? {:#x}".format(opcode), None, ""])
                elif opcode < self.DW_CFA_offset:
                    op1 = opcode & 0x3f
                    pc += op1 * code_align
                    entries.append([pos, data[pos:new_pos], indent+"advance_loc {:d} to {:#x}".format(op1, pc), None, ""])
                elif opcode < self.DW_CFA_restore:
                    op1 = opcode & 0x3f
                    new_pos, op2 = self.get_uleb128(data, new_pos)
                    regname = self.get_register_name(op1)
                    entries.append([pos, data[pos:new_pos], indent+"offset r{:d} ({:s}) at cfa{:+#x}".format(op1, regname, op2 * data_align), None, ""])
                else:
                    op1 = opcode & 0x3f
                    regname = self.get_register_name(op1)
                    entries.append([pos, data[pos:new_pos], indent+"restore r{:d}".format(op1), None, ""])
                pos = new_pos
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            entries.append(["Parse Error\n{}".format(exc_value)])
        return entries

    DW_OP_addr = 0x03                 # Constant address
    DW_OP_deref = 0x06
    DW_OP_const1u = 0x08              # Unsigned 1-byte constant
    DW_OP_const1s = 0x09              # Signed 1-byte constant
    DW_OP_const2u = 0x0a              # Unsigned 2-byte constant
    DW_OP_const2s = 0x0b              # Signed 2-byte constant
    DW_OP_const4u = 0x0c              # Unsigned 4-byte constant
    DW_OP_const4s = 0x0d              # Signed 4-byte constant
    DW_OP_const8u = 0x0e              # Unsigned 8-byte constant
    DW_OP_const8s = 0x0f              # Signed 8-byte constant
    DW_OP_constu = 0x10               # Unsigned LEB128 constant
    DW_OP_consts = 0x11               # Signed LEB128 constant
    DW_OP_dup = 0x12
    DW_OP_drop = 0x13
    DW_OP_over = 0x14
    DW_OP_pick = 0x15                 # 1-byte stack index
    DW_OP_swap = 0x16
    DW_OP_rot = 0x17
    DW_OP_xderef = 0x18
    DW_OP_abs = 0x19
    DW_OP_and = 0x1a
    DW_OP_div = 0x1b
    DW_OP_minus = 0x1c
    DW_OP_mod = 0x1d
    DW_OP_mul = 0x1e
    DW_OP_neg = 0x1f
    DW_OP_not = 0x20
    DW_OP_or = 0x21
    DW_OP_plus = 0x22
    DW_OP_plus_uconst = 0x23          # Unsigned LEB128 addend
    DW_OP_shl = 0x24
    DW_OP_shr = 0x25
    DW_OP_shra = 0x26
    DW_OP_xor = 0x27
    DW_OP_bra = 0x28                  # Signed 2-byte constant
    DW_OP_eq = 0x29
    DW_OP_ge = 0x2a
    DW_OP_gt = 0x2b
    DW_OP_le = 0x2c
    DW_OP_lt = 0x2d
    DW_OP_ne = 0x2e
    DW_OP_skip = 0x2f                 # Signed 2-byte constant
    DW_OP_lit0 = 0x30                 # Literal 0
    DW_OP_lit1 = 0x31                 # Literal 1
    DW_OP_lit2 = 0x32                 # Literal 2
    DW_OP_lit3 = 0x33                 # Literal 3
    DW_OP_lit4 = 0x34                 # Literal 4
    DW_OP_lit5 = 0x35                 # Literal 5
    DW_OP_lit6 = 0x36                 # Literal 6
    DW_OP_lit7 = 0x37                 # Literal 7
    DW_OP_lit8 = 0x38                 # Literal 8
    DW_OP_lit9 = 0x39                 # Literal 9
    DW_OP_lit10 = 0x3a                # Literal 10
    DW_OP_lit11 = 0x3b                # Literal 11
    DW_OP_lit12 = 0x3c                # Literal 12
    DW_OP_lit13 = 0x3d                # Literal 13
    DW_OP_lit14 = 0x3e                # Literal 14
    DW_OP_lit15 = 0x3f                # Literal 15
    DW_OP_lit16 = 0x40                # Literal 16
    DW_OP_lit17 = 0x41                # Literal 17
    DW_OP_lit18 = 0x42                # Literal 18
    DW_OP_lit19 = 0x43                # Literal 19
    DW_OP_lit20 = 0x44                # Literal 20
    DW_OP_lit21 = 0x45                # Literal 21
    DW_OP_lit22 = 0x46                # Literal 22
    DW_OP_lit23 = 0x47                # Literal 23
    DW_OP_lit24 = 0x48                # Literal 24
    DW_OP_lit25 = 0x49                # Literal 25
    DW_OP_lit26 = 0x4a                # Literal 26
    DW_OP_lit27 = 0x4b                # Literal 27
    DW_OP_lit28 = 0x4c                # Literal 28
    DW_OP_lit29 = 0x4d                # Literal 29
    DW_OP_lit30 = 0x4e                # Literal 30
    DW_OP_lit31 = 0x4f                # Literal 31
    DW_OP_reg0 = 0x50                 # Register 0
    DW_OP_reg1 = 0x51                 # Register 1
    DW_OP_reg2 = 0x52                 # Register 2
    DW_OP_reg3 = 0x53                 # Register 3
    DW_OP_reg4 = 0x54                 # Register 4
    DW_OP_reg5 = 0x55                 # Register 5
    DW_OP_reg6 = 0x56                 # Register 6
    DW_OP_reg7 = 0x57                 # Register 7
    DW_OP_reg8 = 0x58                 # Register 8
    DW_OP_reg9 = 0x59                 # Register 9
    DW_OP_reg10 = 0x5a                # Register 10
    DW_OP_reg11 = 0x5b                # Register 11
    DW_OP_reg12 = 0x5c                # Register 12
    DW_OP_reg13 = 0x5d                # Register 13
    DW_OP_reg14 = 0x5e                # Register 14
    DW_OP_reg15 = 0x5f                # Register 15
    DW_OP_reg16 = 0x60                # Register 16
    DW_OP_reg17 = 0x61                # Register 17
    DW_OP_reg18 = 0x62                # Register 18
    DW_OP_reg19 = 0x63                # Register 19
    DW_OP_reg20 = 0x64                # Register 20
    DW_OP_reg21 = 0x65                # Register 21
    DW_OP_reg22 = 0x66                # Register 22
    DW_OP_reg23 = 0x67                # Register 24
    DW_OP_reg24 = 0x68                # Register 24
    DW_OP_reg25 = 0x69                # Register 25
    DW_OP_reg26 = 0x6a                # Register 26
    DW_OP_reg27 = 0x6b                # Register 27
    DW_OP_reg28 = 0x6c                # Register 28
    DW_OP_reg29 = 0x6d                # Register 29
    DW_OP_reg30 = 0x6e                # Register 30
    DW_OP_reg31 = 0x6f                # Register 31
    DW_OP_breg0 = 0x70                # Base register 0
    DW_OP_breg1 = 0x71                # Base register 1
    DW_OP_breg2 = 0x72                # Base register 2
    DW_OP_breg3 = 0x73                # Base register 3
    DW_OP_breg4 = 0x74                # Base register 4
    DW_OP_breg5 = 0x75                # Base register 5
    DW_OP_breg6 = 0x76                # Base register 6
    DW_OP_breg7 = 0x77                # Base register 7
    DW_OP_breg8 = 0x78                # Base register 8
    DW_OP_breg9 = 0x79                # Base register 9
    DW_OP_breg10 = 0x7a               # Base register 10
    DW_OP_breg11 = 0x7b               # Base register 11
    DW_OP_breg12 = 0x7c               # Base register 12
    DW_OP_breg13 = 0x7d               # Base register 13
    DW_OP_breg14 = 0x7e               # Base register 14
    DW_OP_breg15 = 0x7f               # Base register 15
    DW_OP_breg16 = 0x80               # Base register 16
    DW_OP_breg17 = 0x81               # Base register 17
    DW_OP_breg18 = 0x82               # Base register 18
    DW_OP_breg19 = 0x83               # Base register 19
    DW_OP_breg20 = 0x84               # Base register 20
    DW_OP_breg21 = 0x85               # Base register 21
    DW_OP_breg22 = 0x86               # Base register 22
    DW_OP_breg23 = 0x87               # Base register 23
    DW_OP_breg24 = 0x88               # Base register 24
    DW_OP_breg25 = 0x89               # Base register 25
    DW_OP_breg26 = 0x8a               # Base register 26
    DW_OP_breg27 = 0x8b               # Base register 27
    DW_OP_breg28 = 0x8c               # Base register 28
    DW_OP_breg29 = 0x8d               # Base register 29
    DW_OP_breg30 = 0x8e               # Base register 30
    DW_OP_breg31 = 0x8f               # Base register 31
    DW_OP_regx = 0x90                 # Unsigned LEB128 register
    DW_OP_fbreg = 0x91                # Signed LEB128 offset
    DW_OP_bregx = 0x92                # ULEB128 register followed by SLEB128 off
    DW_OP_piece = 0x93                # ULEB128 size of piece addressed
    DW_OP_deref_size = 0x94           # 1-byte size of data retrieved
    DW_OP_xderef_size = 0x95          # 1-byte size of data retrieved
    DW_OP_nop = 0x96
    DW_OP_push_object_address = 0x97
    DW_OP_call2 = 0x98
    DW_OP_call4 = 0x99
    DW_OP_call_ref = 0x9a
    DW_OP_form_tls_address = 0x9b     # TLS offset to address in current thread
    DW_OP_call_frame_cfa = 0x9c       # CFA as determined by CFI
    DW_OP_bit_piece = 0x9d            # ULEB128 size and ULEB128 offset in bits
    DW_OP_implicit_value = 0x9e       # DW_FORM_block follows opcode
    DW_OP_stack_value = 0x9f          # No operands, special like DW_OP_piece
    #
    DW_OP_implicit_pointer = 0xa0
    DW_OP_addrx = 0xa1
    DW_OP_constx = 0xa2
    DW_OP_entry_value = 0xa3
    DW_OP_const_type = 0xa4
    DW_OP_regval_type = 0xa5
    DW_OP_deref_type = 0xa6
    DW_OP_xderef_type = 0xa7
    DW_OP_convert = 0xa8
    DW_OP_reinterpret = 0xa9
    # GNU extensions
    DW_OP_GNU_push_tls_address = 0xe0
    DW_OP_GNU_uninit = 0xf0
    DW_OP_GNU_encoded_addr = 0xf1
    DW_OP_GNU_implicit_pointer = 0xf2
    DW_OP_GNU_entry_value = 0xf3
    DW_OP_GNU_const_type = 0xf4
    DW_OP_GNU_regval_type = 0xf5
    DW_OP_GNU_deref_type = 0xf6
    DW_OP_GNU_convert = 0xf7
    DW_OP_GNU_reinterpret = 0xf9
    DW_OP_GNU_parameter_ref = 0xfa
    # GNU Debug Fission extensions
    DW_OP_GNU_addr_index = 0xfb
    DW_OP_GNU_const_index = 0xfc
    DW_OP_GNU_variable_value = 0xfd
    DW_OP_lo_user = 0xe0              # Implementation-defined range start
    DW_OP_hi_user = 0xff              # Implementation-defined range end

    def dwarf_locexpr_opcode_string(self, code):
        DWARF_ONE_KNOWN_DW_OP = {
            self.DW_OP_GNU_addr_index: "GNU_addr_index",
            self.DW_OP_GNU_const_index: "GNU_const_index",
            self.DW_OP_GNU_const_type: "GNU_const_type",
            self.DW_OP_GNU_convert: "GNU_convert",
            self.DW_OP_GNU_deref_type: "GNU_deref_type",
            self.DW_OP_GNU_encoded_addr: "GNU_encoded_addr",
            self.DW_OP_GNU_entry_value: "GNU_entry_value",
            self.DW_OP_GNU_implicit_pointer: "GNU_implicit_pointer",
            self.DW_OP_GNU_parameter_ref: "GNU_parameter_ref",
            self.DW_OP_GNU_push_tls_address: "GNU_push_tls_address",
            self.DW_OP_GNU_regval_type: "GNU_regval_type",
            self.DW_OP_GNU_reinterpret: "GNU_reinterpret",
            self.DW_OP_GNU_uninit: "GNU_uninit",
            self.DW_OP_GNU_variable_value: "GNU_variable_value",
            self.DW_OP_abs: "abs",
            self.DW_OP_addr: "addr",
            self.DW_OP_addrx: "addrx",
            self.DW_OP_and: "and",
            self.DW_OP_bit_piece: "bit_piece",
            self.DW_OP_bra: "bra",
            self.DW_OP_breg0: "breg0",
            self.DW_OP_breg1: "breg1",
            self.DW_OP_breg2: "breg2",
            self.DW_OP_breg3: "breg3",
            self.DW_OP_breg4: "breg4",
            self.DW_OP_breg5: "breg5",
            self.DW_OP_breg6: "breg6",
            self.DW_OP_breg7: "breg7",
            self.DW_OP_breg8: "breg8",
            self.DW_OP_breg9: "breg9",
            self.DW_OP_breg10: "breg10",
            self.DW_OP_breg11: "breg11",
            self.DW_OP_breg12: "breg12",
            self.DW_OP_breg13: "breg13",
            self.DW_OP_breg14: "breg14",
            self.DW_OP_breg15: "breg15",
            self.DW_OP_breg16: "breg16",
            self.DW_OP_breg17: "breg17",
            self.DW_OP_breg18: "breg18",
            self.DW_OP_breg19: "breg19",
            self.DW_OP_breg20: "breg20",
            self.DW_OP_breg21: "breg21",
            self.DW_OP_breg22: "breg22",
            self.DW_OP_breg23: "breg23",
            self.DW_OP_breg24: "breg24",
            self.DW_OP_breg25: "breg25",
            self.DW_OP_breg26: "breg26",
            self.DW_OP_breg27: "breg27",
            self.DW_OP_breg28: "breg28",
            self.DW_OP_breg29: "breg29",
            self.DW_OP_breg30: "breg30",
            self.DW_OP_breg31: "breg31",
            self.DW_OP_bregx: "bregx",
            self.DW_OP_call2: "call2",
            self.DW_OP_call4: "call4",
            self.DW_OP_call_frame_cfa: "call_frame_cfa",
            self.DW_OP_call_ref: "call_ref",
            self.DW_OP_const1s: "const1s",
            self.DW_OP_const1u: "const1u",
            self.DW_OP_const2s: "const2s",
            self.DW_OP_const2u: "const2u",
            self.DW_OP_const4s: "const4s",
            self.DW_OP_const4u: "const4u",
            self.DW_OP_const8s: "const8s",
            self.DW_OP_const8u: "const8u",
            self.DW_OP_const_type: "const_type",
            self.DW_OP_consts: "consts",
            self.DW_OP_constu: "constu",
            self.DW_OP_constx: "constx",
            self.DW_OP_convert: "convert",
            self.DW_OP_deref: "deref",
            self.DW_OP_deref_size: "deref_size",
            self.DW_OP_deref_type: "deref_type",
            self.DW_OP_div: "div",
            self.DW_OP_drop: "drop",
            self.DW_OP_dup: "dup",
            self.DW_OP_entry_value: "entry_value",
            self.DW_OP_eq: "eq",
            self.DW_OP_fbreg: "fbreg",
            self.DW_OP_form_tls_address: "form_tls_address",
            self.DW_OP_ge: "ge",
            self.DW_OP_gt: "gt",
            self.DW_OP_implicit_pointer: "implicit_pointer",
            self.DW_OP_implicit_value: "implicit_value",
            self.DW_OP_le: "le",
            self.DW_OP_lit0: "lit0",
            self.DW_OP_lit1: "lit1",
            self.DW_OP_lit2: "lit2",
            self.DW_OP_lit3: "lit3",
            self.DW_OP_lit4: "lit4",
            self.DW_OP_lit5: "lit5",
            self.DW_OP_lit6: "lit6",
            self.DW_OP_lit7: "lit7",
            self.DW_OP_lit8: "lit8",
            self.DW_OP_lit9: "lit9",
            self.DW_OP_lit10: "lit10",
            self.DW_OP_lit11: "lit11",
            self.DW_OP_lit12: "lit12",
            self.DW_OP_lit13: "lit13",
            self.DW_OP_lit14: "lit14",
            self.DW_OP_lit15: "lit15",
            self.DW_OP_lit16: "lit16",
            self.DW_OP_lit17: "lit17",
            self.DW_OP_lit18: "lit18",
            self.DW_OP_lit19: "lit19",
            self.DW_OP_lit20: "lit20",
            self.DW_OP_lit21: "lit21",
            self.DW_OP_lit22: "lit22",
            self.DW_OP_lit23: "lit23",
            self.DW_OP_lit24: "lit24",
            self.DW_OP_lit25: "lit25",
            self.DW_OP_lit26: "lit26",
            self.DW_OP_lit27: "lit27",
            self.DW_OP_lit28: "lit28",
            self.DW_OP_lit29: "lit29",
            self.DW_OP_lit30: "lit30",
            self.DW_OP_lit31: "lit31",
            self.DW_OP_lt: "lt",
            self.DW_OP_minus: "minus",
            self.DW_OP_mod: "mod",
            self.DW_OP_mul: "mul",
            self.DW_OP_ne: "ne",
            self.DW_OP_neg: "neg",
            self.DW_OP_nop: "nop",
            self.DW_OP_not: "not",
            self.DW_OP_or: "or",
            self.DW_OP_over: "over",
            self.DW_OP_pick: "pick",
            self.DW_OP_piece: "piece",
            self.DW_OP_plus: "plus",
            self.DW_OP_plus_uconst: "plus_uconst",
            self.DW_OP_push_object_address: "push_object_address",
            self.DW_OP_reg0: "reg0",
            self.DW_OP_reg1: "reg1",
            self.DW_OP_reg2: "reg2",
            self.DW_OP_reg3: "reg3",
            self.DW_OP_reg4: "reg4",
            self.DW_OP_reg5: "reg5",
            self.DW_OP_reg6: "reg6",
            self.DW_OP_reg7: "reg7",
            self.DW_OP_reg8: "reg8",
            self.DW_OP_reg9: "reg9",
            self.DW_OP_reg10: "reg10",
            self.DW_OP_reg11: "reg11",
            self.DW_OP_reg12: "reg12",
            self.DW_OP_reg13: "reg13",
            self.DW_OP_reg14: "reg14",
            self.DW_OP_reg15: "reg15",
            self.DW_OP_reg16: "reg16",
            self.DW_OP_reg17: "reg17",
            self.DW_OP_reg18: "reg18",
            self.DW_OP_reg19: "reg19",
            self.DW_OP_reg20: "reg20",
            self.DW_OP_reg21: "reg21",
            self.DW_OP_reg22: "reg22",
            self.DW_OP_reg23: "reg23",
            self.DW_OP_reg24: "reg24",
            self.DW_OP_reg25: "reg25",
            self.DW_OP_reg26: "reg26",
            self.DW_OP_reg27: "reg27",
            self.DW_OP_reg28: "reg28",
            self.DW_OP_reg29: "reg29",
            self.DW_OP_reg30: "reg30",
            self.DW_OP_reg31: "reg31",
            self.DW_OP_regval_type: "regval_type",
            self.DW_OP_regx: "regx",
            self.DW_OP_reinterpret: "reinterpret",
            self.DW_OP_rot: "rot",
            self.DW_OP_shl: "shl",
            self.DW_OP_shr: "shr",
            self.DW_OP_shra: "shra",
            self.DW_OP_skip: "skip",
            self.DW_OP_stack_value: "stack_value",
            self.DW_OP_swap: "swap",
            self.DW_OP_xderef: "xderef",
            self.DW_OP_xderef_size: "xderef_size",
            self.DW_OP_xderef_type: "xderef_type",
            self.DW_OP_xor: "xor",
        }
        if code in DWARF_ONE_KNOWN_DW_OP:
            return DWARF_ONE_KNOWN_DW_OP[code]
        elif code >= self.DW_OP_lo_user:
            return "lo_user+{:#x}".format(code - self.DW_OP_lo_user)
        else:
            return "??? ({:#x})".format(code)

    def parse_ops(self, vers, addrsize, length, data, pos, indent_n=0):
        indent = " " * ((indent_n + 2)*4)
        entries = []
        ref_size = addrsize if vers < 3 else 0

        if length == 0:
            entries.append([pos, b"", indent+"(empty)", None, ""])
            return entries

        offset = 0
        try:
            while length:
                new_pos, op = self.read_1ubyte(data, pos)
                op_name = self.dwarf_locexpr_opcode_string(op)

                if op in [self.DW_OP_addr]:
                    if addrsize == 4:
                        new_pos, d = self.read_4ubyte(data, new_pos)
                    elif addrsize == 8:
                        new_pos, d = self.read_8ubyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_call_ref, self.DW_OP_GNU_variable_value]:
                    if ref_size == 4:
                        new_pos, d = self.read_4ubyte(data, new_pos)
                    else:
                        new_pos, d = self.read_8ubyte(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_deref]:
                    extra_s = "pop; push *({:s}*)popped_value".format({4:"uint",8:"ulong"}[addrsize])
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_xderef]:
                    extra_s = "pop; pop; push *({:s}*)(popped_value2_as_segment:popped_value1)".format({4:"uint",8:"ulong"}[addrsize])
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_deref_size]:
                    new_pos, d = self.read_1ubyte(data, new_pos)
                    extra_s = "pop; push *({:s}*)popped_value".format({1:"uchar",2:"ushort",4:"uint",8:"ulong"}[d])
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_xderef_size]:
                    new_pos, d = self.read_1ubyte(data, new_pos)
                    extra_s = "pop; pop; push *({:s}*)(popped_value2_as_segment:popped_value1)".format({1:"uchar",2:"ushort",4:"uint",8:"ulong"}[d])
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_pick]:
                    new_pos, d = self.read_1ubyte(data, new_pos)
                    extra_s = "push stack[{:d}]".format(d)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const1u]:
                    new_pos, d = self.read_1ubyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const2u]:
                    new_pos, d = self.read_2ubyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const4u]:
                    new_pos, d = self.read_4ubyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const8u]:
                    new_pos, d = self.read_8ubyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const1s]:
                    new_pos, d = self.read_1sbyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const2u]:
                    new_pos, d = self.read_2sbyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const4s]:
                    new_pos, d = self.read_4sbyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const8s]:
                    new_pos, d = self.read_8sbyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_piece, self.DW_OP_regx, self.DW_OP_plus_uconst]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_constu]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_consts]:
                    new_pos, d = self.get_sleb128(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_addrx, self.DW_OP_GNU_addr_index, self.DW_OP_constx, self.DW_OP_GNU_const_index]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_bit_piece]:
                    new_pos, d1 = self.get_uleb128(data, new_pos)
                    new_pos, d2 = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x},{:#x}".format(offset, op_name, d1, d2), None, ""])
                elif op in [self.DW_OP_lit0, self.DW_OP_lit1, self.DW_OP_lit2, self.DW_OP_lit3, self.DW_OP_lit4,
                            self.DW_OP_lit5, self.DW_OP_lit6, self.DW_OP_lit7, self.DW_OP_lit8, self.DW_OP_lit9,
                            self.DW_OP_lit10, self.DW_OP_lit11, self.DW_OP_lit12, self.DW_OP_lit13, self.DW_OP_lit14,
                            self.DW_OP_lit15, self.DW_OP_lit16, self.DW_OP_lit17, self.DW_OP_lit18, self.DW_OP_lit19,
                            self.DW_OP_lit20, self.DW_OP_lit21, self.DW_OP_lit22, self.DW_OP_lit23, self.DW_OP_lit24,
                            self.DW_OP_lit25, self.DW_OP_lit26, self.DW_OP_lit27, self.DW_OP_lit28, self.DW_OP_lit29,
                            self.DW_OP_lit30, self.DW_OP_lit31]:
                    extra_s = "push {:#x}".format(op - 0x30)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_reg0, self.DW_OP_reg1, self.DW_OP_reg2, self.DW_OP_reg3, self.DW_OP_reg4,
                            self.DW_OP_reg5, self.DW_OP_reg6, self.DW_OP_reg7, self.DW_OP_reg8, self.DW_OP_reg9,
                            self.DW_OP_reg10, self.DW_OP_reg11, self.DW_OP_reg12, self.DW_OP_reg13, self.DW_OP_reg14,
                            self.DW_OP_reg15, self.DW_OP_reg16, self.DW_OP_reg17, self.DW_OP_reg18, self.DW_OP_reg19,
                            self.DW_OP_reg20, self.DW_OP_reg21, self.DW_OP_reg22, self.DW_OP_reg23, self.DW_OP_reg24,
                            self.DW_OP_reg25, self.DW_OP_reg26, self.DW_OP_reg27, self.DW_OP_reg28, self.DW_OP_reg29,
                            self.DW_OP_reg30, self.DW_OP_reg31]:
                    regname = self.get_register_name(op - 0x50)
                    extra_s = "push {:s}".format(regname)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_breg0, self.DW_OP_breg1, self.DW_OP_breg2, self.DW_OP_breg3, self.DW_OP_breg4,
                            self.DW_OP_breg5, self.DW_OP_breg6, self.DW_OP_breg7, self.DW_OP_breg8, self.DW_OP_breg9,
                            self.DW_OP_breg10, self.DW_OP_breg11, self.DW_OP_breg12, self.DW_OP_breg13, self.DW_OP_breg14,
                            self.DW_OP_breg15, self.DW_OP_breg16, self.DW_OP_breg17, self.DW_OP_breg18, self.DW_OP_breg19,
                            self.DW_OP_breg20, self.DW_OP_breg21, self.DW_OP_breg22, self.DW_OP_breg23, self.DW_OP_breg24,
                            self.DW_OP_breg25, self.DW_OP_breg26, self.DW_OP_breg27, self.DW_OP_breg28, self.DW_OP_breg29,
                            self.DW_OP_breg30, self.DW_OP_breg31]:
                    new_pos, d = self.get_sleb128(data, new_pos)
                    regname = self.get_register_name(op-0x70)
                    extra_s = "push {:s}{:+#x}".format(regname, d)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_fbreg]:
                    new_pos, d = self.get_sleb128(data, new_pos)
                    regname = "push frame_base{:*#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_bregx]:
                    new_pos, d1 = self.get_uleb128(data, new_pos)
                    new_pos, d2 = self.get_sleb128(data, new_pos)
                    regname = self.get_register_name(d1)
                    extra_s = "push {:s}{:+#x}".format(regname, d2)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x},{:#x}".format(offset, op_name, d1, d2), None, extra_s])
                elif op in [self.DW_OP_call2]:
                    new_pos, d = self.read_2ubyte(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_call4]:
                    new_pos, d = self.read_4ubyte(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_bra]:
                    new_pos, d = self.read_2sbyte(data, new_pos)
                    d += offset + 3
                    extra_s = "pop; jmp to [{:#x}] if popped_value != 0".format(d)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_skip]:
                    new_pos, d = self.read_2sbyte(data, new_pos)
                    d += offset + 3
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_implicit_value]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    block_s = ' '.join(["{:02x}".format(x) for x in data[new_pos:new_pos+d]])
                    new_pos += d
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:s}".format(offset, op_name, block_s), None, ""])
                elif op in [self.DW_OP_implicit_pointer, self.DW_OP_GNU_implicit_pointer]:
                    if ref_size == 4:
                        new_pos, d1 = self.read_4ubyte(data, new_pos)
                    elif ref_size == 8:
                        new_pos, d1 = self.read_8ubyte(data, new_pos)
                    new_pos, d2 = self.get_sleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} [{:#x}] {:+#x}".format(offset, op_name, d1, d2), None, ""])
                elif op in [self.DW_OP_entry_value, self.DW_OP_GNU_entry_value]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s}".format(offset, op_name), None, ""])
                    entries += self.parse_ops(vers, addrsize, d, data, new_pos, indent=indent+1)
                    new_pos += d
                elif op in [self.DW_OP_const_type, self.DW_OP_GNU_const_type]:
                    new_pos, d1 = self.get_uleb128(data, new_pos)
                    new_pos, d2 = self.read_1ubyte(data, new_pos)
                    block_s = ' '.join(["{:02x}".format(x) for x in data[new_pos:new_pos+d2]])
                    new_pos += d2
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} [{:#x}] {:s}".format(offset, op_name, d1, block_s), None, ""])
                elif op in [self.DW_OP_regval_type, self.DW_OP_GNU_regval_type]:
                    new_pos, d1 = self.get_uleb128(data, new_pos)
                    new_pos, d2 = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x} [{:#x}]".format(offset, op_name, d1, d2), None, ""])
                elif op in [self.DW_OP_deref_type, self.DW_OP_GNU_deref_type]:
                    new_pos, d1 = self.read_1ubyte(data, new_pos)
                    new_pos, d2 = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x} [{:#x}]".format(offset, op_name, d1, d2), None, ""])
                elif op in [self.DW_OP_xderef_type]:
                    new_pos, d1 = self.read_1ubyte(data, new_pos)
                    new_pos, d2 = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} {:#x} [{:#x}]".format(offset, op_name, d1, d2), None, ""])
                elif op in [self.DW_OP_convert, self.DW_OP_GNU_convert, self.DW_OP_reinterpret, self.DW_OP_GNU_reinterpret]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_GNU_parameter_ref]:
                    new_pos, d = self.read_4ubyte(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_drop]:
                    extra_s = "pop"
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_dup]:
                    extra_s = "push stack[0]"
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_over]:
                    extra_s = "push stack[1]"
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_swap]:
                    extra_s = "stack[0],stack[1] = stack[1],stack[0]"
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_rot]:
                    extra_s = "stack[0],stack[1],stack[2] = stack[1],stack[2],stack[0]"
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                else:
                    entries.append([pos, data[pos:new_pos], indent+"[{:#04x}] {:s}".format(offset, op_name), None, ""])
                length -= new_pos - pos
                offset += new_pos - pos
                pos = new_pos
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            entries.append(["Parse Error\n{}".format(exc_value)])
        return entries

    def parse_gcc_except_table(self, gcc_except_table, eh_frame_entries):
        def get_lsda_info(eh_frame_entries):
            dic = {}
            is_fde = False
            for entry in eh_frame_entries:
                if len(entry) != 5:
                    continue
                pos, raw_data, name, value, extra = entry
                if name == "cie_pointer":
                    is_fde = True
                    continue
                if name == "cie_id":
                    is_fde = False
                    continue
                if is_fde:
                    if name == "pc_begin":
                        pc_begin = value
                        continue
                    if name != "augmentation_data(L)":
                        continue
                    dic[value - load_base] = pc_begin + load_base
            return dic

        section_base = gcc_except_table["offset"]
        data = gcc_except_table["data"]
        shdr = [s for s in self.elf.shdrs if s.sh_name == ".gcc_except_table"][0]
        load_base = [phdr for phdr in self.elf.phdrs if phdr.p_type == Phdr.PT_LOAD][0].p_vaddr
        ptr_size = 4 if self.elf.e_class == Elf.ELF_32_BITS else 8
        lsda_pos_info = get_lsda_info(eh_frame_entries)

        entries = []
        pos = 0
        lsda_table_cnt = 0

        try:
            lsda_pos_padding = 0
            while data[pos:]:
                # search LSDA start address
                if (section_base + pos) not in lsda_pos_info:
                    lsda_pos_padding += 1
                    pos += 1
                    continue

                # Found
                if lsda_pos_padding:
                    entries.append([pos-lsda_pos_padding, "Padding", ""])
                    entries.append([pos-lsda_pos_padding, data[pos-lsda_pos_padding:pos], "padding", "", ""])
                    lsda_pos_padding = 0

                entries.append([pos, "LSDA Table[{:4d}]".format(lsda_table_cnt), ""])
                lpstart = lsda_pos_info[section_base + pos]

                # parse lpstart_encoding
                new_pos, lpstart_encoding = self.read_1ubyte(data, pos)
                encoding_str = self.get_encoding_str(lpstart_encoding)
                entries.append([pos, data[pos:new_pos], "landing_pad_start_encoding", lpstart_encoding, "encoding: {:s}".format(encoding_str)])
                pos = new_pos

                # parse lpstart
                if lpstart_encoding != self.DW_EH_PE_omit:
                    new_pos, lpstart = self.read_encoded(lpstart_encoding, data, pos) # overwrite lpstart
                    entries.append([pos, data[pos:new_pos], "landing_pad_start", lpstart, ""])
                    pos = new_pos

                # parse ttype_encoding
                new_pos, ttype_encoding = self.read_1ubyte(data, pos)
                encoding_str = self.get_encoding_str(ttype_encoding)
                entries.append([pos, data[pos:new_pos], "ttype_encoding", ttype_encoding, "encoding: {:s}".format(encoding_str)])
                pos = new_pos

                # parse ttype_base_offset
                ttype_base = None
                if ttype_encoding != self.DW_EH_PE_omit:
                    new_pos, ttype_base_offset = self.get_uleb128(data, pos)
                    ttype_base = new_pos + ttype_base_offset
                    entries.append([pos, data[pos:new_pos], "ttype_base_offset", ttype_base_offset, "ttype_base: {:#x}".format(ttype_base)])
                    pos = new_pos

                # parse call_site_encoding
                new_pos, call_site_encoding = self.read_1ubyte(data, pos)
                encoding_str = self.get_encoding_str(call_site_encoding)
                entries.append([pos, data[pos:new_pos], "call_site_encoding", call_site_encoding, "encoding: {:s}".format(encoding_str)])
                pos = new_pos

                # parse call_site_table_len
                new_pos, call_site_table_len = self.get_uleb128(data, pos)
                entries.append([pos, data[pos:new_pos], "call_site_table_len", call_site_table_len, ""])
                pos = new_pos

                # parse call_site_table
                action_table_pos = pos + call_site_table_len
                table_cnt = 0
                max_action = 0
                while pos < action_table_pos:
                    entries.append([pos, "Call site table[{:4d}]".format(table_cnt), ""])

                    new_pos, call_site_start = self.read_encoded(call_site_encoding, data, pos)
                    if self.is_pie:
                        extra_s = "try-start vma: $codebase+{:#x}".format(lpstart + call_site_start)
                    else:
                        extra_s = "try-start vma: {:#x}".format(lpstart + call_site_start)
                    entries.append([pos, data[pos:new_pos], "call_site_start", call_site_start, extra_s])
                    pos = new_pos

                    new_pos, call_site_length = self.read_encoded(call_site_encoding, data, pos)
                    if self.is_pie:
                        extra_s = "try-end vma: $codebase+{:#x}".format(lpstart + call_site_start + call_site_length)
                    else:
                        extra_s = "try-end vma: {:#x}".format(lpstart + call_site_start + call_site_length)
                    entries.append([pos, data[pos:new_pos], "call_site_length", call_site_length, extra_s])
                    pos = new_pos

                    new_pos, call_site_lpad = self.read_encoded(call_site_encoding, data, pos)
                    if call_site_lpad == 0:
                        extra_s = ""
                    elif self.is_pie:
                        extra_s = "catch vma: $codebase+{:#x}".format(lpstart + call_site_lpad)
                    else:
                        extra_s = "catch vma: {:#x}".format(lpstart + call_site_lpad)
                    entries.append([pos, data[pos:new_pos], "landing_pad", call_site_lpad, extra_s])
                    pos = new_pos

                    new_pos, action = self.get_uleb128(data, pos)
                    max_action = max(action, max_action)
                    if action == 0:
                        extra_s = "no action"
                    else:
                        extra_s = "action: {:#x}".format(action_table_pos + action - 1)
                    entries.append([pos, data[pos:new_pos], "action", action, extra_s])
                    pos = new_pos

                    table_cnt += 1

                # parse action_table
                max_ar_filter = 0
                table_cnt = 0
                if max_action:
                    action_table_end_pos = action_table_pos + max_action + 1
                    while pos < action_table_end_pos:
                        entries.append([pos, "Action table[{:4d}]".format(table_cnt), ""])

                        new_pos, ar_filter = self.get_sleb128(data, pos)
                        if ar_filter == 0:
                            extra_s = "cleanup"
                        else:
                            enc_size = self.encoded_ptr_size(ttype_encoding, ptr_size)
                            extra_s = "catch typeinfo: {:#x}".format(ttype_base - ar_filter * enc_size)
                        entries.append([pos, data[pos:new_pos], "action_record_filter", ar_filter, extra_s])
                        max_ar_filter = max(ar_filter, max_ar_filter)
                        pos = new_pos

                        new_pos, ar_disp = self.get_sleb128(data, pos)
                        if ar_disp & 1:
                            extra_s = "-> Action Table[{:4d}]".format(table_cnt + (ar_disp + 1)//2)
                        elif ar_disp:
                            extra_s = "-> ???"
                        else:
                            extra_s = "list end"
                        entries.append([pos, data[pos:new_pos], "action_record_next", ar_disp, extra_s])
                        pos = new_pos

                        table_cnt += 1

                # parse ttype_table
                if max_ar_filter > 0 and ttype_base is not None:
                    enc_size = self.encoded_ptr_size(ttype_encoding, ptr_size)
                    new_pos = ttype_base - max_ar_filter * enc_size
                    if pos != new_pos:
                        entries.append([pos, "Padding", ""])
                        entries.append([pos, data[pos:new_pos], "padding", "", ""])
                        pos = new_pos
                    current_ar_filter = max_ar_filter
                    while pos < ttype_base:
                        entries.append([pos, "TType table[{:4d}]".format(current_ar_filter), ""])
                        new_pos, ttype = self.read_encoded(ttype_encoding, data, pos)
                        if (ttype_encoding & 0x70) == self.DW_EH_PE_pcrel:
                            ttype_pointer = shdr.sh_offset + pos + ttype
                            if ttype:
                                if self.is_pie:
                                    extra_s = "TType pointer vma: $codebase+{:#x}".format(load_base + ttype_pointer)
                                else:
                                    extra_s = "TType pointer vma: {:#x}".format(load_base + ttype_pointer)
                            else:
                                extra_s = ""
                            entries.append([pos, data[pos:new_pos], "ttype", ttype, extra_s])
                        else:
                            entries.append([pos, data[pos:new_pos], "ttype", ttype, "TType pointer"])
                        pos = new_pos
                        current_ar_filter -= 1
                if ttype_base is not None:
                    entries.append([ttype_base, "TType table base (Stored upwards)", ""])

                # next LSDA
                if ttype_base is None:
                    pass
                else:
                    pos = ttype_base
                lsda_table_cnt +=1
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            entries.append(["Parse Error\n{}".format(exc_value)])
        return entries

    def read_section(self, section_name):
        for s in self.elf.shdrs:
            if s.sh_name != section_name:
                continue
            f = open(self.elf.filename, "rb")
            f.seek(s.sh_offset)
            data = f.read(s.sh_size)
            f.close()
            info("Found {} section".format(section_name))
            return {"name": section_name, "offset": s.sh_offset, "data": data}
        err("Not found {} section".format(section_name))
        return None

    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        try:
            less = which("less")
        except FileNotFoundError as e:
            err("{}".format(e))
            return

        # with hexdump or not
        if "-x" in argv:
            idx = argv.index("-x")
            self.hexdump = True
            argv = argv[:idx] + argv[idx+1:]
        else:
            self.hexdump = False

        # read file
        if "-f" in argv:
            idx = argv.index("-f")
            filename = argv[idx+1]
            argv = argv[:idx] + argv[idx+2:]
        else:
            filename = get_filepath()
            if filename is None:
                err("No executable/library specified")
                return
        if not os.path.exists(filename):
            err("{} is not found".format(filename))
            return
        self.elf = get_elf_headers(filename)
        self.is_pie = is_pie(filename)
        if not self.elf.is_valid():
            err("Elf parsing error")
            return

        # read section
        eh_frame_hdr = self.read_section(".eh_frame_hdr")
        if eh_frame_hdr is None:
            return
        eh_frame = self.read_section(".eh_frame")
        if eh_frame is None:
            return
        gcc_except_table = self.read_section(".gcc_except_table")
        if gcc_except_table is None:
            return

        # parse section
        out = []
        eh_frame_hdr_entries = self.parse_eh_frame_hdr(eh_frame_hdr)
        out += self.format_entry(eh_frame_hdr, eh_frame_hdr_entries)
        eh_frame_entries = self.parse_eh_frame(eh_frame)
        out += self.format_entry(eh_frame, eh_frame_entries)
        gcc_except_table_entries = self.parse_gcc_except_table(gcc_except_table, eh_frame_entries)
        out += self.format_entry(gcc_except_table, gcc_except_table_entries)

        # print
        _, tmp_path = tempfile.mkstemp()
        open(tmp_path, "w").write('\n'.join(out))
        os.system(f"{less} -R {tmp_path}")
        os.unlink(tmp_path)
        return


@register_command
class EntryPointBreakCommand(GenericCommand):
    """Tries to find best entry point and sets a temporary breakpoint on it. The command will test for
    well-known symbols for entry points, such as `main`, `_main`, `__libc_start_main`, etc. defined by
    the setting `entrypoint_symbols`."""
    _cmdline_ = "entry-break"
    _syntax_ = _cmdline_
    _aliases_ = ["start",]
    _category_ = "Debugging Support"

    def __init__(self, *args, **kwargs):
        super().__init__()
        self.add_setting("entrypoint_symbols", "main _main __libc_start_main __uClibc_main start _start", "Possible symbols for entry points")
        return

    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        fpath = get_filepath()
        if fpath is None:
            warn("No executable to debug, use `file` to load a binary")
            return

        if not os.access(fpath, os.X_OK):
            warn("The file '{}' is not executable.".format(fpath))
            return

        if is_alive() and not __gef_qemu_mode__:
            warn("gdb is already running")
            return

        bp = None
        entrypoints = self.get_setting("entrypoint_symbols").split()

        for sym in entrypoints:
            try:
                value = parse_address(sym)
                info("Breaking at '{:s}'".format(str(value)))
                bp = EntryBreakBreakpoint(sym)
                gdb.execute("run {}".format(" ".join(argv)))
                return

            except gdb.error as gdb_error:
                if 'The "remote" target does not support "run".' in str(gdb_error):
                    # this case can happen when doing remote debugging
                    gdb.execute("continue")
                    return
                continue

        # if here, clear the breakpoint if any set
        if bp:
            bp.delete()

        # break at entry point
        entry = get_entry_point()
        if entry is None:
            return

        if is_pie(fpath):
            self.set_init_tbreak_pie(entry, argv)
            gdb.execute("continue")
            return

        self.set_init_tbreak(entry)
        gdb.execute("run {}".format(" ".join(argv)))
        return

    def set_init_tbreak(self, addr):
        info("Breaking at entry-point: {:#x}".format(addr))
        bp = EntryBreakBreakpoint("*{:#x}".format(addr))
        return bp

    def set_init_tbreak_pie(self, addr, argv):
        warn("PIC binary detected, retrieving text base address")
        gdb.execute("set stop-on-solib-events 1")
        hide_context()
        gdb.execute("run {}".format(" ".join(argv)))
        unhide_context()
        gdb.execute("set stop-on-solib-events 0")
        vmmap = get_process_maps()
        base_address = [x.page_start for x in vmmap if x.path == get_filepath()][0]
        return self.set_init_tbreak(base_address + addr)


@register_command
class NamedBreakpointCommand(GenericCommand):
    """Sets a breakpoint and assigns a name to it, which will be shown, when it's hit."""
    _cmdline_ = "name-break"
    _syntax_ = "{:s} NAME [LOCATION]".format(_cmdline_)
    _example_ = "{:s} main *0x4008a9".format(_cmdline_)
    _category_ = "Debugging Support"
    _aliases_ = ["nb",]

    def __init__(self, *args, **kwargs):
        super().__init__()
        return

    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if not argv:
            err("Missing name for breakpoint")
            self.usage()
            return

        name = argv[0]
        location = argv[1] if len(argv) > 1 else "*{}".format(hex(current_arch.pc))

        NamedBreakpoint(location, name)
        return


@register_command
class ContextCommand(GenericCommand):
    """Displays a comprehensive and modular summary of runtime context. Unless setting `enable` is
    set to False, this command will be spawned automatically every time GDB hits a breakpoint, a
    watchpoint, or any kind of interrupt. By default, it will show panes that contain the register
    states, the stack, and the disassembly code around $pc."""
    _cmdline_ = "context"
    _syntax_ = "{:s} [legend|regs|stack|code|args|memory|source|trace|threads|extra]".format(_cmdline_)
    _aliases_ = ["ctx",]
    _category_ = "Debugging Support"

    old_registers = {}

    def __init__(self):
        super().__init__()
        self.add_setting("enable", True, "Enable/disable printing the context when breaking")
        self.add_setting("show_source_code_variable_values", True, "Show extra PC context info in the source code")
        self.add_setting("show_stack_raw", False, "Show the stack pane as raw hexdump (no dereference)")
        self.add_setting("show_registers_raw", False, "Show the registers pane with raw values (no dereference)")
        self.add_setting("show_opcodes_size", 8, "Number of bytes of opcodes to display next to the disassembly")
        self.add_setting("peek_calls", True, "Peek into calls")
        self.add_setting("peek_ret", True, "Peek at return address")
        self.add_setting("nb_lines_stack", 8, "Number of line in the stack pane")
        self.add_setting("grow_stack_down", False, "Order of stack downward starts at largest down to stack pointer")
        self.add_setting("nb_lines_backtrace", 10, "Number of line in the backtrace pane")
        self.add_setting("nb_lines_backtrace_before", 2, "Number of line in the backtrace pane before selected frame")
        self.add_setting("nb_lines_threads", -1, "Number of line in the threads pane")
        self.add_setting("nb_lines_code", 6, "Number of instruction after $pc")
        self.add_setting("nb_lines_code_prev", 3, "Number of instruction before $pc")
        self.add_setting("ignore_registers", "", "Space-separated list of registers not to display (e.g. '$cs $ds $gs')")
        self.add_setting("clear_screen", True, "Clear the screen before printing the context")
        self.add_setting("layout", "legend regs stack code args source memory threads trace extra", "Change the order/presence of the context sections")
        self.add_setting("redirect", "", "Redirect the context information to another TTY")
        self.add_setting("libc_args", False, "Show libc function call args description")
        self.add_setting("libc_args_path", "", "Path to libc function call args json files, provided via gef-extras")
        self.add_setting("smart_cpp_function_name", False, "Print cpp function name without args if demangled")
        self.add_setting("use_native_x_command", False, "Use x/16i insted of gdb_disasembe/capstone")

        if "capstone" in list(sys.modules.keys()):
            self.add_setting("use_capstone", False, "Use capstone as disassembler in the code pane (instead of GDB)")

        self.layout_mapping = {
            "legend": self.show_legend,
            "regs": self.context_regs,
            "stack": self.context_stack,
            "code": self.context_code,
            "args": self.context_args,
            "memory": self.context_memory,
            "source": self.context_source,
            "trace": self.context_trace,
            "threads": self.context_threads,
            "extra": self.context_additional_information,
        }
        return

    def post_load(self):
        gef_on_continue_hook(self.update_registers)
        gef_on_continue_hook(self.empty_extra_messages)
        return

    def show_legend(self):
        if get_gef_setting("gef.disable_color")!=True:
            str_color = get_gef_setting("theme.dereference_string")
            code_addr_color = get_gef_setting("theme.address_code")
            stack_addr_color = get_gef_setting("theme.address_stack")
            heap_addr_color = get_gef_setting("theme.address_heap")
            changed_register_color = get_gef_setting("theme.registers_value_changed")

            gef_print("[ Legend: {} | {} | {} | {} | {} ]".format(
                Color.colorify("Modified register", changed_register_color),
                Color.colorify("Code", code_addr_color),
                Color.colorify("Heap", heap_addr_color),
                Color.colorify("Stack", stack_addr_color),
                Color.colorify("String", str_color)
            ))
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if not self.get_setting("enable") or context_hidden:
            return

        if not all(_ in self.layout_mapping for _ in argv):
            self.usage()
            return

        if len(argv) > 0:
            current_layout = argv
        else:
            current_layout = self.get_setting("layout").strip().split()

        if not current_layout:
            return

        self.tty_rows, self.tty_columns = get_terminal_size()

        redirect = self.get_setting("redirect")
        if redirect and os.access(redirect, os.W_OK):
            enable_redirect_output(to_file=redirect)

        if self.get_setting("clear_screen") and len(argv) == 0:
            clear_screen(redirect)

        for section in current_layout:
            if section[0] == "-":
                continue
            try:
                self.layout_mapping[section]()
            except gdb.MemoryError as e:
                # a MemoryError will happen when $pc is corrupted (invalid address)
                err(str(e))
        self.context_title("")

        if redirect and os.access(redirect, os.W_OK):
            disable_redirect_output()
        return

    def context_title(self, m):
        line_color = get_gef_setting("theme.context_title_line")
        msg_color = get_gef_setting("theme.context_title_message")

        if not m:
            gef_print(Color.colorify(HORIZONTAL_LINE * self.tty_columns, line_color))
            return

        trail_len = len(m) + 6
        title = ""
        width = max(self.tty_columns - trail_len, 0)
        title += Color.colorify("{:{padd}<{width}} ".format("", width=width, padd=HORIZONTAL_LINE), line_color)
        title += Color.colorify(m, msg_color)
        title += Color.colorify(" {:{padd}<4}".format("", padd=HORIZONTAL_LINE), line_color)
        gef_print(title)
        return

    def context_regs(self):
        self.context_title("registers")
        ignored_registers = set(self.get_setting("ignore_registers").split())

        if current_arch is None and is_remote_debug():
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return

        if self.get_setting("show_registers_raw") is False:
            regs = set(current_arch.all_registers)
            printable_registers = " ".join(list(regs - ignored_registers))
            gdb.execute("registers {}".format(printable_registers))
            return

        widest = l = max(map(len, current_arch.all_registers))
        l += 5
        l += current_arch.ptrsize * 2
        nb = get_terminal_size()[1]//l
        i = 1
        line = ""
        changed_color = get_gef_setting("theme.registers_value_changed")
        regname_color = get_gef_setting("theme.registers_register_name")

        for reg in current_arch.all_registers:
            if reg in ignored_registers:
                continue

            try:
                r = gdb.parse_and_eval(reg)
                if r.type.code == gdb.TYPE_CODE_VOID:
                    continue

                new_value_type_flag = (r.type.code == gdb.TYPE_CODE_FLAGS)
                new_value = int(r)

            except (gdb.MemoryError, gdb.error):
                # If this exception is triggered, it means that the current register
                # is corrupted. Just use the register "raw" value (not eval-ed)
                new_value = get_register(reg)
                new_value_type_flag = False

            except Exception:
                new_value = 0
                new_value_type_flag = False

            old_value = self.old_registers.get(reg, 0)

            padreg = reg.ljust(widest, " ")
            value = align_address(new_value)
            old_value = align_address(old_value)
            if value == old_value:
                line += "{}: ".format(Color.colorify(padreg, regname_color))
            else:
                line += "{}: ".format(Color.colorify(padreg, changed_color))
            if new_value_type_flag:
                line += "{:s} ".format(format_address_spaces(value))
            else:
                addr = lookup_address(align_address(int(value)))
                if addr.valid:
                    line += "{:s} ".format(str(addr))
                else:
                    line += "{:s} ".format(format_address_spaces(value))

            if i % nb == 0:
                gef_print(line)
                line = ""
            i += 1

        if line:
            gef_print(line)

        gef_print("Flags: {:s}".format(current_arch.flag_register_to_human()))
        return

    def context_stack(self):
        self.context_title("stack")

        show_raw = self.get_setting("show_stack_raw")
        nb_lines = self.get_setting("nb_lines_stack")

        if current_arch is None and is_remote_debug():
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return

        try:
            sp = current_arch.sp
            if show_raw is True:
                mem = read_memory(sp, 0x10 * nb_lines)
                gef_print(hexdump(mem, base=sp))
            else:
                gdb.execute("dereference {:#x} l{:d}".format(sp, nb_lines))

        except gdb.MemoryError:
            err("Cannot read memory from $SP (corrupted stack pointer?)")

        return

    def addr_has_breakpoint(self, address, bp_locations):
        return any(hex(address) in b for b in bp_locations)

    def context_code(self):
        use_native_x_command = self.has_setting("use_native_x_command") and self.get_setting("use_native_x_command")
        nb_insn = self.get_setting("nb_lines_code")
        nb_insn_prev = self.get_setting("nb_lines_code_prev")
        use_capstone = self.has_setting("use_capstone") and self.get_setting("use_capstone")
        past_insns_color = get_gef_setting("theme.old_context")
        show_opcodes_size = self.has_setting("show_opcodes_size") and self.get_setting("show_opcodes_size")
        cur_insn_color = get_gef_setting("theme.disassemble_current_instruction")

        if current_arch is None and is_remote_debug():
            self.context_title("code")
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return

        pc = current_arch.pc
        breakpoints = gdb.breakpoints() or []
        bp_locations = [b.location for b in breakpoints if b.location and b.location.startswith("*")]

        frame = gdb.selected_frame()
        arch_name = "{}:{}".format(current_arch.arch.lower(), current_arch.mode)

        self.context_title("code:{}".format(arch_name))
        if use_native_x_command:
            gdb.execute("x/16i {:#x}".format(current_arch.pc))
            return

        try:
            instruction_iterator = capstone_disassemble if use_capstone else gef_disassemble

            for insn in instruction_iterator(pc, nb_insn, nb_prev=nb_insn_prev):
                line = []
                is_taken = False
                target = None
                bp_prefix = Color.redify(BP_GLYPH) if self.addr_has_breakpoint(insn.address, bp_locations) else " "

                if show_opcodes_size == 0:
                    text = str(insn)
                else:
                    insn_fmt = "{{:{}o}}".format(show_opcodes_size)
                    text = insn_fmt.format(insn)

                if insn.address < pc:
                    line += "{}{}{}".format(bp_prefix, " "*len(RIGHT_ARROW[1:]), Color.colorify(text, past_insns_color))

                elif insn.address == pc:
                    line += "{}{}".format(bp_prefix, Color.colorify("{:s}{:s}".format(RIGHT_ARROW[1:], text), cur_insn_color))

                    if current_arch.is_conditional_branch(insn):
                        is_taken, reason = current_arch.is_branch_taken(insn)
                        if is_taken:
                            target = insn.operands[-1].split()[0]
                            reason = "[Reason: {:s}]".format(reason) if reason else ""
                            line += Color.colorify("\tTAKEN {:s}".format(reason), "bold green")
                        else:
                            reason = "[Reason: !({:s})]".format(reason) if reason else ""
                            line += Color.colorify("\tNOT taken {:s}".format(reason), "bold red")
                    elif current_arch.is_call(insn) and self.get_setting("peek_calls") is True:
                        target = insn.operands[-1].split()[0]
                    elif current_arch.is_ret(insn) and self.get_setting("peek_ret") is True:
                        target = current_arch.get_ra(insn, frame)

                else:
                    line += "{}{}{}".format(bp_prefix, " "*len(RIGHT_ARROW[1:]), text)

                gef_print("".join(line))

                if target:
                    try:
                        target = int(target, 0)
                    except TypeError: # Already an int
                        pass
                    except ValueError:
                        # If the operand isn't an address right now we can't parse it
                        continue
                    try:
                        for i, tinsn in enumerate(instruction_iterator(target, nb_insn)):
                            if show_opcodes_size == 0:
                                text = str(tinsn)
                            else:
                                text = insn_fmt.format(tinsn)
                            text = "   {}  {}".format (DOWN_ARROW if i == 0 else " ", text)
                            gef_print(text)
                    except:
                        pass
                    break

            self.context_memory_access()
            self.context_memory_access2() # for x86/x64 - fs/gs
            self.context_memory_access3() # for x86/x64 - cs/ss/ds/es

        except gdb.MemoryError:
            err("Cannot disassemble from $PC")
        return

    def context_memory_access(self):
        if not (is_x86() or is_arm32() or is_arm64()):
            return

        inst_iter = gef_disassemble(current_arch.pc, 2)
        insn_here = inst_iter.__next__()
        if insn_here.operands == []:
            return

        insn = ','.join(insn_here.operands)
        insn = re.sub(r"<.+>", "", insn)
        r = re.findall(r"[^:](\[.+?\])", str(insn)) # Unsupported: seg:[reg]
        if not r:
            return

        insn_next = inst_iter.__next__()
        codesize = insn_next.address - insn_here.address

        for code in r:
            code = code[1:-1] # skip "[" and "]"

            if is_x86():
                # add "$" to resiter
                code = code.replace("+", " + ")
                code = code.replace("-", " - ")
                code = code.replace("*", " * ")
                code = code.replace("eiz", " 0 ") # $eiz is always 0x0
                code = code.split()
                code = ["$"+x if x.isalpha() or re.match(r"r\d+d?", x) else x for x in code]
                code = ''.join(code)
                # $rip/$eip points next instruction
                code_orig, code = code, code.replace("$rip", f"$rip+{codesize:#x}")

            elif is_arm32():
                # add "$" to resiter
                code = code.replace(" ", "")
                code = code.replace("#", "")
                code = code.replace("lsl", "<<")
                code = code.split(",")
                code = ["$"+x if x.isalpha() or re.match(r"r\d+", x) else x for x in code]
                if "<<" in code[-1]:
                    code = code[:-2] + ["(" + code[-2] + code[-1] + ")"]
                code = '+'.join(code)
                # $pc points next next instruction
                code_orig, code = code, code.replace("$pc", f"$pc+{codesize*2:#x}")

            elif is_arm64():
                # add "$" to resiter
                code = code.replace(" ", "")
                code = code.replace("#", "")
                code = code.replace("lsl", "<<").replace("sxtw", "<<").replace("uxtw", "<<")
                code = code.replace("xzr", " 0 ") # $xzr is always 0x0
                code = code.replace("wzr", " 0 ") # $wzr is always 0x0
                code = code.replace("wsp", " ($sp&0xffff) ") # $wsp is a half of $sp
                code = code.split(",")
                code = ["$"+x if x.isalpha() or re.match(r"[xw]\d+", x) else x for x in code]
                if "<<" == code[-1]:
                    code[-1] += "0"
                if "<<" in code[-1]:
                    code = code[:-2] + ["(" + code[-2] + code[-1] + ")"]
                code = '+'.join(code)
                # $pc points next next instruction
                code_orig, code = code, code.replace("$pc", f"$pc+{codesize*2:#x}")

            # print
            try:
                code = code.replace("$", "(long)$")
                addr = parse_address(code)
            except:
                # some binary fails to resolve "(long)"
                addr = parse_address(code_orig)
            self.context_title(f"memory access: {code_orig} = {addr:#x}")
            gdb.execute(f"telescope {addr:#x} 1")
        return

    def context_memory_access2(self):
        if not is_x86():
            return

        inst_iter = gef_disassemble(current_arch.pc, 1)
        insn_here = inst_iter.__next__()
        if insn_here.operands == []:
            return

        insn = ','.join(insn_here.operands)
        insn = re.sub(r"<.+>", "", insn)

        r = re.findall(r"((fs|gs):\[?([^,\]]+)\]?)", str(insn))
        if r:
            code, fsgs, offset = r[0][0], r[0][1], r[0][2]
            tls = TlsCommand.getfs() if fsgs == "fs" else TlsCommand.getgs()
            offset = offset.replace("+", " + ")
            offset = offset.replace("-", " - ")
            offset = offset.replace("*", " * ")
            offset = offset.replace("eiz", " 0 ") # $eiz is always 0x0
            offset = offset.split()
            offset = ["$"+x if x.isalpha() or re.match(r"r\d+d?", x) else x for x in offset]
            offset = ''.join(offset)
            offset = parse_address(offset)
            mask = ((1<<32) - 1) if is_32bit() else ((1<<64) - 1)
            addr = (tls + offset) & mask
            self.context_title(f"memory access: {code} = {addr:#x}")
            gdb.execute(f"telescope {addr:#x} 1")
        return

    def context_memory_access3(self):
        if not is_x86():
            return

        inst_iter = gef_disassemble(current_arch.pc, 1)
        insn_here = inst_iter.__next__()
        if insn_here.operands == []:
            return

        insn = ','.join(insn_here.operands)
        insn = re.sub(r"<.+>", "", insn)

        r = re.findall(r"((es|ds|ss|cs):\[?([^,\]]+)\]?)", str(insn))
        for rr in r:
            code, esdssscs, addr = rr[0], rr[1], rr[2]
            addr = addr.replace("+", " + ")
            addr = addr.replace("-", " - ")
            addr = addr.replace("*", " * ")
            addr = addr.replace("eiz", " 0 ") # $eiz is always 0x0
            addr = addr.split()
            addr = ["$"+x if x.isalpha() or re.match(r"r\d+d?", x) else x for x in addr]
            addr = ''.join(addr)
            addr = parse_address(addr)
            self.context_title(f"memory access: {code} = {addr:#x}")
            gdb.execute(f"telescope {addr:#x} 1")
        return

    def context_args(self):
        if current_arch is None and is_remote_debug():
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return

        insn = gef_current_instruction(current_arch.pc)
        if current_arch.is_syscall(insn):
            self.context_title("arguments")
            gdb.execute("syscall-args")
            return

        insn = gef_current_instruction(current_arch.pc)
        if not current_arch.is_call(insn):
            return

        self.size2type = {
            1: "BYTE",
            2: "WORD",
            4: "DWORD",
            8: "QWORD",
        }

        if insn.operands[-1].startswith(self.size2type[current_arch.ptrsize]+" PTR"):
            target = "*" + insn.operands[-1].split()[-1]
        elif "$"+insn.operands[0] in current_arch.all_registers:
            target = "*{:#x}".format(get_register("$"+insn.operands[0]))
        else:
            # is there a symbol?
            ops = " ".join(insn.operands)
            if "<" in ops and ">" in ops:
                # extract it
                target = re.sub(r".*<([^\(> ]*).*", r"\1", ops)
            else:
                # it's an address, just use as is
                target = re.sub(r".*(0x[a-fA-F0-9]*).*", r"\1", ops)

        sym = gdb.lookup_global_symbol(target)
        if sym is None:
            self.print_guessed_arguments(target)
            return

        if sym.type.code != gdb.TYPE_CODE_FUNC:
            err("Symbol '{}' is not a function: type={}".format(target, sym.type.code))
            return

        self.print_arguments_from_symbol(target, sym)
        return

    def print_arguments_from_symbol(self, function_name, symbol):
        """If symbols were found, parse them and print the argument adequately."""
        args = []

        for i, f in enumerate(symbol.type.fields()):
            _value = current_arch.get_ith_parameter(i, in_func=False)[1]
            if _value is None:
                break
            _value = RIGHT_ARROW.join([str(addr) for addr in dereference_from(_value)])
            _name = f.name or "var_{}".format(i)
            _type = f.type.name or self.size2type[f.type.sizeof]
            args.append("{} {} = {}".format(_type, _name, _value))

        self.context_title("arguments")

        if not args:
            gef_print("{} (<void>)".format(function_name))
            return

        gef_print("{} (".format(function_name))
        gef_print("   " + ",\n   ".join(args))
        gef_print(")")
        return

    def print_guessed_arguments(self, function_name):
        """When no symbol, read the current basic block and look for "interesting" instructions."""
        def __get_current_block_start_address():
            pc = current_arch.pc
            try:
                block = gdb.block_for_pc(pc)
                if block and 0 <= pc - block.start <= 0x100:
                    block_start = block.start
                else:
                    block_start = gdb_get_nth_previous_instruction_address(pc, 5)
            except RuntimeError:
                block_start = gdb_get_nth_previous_instruction_address(pc, 5)
            return block_start

        parameter_set = set()
        pc = current_arch.pc
        block_start = __get_current_block_start_address()
        if not block_start:
            return
        use_capstone = self.has_setting("use_capstone") and self.get_setting("use_capstone")
        instruction_iterator = capstone_disassemble if use_capstone else gef_disassemble
        function_parameters = current_arch.function_parameters
        arg_key_color = get_gef_setting("theme.registers_register_name")

        for insn in instruction_iterator(block_start, pc - block_start):
            if not insn.operands:
                continue

            if is_x86_32():
                if insn.mnemonic == "push":
                    parameter_set.add(insn.operands[0])
            else:
                op = "$" + insn.operands[0]
                if op in function_parameters:
                    parameter_set.add(op)

                if is_x86_64():
                    # also consider extended registers
                    extended_registers = {
                        "$rdi": ["$edi", "$di"],
                        "$rsi": ["$esi", "$si"],
                        "$rdx": ["$edx", "$dx"],
                        "$rcx": ["$ecx", "$cx"],
                    }
                    for exreg in extended_registers:
                        if op in extended_registers[exreg]:
                            parameter_set.add(exreg)

        nb_argument = 0
        _arch_mode = "{}_{}".format(current_arch.arch.lower(), current_arch.mode)
        _function_name = None
        if function_name.endswith("@plt"):
            _function_name = function_name.split("@")[0]
            try:
                nb_argument = len(libc_args_definitions[_arch_mode][_function_name])
            except KeyError:
                pass

        if not nb_argument and len(parameter_set) > 0:
            if is_x86_32():
                nb_argument = len(parameter_set)
            else:
                nb_argument = max(function_parameters.index(p)+1 for p in parameter_set)

        args = []
        for i in range(nb_argument):
            _key, _values = current_arch.get_ith_parameter(i, in_func=False)
            _values = RIGHT_ARROW.join([str(addr) for addr in dereference_from(_values)])
            try:
                args.append("{} = {} (def: {})".format(Color.colorify(_key, arg_key_color), _values,
                                                       libc_args_definitions[_arch_mode][_function_name][_key]))
            except KeyError:
                args.append("{} = {}".format(Color.colorify(_key, arg_key_color), _values))

        self.context_title("arguments (guessed)")
        gef_print("{} (".format(function_name))
        if args:
            gef_print("   " + ",\n   ".join(args))
        gef_print(")")
        return

    def line_has_breakpoint(self, file_name, line_number, bp_locations):
        filename_line = "{}:{}".format(file_name, line_number)
        return any(filename_line in loc for loc in bp_locations)

    def context_source(self):
        try:
            pc = current_arch.pc
            symtabline = gdb.find_pc_line(pc)
            symtab = symtabline.symtab
            line_num = symtabline.line - 1 # we subtract one because line number returned by gdb start at 1
            if not symtab.is_valid():
                return

            fpath = symtab.fullname()
            with open(fpath, "r") as f:
                lines = [l.rstrip() for l in f.readlines()]

        except Exception:
            return

        file_base_name = os.path.basename(symtab.filename)
        breakpoints = gdb.breakpoints() or []
        bp_locations = [b.location for b in breakpoints if b.location and file_base_name in b.location]
        past_lines_color = get_gef_setting("theme.old_context")

        nb_line = self.get_setting("nb_lines_code")
        fn = symtab.filename
        title = "source:{}+{}".format(fn, line_num + 1)
        cur_line_color = get_gef_setting("theme.source_current_line")
        self.context_title(title)
        show_extra_info = self.get_setting("show_source_code_variable_values")

        for i in range(line_num - nb_line + 1, line_num + nb_line):
            if i < 0:
                continue

            bp_prefix = Color.redify(BP_GLYPH) if self.line_has_breakpoint(file_base_name, i + 1, bp_locations) else " "

            if i < line_num:
                past_line = Color.colorify("{:4d}   {:s}".format(i + 1, lines[i]), past_lines_color)
                gef_print("{:1s}{:2s}{:s}".format(bp_prefix, "", past_line))

            elif i == line_num:
                prefix = "{:1s}{:2s}{:4d}   ".format(bp_prefix, RIGHT_ARROW[1:-1], i + 1)
                leading = len(lines[i]) - len(lines[i].lstrip())
                if show_extra_info:
                    extra_info = self.get_pc_context_info(pc, lines[i])
                    for ext in extra_info:
                        gef_print("{}// {}".format(" "*(len(prefix) + leading), ext))
                gef_print(Color.colorify("{}{:s}".format(prefix, lines[i]), cur_line_color))

            elif i > line_num:
                try:
                    future_line = "{:4d}   {:s}".format(i + 1, lines[i])
                    gef_print("{:1s}{:2s}{:s}".format(bp_prefix, "", future_line))
                except IndexError:
                    break
        return

    def get_pc_context_info(self, pc, line):
        max_recursion = get_gef_setting("dereference.max_recursion") or 4
        try:
            current_block = gdb.block_for_pc(pc)
            if not current_block or not current_block.is_valid(): return ""
            m = collections.OrderedDict()
            while current_block and not current_block.is_static:
                for sym in current_block:
                    symbol = sym.name
                    if not sym.is_function and re.search(r"\W{}\W".format(symbol), line):
                        val = gdb.parse_and_eval(symbol)
                        if val.type.code in (gdb.TYPE_CODE_PTR, gdb.TYPE_CODE_ARRAY):
                            addr = int(val.address)
                            addrs = dereference_from(addr)
                            # dereference
                            val = str(addrs[0])
                            sep = " {:s} ".format(RIGHT_ARROW)
                            for addr in addrs[1:]:
                                if isinstance(addr, Address):
                                    val += sep + str(addr) + get_symbol_string(addr.value)
                                else:
                                    val += sep + addr # actually this is msg
                            # add "..." or not
                            if max_recursion <= len(addrs) and isinstance(addrs[-1], Address):
                                subseq_addrs = dereference_from(addrs[-1].value)
                                if len(subseq_addrs) > 1:
                                    val += sep + "..."
                        elif val.type.code == gdb.TYPE_CODE_INT:
                            val = hex(int(val))
                        else:
                            continue

                        if symbol not in m:
                            m[symbol] = val
                current_block = current_block.superblock

            if m:
                return ["{}={}".format(Color.yellowify(a), b) for a, b in m.items()]
        except Exception:
            pass
        return []

    def context_trace(self):
        try:
            self.context_title("trace")

            nb_backtrace = self.get_setting("nb_lines_backtrace")
            if nb_backtrace <= 0:
                return

            # backward compat for gdb (gdb < 7.10)
            if not hasattr(gdb, "FrameDecorator"):
                gdb.execute("backtrace {:d}".format(nb_backtrace))
                return

            orig_frame = gdb.selected_frame()
            current_frame = gdb.newest_frame()
            frames = [current_frame]
            while current_frame != orig_frame:
                current_frame = current_frame.older()
                frames.append(current_frame)

            nb_backtrace_before = self.get_setting("nb_lines_backtrace_before")
            level = max(len(frames) - nb_backtrace_before - 1, 0)
            current_frame = frames[level]

            while current_frame:
                current_frame.select()
                if not current_frame.is_valid():
                    continue

                pc = current_frame.pc()
                name = Instruction.smartify_text(current_frame.name())
                items = []
                items.append("{:#x}".format(pc))
                if name:
                    frame_args = gdb.FrameDecorator.FrameDecorator(current_frame).frame_args() or []
                    m = Color.greenify(name)
                    fargs = ["{}={!s}".format(Color.yellowify(x.sym), x.sym.value(current_frame)) for x in frame_args]
                    m += "({})".format(", ".join(fargs))
                    items.append(m)
                else:
                    try:
                        insn = next(gef_disassemble(pc, 1))
                    except gdb.MemoryError as e:
                        break
                    items.append(Color.redify("{} {}".format(insn.mnemonic, ", ".join(insn.operands))))

                idx = Color.colorify("#{}".format(level), "bold green" if current_frame == orig_frame else "bold pink")
                gef_print("[{}] {}".format(idx, RIGHT_ARROW.join(items)))
                current_frame = current_frame.older()
                level += 1
                nb_backtrace -= 1
                if nb_backtrace == 0:
                    break

            orig_frame.select()
        except Exception:
            pass
        return

    def context_threads(self):
        def reason():
            res = gdb.execute("info program", to_string=True).splitlines()
            if not res:
                return "NOT RUNNING"

            for line in res:
                line = line.strip()
                if line.startswith("It stopped with signal "):
                    return line.replace("It stopped with signal ", "").split(",", 1)[0]
                if line == "The program being debugged is not being run.":
                    return "NOT RUNNING"
                if line == "It stopped at a breakpoint that has since been deleted.":
                    return "TEMPORARY BREAKPOINT"
                if line.startswith("It stopped at breakpoint "):
                    return "BREAKPOINT"
                if line == "It stopped after being stepped.":
                    return "SINGLE STEP"

            return "STOPPED"

        self.context_title("threads")

        threads = gdb.selected_inferior().threads()[::-1]
        idx = self.get_setting("nb_lines_threads")
        if idx > 0:
            threads = threads[0:idx]

        if idx == 0:
            return

        if not threads:
            err("No thread selected")
            return

        selected_thread = gdb.selected_thread()
        selected_frame = gdb.selected_frame()

        for i, thread in enumerate(threads):
            line = "[{:s}]".format(Color.colorify("#{:d}".format(i), "bold green" if thread == selected_thread else "bold pink"))
            line += " Id {:d}, ".format(thread.num)
            if thread.name:
                line += 'Name: "{:s}", '.format(thread.name)
            if thread.is_running():
                line += Color.colorify("running", "bold green")
            elif thread.is_stopped():
                line += Color.colorify("stopped", "bold red")
                try:
                    thread.switch()
                except:
                    return
                frame = gdb.selected_frame()
                frame_name = Instruction.smartify_text(frame.name())
                line += " {:s} in".format(Color.colorify("{:#x}".format(frame.pc()), "blue"))
                line += " {:s} ()".format(Color.colorify(frame_name or "??", "bold yellow"))
                line += ", reason: {}".format(Color.colorify(reason(), "bold pink"))
            elif thread.is_exited():
                line += Color.colorify("exited", "bold yellow")
            gef_print(line)
            i += 1

        selected_thread.switch()
        selected_frame.select()
        return

    def context_additional_information(self):
        if not __context_messages__:
            return

        self.context_title("extra")
        for level, text in __context_messages__:
            if level == "error": err(text)
            elif level == "warn": warn(text)
            elif level == "success": ok(text)
            else: info(text)
        return

    def context_memory(self):
        global __watches__
        for address, opt in sorted(__watches__.items()):
            sz, fmt = opt[0:2]
            self.context_title("memory:{:#x}".format(address))
            if fmt == "pointers":
                gdb.execute("dereference {address:#x} L{size:d}".format(address=address, size=sz,))
            else:
                gdb.execute("hexdump {fmt:s} {address:#x} {size:d}".format(address=address, size=sz, fmt=fmt,))
        return

    @classmethod
    def update_registers(cls, event):
        try:
            for reg in current_arch.all_registers:
                try:
                    cls.old_registers[reg] = get_register(reg)
                except Exception:
                    cls.old_registers[reg] = 0
            return
        except:
            return

    def empty_extra_messages(self, event):
        global __context_messages__
        __context_messages__ = []
        return


@register_command
class MemoryCommand(GenericCommand):
    """Add or remove address ranges to the memory view."""
    _cmdline_ = "memory"
    _syntax_ = "{:s} (watch|unwatch|reset|list)".format(_cmdline_)
    _category_ = "Debugging Support"

    def __init__(self):
        super().__init__(prefix=True)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()
        self.usage()
        return


@register_command
class MemoryWatchCommand(GenericCommand):
    """Adds address ranges to the memory view."""
    _cmdline_ = "memory watch"
    _syntax_ = "{:s} ADDRESS [SIZE] [(qword|dword|word|byte|pointers)]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} 0x603000 0x100 byte\n".format(_cmdline_)
    _example_ += "{:s} $sp".format(_cmdline_)
    _category_ = "Debugging Support"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        global __watches__

        if len(argv) not in (1, 2, 3):
            self.usage()
            return

        try:
            address = parse_address(argv[0])
            size = parse_address(argv[1]) if len(argv) > 1 else 0x10
        except:
            self.usage()
            return
        group = "byte"

        if len(argv) == 3:
            group = argv[2].lower()
            if group not in ("qword", "dword", "word", "byte", "pointers"):
                warn("Unexpected grouping '{}'".format(group))
                self.usage()
                return
        else:
            if current_arch.ptrsize == 4:
                group = "dword"
            elif current_arch.ptrsize == 8:
                group = "qword"

        __watches__[address] = (size, group)
        ok("Adding memwatch to {:#x}".format(address))
        return


@register_command
class MemoryUnwatchCommand(GenericCommand):
    """Removes address ranges to the memory view."""
    _cmdline_ = "memory unwatch"
    _syntax_ = "{:s} ADDRESS".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} 0x603000\n".format(_cmdline_)
    _example_ += "{:s} $sp".format(_cmdline_)
    _category_ = "Debugging Support"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        global __watches__
        if not argv:
            self.usage()
            return

        address = parse_address(argv[0])
        res = __watches__.pop(address, None)
        if not res:
            warn("You weren't watching {:#x}".format(address))
        else:
            ok("Removed memwatch of {:#x}".format(address))
        return


@register_command
class MemoryWatchResetCommand(GenericCommand):
    """Removes all watchpoints."""
    _cmdline_ = "memory reset"
    _syntax_ = "{:s}".format(_cmdline_)
    _category_ = "Debugging Support"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        global __watches__
        __watches__.clear()
        ok("Memory watches cleared")
        return


@register_command
class MemoryWatchListCommand(GenericCommand):
    """Lists all watchpoints to display in context layout."""
    _cmdline_ = "memory list"
    _syntax_ = "{:s}".format(_cmdline_)
    _category_ = "Debugging Support"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        global __watches__

        if not __watches__:
            info("No memory watches")
            return

        info("Memory watches:")
        for address, opt in sorted(__watches__.items()):
            gef_print("- {:#x} ({}, {})".format(address, opt[0], opt[1]))
        return


@register_command
class HexdumpCommand(GenericCommand):
    """Display SIZE lines of hexdump from the memory location pointed by ADDRESS."""
    _cmdline_ = "hexdump"
    _syntax_ = "{:s} [-h] qword|dword|word|byte [--phys] [ADDRESS [SIZE]] [REVERSE] [FULL]".format(_cmdline_)
    _example_  = "{:s} byte                  # dump from $sp as byte (0x10 bytes)\n".format(_cmdline_)
    _example_ += "{:s} qword                 # dump from $sp as qword (0x100 bytes)\n".format(_cmdline_)
    _example_ += "{:s} byte $rax 0x64        # dump from $rax as byte (100 bytes)\n".format(_cmdline_)
    _example_ += "{:s} byte $rax 100 FULL    # print the same line without omitting (byte mode only)\n".format(_cmdline_)
    _example_ += "{:s} byte $rax 100 REVERSE # print in reverse order line by line".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION, prefix=True)
        self.add_setting("always_show_ascii", False, "If true, hexdump will always display the ASCII dump")
        self.format = None
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        if "-h" in argv:
            self.usage()
            return

        if not self.format:
            err("Incomplete command")
            return

        fmt = self.format
        target = ""
        valid_formats = ["byte", "word", "dword", "qword"]
        read_len = None
        reverse = False
        full_mode = False

        self.phys_mode = False
        if "--phys" in argv:
            if not is_qemu_system():
                err("Unsupported")
                return
            self.phys_mode = True
            argv.remove("--phys")

        try:
            for arg in argv:
                arg_lower = arg.lower()
                is_format_given = False
                if arg_lower in valid_formats:
                    fmt = valid_format
                    is_format_given = True
                if is_format_given:
                    continue
                if "reverse" == arg_lower:
                    reverse = True
                    continue
                if "full" == arg_lower:
                    full_mode = True
                    continue
                if target:
                    if read_len:
                        self.usage()
                        return
                    read_len = int(arg_lower, 0)
                    continue
                target = arg

            if not target:
                target = "$sp"

            start_addr = parse_address(target)
            read_from = align_address(start_addr)
        except:
            self.usage()
            return

        if not read_len:
            read_len = 0x100 if fmt == "byte" else 0x10

        if fmt == "byte":
            lines = self._hexdump_byte(read_from, read_len, full_mode)
        else:
            lines = self._hexdump(read_from, read_len, fmt)

        if reverse:
            lines.reverse()

        if lines:
            gef_print("\n".join(lines))
        return

    def _hexdump_byte(self, read_from, read_len, full):
        read_from += self.repeat_count * read_len
        mem = self._read_memory(read_from, read_len)
        if mem is None:
            err("cannot access memory")
            return []
        lines_unmerged = hexdump(mem, show_symbol=False, base=read_from).splitlines()
        if full:
            return lines_unmerged

        # merge
        lines = []
        keep_asterisk = False
        for line in lines_unmerged:
            if lines == []:
                lines.append(line)
                continue
            if lines[-1].split("    ")[1] == line.split("    ")[1]:
                if not keep_asterisk:
                    keep_asterisk = True
            else:
                if keep_asterisk:
                    lines.append("*")
                    keep_asterisk = False
                lines.append(line)
        if keep_asterisk:
            lines.append("*")
        return lines

    def _read_memory(self, read_from, read_len):
        if read_len > 0x1000000: # Too large
            return None

        try:
            if self.phys_mode:
                mem = read_physmem(read_from, read_len)
            else:
                mem = read_memory(read_from, read_len)
            return mem
        except:
            pass

        read_end = read_from + read_len
        read_end &= ~(gef_getpagesize() - 1)
        while read_end - read_from > 0:
            try:
                if self.phys_mode:
                    mem = read_physmem(read_from, read_end - read_from)
                else:
                    mem = read_memory(read_from, read_end - read_from)
                return mem
            except:
                pass
            read_end -= gef_getpagesize()
        return None

    def _hexdump(self, start_addr, length, arrange_as):
        offset = self.repeat_count * length

        endianness = endian_str()

        base_address_color = get_gef_setting("theme.dereference_base_address")
        show_ascii = get_gef_setting("hexdump.always_show_ascii")

        formats = {
            "qword": ("Q", 8),
            "dword": ("I", 4),
            "word": ("H", 2),
        }

        r, l = formats[arrange_as]
        fmt_str = "{{base}}{v}+{{offset:#06x}}   {{sym}}{{val:#0{prec}x}}   {{text}}".format(v=VERTICAL_LINE, prec=l*2+2)
        fmt_pack = endianness + r
        lines = []

        i = 0
        text = ""
        while i < length:
            cur_addr = start_addr + (i + offset) * l
            sym = gdb_get_location_from_symbol(cur_addr)
            sym = "<{:s}+{:04x}> ".format(*sym) if sym else ""
            try:
                if self.phys_mode:
                    mem = read_physmem(cur_addr, l)
                else:
                    mem = read_memory(cur_addr, l)
            except:
                break
            val = struct.unpack(fmt_pack, mem)[0]
            if show_ascii:
                text = "".join([chr(b) if 0x20 <= b < 0x7F else "." for b in mem])
            lines.append(fmt_str.format(base=Color.colorify(format_address(cur_addr), base_address_color),
                                        offset=(i + offset) * l, sym=sym, val=val, text=text))
            i += 1
        return lines


@register_command
class HexdumpQwordCommand(HexdumpCommand):
    """Display SIZE lines of hexdump as QWORD from the memory location pointed by ADDRESS."""
    _cmdline_ = "hexdump qword"
    _syntax_ = "{:s} [-h] [--phys] [ADDRESS [SIZE]] [REVERSE]".format(_cmdline_)
    _example_ = "{:s} qword $rsp 16 REVERSE".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__()
        self.format = "qword"
        return


@register_command
class HexdumpDwordCommand(HexdumpCommand):
    """Display SIZE lines of hexdump as DWORD from the memory location pointed by ADDRESS."""
    _cmdline_ = "hexdump dword"
    _syntax_ = "{:s} [-h] [--phys] [ADDRESS [SIZE]] [REVERSE]".format(_cmdline_)
    _example_ = "{:s} $esp 16 REVERSE".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__()
        self.format = "dword"
        return


@register_command
class HexdumpWordCommand(HexdumpCommand):
    """Display SIZE lines of hexdump as WORD from the memory location pointed by ADDRESS."""
    _cmdline_ = "hexdump word"
    _syntax_ = "{:s} [-h] [--phys] [ADDRESS [SIZE]] [REVERSE]".format(_cmdline_)
    _example_ = "{:s} $esp 16 REVERSE".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__()
        self.format = "word"
        return


@register_command
class HexdumpByteCommand(HexdumpCommand):
    """Display SIZE lines of hexdump as BYTE from the memory location pointed by ADDRESS."""
    _cmdline_ = "hexdump byte"
    _syntax_ = "{:s} [-h] [--phys] [ADDRESS [SIZE]] [REVERSE] [FULL]".format(_cmdline_)
    _example_ = "{:s} $rsp 16".format(_cmdline_)
    _aliases_ = ["xxd", ]
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__()
        self.format = "byte"
        return


@register_command
class PatchCommand(GenericCommand):
    """Write specified values to the specified address."""
    _cmdline_ = "patch"
    _syntax_ = "{:s} [-h] qword|dword|word|byte [--phys] LOCATION VALUES\n".format(_cmdline_)
    _syntax_ += "{:s} [-h] string [--phys] LOCATION \"double-escaped string\" [LENGTH]\n".format(_cmdline_)
    _syntax_ += "{:s} [-h] pattern [--phys] LOCATION LENGTH\n".format(_cmdline_)
    _syntax_ += "{:s} [-h] nop [--phys] [LOCATION] [-b BYTE_LENGTH|-i INST_COUNT]\n".format(_cmdline_)
    _syntax_ += "{:s} [-h] inf|trap|ret [--phys] [LOCATION]\n".format(_cmdline_)
    _syntax_ += "{:s} [-h] history\n".format(_cmdline_)
    _syntax_ += "{:s} [-h] revert [HISTORY]".format(_cmdline_)
    _category_ = "Show/Modify Memory"
    SUPPORTED_SIZES = {
        "qword": (8, "Q"),
        "dword": (4, "L"),
        "word": (2, "H"),
        "byte": (1, "B"),
    }
    history = []

    def __init__(self):
        super().__init__(prefix=True, complete=gdb.COMPLETE_LOCATION)
        self.format = None
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        phys_mode = False
        if not self.format:
            self.usage()
            return

        if "--phys" in argv:
            if not is_supported_physmode():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            phys_mode = True
            orig_mode = get_current_mmu_mode()
            argv.remove("--phys")

        argc = len(argv)
        if argc < 2:
            self.usage()
            return

        location, values = argv[0], argv[1:]
        fmt = self.format
        if fmt not in self.SUPPORTED_SIZES:
            self.usage()
            return

        if phys_mode:
            if orig_mode == "virt":
                enable_phys()

        addr = align_address(parse_address(location))
        size, fcode = self.SUPPORTED_SIZES[fmt]

        d = "<" if is_little_endian() else ">"
        for value in values:
            value = parse_address(value) & ((1 << size * 8) - 1)
            vstr = struct.pack(d + fcode, value)
            before_data = read_memory(addr, length=size)
            write_memory(addr, vstr, length=size)
            after_data = read_memory(addr, length=size)
            self.history.insert(0, {"addr":addr, "before_data":before_data, "after_data":after_data, "physmode":get_current_mmu_mode()})
            addr += size

        if phys_mode:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchQwordCommand(PatchCommand):
    """Write specified QWORD to the specified address."""
    _cmdline_ = "patch qword"
    _syntax_ = "{:s} [-h] [--phys] LOCATION QWORD1 [QWORD2 [QWORD3..]]".format(_cmdline_)
    _example_ = "{:s} $rip 0x4141414141414141".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__()
        self.format = "qword"
        return


@register_command
class PatchDwordCommand(PatchCommand):
    """Write specified DWORD to the specified address."""
    _cmdline_ = "patch dword"
    _syntax_ = "{:s} [-h] [--phys] LOCATION DWORD1 [DWORD2 [DWORD3..]]".format(_cmdline_)
    _example_ = "{:s} $rip 0x41414141".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__()
        self.format = "dword"
        return


@register_command
class PatchWordCommand(PatchCommand):
    """Write specified WORD to the specified address."""
    _cmdline_ = "patch word"
    _syntax_ = "{:s} [-h] [--phys] LOCATION WORD1 [WORD2 [WORD3..]]".format(_cmdline_)
    _example_ = "{:s} $rip 0x4141".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__()
        self.format = "word"
        return


@register_command
class PatchByteCommand(PatchCommand):
    """Write specified BYTE to the specified address."""
    _cmdline_ = "patch byte"
    _syntax_ = "{:s} [-h] [--phys] LOCATION BYTE1 [BYTE2 [BYTE3..]]".format(_cmdline_)
    _example_ = "{:s} $rip 0x41 0x41 0x41 0x41 0x41".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__()
        self.format = "byte"
        return


@register_command
class PatchStringCommand(PatchCommand):
    """Write specified string to the specified memory location pointed by LOCATION."""
    _cmdline_ = "patch string"
    _syntax_ = '{:s} [-h] [--phys] LOCATION "double backslash-escaped string" [LENGTH]'.format(_cmdline_)
    _example_ = '{:s} $sp "GEFROCKS"'.format(_cmdline_)
    _category_ = "Show/Modify Memory"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        phys_mode = False
        if "--phys" in argv:
            if not is_supported_physmode():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            phys_mode = True
            orig_mode = get_current_mmu_mode()
            argv.remove("--phys")

        length = None
        if len(argv) == 3:
            length = int(argv[-1], 0)
            argv = argv[:-1]

        argc = len(argv)
        if argc != 2:
            self.usage()
            return

        if phys_mode:
            if orig_mode == "virt":
                enable_phys()

        location, s = argv[0:2]
        addr = align_address(parse_address(location))

        try:
            s = codecs.escape_decode(s)[0]
        except binascii.Error:
            gef_print("Could not decode '\\xXX' encoded string \"{}\"".format(s))
            return

        if length:
            s = s * (length // len(s) + 1)
            s = s[:length]

        before_data = read_memory(addr, length=len(s))
        write_memory(addr, s, len(s))
        after_data = read_memory(addr, length=len(s))
        self.history.insert(0, {"addr":addr, "before_data":before_data, "after_data":after_data, "physmode":get_current_mmu_mode()})

        if phys_mode:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchPatternCommand(PatchCommand):
    """Write pattern string to the specified memory location pointed by LOCATION."""
    _cmdline_ = "patch pattern"
    _syntax_ = "{:s} [-h] [--phys] LOCATION LENGTH".format(_cmdline_)
    _example_ = "{:s} $sp 128".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        phys_mode = False
        if "--phys" in argv:
            if not is_supported_physmode():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            phys_mode = True
            orig_mode = get_current_mmu_mode()
            argv.remove("--phys")

        argc = len(argv)
        if argc != 2:
            self.usage()
            return

        if phys_mode:
            if orig_mode == "virt":
                enable_phys()

        location, length = argv[0:2]
        addr = align_address(parse_address(location))
        s = gef_pystring(generate_cyclic_pattern(int(length, 0)))

        before_data = read_memory(addr, length=len(s))
        write_memory(addr, s, len(s))
        after_data = read_memory(addr, length=len(s))
        self.history.insert(0, {"addr":addr, "before_data":before_data, "after_data":after_data, "physmode":get_current_mmu_mode()})

        if phys_mode:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchNopCommand(PatchCommand):
    """Patch the instruction(s) pointed by parameters with NOP. Note: this command is architecture aware."""
    _cmdline_ = "patch nop"
    _syntax_ = "{:s} [-h] [--phys] [LOCATION] [-b BYTE_LENGTH|-i INST_COUNT]".format(_cmdline_)
    _example_ = "{:s} $pc -i 2".format(_cmdline_)
    _category_ = "Show/Modify Memory"
    _aliases_ = ["nop", ]

    def get_insns_size(self, addr, num_insts):
        addr_after_n = gef_instruction_n(addr, num_insts)
        return addr_after_n.address - addr

    def patch_nop(self, addr, num_bytes):
        if num_bytes == 0:
            info("Not patching since num_bytes == 0")
            return

        if is_arm32() and current_arch.is_thumb() and addr & 1:
            addr -= 1

        nop_op_len = len(current_arch.nop_insn)

        if nop_op_len > num_bytes:
            err("Cannot patch instruction at {:#x} (nop_size is:{:d},insn_size is:{:d})".format(addr, nop_op_len, num_bytes))
            return

        count = num_bytes // nop_op_len
        real_num_bytes = nop_op_len * count

        if real_num_bytes != num_bytes:
            err("Cannot patch instruction at {:#x} (nop instruction does not evenly fit in requested size)".format(addr))
            return

        ok("Patching {:d} bytes from {:s}".format(real_num_bytes, format_address(addr)))
        before_data = read_memory(addr, length=real_num_bytes)
        write_memory(addr, current_arch.nop_insn * count, real_num_bytes)
        after_data = read_memory(addr, length=real_num_bytes)
        self.history.insert(0, {"addr":addr, "before_data":before_data, "after_data":after_data, "physmode":get_current_mmu_mode()})
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        phys_mode = False
        if "--phys" in argv:
            if not is_supported_physmode():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            phys_mode = True
            orig_mode = get_current_mmu_mode()
            argv.remove("--phys")

        num_bytes = None
        num_insts = None
        if "-b" in argv:
            try:
                idx = argv.index("-b")
                num_bytes = int(argv[idx + 1], 0)
                argv = argv[:idx] + argv[idx+2:]
            except:
                self.usage()
                return
        elif "-i" in argv:
            try:
                idx = argv.index("-i")
                num_insts = int(argv[idx + 1], 0)
                argv = argv[:idx] + argv[idx+2:]
            except:
                self.usage()
                return
        else:
            num_insts = 1

        if phys_mode:
            if orig_mode == "virt":
                enable_phys()

        if argv:
            try:
                addr = parse_address(' '.join(argv))
            except:
                self.usage()
                if phys_mode:
                    if orig_mode == "virt":
                        disable_phys()
                return
        else:
            addr = current_arch.pc

        if num_insts:
            num_bytes = self.get_insns_size(addr, num_insts)
        self.patch_nop(addr, num_bytes)

        if phys_mode:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchInfloopCommand(PatchCommand):
    """Patch the instruction(s) pointed by parameters with Infinity loop. Note: this command is architecture aware."""
    _cmdline_ = "patch inf"
    _syntax_ = "{:s} [-h] [--phys] [LOCATION]".format(_cmdline_)
    _example_ = "{:s} $pc".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def patch_infloop(self, addr):
        if is_arm32() and current_arch.is_thumb() and addr & 1:
            addr -= 1

        num_bytes = len(current_arch.infloop_insn)
        ok("Patching {:d} bytes from {:s}".format(num_bytes, format_address(addr)))
        before_data = read_memory(addr, length=num_bytes)
        write_memory(addr, current_arch.infloop_insn, num_bytes)
        after_data = read_memory(addr, length=num_bytes)
        self.history.insert(0, {"addr":addr, "before_data":before_data, "after_data":after_data, "physmode":get_current_mmu_mode()})
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        phys_mode = False
        if "--phys" in argv:
            if not is_supported_physmode():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            phys_mode = True
            orig_mode = get_current_mmu_mode()
            argv.remove("--phys")

        if phys_mode:
            if orig_mode == "virt":
                enable_phys()

        if argv:
            try:
                addr = parse_address(' '.join(argv))
            except:
                self.usage()
                if phys_mode:
                    if orig_mode == "virt":
                        disable_phys()
                return
        else:
            addr = current_arch.pc

        self.patch_infloop(addr)

        if phys_mode:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchTrapCommand(PatchCommand):
    """Patch the instruction(s) pointed by parameters with BKPT. Note: this command is architecture aware."""
    _cmdline_ = "patch trap"
    _syntax_ = "{:s} [-h] [--phys] [LOCATION]".format(_cmdline_)
    _example_ = "{:s} $pc".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def patch_trap(self, addr):
        if is_arm32() and current_arch.is_thumb() and addr & 1:
            addr -= 1

        num_bytes = len(current_arch.trap_insn)
        ok("Patching {:d} bytes from {:s}".format(num_bytes, format_address(addr)))
        before_data = read_memory(addr, length=num_bytes)
        write_memory(addr, current_arch.trap_insn, num_bytes)
        after_data = read_memory(addr, length=num_bytes)
        self.history.insert(0, {"addr":addr, "before_data":before_data, "after_data":after_data, "physmode":get_current_mmu_mode()})
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        phys_mode = False
        if "--phys" in argv:
            if not is_supported_physmode():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            phys_mode = True
            orig_mode = get_current_mmu_mode()
            argv.remove("--phys")

        if phys_mode:
            if orig_mode == "virt":
                enable_phys()

        if argv:
            try:
                addr = parse_address(' '.join(argv))
            except:
                self.usage()
                if phys_mode:
                    if orig_mode == "virt":
                        disable_phys()
                return
        else:
            addr = current_arch.pc

        self.patch_trap(addr)

        if phys_mode:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchRetCommand(PatchCommand):
    """Patch the instruction(s) pointed by parameters with RET. Note: this command is architecture aware."""
    _cmdline_ = "patch ret"
    _syntax_ = "{:s} [-h] [--phys] [LOCATION]".format(_cmdline_)
    _example_ = "{:s} $pc".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def patch_ret(self, addr):
        if is_arm32() and current_arch.is_thumb() and addr & 1:
            addr -= 1

        num_bytes = len(current_arch.ret_insn)
        ok("Patching {:d} bytes from {:s}".format(num_bytes, format_address(addr)))
        before_data = read_memory(addr, length=num_bytes)
        write_memory(addr, current_arch.ret_insn, num_bytes)
        after_data = read_memory(addr, length=num_bytes)
        self.history.insert(0, {"addr":addr, "before_data":before_data, "after_data":after_data, "physmode":get_current_mmu_mode()})
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        phys_mode = False
        if "--phys" in argv:
            if not is_supported_physmode():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            phys_mode = True
            orig_mode = get_current_mmu_mode()
            argv.remove("--phys")

        if phys_mode:
            if orig_mode == "virt":
                enable_phys()

        if argv:
            try:
                addr = parse_address(' '.join(argv))
            except:
                self.usage()
                if phys_mode:
                    if orig_mode == "virt":
                        disable_phys()
                return
        else:
            addr = current_arch.pc

        self.patch_ret(addr)

        if phys_mode:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchHistoryCommand(PatchCommand):
    """Show patch history."""
    _cmdline_ = "patch history"
    _syntax_ = _cmdline_
    _category_ = "Show/Modify Memory"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if self.history:
            for i, hist in enumerate(self.history):
                b = ' '.join(["{:02x}".format(x) for x in hist["before_data"][:0x10]])
                if len(hist["before_data"]) > 0x10:
                    b += "..."
                a = ' '.join(["{:02x}".format(x) for x in hist["after_data"][:0x10]])
                if len(hist["after_data"]) > 0x10:
                    a += "..."
                sym = get_symbol_string(hist["addr"])
                gef_print("[{:d}] {:#x}{:s}: {:s} -> {:s}".format(i, hist["addr"], sym, b, a))
        else:
            info("Patch history is empty.")
        return


@register_command
class PatchRevertCommand(PatchCommand):
    """Revert patch history."""
    _cmdline_ = "patch revert"
    _syntax_ = "{:s} [-h] HISTORY".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        try:
            revert_target = int(argv[0])
        except:
            self.usage()
            gef_print("")
            info("Patch history")
            gdb.execute("patch history")
            return

        if not (0 <= revert_target < len(self.history)):
            err("Invalid target index")
            return

        revert_count = revert_target + 1
        while self.history and revert_count > 0:
            hist = self.history.pop(0)
            b = ' '.join(["{:02x}".format(x) for x in hist["before_data"][:0x10]])
            if len(hist["before_data"]) > 0x10:
                b += "..."
            a = ' '.join(["{:02x}".format(x) for x in hist["after_data"][:0x10]])
            if len(hist["after_data"]) > 0x10:
                a += "..."
            sym = get_symbol_string(hist["addr"])
            info("revert {:#x}{:s}: {:s} -> {:s}".format(hist["addr"], sym, a, b))

            if is_supported_physmode():
                orig_mode = get_current_mmu_mode()
                if orig_mode == "virt" and hist["physmode"] == "phys":
                    enable_phys()
                elif orig_mode == "phys" and hist["physmode"] == "virt":
                    disable_phys()

            write_memory(hist["addr"], hist["before_data"], length=len(hist["before_data"]))

            if is_supported_physmode():
                if orig_mode == "virt" and get_current_mmu_mode() == "phys":
                    disable_phys()
                elif orig_mode == "phys" and get_current_mmu_mode() == "virt":
                    enable_phys()

            revert_count -= 1
        return

@lru_cache()
def dereference_from(addr):
    if not is_alive():
        return [format_address(addr),]

    code_color = get_gef_setting("theme.dereference_code")
    string_color = get_gef_setting("theme.dereference_string")
    max_recursion = get_gef_setting("dereference.max_recursion") or 4
    blacklist = eval(get_gef_setting("dereference.blacklist")) or []
    addr = lookup_address(align_address(int(addr)))
    msg = []
    seen_addrs = set()

    # parse pattern
    #   ... -> addr -> seen_address (loop)
    #   ... -> addr (blacklist)
    #   ... -> addr -> ...
    #   ... -> string
    #   ... -> value
    while max_recursion:
        # check loop
        #   ... -> addr -> seen_address (loop)
        if len(msg) > 1 and addr.value in seen_addrs:
            # If the address 0x0 is mapped, the loop is detected at the address 0x0.
            # but it is generally unnecessary information, so it is omitted.
            if addr.value != 0:
                msg.append("[loop detected]")
            return msg
        seen_addrs.add(addr.value)
        max_recursion -= 1

        #   ... -> addr (blacklist)
        for baddr in blacklist:
            if baddr[0] <= addr.value < baddr[1]:
                msg.append(addr)
                msg.append("[blacklist detected]")
                return msg

        # if addr is mapped to the HW device, an exception occurs, so we add the address to blacklilst -> exit
        try:
            # Is this value a pointer or a value?
            # -- If it's a pointer, dereference
            deref = addr.dereference()
        except:
            start = addr.value & ~(gef_getpagesize()-1)
            end = start + gef_getpagesize()
            err("Receive ignoring packets during access at {:#x}.".format(addr.value))
            err("Add {:#x}-{:#x} to blacklist addresses".format(start, end))
            new_blacklist = blacklist + [[start, end]]
            set_gef_setting("dereference.blacklist", new_blacklist, str, "dereference blacklist to avoid timeout")
            gdb.execute("gef save")
            info("blacklist saved to .gef.rc, edit manually to clear")
            info("try to exit. do restart")
            os._exit(0)

        if deref is not None:
            # it can be referenced
            #   ... -> addr -> ...
            msg.append(addr)
            addr = lookup_address(deref)
            continue # goto next loop

        else:
            # if here, dereferencing addr has triggered a MemoryError, no need to go further
            # but we should check if it is string or value

            # try to parse the string from prev
            #   ... -> string
            if len(msg) > 0: # need address of string
                prev = msg[-1]
                if is_ascii_string(prev.value):
                    s = read_cstring_from_memory(prev.value)
                    if len(s) < get_memory_alignment():
                        txt = '{:s} ({:s}?)'.format(format_address(addr.value), Color.colorify(repr(s), string_color))
                    elif len(s) > 50:
                        txt = Color.colorify('{:s}[...]'.format(repr(s[:50])), string_color)
                    else:
                        txt = Color.colorify('{:s}'.format(repr(s)), string_color)
                    msg.append(txt)
                    return msg

            # if not able to parse cleanly, simply display and return
            #   ... -> value
            msg.append(addr)
            return msg

    # reached to max_recursion
    return msg


@register_command
class DereferenceCommand(GenericCommand):
    """Dereference recursively from an address and display information. This acts like WinDBG `dps` command."""
    _cmdline_ = "dereference"
    _syntax_ = "{:s} [-h] [LOCATION] [[L]NUM]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} $sp L20 # print 20 lines from $sp\n".format(_cmdline_)
    _example_ += "{:s} $sp 20 # same as above".format(_cmdline_)
    _category_ = "Show/Modify Memory"
    _aliases_ = ["telescope", ]
    _repeat_ = True

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        self.add_setting("max_recursion", 4, "Maximum level of pointer recursion")
        self.add_setting("blacklist", "[]", "Dereference black address")
        return

    @staticmethod
    def pprint_dereferenced(addr, idx):
        base_address_color = get_gef_setting("theme.dereference_base_address")
        registers_color = get_gef_setting("theme.dereference_register_value")
        max_recursion = get_gef_setting("dereference.max_recursion") or 4

        sep = " {:s} ".format(RIGHT_ARROW)
        memalign = current_arch.ptrsize

        offset = idx * memalign
        current_address = align_address(addr + offset)
        # addrs: [Address(rax), Address(deref_of_rax), Address(deref_of_deref_of_rax), ..., str(msg)]
        addrs = dereference_from(current_address)
        if len(addrs) == 1: # cannot access this area
            raise

        # create address link list
        link = ""
        for addr in addrs[1:]:
            if link:
                link += sep
            if isinstance(addr, Address):
                link += str(addr) + get_symbol_string(addr.value)
            else:
                link += addr # actually this is msg

        # add "..." or not
        if max_recursion <= len(addrs) and isinstance(addrs[-1], Address):
            subseq_addrs = dereference_from(addrs[-1].value)
            if len(subseq_addrs) > 1:
                link += sep + "..."

        # craete line of one entry
        l = ""
        addr_l = format_address(addrs[0].value)
        addr_l_c = Color.colorify(addr_l, base_address_color)
        idx = offset // memalign
        ma = memalign * 2 + 2
        l += "{:s}{:s}+{:#06x}({:03d}): {:{ma}s}".format(addr_l_c, VERTICAL_LINE, offset, idx, link, ma=ma)

        # retaddr info
        current_address_value = read_int_from_memory(current_address)
        try:
            frame = gdb.newest_frame()
            i = 0
            seen = []
            while frame:
                if frame.pc() == 0:
                    break
                if frame.pc() in seen:
                    break
                seen.append(frame.pc())
                if current_address_value == frame.pc():
                    m = " {:s} retaddr[{:d}]".format(LEFT_ARROW, i)
                    l += Color.colorify(m, registers_color)
                frame = frame.older()
                i += 1
        except:
            pass

        # canary info
        try:
            res = gef_read_canary()
            if res:
                canary, location = res
                if current_address_value == canary:
                    m = " {:s} canary".format(LEFT_ARROW)
                    l += Color.colorify(m, registers_color)
        except:
            pass

        # register info
        try:
            register_hints = []
            for regname in current_arch.all_registers:
                regvalue = get_register(regname)
                if current_address == regvalue:
                    register_hints.append(regname)
            if register_hints:
                m = " {:s} {:s}".format(LEFT_ARROW, ", ".join(list(register_hints)))
                l += Color.colorify(m, registers_color)
        except:
            pass

        offset += memalign
        return l

    @only_if_gdb_running
    def do_invoke(self, argv):
        if "-h" in argv:
            self.usage()
            return

        target = "$sp"
        nb = 10

        for arg in argv:
            if arg.isdigit():
                nb = int(arg)
            elif arg[0] in ("l", "L") and arg[1:].isdigit():
                nb = int(arg[1:])
            else:
                target = arg

        addr = safe_parse_and_eval(target)
        if addr is None:
            err("Invalid address")
            return

        try:
            addr = to_unsigned_long(addr)
        except:
            err("Invalid address")
            return

        if get_gef_setting("context.grow_stack_down") is True:
            from_insnum = nb * (self.repeat_count + 1) - 1
            to_insnum = self.repeat_count * nb - 1
            insnum_step = -1
        else:
            from_insnum = 0 + self.repeat_count * nb
            to_insnum = nb * (self.repeat_count + 1)
            insnum_step = 1

        start_address = align_address(addr)

        for i in range(from_insnum, to_insnum, insnum_step):
            try:
                gef_print(DereferenceCommand.pprint_dereferenced(start_address, i))
            except:
                err("Cannot access memory at address {:#x}".format(start_address + i * current_arch.ptrsize))
                break
        return


@register_command
class ASLRCommand(GenericCommand):
    """View/modify the ASLR setting of GDB. By default, GDB will disable ASLR when it starts the process (i.e. not
    attached). This command allows to change that setting."""
    _cmdline_ = "aslr"
    _syntax_ = "{:s} (on|off)".format(_cmdline_)
    _category_ = "Process Information"

    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        argc = len(argv)

        if argc == 0:
            ret = gdb.execute("show disable-randomization", to_string=True)
            i = ret.find("virtual address space is ")
            if i < 0:
                return
            msg = "ASLR is currently "
            if ret[i + 25:].strip() == "on.":
                msg += Color.redify("disabled")
            else:
                msg += Color.greenify("enabled")
            gef_print(msg)
            return

        elif argc == 1:
            if argv[0] == "on":
                info("Enabling ASLR")
                gdb.execute("set disable-randomization off")
                return
            elif argv[0] == "off":
                info("Disabling ASLR")
                gdb.execute("set disable-randomization on")
                return
            warn("Invalid command")
        self.usage()
        return


@register_command
class ResetCacheCommand(GenericCommand):
    """Reset cache of all stored data. This command is here for debugging and test purposes, GEF
    handles properly the cache reset under "normal" scenario."""
    _cmdline_ = "reset-cache"
    _syntax_ = _cmdline_
    _category_ = "GEF Maintenance Command"

    def do_invoke(self, argv):
        self.dont_repeat()
        reset_all_caches()
        return


@register_command
class VMMapCommand(GenericCommand):
    """Display a comprehensive layout of the virtual memory mapping. If a filter argument, GEF will
    filter out the mapping whose pathname do not match that filter."""
    _cmdline_ = "vmmap"
    _syntax_ = "{:s} [--outer] [-v] [FILTER]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} libc # print entry only `libc`\n".format(_cmdline_)
    _example_ += "{:s} --outer # show qemu-user memory map; only valid in qemu-user mode\n".format(_cmdline_)
    _example_ += "{:s} -v # show register info".format(_cmdline_)
    _category_ = "Process Information"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if is_qemu_system():
            info("Redirect to pagewalk")
            gdb.execute("pagewalk {:s} {:s}".format(current_arch.arch.lower(), ' '.join(argv)))
            return

        outer = False
        if "--outer" in argv:
            argv.remove("--outer")
            if is_qemu_usermode():
                outer = True
            else:
                err("Unsupported")
                return

        self.verbose = False
        if "-v" in argv:
            argv.remove("-v")
            self.verbose = True

        if is_qemu_usermode():
            clear_explored_auxv()
            clear_explored_regions()

        vmmap = get_process_maps(outer)
        if not vmmap:
            for line in gdb.execute('info files', to_string=True).splitlines():
                if line.startswith("Symbols from"):
                    break
            else:
                err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            err("No address mapping information found")
            return

        if not get_gef_setting("gef.disable_color"):
            self.show_legend()

        color = get_gef_setting("theme.table_heading")
        headers = ["Start", "End", "Size", "Offset", "Perm", "Path"]
        w = get_memory_alignment() * 2 + 3
        gef_print(Color.colorify("{:<{w}s}{:<{w}s}{:<{w}s}{:<{w}s}{:<4s} {:s}".format(*headers, w=w), color))

        for entry in vmmap:
            if not argv:
                self.print_entry(entry)
                continue
            if argv[0] in entry.path:
                self.print_entry(entry)
            elif self.is_integer(argv[0]):
                addr = int(argv[0], 0)
                if addr >= entry.page_start and addr < entry.page_end:
                    self.print_entry(entry)

        if is_qemu_usermode():
            info("Searched from auxv, registers, stack values. There may be areas that cannot be detected.")
        return

    def print_entry(self, entry):
        line_color = ""
        if entry.path == "[stack]":
            line_color = get_gef_setting("theme.address_stack")
        elif entry.path == "[heap]":
            line_color = get_gef_setting("theme.address_heap")
        elif entry.permission.value & Permission.READ and entry.permission.value & Permission.EXECUTE:
            line_color = get_gef_setting("theme.address_code")

        l = []
        l.append(Color.colorify(format_address(entry.page_start), line_color))
        l.append(Color.colorify(format_address(entry.page_end), line_color))
        l.append(Color.colorify(format_address(entry.size), line_color))
        l.append(Color.colorify(format_address(entry.offset), line_color))

        if entry.permission.value == (Permission.READ|Permission.WRITE|Permission.EXECUTE):
            l.append(Color.colorify(str(entry.permission), "underline " + line_color))
        else:
            l.append(Color.colorify(str(entry.permission), line_color))

        l.append(Color.colorify(entry.path, line_color))
        line = " ".join(l)

        # register info
        if self.verbose:
            register_hints = []
            for regname in current_arch.all_registers:
                regvalue = get_register(regname)
                if entry.page_start <= regvalue < entry.page_end:
                    register_hints.append(regname)
            if register_hints:
                m = " {:s} {:s}".format(LEFT_ARROW, ", ".join(list(register_hints)))
                registers_color = get_gef_setting("theme.dereference_register_value")
                line += Color.colorify(m, registers_color)

        gef_print(line)
        return

    def show_legend(self):
        code_addr_color = get_gef_setting("theme.address_code")
        stack_addr_color = get_gef_setting("theme.address_stack")
        heap_addr_color = get_gef_setting("theme.address_heap")

        code = Color.colorify("Code", code_addr_color)
        heap = Color.colorify("Heap", heap_addr_color)
        stack = Color.colorify("Stack", stack_addr_color)

        gef_print("[ Legend:  {} | {} | {} ]".format(code, heap, stack))
        return

    def is_integer(self, n):
        try:
            int(n, 0)
        except ValueError:
            return False
        return True


@register_command
class XFilesCommand(GenericCommand):
    """Shows all libraries (and sections) loaded by binary. This command extends the GDB command
    `info files`, by retrieving more information from extra sources, and providing a better
    display with REGEX filtering."""
    _cmdline_ = "xfiles"
    _syntax_ = "{:s} [REGEX]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} libc\n".format(_cmdline_)
    _example_ += "{:s} IO_vtables".format(_cmdline_)
    _category_ = "Process Information"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        color = get_gef_setting("theme.table_heading")
        headers = ["Start", "End", "Name", "File"]
        gef_print(Color.colorify("{:<{w}s}{:<{w}s}{:<21s} {:s}".format(*headers, w=get_memory_alignment()*2+3), color))

        filter_pattern = argv

        for xfile in get_info_files():
            l = []
            l.append(format_address(xfile.zone_start))
            l.append(format_address(xfile.zone_end))
            l.append("{:<21s}".format(xfile.name))
            l.append(xfile.filename)
            l = " ".join(l)

            if not filter_pattern:
                gef_print(l)
            else:
                for filt in filter_pattern:
                    if re.search(filt, l):
                        gef_print(l)
        return


@register_command
class XAddressInfoCommand(GenericCommand):
    """Retrieve and display runtime information for the location(s) given as parameter."""
    _cmdline_ = "xinfo"
    _syntax_ = "{:s} LOCATION".format(_cmdline_)
    _example_ = "{:s} $pc".format(_cmdline_)
    _category_ = "Process Information"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if not argv:
            err ("At least one valid address must be specified")
            self.usage()
            return

        for sym in argv:
            try:
                addr = align_address(parse_address(sym))
                gef_print(titlify("xinfo: {:#x}".format(addr)))
                self.infos(addr)

            except gdb.error as gdb_err:
                err("{:s}".format(str(gdb_err)))
        return

    def infos(self, address):
        addr = lookup_address(address)
        if not addr.valid:
            warn("Cannot reach {:#x} in memory space".format(address))
            return

        sect = addr.section
        info = addr.info

        if sect:
            page_start = format_address(sect.page_start)
            page_end = format_address(sect.page_end)
            page_size = sect.page_end - sect.page_start
            gef_print("Page: {:s} {:s} {:s} (size={:#x})".format(page_start, RIGHT_ARROW, page_end, page_size))
            gef_print("Permissions: {}".format(sect.permission))
            gef_print("Pathname: {:s}".format(sect.path))
            gef_print("Offset (from page): {:#x}".format(addr.value - sect.page_start))
            if sect.inode:
                gef_print("Inode: {:s}".format(sect.inode))

        if info:
            zone_start = format_address(info.zone_start)
            zone_end = format_address(info.zone_end)
            gef_print("Segment: {:s} ({:s}-{:s})".format(info.name, zone_start, zone_end))
            gef_print("Offset (from segment): {:#x}".format(addr.value - info.zone_start))

        sym = gdb_get_location_from_symbol(address)
        if sym:
            name, offset = sym
            msg = "Symbol: {:s}".format(name)
            if offset:
                msg+= "+{:d}".format(offset)
            gef_print(msg)

        return


@register_command
class XorMemoryCommand(GenericCommand):
    """XOR a block of memory. The command allows to simply display the result, or patch it
    runtime at runtime."""
    _cmdline_ = "xor-memory"
    _syntax_ = "{:s} (display|patch) ADDRESS SIZE KEY".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(prefix=True)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()
        self.usage()
        return


@register_command
class XorMemoryDisplayCommand(GenericCommand):
    """Display a block of memory pointed by ADDRESS by xor-ing each byte with KEY. The key must be
    provided in hexadecimal format."""
    _cmdline_ = "xor-memory display"
    _syntax_ = "{:s} ADDRESS SIZE KEY".format(_cmdline_)
    _example_ = "{:s} $sp 16 41414141".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) != 3:
            self.usage()
            return

        address = parse_address(argv[0])
        length = int(argv[1], 0)
        key = argv[2]
        block = read_memory(address, length)
        info("Displaying XOR-ing {:#x}-{:#x} with {:s}".format(address, address + len(block), repr(key)))

        gef_print(titlify("Original block"))
        gef_print(hexdump(block, base=address))

        gef_print(titlify("XOR-ed block"))
        gef_print(hexdump(xor(block, key), base=address))
        return


@register_command
class XorMemoryPatchCommand(GenericCommand):
    """Patch a block of memory pointed by ADDRESS by xor-ing each byte with KEY. The key must be
    provided in hexadecimal format."""
    _cmdline_ = "xor-memory patch"
    _syntax_ = "{:s} ADDRESS SIZE KEY".format(_cmdline_)
    _example_ = "{:s} $sp 16 41414141".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) != 3:
            self.usage()
            return

        address = parse_address(argv[0])
        length = int(argv[1], 0)
        key = argv[2]
        block = read_memory(address, length)
        info("Patching XOR-ing {:#x}-{:#x} with '{:s}'".format(address, address + len(block), key))
        xored_block = xor(block, key)
        write_memory(address, xored_block, length)
        return


@register_command
class TraceRunCommand(GenericCommand):
    """Create a runtime trace of all instructions executed from $pc to LOCATION specified. The
    trace is stored in a text file that can be next imported in IDA Pro to visualize the runtime path."""
    _cmdline_ = "trace-run"
    _syntax_ = "{:s} LOCATION [MAX_CALL_DEPTH]".format(_cmdline_)
    _example_ = "{:s} 0x555555554610".format(_cmdline_)
    _category_ = "Debugging Support"

    def __init__(self):
        super().__init__(self._cmdline_, complete=gdb.COMPLETE_LOCATION)
        self.add_setting("max_tracing_recursion", 1, "Maximum depth of tracing")
        self.add_setting("tracefile_prefix", "./gef-trace-", "Specify the tracing output file prefix")
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) not in (1, 2):
            self.usage()
            return

        if len(argv) == 2 and argv[1].isdigit():
            depth = int(argv[1])
        else:
            depth = 1

        try:
            loc_start = current_arch.pc
            loc_end = parse_address(argv[0])
        except gdb.error as e:
            err("Invalid location: {:s}".format(e))
            return

        self.trace(loc_start, loc_end, depth)
        return

    def get_frames_size(self):
        n = 0
        f = gdb.newest_frame()
        while f:
            n += 1
            f = f.older()
        return n

    def trace(self, loc_start, loc_end, depth):
        info("Tracing from {:#x} to {:#x} (max depth={:d})".format(loc_start, loc_end, depth))
        logfile = "{:s}{:#x}-{:#x}.txt".format(self.get_setting("tracefile_prefix"), loc_start, loc_end)
        enable_redirect_output(to_file=logfile)
        hide_context()
        self.start_tracing(loc_start, loc_end, depth)
        unhide_context()
        disable_redirect_output()
        ok("Done, logfile stored as '{:s}'".format(logfile))
        return

    def start_tracing(self, loc_start, loc_end, depth):
        loc_cur = loc_start
        frame_count_init = self.get_frames_size()

        gef_print("#")
        gef_print("# Execution tracing of {:s}".format(get_filepath()))
        gef_print("# Start address: {:s}".format(format_address(loc_start)))
        gef_print("# End address: {:s}".format(format_address(loc_end)))
        gef_print("# Recursion level: {:d}".format(depth))
        gef_print("# automatically generated by gef.py")
        gef_print("#\n")

        while loc_cur != loc_end:
            try:
                delta = self.get_frames_size() - frame_count_init

                if delta <= depth:
                    gdb.execute("stepi")
                else:
                    gdb.execute("finish")

                loc_cur = current_arch.pc
                gdb.flush()

            except gdb.error as e:
                gef_print("#")
                gef_print("# Execution interrupted at address {:s}".format(format_address(loc_cur)))
                gef_print("# Exception: {:s}".format(e))
                gef_print("#\n")
                break
        return


@register_command
class PatternCommand(GenericCommand):
    """This command will create or search a De Bruijn cyclic pattern to facilitate
    determining the offset in memory. The algorithm used is the same as the one
    used by pwntools, and can therefore be used in conjunction."""
    _cmdline_ = "pattern"
    _syntax_ = "{:s} (create|search) ARGS".format(_cmdline_)
    _category_ = "Exploit Development"

    def __init__(self, *args, **kwargs):
        super().__init__(prefix=True)
        self.add_setting("length", 1024, "Initial length of a cyclic buffer to generate")
        return

    def do_invoke(self, argv):
        self.dont_repeat()
        self.usage()
        return


@register_command
class PatternCreateCommand(GenericCommand):
    """Generate a de Bruijn cyclic pattern. It will generate a pattern long of SIZE,
    incrementally varying of one byte at each generation. The length of each block is
    equal to sizeof(void*).
    Note: This algorithm is the same than the one used by pwntools library."""
    _cmdline_ = "pattern create"
    _syntax_ = "{:s} [SIZE]".format(_cmdline_)
    _aliases_ = ["pattc",]
    _category_ = "Exploit Development"

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 1:
            try:
                sz = int(argv[0], 0)
            except ValueError:
                err("Invalid size")
                return
            set_gef_setting("pattern.length", sz)
        elif len(argv) > 1:
            err("Invalid syntax")
            return

        size = get_gef_setting("pattern.length")
        info("Generating a pattern of {:d} bytes".format(size))
        pattern_str = gef_pystring(generate_cyclic_pattern(size))
        gef_print(pattern_str)
        ok("Saved as '{:s}'".format(gef_convenience(pattern_str)))
        return


@register_command
class PatternSearchCommand(GenericCommand):
    """Search for the cyclic de Bruijn pattern generated by the `pattern create` command. The
    PATTERN argument can be a GDB symbol (such as a register name) or an hexadecimal value."""
    _cmdline_ = "pattern search"
    _syntax_ = "{:s} PATTERN [SIZE]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} $pc\n".format(_cmdline_)
    _example_ += "{:s} 0x61616164\n".format(_cmdline_)
    _example_ += "{:s} aaab".format(_cmdline_)
    _category_ = "Exploit Development"
    _aliases_ = ["patto",]

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        argc = len(argv)
        if argc not in (1, 2):
            self.usage()
            return

        if argc == 2:
            try:
                size = int(argv[1], 0)
            except ValueError:
                err("Invalid size")
                return
        else:
            size = get_gef_setting("pattern.length")

        pattern = argv[0]
        info("Searching '{:s}'".format(pattern))
        self.search(pattern, size)
        return

    def search(self, pattern, size):
        pattern_be, pattern_le = None, None

        # 1. check if it's a symbol (like "$sp" or "0x1337")
        symbol = safe_parse_and_eval(pattern)
        if symbol:
            addr = to_unsigned_long(symbol)
            dereferenced_value = dereference(addr)
            # 1-bis. try to dereference
            if dereferenced_value:
                addr = int(dereferenced_value)

            if current_arch.ptrsize == 4:
                pattern_be = struct.pack(">I", addr)
                pattern_le = struct.pack("<I", addr)
            else:
                pattern_be = struct.pack(">Q", addr)
                pattern_le = struct.pack("<Q", addr)

        else:
            # 2. assume it's a plain string
            pattern_be = gef_pybytes(pattern)
            pattern_le = gef_pybytes(pattern[::-1])

        pattern_be = pattern_be.strip(b"\0")
        pattern_le = pattern_le.strip(b"\0")

        cyclic_pattern = generate_cyclic_pattern(size)
        found = False
        off = cyclic_pattern.find(pattern_le)
        if off >= 0:
            fmt = "Found at offset {:d} (little-endian search) {:s}"
            ok(fmt.format(off, Color.colorify("likely", "bold red") if is_little_endian() else ""))
            found = True

        off = cyclic_pattern.find(pattern_be)
        if off >= 0:
            fmt = "Found at offset {:d} (big-endian search) {:s}"
            ok(fmt.format(off, Color.colorify("likely", "bold green") if is_big_endian() else ""))
            found = True

        if not found:
            err("Pattern '{}' not found".format(pattern))
        return


@register_command
class ChecksecCommand(GenericCommand):
    """Checksec the security properties of the current executable or passed as argument. The
    command checks for the following protections: Canary, NX, PIE, RELRO, Fortify, CET, RPATH, RUNPATH, ASLR"""
    _cmdline_ = "checksec"
    _syntax_ = "{:s} [FILENAME]".format(_cmdline_)
    _example_ = "{:s} /bin/ls".format(_cmdline_)
    _category_ = "Process Information"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        if is_qemu_system():
            self.print_security_properties_qemu_system()
            return

        try:
            readelf = which("readelf")
        except IOError:
            err("Missing `readelf`")
            return

        argc = len(argv)

        if argc == 0:
            filename = get_filepath()
            if filename is None or open(filename, "rb").read(4) != b"\x7fELF":
                if is_qemu_usermode():
                    err("Missing info about architecture. Please set: `file /path/to/target_binary`")
                    return
                else:
                    err("No executable/library specified")
                    return
        elif argc == 1:
            filename = os.path.realpath(os.path.expanduser(argv[0]))
            if not os.access(filename, os.R_OK):
                err("Invalid filename")
                return
        else:
            self.usage()
            return

        info("{:s} for '{:s}'".format(self._cmdline_, filename))
        self.print_security_properties(filename)
        return

    def print_security_properties(self, filename):

        def get_colored_msg(val):
            if val is True:
                msg = Color.greenify(Color.boldify("Enabled"))
            elif val is False:
                msg = Color.redify(Color.boldify("Disabled"))
            elif val is None:
                msg = Color.grayify(Color.boldify("Unknown"))
            return msg

        sec = checksec(filename)

        # Static
        if sec["Static"]:
            gef_print("{:<30s}: {:s}".format("Static/Dynamic", "Static"))
        else:
            gef_print("{:<30s}: {:s}".format("Static/Dynamic", "Dynamic"))

        # Stripped
        if sec["Stripped"]:
            gef_print("{:<30s}: {:s}".format("Stripped", Color.colorify("Yes", "green bold")))
        else:
            gef_print("{:<30s}: {:s}".format("Stripped", Color.colorify("No", "red bold") + " (The symbol remains)"))

        # Canary
        msg = get_colored_msg(sec["Canary"])
        if sec["Canary"] is True and is_alive():
            res = gef_read_canary()
            if not res:
                msg += " (Could not get the canary value)"
            else:
                msg += " (value: {:#x})".format(res[0])
        gef_print("{:<30s}: {:s}".format("Canary", msg))

        # NX
        gef_print("{:<30s}: {:s}".format("NX", get_colored_msg(sec["NX"])))

        # PIE
        gef_print("{:<30s}: {:s}".format("PIE", get_colored_msg(sec["PIE"])))

        # RELRO
        if sec["Full RELRO"]:
            gef_print("{:<30s}: {:s}".format("RELRO", Color.colorify("Full RELRO", "green bold")))
        elif sec["Partial RELRO"]:
            gef_print("{:<30s}: {:s}".format("RELRO", Color.colorify("Partial RELRO", "yellow bold")))
        else:
            gef_print("{:<30s}: {:s}".format("RELRO", Color.colorify("No RELRO", "red bold")))

        # Fortify
        if sec["Fortify"]:
            gef_print("{:<30s}: {:s}".format("Fortify", Color.colorify("Found", "green bold")))
        else:
            gef_print("{:<30s}: {:s}".format("Fortify", Color.colorify("Not Found", "red bold")))

        # CET
        if sec["Intel CET"]:
            gef_print("{:<30s}: {:s}".format("Intel CET", Color.colorify("Found", "green bold") + " (endbr64/endbr32 is found)"))
        else:
            gef_print("{:<30s}: {:s}".format("Intel CET", Color.colorify("Not Found", "red bold") + " (endbr64/endbr32 is not found)"))

        # RPATH
        if not sec["RPATH"]:
            gef_print("{:<30s}: {:s}".format("RPATH", Color.colorify("Not Found", "green bold")))
        else:
            gef_print("{:<30s}: {:s}".format("RPATH", Color.colorify("Found", "red bold")))

        # RUNPATH
        if not sec["RUNPATH"]:
            gef_print("{:<30s}: {:s}".format("RUNPATH", Color.colorify("Not Found", "green bold")))
        else:
            gef_print("{:<30s}: {:s}".format("RUNPATH", Color.colorify("Found", "red bold")))

        # Clang CFI
        if sec["Clang CFI"]:
            gef_print("{:<30s}: {:s}".format("Clang CFI", get_colored_msg(sec["Clang CFI"])))

        # Clang SafeStack
        if sec["Clang SafeStack"]:
            gef_print("{:<30s}: {:s}".format("Clang SafeStack", get_colored_msg(sec["Clang SafeStack"])))

        # System-ASLR
        if not is_remote_debug() or is_remote_but_same_host():
            try:
                system_aslr = int(open("/proc/sys/kernel/randomize_va_space").read())
                if system_aslr == 0:
                    gef_print("{:<30s}: {:s} (randomize_va_space: 0)".format("System ASLR", Color.colorify("Disabled", "red bold")))
                elif system_aslr == 1:
                    gef_print("{:<30s}: {:s} (randomize_va_space: 1)".format("System ASLR", Color.colorify("Partially Enabled", "yellow bold")))
                elif system_aslr == 2:
                    gef_print("{:<30s}: {:s} (randomize_va_space: 2)".format("System ASLR", Color.colorify("Enabled", "green bold")))
            except:
                gef_print("{:<30s}: {:s} (randomize_va_space: error)".format("System-ASLR", Color.colorify("Unknown", "gray bold")))
        else:
            gef_print("{:<30s}: {:s} (attached remote process)".format("System-ASLR", Color.colorify("Unknown", "gray bold")))

        # attached or not
        ret = gdb.execute("info files", to_string=True)
        if "Using the running image of child Thread" in ret or "Using the running image of child process" in ret:
            # gdb ASLR
            ret = gdb.execute("show disable-randomization", to_string=True)
            if "virtual address space is on." in ret:
                gef_print("{:<30s}: {:s} (disable-randomization: on)".format("GDB ASLR setting", Color.colorify("Disabled", "red bold")))
            elif "virtual address space is off." in ret:
                gef_print("{:<30s}: {:s} (disable-randomization: off)".format("GDB ASLR setting", Color.colorify("Enabled", "green bold")))
            else:
                gef_print("{:<30s}: {:s}".format("GDB ASLR setting", Color.colorify("Unknown", "gray bold")))
        elif "Using the running image of attached process" in ret:
            gef_print("{:<30s}: {:s} (attached process)".format("GDB ASLR setting", Color.colorify("Ignored", "gray bold")))
        elif "Debugging a target over a serial line." in ret:
            gef_print("{:<30s}: {:s} (attached process)".format("GDB ASLR setting", Color.colorify("Ignored", "gray bold")))
        return

    def print_security_properties_qemu_system(self):
        if not is_x86():
            return
        ret = gdb.execute("qreg -v", to_string=True)
        flag = False
        for line in ret.splitlines():
            if "CR0 (Control Register 0)" in line:
                flag = True
            if "CR1 (Control Register 1)" in line:
                flag = False
            if "CR4 (Control Register 4)" in line:
                flag = True
            if "DR0-DR3 (Debug Address Register 0-3)" in line:
                flag = False
            if flag:
                gef_print(line)
        return


@register_command
class SropHintCommand(GenericCommand):
    """Hint for sigreturn oriented programming."""
    _cmdline_ = "srop-hint"
    _syntax_ = "{:s} [-a x86|x64|arm|aarch64]".format(_cmdline_)
    _category_ = "Exploit Development"

    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if len(argv) >= 2:
            if argv[0] == "-a" and argv[1] in ["x86", "x64", "arm", "aarch64"]:
                mode = argv[1]
            else:
                self.usage()
                return
        else:
            if is_x86_64():
                mode = "x64"
            elif is_x86_32():
                mode = "x86"
            elif is_arm32():
                mode = "arm"
            elif is_arm64():
                mode = "aarch64"
            else:
                mode = "x64"

        s = ""
        if mode == "x64":
            s += 'exp  = struct.pack("<Q", syscall)    # rax = 15 (rt_sigreturn)\n'
            s += 'exp += struct.pack("<Q", 0xcafebabe) # rt_sigframe.pretcode\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_flags\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_link\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_stack.ss_sp\n'
            s += 'exp += struct.pack("<I", 0x0)        # rt_sigframe.uc.uc_stack.ss_flags\n'
            s += 'exp += struct.pack("<I", 0x0)        # rt_sigframe.uc.uc_stack.ss_size\n'
            s += 'exp += struct.pack("<Q", 0x08)       # rt_sigframe.uc.uc_mcontext.r8\n'
            s += 'exp += struct.pack("<Q", 0x09)       # rt_sigframe.uc.uc_mcontext.r9\n'
            s += 'exp += struct.pack("<Q", 0x0a)       # rt_sigframe.uc.uc_mcontext.r10\n'
            s += 'exp += struct.pack("<Q", 0x0b)       # rt_sigframe.uc.uc_mcontext.r11\n'
            s += 'exp += struct.pack("<Q", 0x0c)       # rt_sigframe.uc.uc_mcontext.r12\n'
            s += 'exp += struct.pack("<Q", 0x0d)       # rt_sigframe.uc.uc_mcontext.r13\n'
            s += 'exp += struct.pack("<Q", 0x0e)       # rt_sigframe.uc.uc_mcontext.r14\n'
            s += 'exp += struct.pack("<Q", 0x0f)       # rt_sigframe.uc.uc_mcontext.r15\n'
            s += 'exp += struct.pack("<Q", 0x07)       # rt_sigframe.uc.uc_mcontext.rdi\n'
            s += 'exp += struct.pack("<Q", 0x06)       # rt_sigframe.uc.uc_mcontext.rsi\n'
            s += 'exp += struct.pack("<Q", 0x05)       # rt_sigframe.uc.uc_mcontext.rbp\n'
            s += 'exp += struct.pack("<Q", 0x02)       # rt_sigframe.uc.uc_mcontext.rbx\n'
            s += 'exp += struct.pack("<Q", 0x04)       # rt_sigframe.uc.uc_mcontext.rdx\n'
            s += 'exp += struct.pack("<Q", 0x01)       # rt_sigframe.uc.uc_mcontext.rax\n'
            s += 'exp += struct.pack("<Q", 0x03)       # rt_sigframe.uc.uc_mcontext.rcx\n'
            s += 'exp += struct.pack("<Q", 0xdeadface) # rt_sigframe.uc.uc_mcontext.rsp\n'
            s += 'exp += struct.pack("<Q", 0xdeadbeef) # rt_sigframe.uc.uc_mcontext.rip\n'
            s += 'exp += struct.pack("<Q", 0x00)       # rt_sigframe.uc.uc_mcontext.rflags\n'
            s += 'exp += struct.pack("<H", 0x33)       # rt_sigframe.uc.uc_mcontext.cs\n'
            s += 'exp += struct.pack("<H", 0x00)       # rt_sigframe.uc.uc_mcontext.gs\n'
            s += 'exp += struct.pack("<H", 0x00)       # rt_sigframe.uc.uc_mcontext.fs\n'
            s += 'exp += struct.pack("<H", 0x00)       # rt_sigframe.uc.uc_mcontext.__pad0\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.err\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.trapno\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.oldmask\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.cr2\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.fpstate # fpu/xmm are not restored if NULL\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.reserved[8]\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_sigmask\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.info\n'
        elif mode == "x86":
            s += 'exp  = struct.pack("<I", syscall)    # eax = 119 (sigreturn)\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.gs\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.fs\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.es\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.ds\n'
            s += 'exp += struct.pack("<I", 0x7)        # sigframe.sc.edi\n'
            s += 'exp += struct.pack("<I", 0x6)        # sigframe.sc.esi\n'
            s += 'exp += struct.pack("<I", 0x5)        # sigframe.sc.ebp\n'
            s += 'exp += struct.pack("<I", 0xdeadface) # sigframe.sc.esp\n'
            s += 'exp += struct.pack("<I", 0x2)        # sigframe.sc.ebx\n'
            s += 'exp += struct.pack("<I", 0x4)        # sigframe.sc.edx\n'
            s += 'exp += struct.pack("<I", 0x3)        # sigframe.sc.ecx\n'
            s += 'exp += struct.pack("<I", 0x1)        # sigframe.sc.eax\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.trapno\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.err\n'
            s += 'exp += struct.pack("<I", 0xdeadbeef) # sigframe.sc.eip\n'
            s += 'exp += struct.pack("<I", 0x23)       # sigframe.sc.cs # use 0x73 if 32bit native machine\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.eflags\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.esp_at_signal\n'
            s += 'exp += struct.pack("<I", 0x2b)       # sigframe.sc.ss # use 0x7b if 32bit native machine\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.fpstate # fpu/xmm are not restored if NULL\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.oldmask\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.cr2\n'
            s += '\n'
        elif mode == "arm":
            s += 'exp += struct.pack("<I", pop_r7_pc)  # pop {r7, pc};\n'
            s += 'exp += struct.pack("<I", 119)        # r7 = 119 (sigreturn)\n'
            s += 'exp += struct.pack("<I", call_svc)   #\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_flags\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_link\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_stack.ss_sp\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_stack.ss_flags\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_stack.ss_size\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_mcontext.trapno\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_mcontext.error_code\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_mcontext.oldmask\n'
            s += 'exp += struct.pack("<I", 0x00)       # sigframe.uc.uc_mcontext.arm_r0\n'
            s += 'exp += struct.pack("<I", 0x01)       # sigframe.uc.uc_mcontext.arm_r1\n'
            s += 'exp += struct.pack("<I", 0x02)       # sigframe.uc.uc_mcontext.arm_r2\n'
            s += 'exp += struct.pack("<I", 0x03)       # sigframe.uc.uc_mcontext.arm_r3\n'
            s += 'exp += struct.pack("<I", 0x04)       # sigframe.uc.uc_mcontext.arm_r4\n'
            s += 'exp += struct.pack("<I", 0x05)       # sigframe.uc.uc_mcontext.arm_r5\n'
            s += 'exp += struct.pack("<I", 0x06)       # sigframe.uc.uc_mcontext.arm_r6\n'
            s += 'exp += struct.pack("<I", 0x07)       # sigframe.uc.uc_mcontext.arm_r7\n'
            s += 'exp += struct.pack("<I", 0x08)       # sigframe.uc.uc_mcontext.arm_r8\n'
            s += 'exp += struct.pack("<I", 0x09)       # sigframe.uc.uc_mcontext.arm_r9\n'
            s += 'exp += struct.pack("<I", 0x0a)       # sigframe.uc.uc_mcontext.arm_r10\n'
            s += 'exp += struct.pack("<I", 0x0b)       # sigframe.uc.uc_mcontext.arm_fp\n'
            s += 'exp += struct.pack("<I", 0x0c)       # sigframe.uc.uc_mcontext.arm_ip\n'
            s += 'exp += struct.pack("<I", 0xdeadface) # sigframe.uc.uc_mcontext.arm_sp\n'
            s += 'exp += struct.pack("<I", 0x0d)       # sigframe.uc.uc_mcontext.arm_lr\n'
            s += 'exp += struct.pack("<I", 0xdeadbeef) # sigframe.uc.uc_mcontext.arm_pc\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_mcontext.arm_cpsr\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_mcontext.fault_address\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_sigmask\n'
        elif mode == "aarch64":
            s += 'exp += struct.pack("<Q", ldp_x8_x9)  # ldp x8, x9, [sp], #16; ret x9;\n'
            s += 'exp += struct.pack("<Q", 139)        # x8 = 139\n'
            s += 'exp += struct.pack("<Q", call_svc)   # \n'
            s += 'exp += struct.pack("<I", 0x0)*32     # rt_sigframe.info\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_flags\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_link\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_stack.ss_sp\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_stack.ss_flags\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_stack.ss_size\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_stack.__unused\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_sigmask\n'
            s += 'exp += struct.pack("<B", 0x0)*120    # rt_sigframe.uc.__unused[120]\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.fault_address\n'
            s += 'exp += struct.pack("<Q", 0x00)       # rt_sigframe.uc.uc_mcontext.regs[31].x0\n'
            s += 'exp += struct.pack("<Q", 0x01)       # rt_sigframe.uc.uc_mcontext.regs[31].x1\n'
            s += 'exp += struct.pack("<Q", 0x02)       # rt_sigframe.uc.uc_mcontext.regs[31].x2\n'
            s += 'exp += struct.pack("<Q", 0x03)       # rt_sigframe.uc.uc_mcontext.regs[31].x3\n'
            s += 'exp += struct.pack("<Q", 0x04)       # rt_sigframe.uc.uc_mcontext.regs[31].x4\n'
            s += 'exp += struct.pack("<Q", 0x05)       # rt_sigframe.uc.uc_mcontext.regs[31].x5\n'
            s += 'exp += struct.pack("<Q", 0x06)       # rt_sigframe.uc.uc_mcontext.regs[31].x6\n'
            s += 'exp += struct.pack("<Q", 0x07)       # rt_sigframe.uc.uc_mcontext.regs[31].x7\n'
            s += 'exp += struct.pack("<Q", 0x08)       # rt_sigframe.uc.uc_mcontext.regs[31].x8\n'
            s += 'exp += struct.pack("<Q", 0x09)       # rt_sigframe.uc.uc_mcontext.regs[31].x9\n'
            s += 'exp += struct.pack("<Q", 0x0a)       # rt_sigframe.uc.uc_mcontext.regs[31].x10\n'
            s += 'exp += struct.pack("<Q", 0x0b)       # rt_sigframe.uc.uc_mcontext.regs[31].x11\n'
            s += 'exp += struct.pack("<Q", 0x0c)       # rt_sigframe.uc.uc_mcontext.regs[31].x12\n'
            s += 'exp += struct.pack("<Q", 0x0d)       # rt_sigframe.uc.uc_mcontext.regs[31].x13\n'
            s += 'exp += struct.pack("<Q", 0x0e)       # rt_sigframe.uc.uc_mcontext.regs[31].x14\n'
            s += 'exp += struct.pack("<Q", 0x0f)       # rt_sigframe.uc.uc_mcontext.regs[31].x15\n'
            s += 'exp += struct.pack("<Q", 0x10)       # rt_sigframe.uc.uc_mcontext.regs[31].x16\n'
            s += 'exp += struct.pack("<Q", 0x11)       # rt_sigframe.uc.uc_mcontext.regs[31].x17\n'
            s += 'exp += struct.pack("<Q", 0x12)       # rt_sigframe.uc.uc_mcontext.regs[31].x18\n'
            s += 'exp += struct.pack("<Q", 0x13)       # rt_sigframe.uc.uc_mcontext.regs[31].x19\n'
            s += 'exp += struct.pack("<Q", 0x14)       # rt_sigframe.uc.uc_mcontext.regs[31].x20\n'
            s += 'exp += struct.pack("<Q", 0x15)       # rt_sigframe.uc.uc_mcontext.regs[31].x21\n'
            s += 'exp += struct.pack("<Q", 0x16)       # rt_sigframe.uc.uc_mcontext.regs[31].x22\n'
            s += 'exp += struct.pack("<Q", 0x17)       # rt_sigframe.uc.uc_mcontext.regs[31].x23\n'
            s += 'exp += struct.pack("<Q", 0x18)       # rt_sigframe.uc.uc_mcontext.regs[31].x24\n'
            s += 'exp += struct.pack("<Q", 0x19)       # rt_sigframe.uc.uc_mcontext.regs[31].x25\n'
            s += 'exp += struct.pack("<Q", 0x1a)       # rt_sigframe.uc.uc_mcontext.regs[31].x26\n'
            s += 'exp += struct.pack("<Q", 0x1b)       # rt_sigframe.uc.uc_mcontext.regs[31].x27\n'
            s += 'exp += struct.pack("<Q", 0x1c)       # rt_sigframe.uc.uc_mcontext.regs[31].x28\n'
            s += 'exp += struct.pack("<Q", 0x1d)       # rt_sigframe.uc.uc_mcontext.regs[31].x29\n'
            s += 'exp += struct.pack("<Q", 0x1e)       # rt_sigframe.uc.uc_mcontext.regs[31].x30\n'
            s += 'exp += struct.pack("<Q", 0xdeadface) # rt_sigframe.uc.uc_mcontext.sp\n'
            s += 'exp += struct.pack("<Q", 0xdeadbeef) # rt_sigframe.uc.uc_mcontext.pc\n'
            s += 'exp += struct.pack("<Q", 0x00)       # rt_sigframe.uc.uc_mcontext.pstate\n'
        gef_print(s.rstrip())
        return


@register_command
class Ret2dlHintCommand(GenericCommand):
    """Hint for ret2dl."""
    _cmdline_ = "ret2dl-hint"
    _syntax_ = "{:s}".format(_cmdline_)
    _category_ = "Exploit Development"

    def do_invoke(self, argv):
        self.dont_repeat()

        s  = ""
        s += "  +---.got/.got.plt @ itself-------+\n"
        s += "  | GOT[0]: _DYNAMIC               |\n"
        s += "  | GOT[1]: link_map               |\n"
        s += "  | GOT[2]: _dl_runtime_resolve@ld |\n"
        s += "  | GOT[3]: func1                  |\n"
        s += "  | GOT[4]: func2                  |\n"
        s += "  | GOT[5]: func3                  |\n"
        s += "  | ...                            |\n"
        s += "  +--------------------------------+\n"
        s += "\n"
        s += "If `link_map` and `_dl_runtime_resolve` are non-zero, just use them.\n"
        s += "If they are zero, you have to resolve them from DT_DEBUG entry of _DYNAMIC.\n"
        s += "\n"
        s += "  +---_DYNAMIC @ itself------+     +---> +---r_debug--------+\n"
        s += "  | QWORD tag                |     |     | QWORD r_version  |\n"
        s += "  | QWORD value              |     |     | QWORD link_map   | <-- HERE\n"
        s += "  +--------------------------+     |     | QWORD r_brk      |\n"
        s += "  | ...                      |     |     | QWORD r_ldbase   |\n"
        s += "  +--------------------------+     |     +------------------+\n"
        s += "  | QWORD tag(0x15:DT_DEBUG) |     |\n"
        s += "  | QWORD value              |-----+\n"
        s += "  +--------------------------+\n"
        s += "\n"
        s += "  (binary itself)              (libc.so)                    (ld-linux.so)\n"
        s += "  +---link_map---+     +-----> +---link_map---+     +-----> +---link_map---+\n"
        s += "  | QWORD l_addr |     |       | QWORD l_addr |     |       | QWORD l_addr |\n"
        s += "  | QWORD l_name |     |       | QWORD l_name |     |       | QWORD l_name |\n"
        s += "  | QWORD l_ld   |     |       | QWORD l_ld   |---+ |       | QWORD l_ld   |\n"
        s += "  | QWORD l_next |-----+       | QWORD l_next |---|-+       | QWORD l_next |\n"
        s += "  | QWORD l_prev |             | QWORD l_prev |   |         | QWORD l_prev |\n"
        s += "  +--------------+             +--------------+   |         +--------------+\n"
        s += "                                                  |\n"
        s += "        +-----------------------------------------+\n"
        s += "        |\n"
        s += "        +--> +---_DYNAMIC @ libc--------+     +---> +---.got/.got.plt @ libc---------+\n"
        s += "             | QWORD tag                |     |     | GOT[0]: _DYNAMIC               |\n"
        s += "             | QWORD value              |     |     | GOT[1]: link_map               |\n"
        s += "             +--------------------------+     |     | GOT[2]: _dl_runtime_resolve@ld | <-- HERE\n"
        s += "             | ...                      |     |     | GOT[3]: func1                  |\n"
        s += "             +--------------------------+     |     | GOT[4]: func2                  |\n"
        s += "             | QWORD tag(0x3:DT_PLTGOT) |     |     | GOT[5]: func3                  |\n"
        s += "             | QWORD value              |-----+     | ...                            |\n"
        s += "             +--------------------------+           +--------------------------------+\n"
        s += "\n"
        s += "\n"
        s += "  _dl_runtime_resolve@.plt.got(link_map, reloc_arg)\n"
        s += "    -> _dl_fixup@ld(link_map, reloc_arg)\n"
        s += "                                   |\n"
        s += "                                   |\n"
        if is_32bit():
            s = s.replace("QWORD", "DWORD")
            s += "  +-------reloc_arg as offset------+\n"
            s += "  |\n"
            s += "  |      +---.rel.plt-----------------------+                           +---.dynsym----------+          +---.dynstr-------+\n"
            s += "  |      | DWORD r_offset                   |                           | DWORD st_name      |          | char[] symbol   |\n"
            s += "  |      | DWORD r_info                     |                           | DWORD st_value     |     +--->| char[] symbol   |\n"
            s += "  |      +----------------------------------+                           | DWORD st_size      |     |    | char[] symbol   |\n"
            s += "  +----> | DWORD r_offset(=writable area)   |   (r_info>>8) * 0x18      | BYTE  st_info      |     |    | char[] symbol   |\n"
            s += "         | DWORD r_info(=(dynsym_idx<<8)|7) |-------------+             | BYTE  st_other     |     |    | ...             |\n"
            s += "         +----------------------------------+             |             | WORD  st_shndx     |     |    +-----------------+\n"
            s += "         | ...                              |             +------------>+--------------------+     |\n"
            s += "         +----------------------------------+                           | DWORD st_name      |-----+\n"
            s += "                                                                        | DWORD st_value     |\n"
            s += "                                                                        | DWORD st_size      |\n"
            s += "                                                                        | BYTE  st_info      |\n"
            s += "                                                                        | BYTE  st_other(=0) |\n"
            s += "                                                                        | WORD  st_shndx     |\n"
            s += "                                                                        +--------------------+\n"
            s += "                                                                        | ...                |\n"
            s += "                                                                        +--------------------+\n"
        else:
            s += "  +---reloc_arg * 0x18 as offset---+\n"
            s += "  |\n"
            s += "  |      +---.rela.plt----------------------+                           +---.dynsym----------+          +---.dynstr-------+\n"
            s += "  |      | QWORD r_offset                   |                           | DWORD st_name      |          | char[] symbol   |\n"
            s += "  |      | QWORD r_info                     |                           | BYTE  st_info      |     +--->| char[] symbol   |\n"
            s += "  |      | QWORD r_addend                   |                           | BYTE  st_other     |     |    | char[] symbol   |\n"
            s += "  +----> +----------------------------------+                           | WORD  st_shndx     |     |    | char[] symbol   |\n"
            s += "         | QWORD r_offset(=writable area)   |   (r_info>>32) * 0x18     | QWORD st_value     |     |    | ...             |\n"
            s += "         | QWORD r_info(=(dynsym_idx<<32)|7)|-------------+             | QWORD st_size      |     |    +-----------------+\n"
            s += "         | QWORD r_addend                   |             +------------>+--------------------+     |\n"
            s += "         +----------------------------------+                           | DWORD st_name      |-----+\n"
            s += "         | ...                              |                           | BYTE  st_info      |\n"
            s += "         +----------------------------------+                           | BYTE  st_other(=0) |\n"
            s += "                                                                        | WORD  st_shndx     |\n"
            s += "                                                                        | QWORD st_value     |\n"
            s += "                                                                        | QWORD st_size      |\n"
            s += "                                                                        +--------------------+\n"
            s += "                                                                        | ...                |\n"
            s += "                                                                        +--------------------+\n"
        s += "\n"
        s += "Use `dynamic` and `linkmap` to display the structure.\n"
        gef_print(s.rstrip())
        return


@register_command
class LinkmapCommand(GenericCommand):
    """Dump link_map with iterating."""
    _cmdline_ = "linkmap"
    _syntax_ = "{:s} [-h] [-a LINK_MAP_ADDRESS]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} # dump itself\n".format(_cmdline_)
    _example_ += "{:s} -a 0x00007ffff7ffe190 # dump specific address".format(_cmdline_)
    _category_ = "Process Information"

    def dump_linkmap(self, link_map):
        section = process_lookup_address(link_map)
        info("link_map: {:#x}".format(link_map))
        info("map: {:#x}-{:#x} ({:s})".format(section.page_start, section.page_end, str(section.permission)))

        current = link_map
        while True:
            addr = current
            l_addr = read_int_from_memory(current)
            current += current_arch.ptrsize
            l_name = read_int_from_memory(current)
            name = read_cstring_from_memory(l_name)
            current += current_arch.ptrsize
            l_ld = read_int_from_memory(current)
            current += current_arch.ptrsize
            l_next = read_int_from_memory(current)
            current += current_arch.ptrsize
            l_prev = read_int_from_memory(current)
            current += current_arch.ptrsize

            if not name:
                name = "(binary itself)"
            gef_print(titlify(name))
            if is_32bit():
                gef_print("{:#010x}:  {:#010x} {:#010x}  |  load_address, name".format(addr, l_addr, l_name))
                gef_print("{:#010x}:  {:#010x} {:#010x}  |  dynamic, next".format(addr + current_arch.ptrsize*2, l_ld, l_next))
                gef_print("{:#010x}:  {:#010x} {:10s}  |  prev".format(addr + current_arch.ptrsize*4, l_prev, ""))
            else:
                gef_print("{:#018x}:  {:#018x} {:#018x}  |  load_address, name".format(addr, l_addr, l_name))
                gef_print("{:#018x}:  {:#018x} {:#018x}  |  dynamic, next".format(addr + current_arch.ptrsize*2, l_ld, l_next))
                gef_print("{:#018x}:  {:#018x} {:18s}  |  prev".format(addr + current_arch.ptrsize*4, l_prev, ""))

            if l_next == 0:
                break
            current = l_next
        return

    @staticmethod
    def get_linkmap(filename, silent=False):
        if not silent:
            info("filename: {:s}".format(filename))
        elf = Elf(filename)
        sec = checksec(filename)

        try:
            got = [s for s in elf.shdrs if s.sh_name == ".got.plt"][0].sh_addr
        except:
            got = [s for s in elf.shdrs if s.sh_name == ".got"][0].sh_addr
        if sec["PIE"]:
            load_base = get_section_base_address(filename)
            got += load_base

        link_map_org = link_map = read_int_from_memory(got + current_arch.ptrsize)
        if link_map:
            if sec["PIE"]:
                link_map += load_base
                if not silent:
                    info("GOT[1]: {:#x} -> {:#x} ({:#x})".format(got + current_arch.ptrsize, link_map_org, link_map))
            else:
                if not silent:
                    info("GOT[1]: {:#x} -> {:#x}".format(got + current_arch.ptrsize, link_map))
        else:
            # Full-RELRO
            if not silent:
                err("GOT[1]: {:#x} -> {:#x}. Since link_map is 0, we will try to get from DT_DEBUG.".format(got + current_arch.ptrsize, link_map))
            current = dynamic = DynamicCommand.get_dynamic(filename, silent)
            while True:
                tag = read_int_from_memory(current)
                current += current_arch.ptrsize
                val = read_int_from_memory(current)
                current += current_arch.ptrsize
                if tag not in DynamicCommand.DT_TABLE:
                    link_map = None
                    if not silent:
                        info("Not found link_map")
                    break
                if DynamicCommand.DT_TABLE[tag] == "DT_DEBUG":
                    dt_debug = val
                    val_addr = current - current_arch.ptrsize
                    if not silent:
                        info("_DYNAMIC+{:#x}(=DT_DEBUG): {:#x} -> {:#x}".format(val_addr - dynamic, val_addr, dt_debug))
                    link_map = read_int_from_memory(dt_debug + current_arch.ptrsize)
                    if not silent:
                        info("DT_DEBUG+{:#x}: {:#x} -> {:#x}".format(current_arch.ptrsize, dt_debug + current_arch.ptrsize, link_map))
                    break
        return link_map

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        filename = None
        link_map = None

        if "-a" in argv:
            try:
                idx = argv.index("-a")
                link_map = int(argv[idx + 1], 0)
                argv = argv[:idx] + argv[idx+2:]
            except:
                self.usage()
                return
        else:
            filename = get_filepath()

        if argv:
            self.usage()
            return

        if filename:
            if not os.path.exists(filename):
                err("{:s} is not found.".format(filename))
                return
            if is_static(filename):
                info("The binary is static build. There is no link_map.")
                return
            try:
                link_map = self.get_linkmap(filename)
            except:
                err("Failed to get link_map.")
                return

        if link_map is None:
            info("link_map is 0.")
            return

        try:
            self.dump_linkmap(link_map)
        except:
            err("Failed to parse.")
        return


@register_command
class DynamicCommand(GenericCommand):
    """Display current status of the _DYNAMIC area."""
    _cmdline_ = "dynamic"
    _syntax_ = "{:s} [-h] [-a DYNAMIC_ADDRESS|-f FILENAME]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} # dump itself\n".format(_cmdline_)
    _example_ += "{:s} -f /lib/x86_64-linux-gnu/libc-2.31.so # dump specific binary\n".format(_cmdline_)
    _example_ += "{:s} -a 0x403de0 # dump specific address".format(_cmdline_)
    _category_ = "Process Information"

    DT_TABLE = {
        0: "DT_NULL",
        1: "DT_NEEDED",
        2: "DT_PLTRELSZ",
        3: "DT_PLTGOT",
        4: "DT_HASH",
        5: "DT_STRTAB",
        6: "DT_SYMTAB",
        7: "DT_RELA",
        8: "DT_RELASZ",
        9: "DT_RELAENT",
        10: "DT_STRSZ",
        11: "DT_SYMENT",
        12: "DT_INIT",
        13: "DT_FINI",
        14: "DT_SONAME",
        15: "DT_RPATH",
        16: "DT_SYMBOLIC",
        17: "DT_REL",
        18: "DT_RELSZ",
        19: "DT_RELENT",
        20: "DT_PLTREL",
        21: "DT_DEBUG",
        22: "DT_TEXTREL",
        23: "DT_JMPREL",
        24: "DT_BIND_NOW",
        25: "DT_INIT_ARRAY",
        26: "DT_FINI_ARRAY",
        27: "DT_INIT_ARRAYSZ",
        28: "DT_FINI_ARRAYSZ",
        29: "DT_RUNPATH",
        30: "DT_FLAGS",
        #32: "DT_ENCODING", # unspecified
        32: "DT_PREINIT_ARRAY",
        33: "DT_PREINIT_ARRAYSZ",
        34: "DT_SYMTAB_SHNDX",
        35: "DT_RELRSZ",
        36: "DT_RELR",
        37: "DT_RELRENT",
        #0x6000000d: "DT_LOOS", # unspecified
        0x6000000e: "DT_SUNW_RTLDINF",
        0x6000000f: "DT_ANDROID_REL",
        0x60000010: "DT_ANDROID_RELSZ",
        0x60000011: "DT_ANDROID_RELA",
        0x60000012: "DT_ANDROID_RELASZ",
        0x6fffe000: "DT_ANDROID_RELR",
        0x6fffe001: "DT_ANDROID_RELRSZ",
        0x6fffe003: "DT_ANDROID_RELRENT",
        0x6fffe005: "DT_ANDROID_RELRCOUNT",
        #0x6ffff000: "DT_HIOS", # unspecified
        #0x6ffffd00: "DT_VALRNGLO", # unspecified
        0x6ffffdf5: "DT_GNU_PRELINKED",
        0x6ffffdf6: "DT_GNU_CONFLICTSZ",
        0x6ffffdf7: "DT_GNU_LIBLISTSZ",
        0x6ffffdf8: "DT_CHECKSUM",
        0x6ffffdf9: "DT_PLTPADSZ",
        0x6ffffdfa: "DT_MOVEENT",
        0x6ffffdfb: "DT_MOVESZ",
        0x6ffffdfc: "DT_FEATURE_1",
        0x6ffffdfd: "DT_POSFLAG_1",
        0x6ffffdfe: "DT_SYMINSZ",
        0x6ffffdff: "DT_SYMINENT",
        #0x6ffffdff: "DT_VALRNGHI", # unspecified
        #0x6ffffe00: "DT_ADDRRNGLO", # unspecified
        0x6ffffef5: "DT_GNU_HASH",
        0x6ffffef6: "DT_TLSDESC_PLT",
        0x6ffffef7: "DT_TLSDESC_GOT",
        0x6ffffef8: "DT_GNU_CONFLICT",
        0x6ffffef9: "DT_GNU_LIBLIST",
        0x6ffffefa: "DT_CONFIG",
        0x6ffffefb: "DT_DEPAUDIT",
        0x6ffffefc: "DT_AUDIT",
        0x6ffffefd: "DT_PLTPAD",
        0x6ffffefe: "DT_MOVETAB",
        0x6ffffeff: "DT_SYMINFO",
        #0x6ffffeff: "DT_ADDRRNGHI", # unspecified
        0x6ffffff0: "DT_VERSYM",
        0x6ffffff9: "DT_RELACOUNT",
        0x6ffffffa: "DT_RELCOUNT",
        0x6ffffffb: "DT_FLAGS_1",
        0x6ffffffc: "DT_VERDEF",
        0x6ffffffd: "DT_VERDEFNUM",
        0x6ffffffe: "DT_VERNEED",
        0x6fffffff: "DT_VERNEEDNUM",
        #0x70000000: "DT_LOPROC", # unspecified
        0x70000001: "DT_SPARC_REGISTER",
        0x7ffffffd: "DT_AUXILIARY",
        0x7ffffffe: "DT_USED",
        0x7fffffff: "DT_FILTER",
        #0x7fffffff: "DT_HIPROC", # unspecified
    }

    def dump_dynamic(self, dynamic):
        section = process_lookup_address(dynamic)
        info("map: {:#x}-{:#x} ({:s})".format(section.page_start, section.page_end, str(section.permission)))

        current = dynamic
        while True:
            addr = current
            tag = read_int_from_memory(current)
            current += current_arch.ptrsize
            val = read_int_from_memory(current)
            current += current_arch.ptrsize

            if not tag in self.DT_TABLE:
                break

            if is_32bit():
                gef_print("{:#010x}:  {:#010x} {:#010x}  |  tag:{:s}".format(addr, tag, val, self.DT_TABLE[tag]))
            else:
                gef_print("{:#018x}:  {:#018x} {:#018x}  |  tag:{:s}".format(addr, tag, val, self.DT_TABLE[tag]))
        return

    @staticmethod
    def get_dynamic(filename, silent=False):
        if not silent:
            info("filename: {:s}".format(filename))
        elf = Elf(filename)
        sec = checksec(filename)

        try:
            got = [s for s in elf.shdrs if s.sh_name == ".got.plt"][0].sh_addr
        except:
            got = [s for s in elf.shdrs if s.sh_name == ".got"][0].sh_addr
        if sec["PIE"]:
            load_base = get_section_base_address(filename)
            got += load_base

        dynamic_org = dynamic = read_int_from_memory(got)
        if sec["PIE"]:
            dynamic += load_base
            if not silent:
                info("GOT[0]: {:#x} -> {:#x} ({:#x})".format(got, dynamic_org, dynamic))
        else:
            if not silent:
                info("GOT[0]: {:#x} -> {:#x}".format(got, dynamic))
        return dynamic

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        filename = None
        dynamic = None

        if "-a" in argv:
            try:
                idx = argv.index("-a")
                dynamic = int(argv[idx + 1], 0)
                argv = argv[:idx] + argv[idx+2:]
            except:
                self.usage()
                return
        elif "-f" in argv:
            try:
                idx = argv.index("-f")
                filename = argv[idx + 1]
                argv = argv[:idx] + argv[idx+2:]
            except:
                self.usage()
                return
        else:
            filename = get_filepath()

        if argv:
            self.usage()
            return

        if filename:
            if not os.path.exists(filename):
                err("{:s} is not found.".format(filename))
                return
            if is_static(filename):
                info("The binary is static build. There is no _DYNAMIC.")
                return
            if get_section_base_address(filename) is None:
                err("{:s} is not loeaded.".format(filename))
                return
            try:
                dynamic = self.get_dynamic(filename)
            except:
                err("Failed to get _DYNAMIC.")
                return

        if dynamic is None:
            info("_DYNAMIC is 0.")
            return

        try:
            self.dump_dynamic(dynamic)
        except:
            err("Failed to parse.")
        return


@register_command
class DestructorDumpCommand(GenericCommand):
    """Display registered destructor functions."""
    _cmdline_ = "dtor-dump"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    def ror(self, val, bits, arch_bits):
        new_val = (val >> bits) | (val << (arch_bits-bits))
        mask = (1 << arch_bits) - 1
        return new_val & mask

    def decode_function(self, fn):
        if is_x86_64():
            decoded_fn = self.ror(fn, 17, 64) ^ self.cookie
        elif is_x86_32():
            decoded_fn = self.ror(fn, 9, 32) ^ self.cookie
        elif is_arm32() or is_arm64():
            decoded_fn = fn ^ self.cookie
        return decoded_fn

    def perm(self, addr):
        try:
            return "[{:s}]".format(str(lookup_address(addr).section.permission))
        except:
            return "[???]"

    def dump_tls_dtors(self):
        if not self.tls:
            err("TLS is not found")
            return

        if is_x86_64():
            head_p = self.tls - 0x60
        elif is_x86_32():
            head_p = self.tls - 0x3c
        elif is_arm32():
            head_p = self.tls + 0x20
        elif is_arm64():
            head_p = self.tls + 0x40

        current = head = read_int_from_memory(head_p)
        if head:
            gef_print("{:s}: {:#x}{:s}: {:#x}{:s}".format("tls_dtor_list", head_p, self.perm(head_p), head, self.perm(head)))
        else:
            gef_print("{:s}: {:#x}{:s}: {:#x}".format("tls_dtor_list", head_p, self.perm(head_p), head))
        while current:
            addr = current
            func = read_int_from_memory(current)
            current += current_arch.ptrsize
            obj = read_int_from_memory(current)
            current += current_arch.ptrsize
            link_map = read_int_from_memory(current)
            current += current_arch.ptrsize
            next_ = read_int_from_memory(current)
            current += current_arch.ptrsize
            decoded_fn = self.decode_function(func)
            sym = get_symbol_string(decoded_fn)
            decoded_fn_s = Color.boldify("{:#x}".format(decoded_fn))
            gef_print("    -> func:     {:#x}{:s}: {:#x} (={:s}{:s})".format(addr, self.perm(addr), func, decoded_fn_s, sym))
            gef_print("       obj:      {:#x}{:s}: {:#x}".format(addr + current_arch.ptrsize*1, self.perm(addr + current_arch.ptrsize*1), obj))
            gef_print("       link_map: {:#x}{:s}: {:#x}".format(addr + current_arch.ptrsize*2, self.perm(addr + current_arch.ptrsize*2), link_map))
            gef_print("       next:     {:#x}{:s}: {:#x}".format(addr + current_arch.ptrsize*3, self.perm(addr + current_arch.ptrsize*3), next_))
            current = next_
        return

    def dump_exit_funcs(self, name):
        try:
            head_p = parse_address("&"+name)
        except:
            err("Not found symbol ({:s})".format(name))
            return

        current = head = read_int_from_memory(head_p)
        gef_print("{:s}: {:#x}{:s}: {:#x}{:s}".format(name, head_p, self.perm(head_p), head, self.perm(head)))
        if not current:
            return

        next_ = read_int_from_memory(current)
        current += current_arch.ptrsize
        idx = read_int_from_memory(current)
        current += current_arch.ptrsize
        gef_print("    -> next:  {:#x}{:s}: {:#x}".format(head + current_arch.ptrsize*0, self.perm(head + current_arch.ptrsize*0), next_))
        gef_print("       idx:   {:#x}{:s}: {:#x}".format(head + current_arch.ptrsize*1, self.perm(head + current_arch.ptrsize*1), idx))
        for i in range(32):
            addr = current
            flavor = read_int_from_memory(current)
            current += current_arch.ptrsize
            fn = read_int_from_memory(current)
            current += current_arch.ptrsize
            arg = read_int_from_memory(current)
            current += current_arch.ptrsize
            dso_handle = read_int_from_memory(current)
            current += current_arch.ptrsize
            if fn == arg == dso_handle == 0: # flavor might be non-zero, so skip check
                break
            decoded_fn = self.decode_function(fn)
            sym = get_symbol_string(decoded_fn)
            decoded_fn_s = Color.boldify("{:#x}".format(decoded_fn))
            fns = "       fns[{:d}]:{:#x}{:s}:".format(i, addr, self.perm(addr))
            gef_print("{} flavor:{:d}".format(fns, flavor))
            gef_print("{} func:{:#x} (={:s}{:s})".format(" "*len(fns), fn, decoded_fn_s, sym))
            gef_print("{} arg:{:#x}".format(" "*len(fns), arg))
            gef_print("{} dso_handle:{:#x}".format(" "*len(fns), dso_handle))
        return

    def yield_linkmap(self):
        link_map = LinkmapCommand.get_linkmap(get_filepath(), silent=True)
        while link_map:
            dic = {}
            dic["load_address"] = read_int_from_memory(link_map)
            name_ptr = read_int_from_memory(link_map + current_arch.ptrsize*1)
            dic["name"] = dic["name_org"] = read_cstring_from_memory(name_ptr)
            if dic["name_org"] == "":
                dic["name"] = "{:s}".format(get_filepath())
            dic["dynamic"] = read_int_from_memory(link_map + current_arch.ptrsize*2)
            dic["next"] = read_int_from_memory(link_map + current_arch.ptrsize*3)
            yield dic
            link_map = dic["next"]

    def dump_sections_not_array(self, section_name):
        if not is_static(get_filepath()):
            for link_map in self.yield_linkmap():
                if not os.path.exists(link_map["name"]):
                    continue
                elf = Elf(link_map["name"])
                try:
                    shdr = [s for s in elf.shdrs if s.sh_name == section_name][0]
                except:
                    continue
                if is_pie(link_map["name"]):
                    addr = shdr.sh_addr + link_map["load_address"]
                else:
                    addr = shdr.sh_addr
                gef_print(link_map["name"])
                sym = get_symbol_string(addr)
                func_s = Color.boldify("{:#x}".format(addr))
                gef_print("    -> {:s}{:s}".format(func_s, sym))
        else:
            elf = Elf(get_filepath())
            try:
                shdr = [s for s in elf.shdrs if s.sh_name == section_name][0]
            except:
                err("Not found {:s} section".format(section_name))
                return
            addr = shdr.sh_addr
            gef_print(get_filepath())
            sym = get_symbol_string(addr)
            func_s = Color.boldify("{:#x}".format(addr))
            gef_print("    -> {:s}{:s}".format(func_s, sym))
        return

    def dump_sections(self, section_name):
        if not is_static(get_filepath()):
            for link_map in self.yield_linkmap():
                if not os.path.exists(link_map["name"]):
                    continue
                elf = Elf(link_map["name"])
                try:
                    shdr = [s for s in elf.shdrs if s.sh_name == section_name][0]
                except:
                    continue
                entries = []
                for i in range(shdr.sh_size // current_arch.ptrsize):
                    if is_pie(link_map["name"]):
                        addr = shdr.sh_addr + link_map["load_address"] + current_arch.ptrsize * i
                    else:
                        addr = shdr.sh_addr + current_arch.ptrsize * i
                    func = read_int_from_memory(addr)
                    if is_32bit() and func in [0, 0xffffffff]:
                        continue
                    if is_64bit() and func in [0, 0xffffffffffffffff]:
                        continue
                    entries.append([addr, func])
                if not entries:
                    continue
                gef_print(link_map["name"])
                for addr, func in entries:
                    sym = get_symbol_string(func)
                    func_s = Color.boldify("{:#x}".format(func))
                    gef_print("    -> {:#x}{:s}: {:s}{:s}".format(addr, self.perm(addr), func_s, sym))
        else:
            elf = Elf(get_filepath())
            try:
                shdr = [s for s in elf.shdrs if s.sh_name == section_name][0]
            except:
                err("Not found {:s} section".format(section_name))
                return
            entries = []
            for i in range(shdr.sh_size // current_arch.ptrsize):
                addr = shdr.sh_addr + current_arch.ptrsize * i
                func = read_int_from_memory(addr)
                if is_32bit() and func in [0, 0xffffffff]:
                    continue
                if is_64bit() and func in [0, 0xffffffffffffffff]:
                    continue
                entries.append([addr, func])
            if not entries:
                err("Not found valid entry")
                return
            gef_print(get_filepath())
            for addr, func in entries:
                sym = get_symbol_string(func)
                func_s = Color.boldify("{:#x}".format(func))
                gef_print("    -> {:#x}{:s}: {:s}{:s}".format(addr, self.perm(addr), func_s, sym))
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    @only_if_x86_32_64_or_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        # init
        if is_x86_64():
            self.tls = TlsCommand.getfs()
            self.cookie = read_int_from_memory(self.tls + 0x30)
        elif is_x86_32():
            self.tls = TlsCommand.getgs()
            self.cookie = read_int_from_memory(self.tls + 0x18)
        elif is_arm32() or is_arm64():
            if is_arm32():
                try:
                    self.tls = parse_address("(unsigned int)__aeabi_read_tp()")
                except:
                    err("Not found symbol (__aeabi_read_tp)")
                    return
            else:
                try:
                    self.tls = get_register("$TPIDR_EL0")
                except:
                    err("Fail reading $TPIDR_EL0 register")
                    return
            try:
                cookie_ptr = parse_address("&__pointer_chk_guard_local")
            except:
                err("Not found symbol (__pointer_chk_guard_local)")
                return
            self.cookie = read_int_from_memory(cookie_ptr)

        # dump
        gef_print(titlify("tls_dtor_list: registered by __cxa_thread_atexit_impl()"))
        self.dump_tls_dtors()

        gef_print(titlify("__exit_funcs: registered by atexit(), on_exit()"))
        self.dump_exit_funcs("__exit_funcs")

        gef_print(titlify("__quick_exit_funcs: registered by at_quick_exit()"))
        self.dump_exit_funcs("__quick_exit_funcs")

        gef_print(titlify(".fini_array"))
        self.dump_sections(".fini_array")

        gef_print(titlify(".fini"))
        self.dump_sections_not_array(".fini")

        gef_print(titlify(".dtors"))
        self.dump_sections(".dtors")

        gef_print(titlify("__libc_atexit"))
        self.dump_sections("__libc_atexit")
        return


@register_command
class GotCommand(GenericCommand):
    """Display current status of the got/plt inside the process."""
    _cmdline_ = "got"
    _syntax_ = "{:s} [FUNCTION_NAME ...] ".format(_cmdline_)
    _example_ = "{:s} fread printf".format(_cmdline_)
    _category_ = "Process Information"
    _aliases_ = ["plt", ]

    def __init__(self, *args, **kwargs):
        super().__init__()
        self.add_setting("function_resolved", "green", "Line color of the got command output if the function has been resolved")
        self.add_setting("function_not_resolved", "yellow", "Line color of the got command output if the function has not been resolved")
        return

    def get_jmp_slots(self, readelf, filename):
        output = []
        cmd = [readelf, "--relocs", "--wide", filename]
        lines = gef_execute_external(cmd, as_list=True)
        for line in lines:
            if "JUMP" in line or 'GLOB_DAT' in line:
                output.append(line)
        return output

    def get_plt_addresses(self, objdump, filename):
        if hasattr(self, 'plts'):
            return self.plts
        output = {}
        cmd = [objdump, "-j", ".plt", "-j", ".plt.sec", "-j", ".plt.got", "-d", filename]
        try:
            lines = gef_execute_external(cmd, as_list=True)
        except:
            lines = ""
        for line in lines:
            r = re.findall(r"^([0-9a-f]+) <(.+)@plt>:", line)
            if r:
                address = r[0][0]
                func_name = r[0][1]
                output[func_name] = int(address, 16)
        self.plts = output
        return self.plts

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        try:
            readelf = which("readelf")
        except IOError:
            err("Missing `readelf`")
            return

        try:
            objdump = which("objdump")
        except IOError:
            err("Missing `objdump`")
            return

        # get the filtering parameter.
        func_names_filter = []
        if argv:
            func_names_filter = argv

        filename = get_filepath()
        if filename is None:
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return

        # getting vmmap to understand the boundaries of the main binary
        # we will use this info to understand if a function has been resolved or not.
        vmmap = get_process_maps()
        base_address = min([x.page_start for x in vmmap if x.path in [filename, "<explored>", "[code]"]])
        end_address = max([x.page_end for x in vmmap if x.path in [filename, "<explored>", "[code]"]])

        # qemu uses fix address if pie / aslr is enable
        if is_qemu_usermode():
            if is_32bit():
                base_address = 0x40000000
            else:
                base_address = 0x4000000000

        # get the checksec output.
        checksec_status = checksec(filename)
        full_relro = checksec_status["Full RELRO"]
        pie = checksec_status["PIE"] # if pie we will have offset instead of abs address.

        relro_status = "Full RELRO"
        if not full_relro:
            relro_status = "Partial RELRO"
            partial_relro = checksec_status["Partial RELRO"]

            if not partial_relro:
                relro_status = "No RELRO"

        # retrieve jump slots using readelf
        jmpslots = self.get_jmp_slots(readelf, filename)

        # retrieve plt address
        plts = self.get_plt_addresses(objdump, filename)

        got_protection = Color.boldify(relro_status)
        got_functions = Color.boldify("{}".format(len(jmpslots)))
        gef_print("GOT protection: {} | GOT functions: {} ".format(got_protection, got_functions))

        fmt = "{:>14s} ({:>9s}) {:>14s} ({:>9s}) {:s}"
        legend = ["PLT", "Offset", "GOT", "Offset", "Symbol -> GOTvalue"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for line in sorted(jmpslots):
            address, _, _, _, name = line.split()[:5]

            # if we have a filter let's skip the entries that are not requested.
            if func_names_filter:
                if not any(map(lambda x: x in name, func_names_filter)):
                    continue
            got_address = int(address, 16)

            # resolve PLT
            if name.split("@")[0] in plts:
                plt_address = plts[name.split("@")[0]]
            else:
                plt_address = None

            # address_val is an offset from the base_address if we have PIE.
            if pie:
                got_address += base_address
                if plt_address:
                    plt_address += base_address

            got_offset = got_address - base_address
            if plt_address:
                plt_offset = plt_address - base_address

            # read the address of the function.
            got_value = read_int_from_memory(got_address)

            # for the swag: different colors if the function has been resolved or not.
            if base_address < got_value < end_address or got_value == 0:
                color = self.get_setting("function_not_resolved") # function hasn't already been resolved
            else:
                color = self.get_setting("function_resolved") # function has already been resolved

            name_c = Color.colorify(name, color)
            got_value_c = Color.colorify(hex(got_value), color)
            if plt_address:
                fmt = "{:#14x} ({:+#9x}) {:#14x} ({:+#9x}) {:s} {:s} {:s}"
                line = fmt.format(plt_address, plt_offset, got_address, got_offset, name_c, RIGHT_ARROW, got_value_c)
            else:
                fmt = "{:>14s} {:11s} {:#14x} ({:+#9x}) {:s} {:s} {:s}"
                line = fmt.format("Not found", "", got_address, got_offset, name_c, RIGHT_ARROW, got_value_c)
            gef_print(line)
        return


@register_command
class FormatStringSearchCommand(GenericCommand):
    """Exploitable format-string helper: this command will set up specific breakpoints
    at well-known dangerous functions (printf, snprintf, etc.), and check if the pointer
    holding the format string is writable, and therefore susceptible to format string
    attacks if an attacker can control its content."""
    _cmdline_ = "format-string-helper"
    _syntax_ = _cmdline_
    _aliases_ = ["fmtstr-helper",]
    _category_ = "Debugging Support"

    def do_invoke(self, argv):
        self.dont_repeat()

        dangerous_functions = {
            "printf": 0,
            "sprintf": 1,
            "fprintf": 1,
            "snprintf": 2,
            "vsnprintf": 3,
            "dprintf": 1,
            "vprintf": 1,
            "vfprintf": 2,
            "vdprintf": 2,
            "vsprintf": 2
        }

        enable_redirect_output("/dev/null")

        for func_name, num_arg in dangerous_functions.items():
            FormatStringBreakpoint(func_name, num_arg)

        disable_redirect_output()
        ok("Enabled {:d} FormatStringBreakpoint".format(len(dangerous_functions)))
        return


@register_command
class HeapAnalysisCommand(GenericCommand):
    """Heap vulnerability analysis helper: this command aims to track dynamic heap allocation
    done through malloc()/free() to provide some insights on possible heap vulnerabilities. The
    following vulnerabilities are checked:
    - NULL free
    - Use-after-Free
    - Double Free
    - Heap overlap"""
    _cmdline_ = "heap-analysis-helper"
    _syntax_ = "{:s} [show]".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        self.add_setting("check_free_null", False, "Break execution when a free(NULL) is encountered")
        self.add_setting("check_double_free", True, "Break execution when a double free is encountered")
        self.add_setting("check_weird_free", True, "Break execution when free() is called against a non-tracked pointer")
        self.add_setting("check_uaf", True, "Break execution when a possible Use-after-Free condition is found")
        self.add_setting("check_heap_overlap", True, "Break execution when a possible overlap in allocation is found")
        self.bp_malloc = None
        self.bp_calloc = None
        self.bp_free = None
        self.bp_realloc = None
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    @experimental_feature
    def do_invoke(self, argv):
        self.dont_repeat()

        if not argv:
            self.setup()
            return

        if argv[0] == "show":
            self.dump_tracked_allocations()
        return

    def setup(self):
        ok("Tracking malloc() & calloc()")
        self.bp_malloc = TraceMallocBreakpoint("__libc_malloc")
        self.bp_calloc = TraceMallocBreakpoint("__libc_calloc")
        ok("Tracking free()")
        self.bp_free = TraceFreeBreakpoint()
        ok("Tracking realloc()")
        self.bp_realloc = TraceReallocBreakpoint()

        ok("Disabling hardware watchpoints (this may increase the latency)")
        gdb.execute("set can-use-hw-watchpoints 0")

        info("Dynamic breakpoints correctly setup, GEF will break execution if a possible vulnerabity is found.")
        warn("{}: The heap analysis slows down the execution noticeably.".format(
            Color.colorify("Note", "bold underline yellow")))

        # when inferior quits, we need to clean everything for a next execution
        gef_on_exit_hook(self.clean)
        return

    def dump_tracked_allocations(self):
        global __heap_allocated_list__, __heap_freed_list__, __heap_uaf_watchpoints__

        if __heap_allocated_list__:
            ok("Tracked as in-use chunks:")
            for addr, sz in __heap_allocated_list__:
                gef_print("{:#x} = malloc({:d})".format(addr, sz))
        else:
            ok("No malloc() chunk tracked")

        if __heap_freed_list__:
            ok("Tracked as free-ed chunks:")
            for addr, sz in __heap_freed_list__:
                gef_print("free({:#x})".format(addr))
        else:
            ok("No free() chunk tracked")
        return

    def clean(self, event):
        global __heap_allocated_list__, __heap_freed_list__, __heap_uaf_watchpoints__

        ok("{} - Cleaning up".format(Color.colorify("Heap-Analysis", "yellow bold"),))
        for bp in [self.bp_malloc, self.bp_calloc, self.bp_free, self.bp_realloc]:
            if hasattr(bp, "retbp") and bp.retbp:
                try:
                    bp.retbp.delete()
                except RuntimeError:
                    # in some cases, gdb was found failing to correctly remove the retbp
                    # but they can be safely ignored since the debugging session is over
                    pass

            bp.delete()

        for wp in __heap_uaf_watchpoints__:
            wp.delete()

        __heap_allocated_list__ = []
        __heap_freed_list__ = []
        __heap_uaf_watchpoints__ = []

        ok("{} - Re-enabling hardware watchpoints".format(Color.colorify("Heap-Analysis", "yellow bold"),))
        gdb.execute("set can-use-hw-watchpoints 1")

        gef_on_exit_unhook(self.clean)
        return


@register_command
class SyscallSearchCommand(GenericCommand):
    """Search the syscall number"""
    _cmdline_ = "syscall-search"
    _syntax_ = "{:s} [-h] [-v] [-a ARCH] [-m MODE] SYSCALL_NAME_REGEX_SEARCH_PATTERN|SYSCALL_NUM".format(_cmdline_)
    _example_ = "\n"
    _example_ += '{:s} -a X86 -m 64  "^writev?" # amd64\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 32  "^writev?" # i386 on amd64\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m N32 "^writev?" # i386 native\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM64      "^writev?" # arm64\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m 32  "^writev?" # arm32 on arm64\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m N32 "^writev?" # arm32 native'.format(_cmdline_)
    _category_ = "Misc"

    def print_legend(self):
        if self.verbose:
            headers = ["NR", "Name", "Parameter"]
            gef_print(Color.colorify("{:<25} {:<20} {}".format(*headers), get_gef_setting("theme.table_heading")))
        else:
            headers = ["NR", "Name"]
            gef_print(Color.colorify("{:<25} {:<20}".format(*headers), get_gef_setting("theme.table_heading")))
        return

    def print_syscall_by_number(self, syscall_table, syscall_num):
        self.print_legend()
        for num, entry in syscall_table.items():
            if num == syscall_num:
                nr = "{:d} (={:#x})".format(num, num)
                if self.verbose:
                    param = ('\n'+" "*47).join(["{}: {}".format(i, param.param) for i, param in enumerate(entry.params, start=1)])
                else:
                    param = ""
                gef_print("{:<25} {:<20} {}".format(nr, entry.name, param))
        return

    def print_syscall_by_name(self, syscall_table, syscall_name_pattern):
        self.print_legend()
        for num, entry in syscall_table.items():
            if re.search(syscall_name_pattern, entry.name):
                nr = "{:d} (={:#x})".format(num, num)
                if self.verbose:
                    param = ('\n'+" "*47).join(["{}: {}".format(i, param.param) for i, param in enumerate(entry.params, start=1)])
                else:
                    param = ""
                gef_print("{:<25} {:<20} {}".format(nr, entry.name, param))
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        arch = None
        if "-a" in argv:
            idx = argv.index("-a")
            arch = argv[idx + 1]
            argv = argv[:idx] + argv[idx+2:]

        mode = None
        if "-m" in argv:
            idx = argv.index("-m")
            mode = argv[idx + 1]
            argv = argv[:idx] + argv[idx+2:]

        if len(argv) != 1:
            self.usage()
            return

        try:
            syscall_table = SyscallArgsCommand.get_syscall_table(arch, mode)
        except:
            self.usage()
            return

        syscall_num = None
        syscall_name_pattern = None
        try:
            syscall_num = int(argv[0], 0)
        except:
            syscall_name_pattern = argv[0]

        if syscall_num is not None:
            self.print_syscall_by_number(syscall_table, syscall_num)
        if syscall_name_pattern is not None:
            self.print_syscall_by_name(syscall_table, syscall_name_pattern)
        return


@register_command
class SyscallArgsCommand(GenericCommand):
    """Gets the syscall name and arguments based on the register values in the current state."""
    _cmdline_ = "syscall-args"
    _syntax_ = "{:s} [-h] [SYSCALL_NUM]".format(_cmdline_)
    _category_ = "Debugging Support"

    @only_if_gdb_running
    @only_if_x86_32_64_or_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        syscall_table = self.get_syscall_table()

        if len(argv) == 1:
            reg_value = int(argv[0], 0)
        else:
            reg_value = get_register(current_arch.syscall_register)
        if reg_value not in syscall_table:
            warn("There is no system call for {:#x}".format(reg_value))
            return
        syscall_entry = syscall_table[reg_value]

        values = []
        for param in syscall_entry.params:
            values.append(get_register(param.reg))

        parameters = [s.param for s in syscall_entry.params]
        registers = [s.reg for s in syscall_entry.params]

        info("Detected syscall")
        gef_print("    " + Color.colorify("{}({})".format(syscall_entry.name, ", ".join(parameters)), "bold yellow"))

        headers = ["Parameter", "Register", "Value"]
        info(Color.colorify("{:<20} {:<20} {}".format(*headers), get_gef_setting("theme.table_heading")))
        gef_print("    {:<20} {:<20} {:#x}".format("_NR", current_arch.syscall_register, reg_value))

        param_names = [re.split(r" |\*", p)[-1] for p in parameters]
        for name, register, value in zip(param_names, registers, values):
            line = "    {:<20} {:<20} {:#x}".format(name, register, value)
            addrs = dereference_from(value)
            if len(addrs) > 1:
                sep = " {:s} ".format(RIGHT_ARROW)
                for addr in addrs[1:]:
                    if isinstance(addr, Address):
                        line += sep + str(addr) + get_symbol_string(addr.value)
                    else:
                        line += sep + addr # actually this is msg
            gef_print(line)
        return

    @staticmethod
    def get_syscall_table(arch=None, mode=None):
        def is_emulated32():
            if is_qemu_usermode():
                return True

            if is_qemu_system():
                # corner case (ex: using qemu-system-x86_64, but process is executed as 32bit mode)
                # is not able to be detected
                return True

            for m in get_process_maps():
                # native x86:
                # 0xbffdf000 0xc0000000 0x021000 0x000000 rw- [stack]
                # emulated x86 on x86_64
                # 0xfffdd000 0xffffe000 0x021000 0x000000 rw- [stack]
                # native arm:
                # 0xbefdf000 0xbf000000 0x021000 0x000000 rw- [stack]
                # emulated arm on aarch64
                # 0xfffcf000 0xffff0000 0x021000 0x000000 rw- [stack]
                if m.path == "[stack]":
                    return (m.page_start >> 28) == 0xf
            else:
                return False # by default it considers on native

        def is_secure():
            scr = get_register("$SCR" if is_arm32() else "$SCR_EL3")
            if scr is None:
                return False
            return (scr & 0b1) == 0

        if arch is None and mode is None :
            if is_x86_64():
                arch, mode = "X86", "64"
            elif is_x86_32():
                if is_emulated32():
                    arch, mode = "X86", "32"
                else:
                    arch, mode = "X86", "N32"
            elif is_arm64():
                if is_secure():
                    arch, mode = "ARM64", "S"
                else:
                    arch, mode = "ARM64", None
            elif is_arm32():
                if is_secure():
                    arch, mode = "ARM", "S"
                else:
                    if is_emulated32():
                        arch, mode = "ARM", "32"
                    else:
                        arch, mode = "ARM", "N32"

        Entry = collections.namedtuple('Entry', 'name params')
        Param = collections.namedtuple('Param', 'reg param')

        # The info of arguments type is picked up from kernel source around "SYSCALL_DEFINE*(...) / COMPAT_SYSCALL_DEFINE*(...)",
        # The command I used: cd linux-5.*; ag --cc -A 6 "SYSCALL_DEFINE.*\bFUNCTION_NAME\b"
        # But these are some exceptions (ex: not found), I picked up from the function of syscall implementation, and so on
        if arch == "X86" and mode == "64":
            register_list = ["$rdi", "$rsi", "$rdx", "$r10", "$r8", "$r9"]
            # arch/x86/entry/syscalls/syscall_64.tbl
            # arch/x86/include/asm/unistd.h
            # arch/x86/include/uapi/asm/unistd.h
            # arch/x86/include/generated/uapi/asm/unistd-64.h
            # arch/x86/include/generated/uapi/asm/unistd-x32.h
            syscall_list = [
                [0x0,   'read', ['unsigned int fd', 'char *buf', 'size_t count']],
                [0x1,   'write', ['unsigned int fd', 'const char *buf', 'size_t count']],
                [0x2,   'open', ['const char *filename', 'int flags', 'umode_t mode']],
                [0x3,   'close', ['unsigned int fd']],
                [0x4,   'stat', ['const char *filename', 'struct __old_kernel_stat *statbuf']],
                [0x5,   'fstat', ['unsigned int fd', 'struct __old_kernel_stat *statbuf']],
                [0x6,   'lstat', ['const char *filename', 'struct __old_kernel_stat *statbuf']],
                [0x7,   'poll', ['struct pollfd *ufds', 'unsigned int nfds', 'int timeout_msecs']],
                [0x8,   'lseek', ['unsigned int fd', 'off_t offset', 'unsigned int whence']],
                [0x9,   'mmap', ['unsigned long addr', 'unsigned long len', 'unsigned long prot', 'unsigned long flags', 'unsigned long fd', 'unsigned long off']],
                [0xa,   'mprotect', ['unsigned long start', 'size_t len', 'unsigned long prot']],
                [0xb,   'munmap', ['unsigned long addr', 'size_t len']],
                [0xc,   'brk', ['unsigned long brk']],
                [0xd,   'rt_sigaction', ['int sig', 'const struct sigaction *act', 'struct sigaction *oact', 'size_t sigsetsize']],
                [0xe,   'rt_sigprocmask', ['int how', 'sigset_t *nset', 'sigset_t *oset', 'size_t sigsetsize']],
                [0xf,   'rt_sigreturn', []],
                [0x10,  'ioctl', ['unsigned int fd', 'unsigned int cmd', 'unsigned long arg']],
                [0x11,  'pread64', ['unsigned int fd', 'char *buf', 'size_t count', 'loff_t pos']],
                [0x12,  'pwrite64', ['unsigned int fd', 'const char *buf', 'size_t count', 'loff_t pos']],
                [0x13,  'readv', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen']],
                [0x14,  'writev', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen']],
                [0x15,  'access', ['const char *filename', 'int mode']],
                [0x16,  'pipe', ['int *fildes']],
                [0x17,  'select', ['int n', 'fd_set *inp', 'fd_set *outp', 'fd_set *exp', 'struct __kernel_old_timeval *tvp']],
                [0x18,  'sched_yield', []],
                [0x19,  'mremap', ['unsigned long addr', 'unsigned long old_len', 'unsigned long new_len', 'unsigned long flags', 'unsigned long new_addr']],
                [0x1a,  'msync', ['unsigned long start', 'size_t len', 'int flags']],
                [0x1b,  'mincore', ['unsigned long start', 'size_t len', 'unsigned char *vec']],
                [0x1c,  'madvise', ['unsigned long start', 'size_t len_in', 'int behavior']],
                [0x1d,  'shmget', ['key_t key', 'size_t size', 'int shmflg']],
                [0x1e,  'shmat', ['int shmid', 'char *shmaddr', 'int shmflg']],
                [0x1f,  'shmctl', ['int shmid', 'int cmd', 'struct shmid_ds *buf']],
                [0x20,  'dup', ['unsigned int fildes']],
                [0x21,  'dup2', ['unsigned int oldfd', 'unsigned int newfd']],
                [0x22,  'pause', []],
                [0x23,  'nanosleep', ['struct __kernel_timespec *rqtp', 'struct __kernel_timespec *rmtp']],
                [0x24,  'getitimer', ['int which', 'struct __kernel_old_itimerval *value']],
                [0x25,  'alarm', ['unsigned int seconds']],
                [0x26,  'setitimer', ['int which', 'struct __kernel_old_itimerval *value', 'struct __kernel_old_itimerval *ovalue']],
                [0x27,  'getpid', []],
                [0x28,  'sendfile', ['int out_fd', 'int in_fd', 'off_t *offset', 'size_t count']],
                [0x29,  'socket', ['int family', 'int type', 'int protocol']],
                [0x2a,  'connect', ['int fd', 'struct sockaddr *uservaddr', 'int addrlen']],
                [0x2b,  'accept', ['int fd', 'struct sockaddr *upeer_sockaddr', 'int *upeer_addrlen']],
                [0x2c,  'sendto', ['int fd', 'void *buff', 'size_t len', 'unsigned int flags', 'struct sockaddr *addr', 'int addr_len']],
                [0x2d,  'recvfrom', ['int fd', 'void *ubuf', 'size_t size', 'unsigned int flags', 'struct sockaddr *addr', 'int *addr_len']],
                [0x2e,  'sendmsg', ['int fd', 'struct user_msghdr *msg', 'unsigned int flags']],
                [0x2f,  'recvmsg', ['int fd', 'struct user_msghdr *msg', 'unsigned int flags']],
                [0x30,  'shutdown', ['int fd', 'int how']],
                [0x31,  'bind', ['int fd', 'struct sockaddr *umyaddr', 'int addrlen']],
                [0x32,  'listen', ['int fd', 'int backlog']],
                [0x33,  'getsockname', ['int fd', 'struct sockaddr *usockaddr', 'int *usockaddr_len']],
                [0x34,  'getpeername', ['int fd', 'struct sockaddr *usockaddr', 'int *usockaddr_len']],
                [0x35,  'socketpair', ['int family', 'int type', 'int protocol', 'int *usockvec']],
                [0x36,  'setsockopt', ['int fd', 'int level', 'int optname', 'char *optval', 'int optlen']],
                [0x37,  'getsockopt', ['int fd', 'int level', 'int optname', 'char *optval', 'int *optlen']],
                [0x38,  'clone', ['unsigned long clone_flags', 'unsigned long newsp', 'int *parent_tidptr', 'int *child_tidptr', 'unsigned long tls']],
                [0x39,  'fork', []],
                [0x3a,  'vfork', []],
                [0x3b,  'execve', ['const char *filename', 'const char *const *argv', 'const char *const *envp']],
                [0x3c,  'exit', ['int error_code']],
                [0x3d,  'wait4', ['pid_t upid', 'int *stat_addr', 'int options', 'struct rusage *ru']],
                [0x3e,  'kill', ['pid_t pid', 'int sig']],
                [0x3f,  'uname', ['struct old_utsname *name']],
                [0x40,  'semget', ['key_t key', 'int nsems', 'int semflg']],
                [0x41,  'semop', ['int semid', 'struct sembuf *tsops', 'unsigned nsops']],
                [0x42,  'semctl', ['int semid', 'int semnum', 'int cmd', 'unsigned long arg']],
                [0x43,  'shmdt', ['char *shmaddr']],
                [0x44,  'msgget', ['key_t key', 'int msgflg']],
                [0x45,  'msgsnd', ['int msqid', 'struct msgbuf *msgp', 'size_t msgsz', 'int msgflg']],
                [0x46,  'msgrcv', ['int msqid', 'struct msgbuf *msgp', 'size_t msgsz', 'long msgtyp', 'int msgflg']],
                [0x47,  'msgctl', ['int msqid', 'int cmd', 'struct msqid_ds *buf']],
                [0x48,  'fcntl', ['unsigned int fd', 'unsigned int cmd', 'unsigned long arg']],
                [0x49,  'flock', ['unsigned int fd', 'unsigned int cmd']],
                [0x4a,  'fsync', ['unsigned int fd']],
                [0x4b,  'fdatasync', ['unsigned int fd']],
                [0x4c,  'truncate', ['const char *path', 'long length']],
                [0x4d,  'ftruncate', ['unsigned int fd', 'unsigned long length']],
                [0x4e,  'getdents', ['unsigned int fd', 'struct linux_dirent *dirent', 'unsigned int count']],
                [0x4f,  'getcwd', ['char *buf', 'unsigned long size']],
                [0x50,  'chdir', ['const char *filename']],
                [0x51,  'fchdir', ['unsigned int fd']],
                [0x52,  'rename', ['const char *oldname', 'const char *newname']],
                [0x53,  'mkdir', ['const char *pathname', 'umode_t mode']],
                [0x54,  'rmdir', ['const char *pathname']],
                [0x55,  'creat', ['const char *pathname', 'umode_t mode']],
                [0x56,  'link', ['const char *oldname', 'const char *newname']],
                [0x57,  'unlink', ['const char *pathname']],
                [0x58,  'symlink', ['const char *oldname', 'const char *newname']],
                [0x59,  'readlink', ['const char *path', 'char *buf', 'int bufsiz']],
                [0x5a,  'chmod', ['const char *filename', 'umode_t mode']],
                [0x5b,  'fchmod', ['unsigned int fd', 'umode_t mode']],
                [0x5c,  'chown', ['const char *filename', 'uid_t user', 'gid_t group']],
                [0x5d,  'fchown', ['unsigned int fd', 'uid_t user', 'gid_t group']],
                [0x5e,  'lchown', ['const char *filename', 'uid_t user', 'gid_t group']],
                [0x5f,  'umask', ['int mask']],
                [0x60,  'gettimeofday', ['struct __kernel_old_timeval *tv', 'struct timezone *tz']],
                [0x61,  'getrlimit', ['unsigned int resource', 'struct rlimit *rlim']],
                [0x62,  'getrusage', ['int who', 'struct rusage *ru']],
                [0x63,  'sysinfo', ['struct sysinfo *info']],
                [0x64,  'times', ['struct tms *tbuf']],
                [0x65,  'ptrace', ['long request', 'long pid', 'unsigned long addr', 'unsigned long data']],
                [0x66,  'getuid', []],
                [0x67,  'syslog', ['int type', 'char *buf', 'int len']],
                [0x68,  'getgid', []],
                [0x69,  'setuid', ['uid_t uid']],
                [0x6a,  'setgid', ['gid_t gid']],
                [0x6b,  'geteuid', []],
                [0x6c,  'getegid', []],
                [0x6d,  'setpgid', ['pid_t pid', 'pid_t pgid']],
                [0x6e,  'getppid', []],
                [0x6f,  'getpgrp', []],
                [0x70,  'setsid', []],
                [0x71,  'setreuid', ['uid_t ruid', 'uid_t euid']],
                [0x72,  'setregid', ['gid_t rgid', 'gid_t egid']],
                [0x73,  'getgroups', ['int gidsetsize', 'gid_t *grouplist']],
                [0x74,  'setgroups', ['int gidsetsize', 'gid_t *grouplist']],
                [0x75,  'setresuid', ['uid_t ruid', 'uid_t euid', 'uid_t suid']],
                [0x76,  'getresuid', ['uid_t *ruidp', 'uid_t *euidp', 'uid_t *suidp']],
                [0x77,  'setresgid', ['gid_t rgid', 'gid_t egid', 'gid_t sgid']],
                [0x78,  'getresgid', ['gid_t *rgidp', 'gid_t *egidp', 'gid_t *sgidp']],
                [0x79,  'getpgid', ['pid_t pid']],
                [0x7a,  'setfsuid', ['uid_t uid']],
                [0x7b,  'setfsgid', ['gid_t gid']],
                [0x7c,  'getsid', ['pid_t pid']],
                [0x7d,  'capget', ['cap_user_header_t header', 'cap_user_data_t dataptr']],
                [0x7e,  'capset', ['cap_user_header_t header', 'const cap_user_data_t data']],
                [0x7f,  'rt_sigpending', ['sigset_t *uset', 'size_t sigsetsize']],
                [0x80,  'rt_sigtimedwait', ['const sigset_t *uthese', 'siginfo_t *uinfo', 'const struct __kernel_timespec *uts', 'size_t sigsetsize']],
                [0x81,  'rt_sigqueueinfo', ['pid_t pid', 'int sig', 'siginfo_t *uinfo']],
                [0x82,  'rt_sigsuspend', ['sigset_t *unewset', 'size_t sigsetsize']],
                [0x83,  'sigaltstack', ['const stack_t *uss', 'stack_t *uoss']],
                [0x84,  'utime', ['char *filename', 'struct utimbuf *times']],
                [0x85,  'mknod', ['const char *filename', 'umode_t mode', 'unsigned dev']],
                [0x86,  'uselib', ['const char *library']],
                [0x87,  'personality', ['unsigned int personality']],
                [0x88,  'ustat', ['unsigned dev', 'struct ustat *ubuf']],
                [0x89,  'statfs', ['const char *pathname', 'struct statfs *buf']],
                [0x8a,  'fstatfs', ['unsigned int fd', 'struct statfs *buf']],
                [0x8b,  'sysfs', ['int option', 'unsigned long arg1', 'unsigned long arg2']],
                [0x8c,  'getpriority', ['int which', 'int who']],
                [0x8d,  'setpriority', ['int which', 'int who', 'int niceval']],
                [0x8e,  'sched_setparam', ['pid_t pid', 'struct sched_param *param']],
                [0x8f,  'sched_getparam', ['pid_t pid', 'struct sched_param *param']],
                [0x90,  'sched_setscheduler', ['pid_t pid', 'int policy', 'struct sched_param *param']],
                [0x91,  'sched_getscheduler', ['pid_t pid']],
                [0x92,  'sched_get_priority_max', ['int policy']],
                [0x93,  'sched_get_priority_min', ['int policy']],
                [0x94,  'sched_rr_get_interval', ['pid_t pid', 'struct __kernel_timespec *interval']],
                [0x95,  'mlock', ['unsigned long start', 'size_t len']],
                [0x96,  'munlock', ['unsigned long start', 'size_t len']],
                [0x97,  'mlockall', ['int flags']],
                [0x98,  'munlockall', []],
                [0x99,  'vhangup', []],
                [0x9a,  'modify_ldt', ['int func', 'void *ptr', 'unsigned long bytecount']],
                [0x9b,  'pivot_root', ['const char *new_root', 'const char *put_old']],
                [0x9c,  '_sysctl', ['struct __sysctl_args *args']], # sysctl # deleted from kenrel 5.5 ?
                [0x9d,  'prctl', ['int option', 'unsigned long arg2', 'unsigned long arg3', 'unsigned long arg4', 'unsigned long arg5']],
                [0x9e,  'arch_prctl', ['int option', 'unsigned long arg2']],
                [0x9f,  'adjtimex', ['struct __kernel_timex *txc_p']],
                [0xa0,  'setrlimit', ['unsigned int resource', 'struct rlimit *rlim']],
                [0xa1,  'chroot', ['const char *filename']],
                [0xa2,  'sync', []],
                [0xa3,  'acct', ['const char *name']],
                [0xa4,  'settimeofday', ['struct __kernel_old_timeval *tv', 'struct timezone *tz']],
                [0xa5,  'mount', ['char *dev_name', 'char *dir_name', 'char *type', 'unsigned long flags', 'void *data']],
                [0xa6,  'umount2', ['char *name', 'int flags']],
                [0xa7,  'swapon', ['const char *specialfile', 'int swap_flags']],
                [0xa8,  'swapoff', ['const char *specialfile']],
                [0xa9,  'reboot', ['int magic1', 'int magic2', 'unsigned int cmd', 'void *arg']],
                [0xaa,  'sethostname', ['char *name', 'int len']],
                [0xab,  'setdomainname', ['char *name', 'int len']],
                [0xac,  'iopl', ['unsigned int level']],
                [0xad,  'ioperm', ['unsigned long from', 'unsigned long num', 'int turn_on']],
                #0xae,  create_module # deleted from kernel 2.6
                [0xaf,  'init_module', ['void *umod', 'unsigned long len', 'const char *uargs']],
                [0xb0,  'delete_module', ['const char *name_user', 'unsigned int flags']],
                #0xb1,  get_kernel_syms # deleted from kernel 2.6
                #0xb2,  query_module # deleted from kernel 2.6
                [0xb3,  'quotactl', ['unsigned int cmd', 'const char *special', 'qid_t id', 'void *addr']],
                #0xb4,  nfsservctl # deleted from kernel 3.1
                #0xb5,  getpmsg # unimplemented
                #0xb6,  putpmsg # unimplemented
                #0xb7,  afs_syscall # unimplemented
                #0xb8,  tuxcall # unimplemented
                #0xb9,  security # unimplemented
                [0xba,  'gettid', []],
                [0xbb,  'readahead', ['int fd', 'loff_t offset', 'size_t count']],
                [0xbc,  'setxattr', ['const char *pathname', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0xbd,  'lsetxattr', ['const char *pathname', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0xbe,  'fsetxattr', ['int fd', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0xbf,  'getxattr', ['const char *pathname', 'const char *name', 'void *value', 'size_t size']],
                [0xc0,  'lgetxattr', ['const char *pathname', 'const char *name', 'void *value', 'size_t size']],
                [0xc1,  'fgetxattr', ['int fd', 'const char *name', 'void *value', 'size_t size']],
                [0xc2,  'listxattr', ['const char *pathname', 'char *list', 'size_t size']],
                [0xc3,  'llistxattr', ['const char *pathname', 'char *list', 'size_t size']],
                [0xc4,  'flistxattr', ['int fd', 'char *list', 'size_t size']],
                [0xc5,  'removexattr', ['const char *pathname', 'const char *name']],
                [0xc6,  'lremovexattr', ['const char *pathname', 'const char *name']],
                [0xc7,  'fremovexattr', ['int fd', 'const char *name']],
                [0xc8,  'tkill', ['pid_t pid', 'int sig']],
                [0xc9,  'time', ['__kernel_old_time_t *tloc']],
                [0xca,  'futex', ['u32 *uaddr', 'int op', 'u32 val', 'struct __kernel_timespec *utime', 'u32 *uaddr2', 'u32 val3']],
                [0xcb,  'sched_setaffinity', ['pid_t pid', 'unsigned int len', 'unsigned long *user_mask_ptr']],
                [0xcc,  'sched_getaffinity', ['pid_t pid', 'unsigned int len', 'unsigned long *user_mask_ptr']],
                [0xcd,  'set_thread_area', ['struct user_desc *u_info']],
                [0xce,  'io_setup', ['unsigned nr_events', 'aio_context_t *ctxp']],
                [0xcf,  'io_destroy', ['aio_context_t ctx']],
                [0xd0,  'io_getevents', ['aio_context_t ctx_id', 'long min_nr', 'long nr', 'struct io_event *events', 'struct __kernel_timespec *timeout']],
                [0xd1,  'io_submit', ['aio_context_t ctx_id', 'long nr', 'struct iocb **iocbpp']],
                [0xd2,  'io_cancel', ['aio_context_t ctx_id', 'struct iocb *iocb', 'struct io_event *result']],
                [0xd3,  'get_thread_area', ['struct user_desc *u_info']],
                [0xd4,  'lookup_dcookie', ['u64 cookie64', 'char *buf', 'size_t len']],
                [0xd5,  'epoll_create', ['int size']],
                #0xd6,  epoll_ctl_old # unimplemented
                #0xd7,  epoll_wait_old # unimplemented
                [0xd8,  'remap_file_pages', ['unsigned long start', 'unsigned long size', 'unsigned long prot', 'unsigned long pgoff', 'unsigned long flags']],
                [0xd9,  'getdents64', ['unsigned int fd', 'struct linux_dirent64 *dirent', 'unsigned int count']],
                [0xda,  'set_tid_address', ['int *tidptr']],
                [0xdb,  'restart_syscall', []],
                [0xdc,  'semtimedop', ['int semid', 'struct sembuf *tsops', 'unsigned int nsops', 'const struct __kernel_timespec *timeout']],
                [0xdd,  'fadvise64', ['int fd', 'loff_t offset', 'size_t len', 'int advice']],
                [0xde,  'timer_create', ['clockid_t which_clock', 'struct sigevent *timer_event_spec', 'timer_t *created_timer_id']],
                [0xdf,  'timer_settime', ['timer_t timer_id', 'int flags', 'const struct __kernel_itimerspec *new_setting', 'struct __kernel_itimerspec *old_setting']],
                [0xe0,  'timer_gettime', ['timer_t timer_id', 'struct __kernel_itimerspec *setting']],
                [0xe1,  'timer_getoverrun', ['timer_t timer_id']],
                [0xe2,  'timer_delete', ['timer_t timer_id']],
                [0xe3,  'clock_settime', ['clockid_t which_clock', 'const struct __kernel_timespec *tp']],
                [0xe4,  'clock_gettime', ['clockid_t which_clock', 'struct __kernel_timespec *tp']],
                [0xe5,  'clock_getres', ['clockid_t which_clock', 'struct __kernel_timespec *tp']],
                [0xe6,  'clock_nanosleep', ['clockid_t which_clock', 'int flags', 'const struct __kernel_timespec *rqtp', 'struct __kernel_timespec *rmtp']],
                [0xe7,  'exit_group', ['int error_code']],
                [0xe8,  'epoll_wait', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'int timeout']],
                [0xe9,  'epoll_ctl', ['int epfd', 'int op', 'int fd', 'struct epoll_event *event']],
                [0xea,  'tgkill', ['pid_t tgid', 'pid_t pid', 'int sig']],
                [0xeb,  'utimes', ['char *filename', 'struct __kernel_old_timeval *utimes']],
                #0xec,  vserver # unimplemented
                [0xed,  'mbind', ['unsigned long start', 'unsigned long len', 'unsigned long mode', 'const unsigned long *nmask', 'unsigned long maxnode', 'unsigned int flags']],
                [0xee,  'set_mempolicy', ['int mode', 'const unsigned long *nmask', 'unsigned long maxnode']],
                [0xef,  'get_mempolicy', ['int *policy', 'unsigned long *nmask', 'unsigned long maxnode', 'unsigned long addr', 'unsigned long flags']],
                [0xf0,  'mq_open', ['const char *u_name', 'int oflag', 'umode_t mode', 'struct mq_attr *u_attr']],
                [0xf1,  'mq_unlink', ['const char *u_name']],
                [0xf2,  'mq_timedsend', ['mqd_t mqdes', 'const char *u_msg_ptr', 'size_t msg_len', 'unsigned int msg_prio', 'const struct __kernel_timespec *u_abs_timeout']],
                [0xf3,  'mq_timedreceive', ['mqd_t mqdes', 'char *u_msg_ptr', 'size_t msg_len', 'unsigned int *u_msg_prio', 'const struct __kernel_timespec *u_abs_timeout']],
                [0xf4,  'mq_notify', ['mqd_t mqdes', 'const struct sigevent *u_notification']],
                [0xf5,  'mq_getsetattr', ['mqd_t mqdes', 'const struct mq_attr *u_mqstat', 'struct mq_attr *u_omqstat']],
                [0xf6,  'kexec_load', ['unsigned long entry', 'unsigned long nr_segments', 'struct kexec_segment *segments', 'unsigned long flags']],
                [0xf7,  'waitid', ['int which', 'pid_t pid', 'struct siginfo *infop', 'int options', 'struct rusage *ru']],
                [0xf8,  'add_key', ['const char *_type', 'const char *_description', 'const void *_payload', 'size_t plen', 'key_serial_t ringid']],
                [0xf9,  'request_key', ['const char *_type', 'const char *_description', 'const char *_callout_info', 'key_serial_t destringid']],
                [0xfa,  'keyctl', ['int option', 'unsigned long arg2', 'unsigned long arg3', 'unsigned long arg4', 'unsigned long arg5']],
                [0xfb,  'ioprio_set', ['int which', 'int who', 'int ioprio']],
                [0xfc,  'ioprio_get', ['int which', 'int who']],
                [0xfd,  'inotify_init', []],
                [0xfe,  'inotify_add_watch', ['int fd', 'const char *pathname', 'u32 mask']],
                [0xff,  'inotify_rm_watch', ['int fd', '__s32 wd']],
                [0x100, 'migrate_pages', ['pid_t pid', 'unsigned long maxnode', 'const unsigned long *old_nodes', 'const unsigned long *new_nodes']],
                [0x101, 'openat', ['int dfd', 'const char *filename', 'int flags', 'umode_t mode']],
                [0x102, 'mkdirat', ['int dfd', 'const char *pathname', 'umode_t mode']],
                [0x103, 'mknodat', ['int dfd', 'const char *filename', 'umode_t mode', 'unsigned int dev']],
                [0x104, 'fchownat', ['int dfd', 'const char *filename', 'uid_t user', 'gid_t group', 'int flag']],
                [0x105, 'futimesat', ['int dfd', 'const char *filename', 'struct __kernel_old_timeval *utimes']],
                [0x106, 'newfstatat', ['int dfd', 'const char *filename', 'struct stat *statbuf', 'int flag']],
                [0x107, 'unlinkat', ['int dfd', 'const char *pathname', 'int flag']],
                [0x108, 'renameat', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname']],
                [0x109, 'linkat', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname', 'int flags']],
                [0x10a, 'symlinkat', ['const char *oldname', 'int newdfd', 'const char *newname']],
                [0x10b, 'readlinkat', ['int dfd', 'const char *pathname', 'char *buf', 'int bufsiz']],
                [0x10c, 'fchmodat', ['int dfd', 'const char *filename', 'umode_t mode']],
                [0x10d, 'faccessat', ['int dfd', 'const char *filename', 'int mode']],
                [0x10e, 'pselect6', ['int n', 'fd_set *inp', 'fd_set *outp', 'fd_set *exp', 'struct __kernel_timespec *tsp', 'void *sig']],
                [0x10f, 'ppoll', ['struct pollfd *ufds', 'unsigned int nfds', 'struct __kernel_timespec *tsp', 'const sigset_t *sigmask', 'size_t sigsetsize']],
                [0x110, 'unshare', ['unsigned long unshare_flags']],
                [0x111, 'set_robust_list', ['struct robust_list_head *head', 'size_t len']],
                [0x112, 'get_robust_list', ['int pid', 'struct robust_list_head **head_ptr', 'size_t *len_ptr']],
                [0x113, 'splice', ['int fd_in', 'loff_t *off_in', 'int fd_out', 'loff_t *off_out', 'size_t len', 'unsigned int flags']],
                [0x114, 'tee', ['int fdin', 'int fdout', 'size_t len', 'unsigned int flags']],
                [0x115, 'sync_file_range', ['int fd', 'loff_t offset', 'loff_t nbytes', 'unsigned int flags']],
                [0x116, 'vmsplice', ['int fd', 'const struct iovec *uiov', 'unsigned long nr_segs', 'unsigned int flags']],
                [0x117, 'move_pages', ['pid_t pid', 'unsigned long nr_pages', 'const void **pages', 'const int *nodes', 'int *status', 'int flags']],
                [0x118, 'utimensat', ['int dfd', 'const char *filename', 'struct __kernel_timespec *utimes', 'int flags']],
                [0x119, 'epoll_pwait', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'int timeout', 'const sigset_t *sigmask', 'size_t sigsetsize']],
                [0x11a, 'signalfd', ['int ufd', 'sigset_t *user_mask', 'size_t sizemask']],
                [0x11b, 'timerfd_create', ['int clockid', 'int flags']],
                [0x11c, 'eventfd', ['unsigned int count']],
                [0x11d, 'fallocate', ['int fd', 'int mode', 'loff_t offset', 'loff_t len']],
                [0x11e, 'timerfd_settime', ['int ufd', 'int flags', 'const struct __kernel_itimerspec *utmr', 'struct __kernel_itimerspec *otmr']],
                [0x11f, 'timerfd_gettime', ['int ufd', 'struct __kernel_itimerspec *otmr']],
                [0x120, 'accept4', ['int fd', 'struct sockaddr *upeer_sockaddr', 'int *upeer_addrlen', 'int flags']],
                [0x121, 'signalfd4', ['int ufd', 'sigset_t *user_mask', 'size_t sizemask', 'int flags']],
                [0x122, 'eventfd2', ['unsigned int count', 'int flags']],
                [0x123, 'epoll_create1', ['int flags']],
                [0x124, 'dup3', ['unsigned int oldfd', 'unsigned int newfd', 'int flags']],
                [0x125, 'pipe2', ['int *fildes', 'int flags']],
                [0x126, 'inotify_init1', ['int flags']],
                [0x127, 'preadv', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen', 'unsigned long pos_l', 'unsigned long pos_h']],
                [0x128, 'pwritev', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen', 'unsigned long pos_l', 'unsigned long pos_h']],
                [0x129, 'rt_tgsigqueueinfo', ['pid_t tgid', 'pid_t pid', 'int sig', 'siginfo_t *uinfo']],
                [0x12a, 'perf_event_open', ['struct perf_event_attr *attr_uptr', 'pid_t pid', 'int cpu', 'int group_fd', 'unsigned long flags']],
                [0x12b, 'recvmmsg', ['int fd', 'struct mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags', 'struct __kernel_timespec *timeout']],
                [0x12c, 'fanotify_init', ['unsigned int flags', 'unsigned int event_f_flags']],
                [0x12d, 'fanotify_mark', ['int fanotify_fd', 'unsigned int flags', '__u64 mask', 'int dfd', 'const char *pathname']],
                [0x12e, 'prlimit64', ['pid_t pid', 'unsigned int resource', 'const struct rlimit64 *new_rlim', 'struct rlimit64 *old_rlim']],
                [0x12f, 'name_to_handle_at', ['int dfd', 'const char *name', 'struct file_handle *handle', 'int *mnt_id', 'int flag']],
                [0x130, 'open_by_handle_at', ['int mountdirfd', 'struct file_handle *handle', 'int flags']],
                [0x131, 'clock_adjtime', ['clockid_t which_clock', 'struct __kernel_timex *tx']],
                [0x132, 'syncfs', ['int fd']],
                [0x133, 'sendmmsg', ['int fd', 'struct mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags']],
                [0x134, 'setns', ['int fd', 'int flags']],
                [0x135, 'getcpu', ['unsigned *cpup', 'unsigned *nodep', 'struct getcpu_cache *unused']],
                [0x136, 'process_vm_readv', ['pid_t pid', 'const struct iovec *lvec', 'unsigned long liovcnt', 'const struct iovec *rvec', 'unsigned long riovcnt', 'unsigned long flags']],
                [0x137, 'process_vm_writev', ['pid_t pid', 'const struct iovec *lvec', 'unsigned long liovcnt', 'const struct iovec *rvec', 'unsigned long riovcnt', 'unsigned long flags']],
                [0x138, 'kcmp', ['pid_t pid1', 'pid_t pid2', 'int type', 'unsigned long idx1', 'unsigned long idx2']],
                [0x139, 'finit_module', ['int fd', 'const char *uargs', 'int flags']],
                [0x13a, 'sched_setattr', ['pid_t pid', 'struct sched_attr *uattr', 'unsigned int flags']],
                [0x13b, 'sched_getattr', ['pid_t pid', 'struct sched_attr *uattr', 'unsigned int usize', 'unsigned int flags']],
                [0x13c, 'renameat2', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname', 'unsigned int flags']],
                [0x13d, 'seccomp', ['unsigned int op', 'unsigned int flags', 'void *uargs']],
                [0x13e, 'getrandom', ['char *buf', 'size_t count', 'unsigned int flags']],
                [0x13f, 'memfd_create', ['const char *uname', 'unsigned int flags']],
                [0x140, 'kexec_file_load', ["int kernel_fd", "int initrd_fd", "unsigned long cmdline_len", "const char *cmdline_ptr", "unsigned long flags"]],
                [0x141, 'bpf', ['int cmd', 'union bpf_attr *uattr', 'unsigned int size']],
                [0x142, 'execveat', ['int fd', 'const char *filename', 'const char *const *argv', 'const char *const *envp', 'int flags']],
                [0x143, 'userfaultfd', ['int flags']],
                [0x144, 'membarrier', ['int cmd', 'int flags']],
                [0x145, 'mlock2', ['unsigned long start', 'size_t len', 'int flags']],
                [0x146, 'copy_file_range', ['int fd_in', 'loff_t *off_in', 'int fd_out', 'loff_t *off_out', 'size_t len', 'unsigned int flags']],
                [0x147, 'preadv2', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen', 'unsigned long pos_l', 'unsigned long pos_h', 'rwf_t flags']],
                [0x148, 'pwritev2', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen', 'unsigned long pos_l', 'unsigned long pos_h', 'rwf_t flags']],
                [0x149, 'pkey_mprotect', ['unsigned long start', 'size_t len', 'unsigned long prot', 'int pkey']],
                [0x14a, 'pkey_alloc', ['unsigned long flags', 'unsigned long init_val']],
                [0x14b, 'pkey_free', ['int pkey']],
                [0x14c, 'statx', ['int dfd', 'const char *filename', 'unsigned flags', 'unsigned int mask', 'struct statx *buffer']],
                [0x14d, 'io_pgetevents', ['aio_context_t ctx_id', 'long min_nr', 'long nr', 'struct io_event *events', 'struct __kernel_timespec *timeout', 'const struct __aio_sigset *usig']],
                [0x14e, 'rseq', ['struct rseq *rseq', 'u32 rseq_len', 'int flags', 'u32 sig']],
                # 0x14e-0x182, unused
                # 0x183-0x1a7, don't use
                [0x1a8, 'pidfd_send_signal', ['int pidfd', 'int sig', 'siginfo_t *info', 'unsigned int flags']],
                [0x1a9, 'io_uring_setup', ['u32 entries', 'struct io_uring_params *params']],
                [0x1aa, 'io_uring_enter', ['unsigned int fd', 'u32 to_submit', 'u32 min_complete', 'u32 flags', 'const sigset_t *sig', 'size_t sigsz']],
                [0x1ab, 'io_uring_register', ['unsigned int fd', 'unsigned int opcode', 'void *arg', 'unsigned int nr_args']],
                [0x1ac, 'open_tree', ['int dfd', 'const char *filename', 'unsigned flags']],
                [0x1ad, 'move_mount', ['int from_dfd', 'const char *from_pathname', 'int to_dfd', 'const char *to_pathname', 'unsigned int flags']],
                [0x1ae, 'fsopen', ['const char *_fs_name', 'unsigned int flags']],
                [0x1af, 'fsconfig', ['int fd', 'unsigned int cmd', 'const char *_key', 'const void *_value', 'int aux']],
                [0x1b0, 'fsmount', ['int fs_fd', 'unsigned int flags', 'unsigned int attr_flags']],
                [0x1b1, 'fspick', ['int, dfd', 'const char *path', 'unsigned int flags']],
                [0x1b2, 'pidfd_open', ['pid_t pid', 'unsigned int flags']],
                [0x1b3, 'clone3', ['struct clone_args *uargs', 'size_t size']],
                [0x1b4, 'close_range', ['unsigned int fd', 'unsigned int max_fd', 'unsigned int flag']],
                [0x1b5, 'openat2', ['int dfd', 'const char *filename', 'struct open_how *how', 'size_t usize']],
                [0x1b6, 'pidfd_getfd', ['int pidfd', 'int fd', 'unsigned int flags']],
                [0x1b7, 'faccessat2', ['int dfd', 'const char *filename', 'int mode', 'int flags']],
                [0x1b8, 'process_madvise', ['int pidfd', 'const struct iovec *vec', 'size_t vlen', 'int behavior', 'unsigned int flags']],
                [0x1b9, 'epoll_pwait2', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'const struct __kernel_timespec *timeout', 'const sigset_t *sigmask', 'size_t sigsetsize']],
                [0x1ba, 'mount_setattr', ['int dfd', 'const char *path', 'unsigned int flags', 'struct mount_attr *uattr', 'size_t usize']],
                [0x1bb, 'quotactl_fd', ['unsigned int fd', 'unsigned int cmd', 'qid_t id', 'void __user *addr']],
                [0x1bc, 'landlock_create_ruleset', ['const struct landlock_ruleset_attr *const attr', 'const size_t size', 'const __u32 flags']],
                [0x1bd, 'landlock_add_rule', ['const int ruleset_fd', 'const enum landlock_rule_type rule_type', 'const void *const rule_attr', 'const __u32 flags']],
                [0x1be, 'landlock_restrict_self', ['const int ruleset_fd', 'const __u32 flags']],
                [0x1bf, 'memfd_secret', ['unsigned int, flags']],
                [0x1c0, 'process_mrelease', ['int pidfd', 'unsigned int flags']],
                [0x1c1, 'futex_waitv', ['struct futex_waitv *waiters', 'unsigned int nr_futexes', 'unsigned int flags', 'struct __kernel_timespec *timeout', 'clockid_t clockid']],
                [0x1c2, 'set_mempolicy_home_node', ['unsigned long start', 'unsigned long len', 'unsigned long home_node', 'unsigned long flags']],
            ]
            syscall_list += [ # x32
                [0x40000200, 'rt_sigaction', ['int sig', 'const struct compat_sigaction *act', 'struct compat_sigaction *oact', 'compat_size_t sigsetsize']], # compat
                [0x40000201, 'rt_sigreturn', []], # compat x32_rt_sigreturn
                [0x40000202, 'ioctl', ['unsigned int fd', 'unsigned int cmd', 'compat_ulong_t arg']], # compat
                [0x40000203, 'readv', ['compat_ulong_t fd', 'const struct compat_iovec *vec', 'compat_ulong_t vlen']], # compat
                [0x40000204, 'writev', ['compat_ulong_t fd', 'const struct compat_iovec *vec', 'compat_ulong_t vlen']], # compat
                [0x40000205, 'recvfrom', ['int fd', 'void *buf', 'compat_size_t len', 'unsigned int flags', 'struct sockaddr *addr', 'int *addr_len']], # compat
                [0x40000206, 'sendmsg', ['int fd', 'struct compat_msghdr *msg', 'unsigned int flags']], # compat
                [0x40000207, 'recvmsg', ['int fd', 'struct compat_msghdr *msg', 'unsigned int flags']], # compat
                [0x40000208, 'execve', ['const char *filename', 'const compat_uptr_t *argv', 'const compat_uptr_t *envp']], # compat
                [0x40000209, 'ptrace', ['compat_long_t request', 'compat_long_t pid', 'compat_long_t addr', 'compat_long_t data']], # compat
                [0x4000020a, 'rt_sigpending', ['compat_sigset_t *uset', 'compat_size_t sigsetsize']],
                [0x4000020b, 'rt_sigtimedwait', ['const compat_sigset_t *uthese', 'struct compat_siginfo *uinfo', 'struct __kernel_timespec *uts', 'compat_size_t sigsetsize']], # compat rt_sigtimedwait_time64
                [0x4000020c, 'rt_sigqueueinfo', ['compat_pid_t pid', 'int sig', 'struct compat_siginfo *uinfo']], # compat
                [0x4000020d, 'sigaltstack', ['const compat_stack_t *uss_ptr', 'compat_stack_t *uoss_ptr']], # compat
                [0x4000020e, 'timer_create', ['clockid_t which_clock', 'struct compat_sigevent *timer_event_spec', 'timer_t *created_timer_id']], # compat
                [0x4000020f, 'mq_notify', ['mqd_t mqdes', 'const struct compat_sigevent *u_notification']], # compat
                [0x40000210, 'kexec_load', ['compat_ulong_t entry', 'compat_ulong_t nr_segments', 'struct compat_kkexec_segment *segments', 'compat_ulong_t flags']], # compat
                [0x40000211, 'waitid', ['int which', 'compat_pid_t pid', 'struct compat_siginfo *infop', 'int options', 'struct compat_rusage *uru']], # compat
                [0x40000212, 'set_robust_list', ['struct compat_robust_list_head *head', 'compat_size_t len']], # compat
                [0x40000213, 'get_robust_list', ['int pid', 'compat_uptr_t *head_ptr', 'compat_size_t *len_ptr']], # compat
                [0x40000214, 'vmsplice', ['int fd', 'const struct compat_iovec *iov32', 'unsigned int nr_segs', 'unsigned int flags']], # compat
                [0x40000215, 'move_pages', ['pid_t pid', 'compat_ulong_t nr_pages', 'compat_uptr_t *pages32', 'const int *nodes', 'int *status', 'int flags']], # compat
                [0x40000216, 'preadv', ['unsigned long fd', 'const struct compat_iovec *vec', 'unsigned long vlen', 'loff_t pos']], # compat preadv64
                [0x40000217, 'pwritev', ['unsigned long fd', 'const struct compat_iovec *vec', 'unsigned long vlen', 'loff_t pos']], # compat pwritev64
                [0x40000218, 'rt_tgsigqueueinfo', ['compat_pid_t tgid', 'compat_pid_t pid', 'int sig', 'struct compat_siginfo *uinfo']], # compat
                [0x40000219, 'recvmmsg', ['int fd', 'struct compat_mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags', 'struct __kernel_timespec *timeout']], # compat recvmmsg_time64
                [0x4000021a, 'sendmmsg', ['int fd', 'struct compat_mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags']], # compat
                [0x4000021b, 'process_vm_readv', ['compat_pid_t pid', 'const struct compat_iovec *lvec', 'compat_ulong_t liovcnt', 'const struct compat_iovec *rvec', 'compat_ulong_t riovcnt', 'compat_ulong_t flags']], # compat
                [0x4000021c, 'process_vm_writev', ['compat_pid_t pid', 'const struct compat_iovec *lvec', 'compat_ulong_t liovcnt', 'const struct compat_iovec *rvec', 'compat_ulong_t riovcnt', 'compat_ulong_t flags']], # compat
                [0x4000021d, 'setsockopt', ['int fd', 'int level', 'int optname', 'char *optval', 'int optlen']],
                [0x4000021e, 'getsockopt', ['int fd', 'int level', 'int optname', 'char *optval', 'int *optlen']],
                [0x4000021f, 'io_setup', ['unsigned nr_events', 'u32 *ctx32p']], # compat
                [0x40000220, 'io_submit', ['compat_aio_context_t ctx_id', 'int nr', 'compat_uptr_t *iocbpp']], # compat
                [0x40000221, 'execveat', ['int fd', 'const char *filename', 'const compat_uptr_t *argv', 'const compat_uptr_t *envp', 'int flags']], # compat
                [0x40000222, 'preadv2', ['unsigned long fd', 'const struct compat_iovec *vec', 'unsigned long vlen', 'loff_t pos', 'rwf_t flags']], # compat preadv64v2
                [0x40000223, 'pwritev2', ['unsigned long fd', 'const struct compat_iovec *vec', 'unsigned long vlen', 'loff_t pos', 'rwf_t flags']], # compat pwritev64v2
            ]
            name_list = list(zip(*syscall_list))[1]
            for s in syscall_list[::]:
                if name_list.count(s[1]) == 2: # already added
                    continue
                syscall_list += [[s[0]+0x40000000, s[1], s[2]]]

        elif arch == "X86" and mode == "32":
            register_list = ["$ebx", "$ecx", "$edx", "$esi", "$edi", "$ebp"]
            # arch/x86/include/asm/unistd.h
            # arch/x86/include/uapi/asm/unistd.h
            # arch/x86/include/generated/uapi/asm/unistd-32.h
            # arch/x86/entry/syscalls/syscall_32.tbl
            syscall_list = [
                [0x0,   'restart_syscall', []],
                [0x1,   'exit', ['int error_code']],
                [0x2,   'fork', []],
                [0x3,   'read', ['unsigned int fd', 'char *buf', 'size_t count']],
                [0x4,   'write', ['unsigned int fd', 'const char *buf', 'size_t count']],
                [0x5,   'open', ['const char *filename', 'int flags', 'umode_t mode']], # compat
                [0x6,   'close', ['unsigned int fd']],
                [0x7,   'waitpid', ['pid_t pid', 'int *stat_addr', 'int options']],
                [0x8,   'creat', ['const char *pathname', 'umode_t mode']],
                [0x9,   'link', ['const char *oldname', 'const char *newname']],
                [0xa,   'unlink', ['const char *pathname']],
                [0xb,   'execve', ['const char *filename', 'const compat_uptr_t *argv', 'const compat_uptr_t *envp']], # compat
                [0xc,   'chdir', ['const char *filename']],
                [0xd,   'time', ['old_time32_t *tloc']], # time32
                [0xe,   'mknod', ['const char *filename', 'umode_t mode', 'unsigned dev']],
                [0xf,   'chmod', ['const char *filename', 'umode_t mode']],
                [0x10,  'lchown', ['const char *filename', 'old_uid_t user', 'old_gid_t group']], # lchown16
                #0x11,  break # unimplemented
                [0x12,  'oldstat', ['const char *filename', 'struct __old_kernel_stat *statbuf']], # fstat
                [0x13,  'lseek', ['unsigned int fd', 'compat_off_t offset', 'unsigned int whence']], # compat
                [0x14,  'getpid', []],
                [0x15,  'mount', ['const char *dev_name', 'const char *dir_name', 'const char *type', 'compat_ulong_t flags', 'const void *data']], # compat
                [0x16,  'umount', ['char *name']], # oldumount
                [0x17,  'setuid', ['old_uid_t uid']], # setuid16
                [0x18,  'getuid', []], # getuid16
                [0x19,  'stime', ['old_time32_t *tptr']], # stime32
                [0x1a,  'ptrace', ['compat_long_t request', 'compat_long_t pid', 'compat_long_t addr', 'compat_long_t data']], # compat
                [0x1b,  'alarm', ['unsigned int seconds']],
                [0x1c,  'oldfstat', ['unsigned int fd', 'struct __old_kernel_stat *statbuf']], # fstat
                [0x1d,  'pause', []],
                [0x1e,  'utime', ['char *filename', 'struct old_utimbuf32 *t']], # utime32
                #0x1f,  stty # unimplemented
                #0x20,  gtty # unimplemented
                [0x21,  'access', ['const char *filename', 'int mode']],
                [0x22,  'nice', ['int increment']],
                #0x23,  ftime # unimplemented
                [0x24,  'sync', []],
                [0x25,  'kill', ['pid_t pid', 'int sig']],
                [0x26,  'rename', ['const char *oldname', 'const char *newname']],
                [0x27,  'mkdir', ['const char *pathname', 'umode_t mode']],
                [0x28,  'rmdir', ['const char *pathname']],
                [0x29,  'dup', ['unsigned int fildes']],
                [0x2a,  'pipe', ['int *fildes']],
                [0x2b,  'times', ['struct compat_tms *tbuf']], # compat
                #0x2c,  prof # unimplemented
                [0x2d,  'brk', ['unsigned long brk']],
                [0x2e,  'setgid', ['old_gid_t gid']], # setgid16
                [0x2f,  'getgid', []], # getgid16
                [0x30,  'signal', ['int sig', '__sighandler_t handler']],
                [0x31,  'geteuid', []], # geteuid16
                [0x32,  'getegid', []], # getegid16
                [0x33,  'acct', ['const char *name']],
                [0x34,  'umount2', ['char *name', 'int flags']], # umount
                #0x35,  lock # unimplemented
                [0x36,  'ioctl', ['unsigned int fd', 'unsigned int cmd', 'compat_ulong_t arg']], # compat
                [0x37,  'fcntl', ['unsigned int fd', 'unsigned int cmd', 'compat_ulong_t arg']], # compat fcntl64
                #0x38,  mpx # unimplemented
                [0x39,  'setpgid', ['pid_t pid', 'pid_t pgid']],
                #0x3a,  ulimit # unimplemented
                [0x3b,  'oldolduname', ['struct oldold_utsname *name']], # olduname
                [0x3c,  'umask', ['int mask']],
                [0x3d,  'chroot', ['const char *filename']],
                [0x3e,  'ustat', ['unsigned dev', 'struct compat_ustat *u']], # compat
                [0x3f,  'dup2', ['unsigned int oldfd', 'unsigned int newfd']],
                [0x40,  'getppid', []],
                [0x41,  'getpgrp', []],
                [0x42,  'setsid', []],
                [0x43,  'sigaction', ['int sig', 'const struct compat_old_sigaction *act', 'struct compat_old_sigaction *oact']], # compat
                [0x44,  'sgetmask', []],
                [0x45,  'ssetmask', ['int newmask']],
                [0x46,  'setreuid', ['old_uid_t ruid', 'old_uid_t euid']], # setreuid16
                [0x47,  'setregid', ['old_gid_t rgid', 'old_gid_t egid']], # setregid16
                [0x48,  'sigsuspend', ['old_sigset_t mask']],
                [0x49,  'sigpending', ['compat_old_sigset_t *set32']], # compat
                [0x4a,  'sethostname', ['char *name', 'int len']],
                [0x4b,  'setrlimit', ['unsigned int resource', 'struct compat_rlimit *rlim']], # compat
                [0x4c,  'getrlimit', ['unsigned int resource', 'struct compat_rlimit *rlim']], # compat old_getrlimit
                [0x4d,  'getrusage', ['int who', 'struct compat_rusage *ru']], # compat
                [0x4e,  'gettimeofday', ['struct old_timeval32 *tv', 'struct timezone *tz']], # compat
                [0x4f,  'settimeofday', ['struct old_timeval32 *tv', 'struct timezone *tz']], # compat
                [0x50,  'getgroups', ['int gidsetsize', 'old_gid_t *grouplist']], # getgroups16
                [0x51,  'setgroups', ['int gidsetsize', 'old_gid_t *grouplist']], # setgroups16
                [0x52,  'select', ['struct compat_sel_arg_struct *arg']], # compat old_select
                [0x53,  'symlink', ['const char *oldname', 'const char *newname']],
                [0x54,  'oldlstat', ['const char *filename', 'struct __old_kernel_stat *statbuf']], # lstat
                [0x55,  'readlink', ['const char *path', 'char *buf', 'int bufsiz']],
                [0x56,  'uselib', ['const char *library']],
                [0x57,  'swapon', ['const char *specialfile', 'int swap_flags']],
                [0x58,  'reboot', ['int magic1', 'int magic2', 'unsigned int cmd', 'void *arg']],
                [0x59,  'readdir', ['unsigned int fd', 'struct compat_old_linux_dirent *dirent', 'unsigned int count']], # compat old_readdir
                [0x5a,  'mmap', ['struct mmap_arg_struct32 *arg']], # compat ia32_mmap
                [0x5b,  'munmap', ['unsigned long addr', 'size_t len']],
                [0x5c,  'truncate', ['const char *path', 'compat_off_t length']], # compat
                [0x5d,  'ftruncate', ['unsigned int fd', 'compat_ulong_t length']], # compat
                [0x5e,  'fchmod', ['unsigned int fd', 'umode_t mode']],
                [0x5f,  'fchown', ['unsigned int fd', 'old_uid_t user', 'old_gid_t group']], # fchown16
                [0x60,  'getpriority', ['int which', 'int who']],
                [0x61,  'setpriority', ['int which', 'int who', 'int niceval']],
                #0x62,  profil # unimplemented
                [0x63,  'statfs', ['const char *pathname', 'struct compat_statfs *buf']], # compat
                [0x64,  'fstatfs', ['unsigned int fd', 'struct compat_statfs *buf']], # compat
                [0x65,  'ioperm', ['unsigned long from', 'unsigned long num', 'int turn_on']],
                [0x66,  'socketcall', ['int call', 'u32 *args']], # compat
                [0x67,  'syslog', ['int type', 'char *buf', 'int len']],
                [0x68,  'setitimer', ['int which', 'struct old_itimerval32 *value', 'struct old_itimerval32 *ovalue']], # compat
                [0x69,  'getitimer', ['int which', 'struct old_itimerval32 *value']], # compat
                [0x6a,  'stat', ['const char *filename', 'struct compat_stat *statbuf']], # compat newstat
                [0x6b,  'lstat', ['const char *filename', 'struct compat_stat *statbuf']], # compat newlstat
                [0x6c,  'fstat', ['unsigned int fd', 'struct compat_stat *statbuf']], # compat newfstat
                [0x6d,  'olduname', ['struct old_utsname *name']], # uname
                [0x6e,  'iopl', ['unsigned int level']],
                [0x6f,  'vhangup', []],
                #0x70,  idle # deleted from kernel 2.3.13
                #0x71,  vm86old # only native i386
                [0x72,  'wait4', ['compat_pid_t upid', 'compat_uint_t *stat_addr', 'int options', 'struct compat_rusage *ru']], # compat
                [0x73,  'swapoff', ['const char *specialfile']],
                [0x74,  'sysinfo', ['struct compat_sysinfo *info']], # compat
                [0x75,  'ipc', ['u32 call', 'int first', 'int second', 'u32 third', 'compat_uptr_t ptr', 'u32 fifth']], # compat
                [0x76,  'fsync', ['unsigned int fd']],
                [0x77,  'sigreturn', []], # compat
                [0x78,  'clone', ['unsigned long clone_flags', 'unsigned long newsp', 'int *parent_tidptr', 'unsigned long tls_val', 'int *child_tidptr']], # compat ia32_clone
                [0x79,  'setdomainname', ['char *name', 'int len']],
                [0x7a,  'uname', ['struct new_utsname *name']], # newuname
                [0x7b,  'modify_ldt', ['int func', 'void *ptr', 'unsigned long bytecount']],
                [0x7c,  'adjtimex', ['struct old_timex32 *utp']], # adjtimex_time32
                [0x7d,  'mprotect', ['unsigned long start', 'size_t len', 'unsigned long prot']],
                [0x7e,  'sigprocmask', ['int how', 'compat_old_sigset_t *nset', 'compat_old_sigset_t *oset']], # compat
                #0x7f,  create_module # deleted from kernel 2.6
                [0x80,  'init_module', ['void *umod', 'unsigned long len', 'const char *uargs']],
                [0x81,  'delete_module', ['const char *name_user', 'unsigned int flags']],
                #0x82,  get_kernel_syms # deleted from kernel 2.6
                [0x83,  'quotactl', ['unsigned int cmd', 'const char *special', 'qid_t id', 'void *addr']], # compat quotactl32
                [0x84,  'getpgid', ['pid_t pid']],
                [0x85,  'fchdir', ['unsigned int fd']],
                [0x86,  'bdflush', ['int func', 'long data']],
                [0x87,  'sysfs', ['int option', 'unsigned long arg1', 'unsigned long arg2']],
                [0x88,  'personality', ['unsigned int personality']],
                #0x89,  afs_syscall # unimplemented
                [0x8a,  'setfsuid', ['old_uid_t uid']], # setfsuid16
                [0x8b,  'setfsgid', ['old_gid_t gid']], # setfsgid16
                [0x8c,  '_llseek', ['unsigned int fd', 'unsigned long offset_high', 'unsigned long offset_low', 'loff_t *result', 'unsigned int whence']], # llseek
                [0x8d,  'getdents', ['unsigned int fd', 'struct compat_linux_dirent *dirent', 'unsigned int count']], # compat
                [0x8e,  '_newselect', ['int n', 'compat_ulong_t *inp', 'compat_ulong_t *outp', 'compat_ulong_t *exp', 'struct old_timeval32 *tvp']], # compat select
                [0x8f,  'flock', ['unsigned int fd', 'unsigned int cmd']],
                [0x90,  'msync', ['unsigned long start', 'size_t len', 'int flags']],
                [0x91,  'readv', ['compat_ulong_t fd', 'const struct compat_iovec *vec', 'compat_ulong_t vlen']], # compat
                [0x92,  'writev', ['compat_ulong_t fd', 'const struct compat_iovec *vec', 'compat_ulong_t vlen']], # compat
                [0x93,  'getsid', ['pid_t pid']],
                [0x94,  'fdatasync', ['unsigned int fd']],
                [0x95,  '_sysctl', ['struct __sysctl_args *args']], # sysctl # deleted from kenrel 5.5 ?
                [0x96,  'mlock', ['unsigned long start', 'size_t len']],
                [0x97,  'munlock', ['unsigned long start', 'size_t len']],
                [0x98,  'mlockall', ['int flags']],
                [0x99,  'munlockall', []],
                [0x9a,  'sched_setparam', ['pid_t pid', 'struct sched_param *param']],
                [0x9b,  'sched_getparam', ['pid_t pid', 'struct sched_param *param']],
                [0x9c,  'sched_setscheduler', ['pid_t pid', 'int policy', 'struct sched_param *param']],
                [0x9d,  'sched_getscheduler', ['pid_t pid']],
                [0x9e,  'sched_yield', []],
                [0x9f,  'sched_get_priority_max', ['int policy']],
                [0xa0,  'sched_get_priority_min', ['int policy']],
                [0xa1,  'sched_rr_get_interval', ['pid_t pid', 'struct old_timespec32 *interval']], # sched_rr_get_interval_time32
                [0xa2,  'nanosleep', ['struct old_timespec32 *rqtp', 'struct old_timespec32 *rmtp']], # nanosleep_time32
                [0xa3,  'mremap', ['unsigned long addr', 'unsigned long old_len', 'unsigned long new_len', 'unsigned long flags', 'unsigned long new_addr']],
                [0xa4,  'setresuid', ['old_uid_t ruid', 'old_uid_t euid', 'old_uid_t suid']], # setresuid16
                [0xa5,  'getresuid', ['old_uid_t *ruidp', 'old_uid_t *euidp', 'old_uid_t *suidp']], # getresuid16
                #0xa6,  vm86 # only native i386
                #0xa7,  query_module # deleted from kernel 2.6
                [0xa8,  'poll', ['struct pollfd *ufds', 'unsigned int nfds', 'int timeout_msecs']],
                #0xa9,  nfsservctl # deleted from kernel 3.1
                [0xaa,  'setresgid', ['old_gid_t rgid', 'old_gid_t egid', 'old_gid_t sgid']], # setresgid16
                [0xab,  'getresgid', ['old_gid_t *rgidp', 'old_gid_t *egidp', 'old_gid_t *sgidp']], # getresgid16
                [0xac,  'prctl', ['int option', 'unsigned long arg2', 'unsigned long arg3', 'unsigned long arg4', 'unsigned long arg5']],
                [0xad,  'rt_sigreturn', []], # compat
                [0xae,  'rt_sigaction', ['int sig', 'const struct compat_sigaction *act', 'struct compat_sigaction *oact', 'compat_size_t sigsetsize']], # compat
                [0xaf,  'rt_sigprocmask', ['int how', 'compat_sigset_t *nset', 'compat_sigset_t *oset', 'compat_size_t sigsetsize']], # compat
                [0xb0,  'rt_sigpending', ['compat_sigset_t *uset', 'compat_size_t sigsetsize']], # compat
                [0xb1,  'rt_sigtimedwait', ['compat_sigset_t *uthese', 'struct compat_siginfo_t *uinfo', 'struct old_timespec32 *uts', 'compat_size_t sigsetsize']], # compat rt_sigtimedwait_time32
                [0xb2,  'rt_sigqueueinfo', ['compat_pid_t pid', 'int sig', 'struct compat_siginfo *uinfo']], # compat
                [0xb3,  'rt_sigsuspend', ['compat_sigset_t *unewset', 'compat_size_t sigsetsize']], # compat
                [0xb4,  'pread64', ['unsigned int fd', 'char *ubuf', 'u32 count', 'u32 poslo', 'u32 poshi']], # ia32_pread64
                [0xb5,  'pwrite64', ['unsigned int fd', 'const char *ubuf', 'u32 count', 'u32 poslo', 'u32 poshi']], # ia32_pwrite64
                [0xb6,  'chown', ['const char *filename', 'old_uid_t user', 'old_gid_t group']], # chown16
                [0xb7,  'getcwd', ['char *buf', 'unsigned long size']],
                [0xb8,  'capget', ['cap_user_header_t header', 'cap_user_data_t dataptr']],
                [0xb9,  'capset', ['cap_user_header_t header', 'const cap_user_data_t data']],
                [0xba,  'sigaltstack', ['const compat_stack_t *uss_ptr', 'compat_stack_t *uoss_ptr']], # compat
                [0xbb,  'sendfile', ['int out_fd', 'int in_fd', 'compat_off_t *offset', 'compat_size_t count']], # compat
                #0xbc,  getpmsg # unimplemented
                #0xbd,  putpmsg # unimplemented
                [0xbe,  'vfork', []],
                [0xbf,  'ugetrlimit', ['unsigned int resource', 'struct compat_rlimit *rlim']], # compat getrlimit
                [0xc0,  'mmap2', ['unsigned long addr', 'unsigned long len', 'unsigned long prot', 'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff']], # mmap_pgoff
                [0xc1,  'truncate64', ['const char *filename', 'unsigned long offset_low', 'unsigned long offset_high']], # ia32_truncate64
                [0xc2,  'ftruncate64', ['unsigned int fd', 'unsigned long offset_low', 'unsigned long offset_high']], # ia32_ftruncate64
                [0xc3,  'stat64', ['const char *filename', 'struct stat64 *statbuf']], # compat ia32_stat64
                [0xc4,  'lstat64', ['const char *filename', 'struct stat64 *statbuf']], # compat ia32_lstat64
                [0xc5,  'fstat64', ['unsigned long fd', 'struct stat64 *statbuf']], # compat ia32_fstat64
                [0xc6,  'lchown32', ['const char *filename', 'uid_t user', 'gid_t group']], # lchown
                [0xc7,  'getuid32', []], # getuid
                [0xc8,  'getgid32', []], # getgid
                [0xc9,  'geteuid32', []], # geteuid
                [0xca,  'getegid32', []], # getegid
                [0xcb,  'setreuid32', ['uid_t ruid', 'uid_t euid']], # setreuid32
                [0xcc,  'setregid32', ['gid_t rgid', 'gid_t egid']], # setregid32
                [0xcd,  'getgroups32', ['int gidsetsize', 'gid_t *grouplist']], # getgroups32
                [0xce,  'setgroups32', ['int gidsetsize', 'gid_t *grouplist']], # setgroups32
                [0xcf,  'fchown32', ['unsigned int fd', 'uid_t user', 'gid_t group']], # fchown
                [0xd0,  'setresuid32', ['uid_t ruid', 'uid_t euid', 'uid_t suid']], # setresuid
                [0xd1,  'getresuid32', ['uid_t *ruidp', 'uid_t *euidp', 'uid_t *suidp']], # getresuid
                [0xd2,  'setresgid32', ['gid_t rgid', 'gid_t egid', 'gid_t sgid']], # setresgid
                [0xd3,  'getresgid32', ['gid_t *rgidp', 'gid_t *egidp', 'gid_t *sgidp']], # getresgid
                [0xd4,  'chown32', ['const char *filename', 'uid_t user', 'gid_t group']], # chown
                [0xd5,  'setuid32', ['uid_t uid']], # setuid
                [0xd6,  'setgid32', ['gid_t gid']], # setgid
                [0xd7,  'setfsuid32', ['uid_t uid']], # setfsuid
                [0xd8,  'setfsgid32', ['gid_t gid']], # setfsgid
                [0xd9,  'pivot_root', ['const char *new_root', 'const char *put_old']],
                [0xda,  'mincore', ['unsigned long start', 'size_t len', 'unsigned char *vec']],
                [0xdb,  'madvise', ['unsigned long start', 'size_t len_in', 'int behavior']],
                [0xdc,  'getdents64', ['unsigned int fd', 'struct linux_dirent64 *dirent', 'unsigned int count']],
                [0xdd,  'fcntl64', ['unsigned int fd', 'unsigned int cmd', 'compat_ulong_t arg']], # compat
                #0xde,  unused
                #0xdf,  unused
                [0xe0,  'gettid', []],
                [0xe1,  'readahead', ['int fd', 'unsigned int off_lo', 'unsigned int off_high', 'size_t count']], # ia32_readahead
                [0xe2,  'setxattr', ['const char *pathname', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0xe3,  'lsetxattr', ['const char *pathname', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0xe4,  'fsetxattr', ['int fd', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0xe5,  'getxattr', ['const char *pathname', 'const char *name', 'void *value', 'size_t size']],
                [0xe6,  'lgetxattr', ['const char *pathname', 'const char *name', 'void *value', 'size_t size']],
                [0xe7,  'fgetxattr', ['int fd', 'const char *name', 'void *value', 'size_t size']],
                [0xe8,  'listxattr', ['const char *pathname', 'char *list', 'size_t size']],
                [0xe9,  'llistxattr', ['const char *pathname', 'char *list', 'size_t size']],
                [0xea,  'flistxattr', ['int fd', 'char *list', 'size_t size']],
                [0xeb,  'removexattr', ['const char *pathname', 'const char *name']],
                [0xec,  'lremovexattr', ['const char *pathname', 'const char *name']],
                [0xed,  'fremovexattr', ['int fd', 'const char *name']],
                [0xee,  'tkill', ['pid_t pid', 'int sig']],
                [0xef,  'sendfile64', ['int out_fd', 'int in_fd', 'loff_t *offset', 'size_t count']],
                [0xf0,  'futex', ['u32 *uaddr', 'int op', 'u32 val', 'struct old_timespec32 *utime', 'u32 *uaddr2', 'u32 val3']], # futex_time32
                [0xf1,  'sched_setaffinity', ['compat_pid_t pid', 'unsigned int len', 'compat_ulong_t *user_mask_ptr']], # compat
                [0xf2,  'sched_getaffinity', ['compat_pid_t pid', 'unsigned int len', 'compat_ulong_t *user_mask_ptr']], # compat
                [0xf3,  'set_thread_area', ['struct user_desc *u_info']],
                [0xf4,  'get_thread_area', ['struct user_desc *u_info']],
                [0xf5,  'io_setup', ['unsigned nr_events', 'u32 *ctx32p']], # compat
                [0xf6,  'io_destroy', ['aio_context_t ctx']],
                [0xf7,  'io_getevents', ['__u32 ctx_id', '__s32 min_nr', '__s32 nr', 'struct io_event *events', 'struct old_timespec32 *timeout']], # io_getevents_time32
                [0xf8,  'io_submit', ['compat_aio_context_t ctx_id', 'int nr', 'compat_uptr_t *iocbpp']], # compat
                [0xf9,  'io_cancel', ['aio_context_t ctx_id', 'struct iocb *iocb', 'struct io_event *result']],
                [0xfa,  'fadvise64', ['int fd', 'unsigned int offset_lo', 'unsigned int offset_hi', 'size_t len', 'int advice']], # ia32_fadvise64
                #0xfb,  set_zone_reclaim
                [0xfc,  'exit_group', ['int error_code']],
                [0xfd,  'lookup_dcookie', ['u32 w0', 'u32 w1', 'char *buf', 'compat_size_t len']], # compat
                [0xfe,  'epoll_create', ['int size']],
                [0xff,  'epoll_ctl', ['int epfd', 'int op', 'int fd', 'struct epoll_event *event']],
                [0x100, 'epoll_wait', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'int timeout']],
                [0x101, 'remap_file_pages', ['unsigned long start', 'unsigned long size', 'unsigned long prot', 'unsigned long pgoff', 'unsigned long flags']],
                [0x102, 'set_tid_address', ['int *tidptr']],
                [0x103, 'timer_create', ['clockid_t which_clock', 'struct compat_sigevent *timer_event_spec', 'timer_t *created_timer_id']], # compat
                [0x104, 'timer_settime', ['timer_t timer_id', 'int flags', 'struct old_itimerspec32 *new', 'struct old_itimerspec32 *old']], # timer_settime32
                [0x105, 'timer_gettime', ['timer_t timer_id', 'struct old_itimerspec32 *setting']],
                [0x106, 'timer_getoverrun', ['timer_t timer_id']],
                [0x107, 'timer_delete', ['timer_t timer_id']],
                [0x108, 'clock_settime', ['clockid_t which_clock', 'struct old_timespec32 *tp']], # clock_settime32
                [0x109, 'clock_gettime', ['clockid_t which_clock', 'struct old_timespec32 *tp']], # clock_gettime32
                [0x10a, 'clock_getres', ['clockid_t which_clock', 'struct old_timespec32 *tp']], # clock_getres_time32
                [0x10b, 'clock_nanosleep', ['clockid_t which_clock', 'int flags', 'struct old_timespec32 *rqtp', 'struct old_timespec32 *rmtp']], # clock_nanosleep_time32
                [0x10c, 'statfs64', ['const char *pathname', 'compat_size_t sz', 'struct compat_statfs64 *buf']], # compat
                [0x10d, 'fstatfs64', ['unsigned int fd', 'compat_size_t sz', 'struct compat_statfs64 *buf']], # compat
                [0x10e, 'tgkill', ['pid_t tgid', 'pid_t pid', 'int sig']],
                [0x10f, 'utimes', ['char *filename', 'struct old_timeval32 *utimes']], # utimes_time32
                [0x110, 'fadvise64_64', ['int fd', '__u32 offset_low', '__u32 offset_high', '__u32 len_low', '__u32 len_high', 'int advice']], # ia32_fadvise64_64
                #0x111, vserver # unimplemented
                [0x112, 'mbind', ['unsigned long start', 'unsigned long len', 'unsigned long mode', 'const unsigned long *nmask', 'unsigned long maxnode', 'unsigned int flags']],
                [0x113, 'get_mempolicy', ['int *policy', 'compat_ulong_t *nmask', 'compat_ulong_t maxnode', 'compat_ulong_t addr', 'compat_ulong_t flags']], # compat
                [0x114, 'set_mempolicy', ['int mode', 'const unsigned long *nmask', 'unsigned long maxnode']],
                [0x115, 'mq_open', ['const char *u_name', 'int oflag', 'compat_mode_t mode', 'struct compat_mq_attr *u_attr']], # compat
                [0x116, 'mq_unlink', ['const char *u_name']],
                [0x117, 'mq_timedsend', ['mqd_t mqdes', 'const char *u_msg_ptr', 'unsigned int msg_len', 'unsigned int msg_prio', 'const struct old_timespec32 *u_abs_timeout']], # mq_timedsend_time32
                [0x118, 'mq_timedreceive', ['mqd_t mqdes', 'char *u_msg_ptr', 'unsigned int msg_len', 'unsigned int *u_msg_prio', 'const struct old_timespec32 *u_abs_timeout']], # mq_timedreceive_time32
                [0x119, 'mq_notify', ['mqd_t mqdes', 'const struct compat_sigevent *u_notification']], # compat
                [0x11a, 'mq_getsetattr', ['mqd_t mqdes', 'const struct compat_mq_attr *u_mqstat', 'struct compat_mq_attr *u_omqstat']], # compat
                [0x11b, 'kexec_load', ['compat_ulong_t entry', 'compat_ulong_t nr_segments', 'struct compat_kexec_segment *segments', 'compat_ulong_t flags']], # compat
                [0x11c, 'waitid', ['int which', 'compat_pid_t pid', 'struct compat_siginfo *infop', 'int options', 'struct compat_rusage *uru']], # compat
                #0x11d, unused
                [0x11e, 'add_key', ['const char *_type', 'const char *_description', 'const void *_payload', 'size_t plen', 'key_serial_t ringid']],
                [0x11f, 'request_key', ['const char *_type', 'const char *_description', 'const char *_callout_info', 'key_serial_t destringid']],
                [0x120, 'keyctl', ['u32 option', 'u32 arg2', 'u32 arg3', 'u32 arg4', 'u32 arg5']], # compat
                [0x121, 'ioprio_set', ['int which', 'int who', 'int ioprio']],
                [0x122, 'ioprio_get', ['int which', 'int who']],
                [0x123, 'inotify_init', []],
                [0x124, 'inotify_add_watch', ['int fd', 'const char *pathname', 'u32 mask']],
                [0x125, 'inotify_rm_watch', ['int fd', '__s32 wd']],
                [0x126, 'migrate_pages', ['pid_t pid', 'unsigned long maxnode', 'const unsigned long *old_nodes', 'const unsigned long *new_nodes']],
                [0x127, 'openat', ['int dfd', 'const char *filename', 'int flags', 'umode_t mode']], # compat
                [0x128, 'mkdirat', ['int dfd', 'const char *pathname', 'umode_t mode']],
                [0x129, 'mknodat', ['int dfd', 'const char *filename', 'umode_t mode', 'unsigned int dev']],
                [0x12a, 'fchownat', ['int dfd', 'const char *filename', 'uid_t user', 'gid_t group', 'int flag']],
                [0x12b, 'futimesat', ['unsigned int dfd', 'const char *filename', 'struct old_timeval32 *t']], # futimesat_time32
                [0x12c, 'fstatat64', ['unsigned int dfd', 'const char *filename', 'struct stat64 *statbuf', 'int flag']], # compat ia32_fstatat64
                [0x12d, 'unlinkat', ['int dfd', 'const char *pathname', 'int flag']],
                [0x12e, 'renameat', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname']],
                [0x12f, 'linkat', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname', 'int flags']],
                [0x130, 'symlinkat', ['const char *oldname', 'int newdfd', 'const char *newname']],
                [0x131, 'readlinkat', ['int dfd', 'const char *pathname', 'char *buf', 'int bufsiz']],
                [0x132, 'fchmodat', ['int dfd', 'const char *filename', 'umode_t mode']],
                [0x133, 'faccessat', ['int dfd', 'const char *filename', 'int mode']],
                [0x134, 'pselect6', ['int n', 'compat_ulong_t *inp', 'compat_ulong_t *outp', 'compat_ulong_t *exp', 'struct old_timespec32 *tsp', 'void *sig']], # compat pselect6_time32
                [0x135, 'ppoll', ['struct pollfd *ufds', 'unsigned int nfds', 'struct old_timespec32 *tsp', 'const compat_sigset_t *sigmask', 'compat_size_t sigsetsize']], # compat ppoll_time32
                [0x136, 'unshare', ['unsigned long unshare_flags']],
                [0x137, 'set_robust_list', ['struct compat_robust_list_head *head', 'compat_size_t len']], # compat
                [0x138, 'get_robust_list', ['int pid', 'compat_uptr_t *head_ptr', 'compat_size_t *len_ptr']], # compat
                [0x139, 'splice', ['int fd_in', 'loff_t *off_in', 'int fd_out', 'loff_t *off_out', 'size_t len', 'unsigned int flags']],
                [0x13a, 'sync_file_range', ['int fd', 'unsigned int off_low', 'unsigned int off_hi', 'unsigned int n_low', 'unsigned int n_hi', 'unsigned int flags']], # ia32_sync_file_range
                [0x13b, 'tee', ['int fdin', 'int fdout', 'size_t len', 'unsigned int flags']],
                [0x13c, 'vmsplice', ['int fd', 'const struct compat_iovec *iov32', 'unsigned int nr_segs', 'unsigned int flags']], # compat
                [0x13d, 'move_pages', ['pid_t pid', 'compat_ulong_t nr_pages', 'compat_uptr_t *pages32', 'const int *nodes', 'int *status', 'int flags']], # compat
                [0x13e, 'getcpu', ['unsigned *cpup', 'unsigned *nodep', 'struct getcpu_cache *unused']],
                [0x13f, 'epoll_pwait', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'int timeout', 'const sigset_t *sigmask', 'size_t sigsetsize']],
                [0x140, 'utimensat', ['unsigned int dfd', 'const char *filename', 'struct old_timespec32 *t', 'int flags']], # utimensat_time32
                [0x141, 'signalfd', ['int ufd', 'const compat_sigset_t *user_mask', 'compat_size_t sizemask']], # compat
                [0x142, 'timerfd_create', ['int clockid', 'int flags']],
                [0x143, 'eventfd', ['unsigned int count']],
                [0x144, 'fallocate', ['int fd', 'int mode', 'unsigned int offset_lo', 'unsigned int offset_hi', 'unsigned int len_lo', 'unsigned int len_hi']], # ia32_fallocate
                [0x145, 'timerfd_settime', ['int ufd', 'int flags', 'const struct old_itimerspec32 *utmr', 'struct old_itimerspec32 *otmr']], # timerfd_settime32
                [0x146, 'timerfd_gettime', ['int ufd', 'struct old_itimerspec32 *otmr']], # timerfd_gettime32
                [0x147, 'signalfd4', ['int ufd', 'const compat_sigset_t *user_mask', 'compat_size_t sizemask', 'int flags']], # compat
                [0x148, 'eventfd2', ['unsigned int count', 'int flags']],
                [0x149, 'epoll_create1', ['int flags']],
                [0x14a, 'dup3', ['unsigned int oldfd', 'unsigned int newfd', 'int flags']],
                [0x14b, 'pipe2', ['int *fildes', 'int flags']],
                [0x14c, 'inotify_init1', ['int flags']],
                [0x14d, 'preadv', ['compat_ulong_t fd', 'const struct compat_iovec *vec', 'compat_ulong_t vlen', 'u32 pos_low', 'u32 pos_high']], # compat
                [0x14e, 'pwritev', ['compat_ulong_t fd', 'const struct compat_iovec *vec', 'compat_ulong_t vlen', 'u32 pos_low', 'u32 pos_high']], # compat
                [0x14f, 'rt_tgsigqueueinfo', ['compat_pid_t tgid', 'compat_pid_t pid', 'int sig', 'struct compat_siginfo_t *uinfo']], # compat
                [0x150, 'perf_event_open', ['struct perf_event_attr *attr_uptr', 'pid_t pid', 'int cpu', 'int group_fd', 'unsigned long flags']],
                [0x151, 'recvmmsg', ['int fd', 'struct compat_mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags', 'struct old_timespec32 *timeout']], # compat recvmmsg_time32
                [0x152, 'fanotify_init', ['unsigned int flags', 'unsigned int event_f_flags']],
                [0x153, 'fanotify_mark', ['int fanotify_fd', 'unsigned int flags', '__u32 mask0', '__u32 mask1', 'int dfd', 'const char *pathname']], # compat
                [0x154, 'prlimit64', ['pid_t pid', 'unsigned int resource', 'const struct rlimit64 *new_rlim', 'struct rlimit64 *old_rlim']],
                [0x155, 'name_to_handle_at', ['int dfd', 'const char *name', 'struct file_handle *handle', 'int *mnt_id', 'int flag']],
                [0x156, 'open_by_handle_at', ['int mountdirfd', 'struct file_handle *handle', 'int flags']], # compat
                [0x157, 'clock_adjtime', ['clockid_t which_clock', 'struct old_timex32 *utp']], # clock_adjtime32
                [0x158, 'syncfs', ['int fd']],
                [0x159, 'sendmmsg', ['int fd', 'struct compat_mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags']], # compat
                [0x15a, 'setns', ['int fd', 'int flags']],
                [0x15b, 'process_vm_readv', ['compat_pid_t pid', 'const struct compat_iovec *lvec', 'compat_ulong_t liovcnt', 'const struct compat_iovec *rvec', 'compat_ulong_t riovcnt', 'compat_ulong_t flags']], # compat
                [0x15c, 'process_vm_writev', ['compat_pid_t pid', 'const struct compat_iovec *lvec', 'compat_ulong_t liovcnt', 'const struct compat_iovec *rvec', 'compat_ulong_t riovcnt', 'compat_ulong_t flags']], # compat
                [0x15d, 'kcmp', ['pid_t pid1', 'pid_t pid2', 'int type', 'unsigned long idx1', 'unsigned long idx2']],
                [0x15e, 'finit_module', ['int fd', 'const char *uargs', 'int flags']],
                [0x15f, 'sched_setattr', ['pid_t pid', 'struct sched_attr *uattr', 'unsigned int flags']],
                [0x160, 'sched_getattr', ['pid_t pid', 'struct sched_attr *uattr', 'unsigned int usize', 'unsigned int flags']],
                [0x161, 'renameat2', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname', 'unsigned int flags']],
                [0x162, 'seccomp', ['unsigned int op', 'unsigned int flags', 'void *uargs']],
                [0x163, 'getrandom', ['char *buf', 'size_t count', 'unsigned int flags']],
                [0x164, 'memfd_create', ['const char *uname', 'unsigned int flags']],
                [0x165, 'bpf', ['int cmd', 'union bpf_attr *uattr', 'unsigned int size']],
                [0x166, 'execveat', ['int fd', 'const char *filename', 'const compat_uptr_t *argv', 'const compat_uptr_t *envp', 'int flags']], # compat
                [0x167, 'socket', ['int family', 'int type', 'int protocol']],
                [0x168, 'socketpair', ['int family', 'int type', 'int protocol', 'int *usockvec']],
                [0x169, 'bind', ['int fd', 'struct sockaddr *umyaddr', 'int addrlen']],
                [0x16a, 'connect', ['int fd', 'struct sockaddr *uservaddr', 'int addrlen']],
                [0x16b, 'listen', ['int fd', 'int backlog']],
                [0x16c, 'accept4', ['int fd', 'struct sockaddr *upeer_sockaddr', 'int *upeer_addrlen', 'int flags']],
                [0x16d, 'getsockopt', ['int fd', 'int level', 'int optname', 'char *optval', 'int *optlen']],
                [0x16e, 'setsockopt', ['int fd', 'int level', 'int optname', 'char *optval', 'int optlen']],
                [0x16f, 'getsockname', ['int fd', 'struct sockaddr *usockaddr', 'int *usockaddr_len']],
                [0x170, 'getpeername', ['int fd', 'struct sockaddr *usockaddr', 'int *usockaddr_len']],
                [0x171, 'sendto', ['int fd', 'void *buff', 'size_t len', 'unsigned int flags', 'struct sockaddr *addr', 'int addr_len']],
                [0x172, 'sendmsg', ['int fd', 'struct compat_msghdr *msg', 'unsigned int flags']], # compat
                [0x173, 'recvfrom', ['int fd', 'void *ubuf', 'compat_size_t size', 'unsigned int flags', 'struct sockaddr *addr', 'int *addr_len']], # compat
                [0x174, 'recvmsg', ['int fd', 'struct compat_msghdr *msg', 'unsigned int flags']], # compat
                [0x175, 'shutdown', ['int fd', 'int how']],
                [0x176, 'userfaultfd', ['int flags']],
                [0x177, 'membarrier', ['int cmd', 'int flags']],
                [0x178, 'mlock2', ['unsigned long start', 'size_t len', 'int flags']],
                [0x179, 'copy_file_range', ['int fd_in', 'loff_t *off_in', 'int fd_out', 'loff_t *off_out', 'size_t len', 'unsigned int flags']],
                [0x17a, 'preadv2', ['compat_ulong_t fd', 'const struct compat_iovec *vec', 'compat_ulong_t vlen', 'u32 pos_low', 'u32 pos_high', 'rwf_t flags']], # compat
                [0x17b, 'pwritev2', ['compat_ulong_t fd', 'const struct compat_iovec *vec', 'compat_ulong_t vlen', 'u32 pos_low', 'u32 pos_high', 'rwf_t flags']], # compat
                [0x17c, 'pkey_mprotect', ['unsigned long start', 'size_t len', 'unsigned long prot', 'int pkey']],
                [0x17d, 'pkey_alloc', ['unsigned long flags', 'unsigned long init_val']],
                [0x17e, 'pkey_free', ['int pkey']],
                [0x17f, 'statx', ['int dfd', 'const char *filename', 'unsigned flags', 'unsigned int mask', 'struct statx *buffer']],
                [0x180, 'arch_prctl', ['int option', 'unsigned long arg2']], # compat
                [0x181, 'io_pgetevents', ['compat_aio_context_t ctx_id', 'compat_long_t min_nr', 'compat_long_t nr', 'struct io_event *events', 'struct old_timespec32 *timeout', 'const struct __compat_aio_sigset *usig']], # compat
                [0x182, 'rseq', ['struct rseq *rseq', 'u32 rseq_len', 'int flags', 'u32 sig']],
                # 0x183-0x187: don't use
                [0x189, 'semget', ['key_t key', 'int nsems', 'int semflg']],
                [0x18a, 'semctl', ['int semid', 'int semnum', 'int cmd', 'int arg']], # compat
                [0x18b, 'shmget', ['key_t key', 'size_t size', 'int shmflg']],
                [0x18c, 'shmctl', ['int shmid', 'int cmd', 'void *uptr']], # compat
                [0x18d, 'shmat', ['int shmid', 'compat_uptr_t *shmaddr', 'int shmflg']], # compat
                [0x18e, 'shmdt', ['char *shmaddr']],
                [0x18f, 'msgget', ['key_t key', 'int msgflg']],
                [0x190, 'msgsnd', ['int msqid', 'struct compat_uptr_t *msgp', 'compat_ssize_t msgsz', 'int msgflg']], # compat
                [0x191, 'msgrcv', ['int msqid', 'struct compat_uptr_t *msgp', 'compat_ssize_t msgsz', 'compat_long_t msgtyp', 'int msgflg']], # compat
                [0x192, 'msgctl', ['int msqid', 'int cmd', 'void *uptr']], # compat
                [0x193, 'clock_gettime_time64', ['const clockid_t which_clock', 'struct __kernel_timespec *tp']], # clock_gettime
                [0x194, 'clock_settime_time64', ['const clockid_t which_clock', 'struct __kernel_timespec *tp']], # clock_settime
                [0x195, 'clock_adjtime_time64', ['const clockid_t which_clock', 'struct __kernel_timex *utx']], # clock_adjtime
                [0x196, 'clock_getres_time64', ['const clockid_t which_clock', 'struct __kernel_timespec *tp']], # clock_getres
                [0x197, 'clock_nanosleep_time64', ['const clockid_t which_clock', 'int flags', 'const struct __kernel_timespec *rqtp', 'struct __kernel_timespec *rmtp']], # clock_nanosleep
                [0x198, 'timer_gettime_time64', ['timer_t timer_id', 'struct __kernel_itimerspec *setting']], # timer_gettime
                [0x199, 'timer_settime_time64', ['timer_t timer_id', 'int flags', 'const struct __kernel_itimerspec *new_setting', 'struct __kernel_itimerspec *old_setting']], # timer_settime
                [0x19a, 'timerfd_gettime_time64', ['int ufd', 'struct __kernel_itimerspec *otmr']], # timerfd_gettime
                [0x19b, 'timerfd_settime_time64', ['int ufd', 'int flags', 'const struct __kernel_itimerspec *utmr', 'struct __kernel_itimerspec *otmr']], # timerfd_settime
                [0x19c, 'utimensat_time64', ['int dfd', 'const char *filename', 'struct __kernel_timespec *utimes', 'int flags']], # utimensat
                [0x19d, 'pselect6_time64', ['int n', 'compat_ulong_t *inp', 'compat_ulong_t *outp', 'compat_ulong_t *exp', 'struct __kernel_timespec *tsp', 'void *sig']], # compat
                [0x19e, 'ppoll_time64', ['struct pollfd *ufds', 'unsigned int nfds', 'struct __kernel_timespec *tsp', 'const compat_sigset_t *sigmask', 'compat_size_t sigsetsize']], # compat
                #0x19f, unused
                [0x1a0, 'io_pgetevents_time64', ['aio_context_t ctx_id', 'long min_nr', 'long nr', 'struct io_event *events', 'struct __kernel_timespec *timeout', 'const struct __aio_sigset *usig']], # io_pgetevents
                [0x1a1, 'recvmmsg_time64', ['int fd', 'struct compat_mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags', 'struct __kernel_timespec *timeout']], # compat
                [0x1a2, 'mq_timedsend_time64', ['mqd_t mqdes', 'const char *u_msg_ptr', 'size_t msg_len', 'unsigned int msg_prio', 'const struct __kernel_timespec *u_abs_timeout']], # mq_timedsend
                [0x1a3, 'mq_timedreceive_time64', ['mqd_t mqdes', 'char *u_msg_ptr', 'size_t msg_len', 'unsigned int *u_msg_prio', 'const struct __kernel_timespec *u_abs_timeout']], # mq_timedreceive
                [0x1a4, 'semtimedop_time64', ['int semid', 'struct sembuf *tsops', 'unsigned int nsops', 'const struct __kernel_timespec *timeout']], # semtimedop
                [0x1a5, 'rt_sigtimedwait_time64', ['compat_sigset_t *uthese', 'struct compat_siginfo *uinfo', 'struct __kernel_timespec *uts', 'compat_size_t sigsetsize']], # compat
                [0x1a6, 'futex_time64', ['u32 *uaddr', 'int op', 'u32 val', 'struct __kernel_timespec *utime', 'u32 *uaddr2', 'u32 val3']], # futex
                [0x1a7, 'sched_rr_get_interval_time64', ['pid_t pid', 'struct __kernel_timespec *interval']], # sched_rr_get_interval
                [0x1a8, 'pidfd_send_signal', ['int pidfd', 'int sig', 'siginfo_t *info', 'unsigned int flags']],
                [0x1a9, 'io_uring_setup', ['u32 entries', 'struct io_uring_params *params']],
                [0x1aa, 'io_uring_enter', ['unsigned int fd', 'u32 to_submit', 'u32 min_complete', 'u32 flags', 'const sigset_t *sig', 'size_t sigsz']],
                [0x1ab, 'io_uring_register', ['unsigned int fd', 'unsigned int opcode', 'void *arg', 'unsigned int nr_args']],
                [0x1ac, 'open_tree', ['int dfd', 'const char *filename', 'unsigned flags']],
                [0x1ad, 'move_mount', ['int from_dfd', 'const char *from_pathname', 'int to_dfd', 'const char *to_pathname', 'unsigned int flags']],
                [0x1ae, 'fsopen', ['const char *_fs_name', 'unsigned int flags']],
                [0x1af, 'fsconfig', ['int fd', 'unsigned int cmd', 'const char *_key', 'const void *_value', 'int aux']],
                [0x1b0, 'fsmount', ['int fs_fd', 'unsigned int flags', 'unsigned int attr_flags']],
                [0x1b1, 'fspick', ['int, dfd', 'const char *path', 'unsigned int flags']],
                [0x1b2, 'pidfd_open', ['pid_t pid', 'unsigned int flags']],
                [0x1b3, 'clone3', ['struct clone_args *uargs', 'size_t size']],
                [0x1b4, 'close_range', ['unsigned int fd', 'unsigned int max_fd', 'unsigned int flag']],
                [0x1b5, 'openat2', ['int dfd', 'const char *filename', 'struct open_how *how', 'size_t usize']],
                [0x1b6, 'pidfd_getfd', ['int pidfd', 'int fd', 'unsigned int flags']],
                [0x1b7, 'faccessat2', ['int dfd', 'const char *filename', 'int mode', 'int flags']],
                [0x1b8, 'process_madvise', ['int pidfd', 'const struct iovec *vec', 'size_t vlen', 'int behavior', 'unsigned int flags']],
                [0x1b9, 'epoll_pwait2', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'const struct __kernel_timespec *timeout', 'const compat_sigset_t *sigmask', 'compat_size_t sigsetsize']], # compat
                [0x1ba, 'mount_setattr', ['int dfd', 'const char *path', 'unsigned int flags', 'struct mount_attr *uattr', 'size_t usize']],
                [0x1bb, 'quotactl_fd', ['unsigned int fd', 'unsigned int cmd', 'qid_t id', 'void __user *addr']],
                [0x1bc, 'landlock_create_ruleset', ['const struct landlock_ruleset_attr *const attr', 'const size_t size', 'const __u32 flags']],
                [0x1bd, 'landlock_add_rule', ['const int ruleset_fd', 'const enum landlock_rule_type rule_type', 'const void *const rule_attr', 'const __u32 flags']],
                [0x1be, 'landlock_restrict_self', ['const int ruleset_fd', 'const __u32 flags']],
                [0x1bf, 'memfd_secret', ['unsigned int, flags']],
                [0x1c0, 'process_mrelease', ['int pidfd', 'unsigned int flags']],
                [0x1c1, 'futex_waitv', ['struct futex_waitv *waiters', 'unsigned int nr_futexes', 'unsigned int flags', 'struct __kernel_timespec *timeout', 'clockid_t clockid']],
                [0x1c2, 'set_mempolicy_home_node', ['unsigned long start', 'unsigned long len', 'unsigned long home_node', 'unsigned long flags']],
            ]

        elif arch == "X86" and mode == "N32":
            register_list = ["$ebx", "$ecx", "$edx", "$esi", "$edi", "$ebp"]
            # arch/x86/include/asm/unistd.h
            # arch/x86/include/uapi/asm/unistd.h
            # arch/x86/include/generated/uapi/asm/unistd-32.h
            # arch/x86/entry/syscalls/syscall_32.tbl
            syscall_list = [
                [0x0,   'restart_syscall', []],
                [0x1,   'exit', ['int error_code']],
                [0x2,   'fork', []],
                [0x3,   'read', ['unsigned int fd', 'char *buf', 'size_t count']],
                [0x4,   'write', ['unsigned int fd', 'const char *buf', 'size_t count']],
                [0x5,   'open', ['const char *filename', 'int flags', 'umode_t mode']],
                [0x6,   'close', ['unsigned int fd']],
                [0x7,   'waitpid', ['pid_t pid', 'int *stat_addr', 'int options']],
                [0x8,   'creat', ['const char *pathname', 'umode_t mode']],
                [0x9,   'link', ['const char *oldname', 'const char *newname']],
                [0xa,   'unlink', ['const char *pathname']],
                [0xb,   'execve', ['const char *filename', 'const char *const *argv', 'const char *const *envp']],
                [0xc,   'chdir', ['const char *filename']],
                [0xd,   'time', ['old_time32_t *tloc']], # time32
                [0xe,   'mknod', ['const char *filename', 'umode_t mode', 'unsigned dev']],
                [0xf,   'chmod', ['const char *filename', 'umode_t mode']],
                [0x10,  'lchown', ['const char *filename', 'old_uid_t user', 'old_gid_t group']], # lchown16
                #0x11,  break # unimplemented
                [0x12,  'oldstat', ['const char *filename', 'struct __old_kernel_stat *statbuf']], # fstat
                [0x13,  'lseek', ['unsigned int fd', 'off_t offset', 'unsigned int whence']],
                [0x14,  'getpid', []],
                [0x15,  'mount', ['const char *dev_name', 'const char *dir_name', 'const char *type', 'unsigned long flags', 'void *data']],
                [0x16,  'umount', ['char *name']], # oldumount
                [0x17,  'setuid', ['old_uid_t uid']], # setuid16
                [0x18,  'getuid', []], # getuid16
                [0x19,  'stime', ['old_time32_t *tptr']], # stime32
                [0x1a,  'ptrace', ['long request', 'long pid', 'unsigned long addr', 'unsigned long data']],
                [0x1b,  'alarm', ['unsigned int seconds']],
                [0x1c,  'oldfstat', ['unsigned int fd', 'struct __old_kernel_stat *statbuf']], # fstat
                [0x1d,  'pause', []],
                [0x1e,  'utime', ['char *filename', 'struct old_utimbuf32 *t']], # utime32
                #0x1f,  stty # unimplemented
                #0x20,  gtty # unimplemented
                [0x21,  'access', ['const char *filename', 'int mode']],
                [0x22,  'nice', ['int increment']],
                #0x23,  ftime # unimplemented
                [0x24,  'sync', []],
                [0x25,  'kill', ['pid_t pid', 'int sig']],
                [0x26,  'rename', ['const char *oldname', 'const char *newname']],
                [0x27,  'mkdir', ['const char *pathname', 'umode_t mode']],
                [0x28,  'rmdir', ['const char *pathname']],
                [0x29,  'dup', ['unsigned int fildes']],
                [0x2a,  'pipe', ['int *fildes']],
                [0x2b,  'times', ['struct tms *tbuf']],
                #0x2c,  prof # unimplemented
                [0x2d,  'brk', ['unsigned long brk']],
                [0x2e,  'setgid', ['old_gid_t gid']], # setgid16
                [0x2f,  'getgid', []], # getgid16
                [0x30,  'signal', ['int sig', '__sighandler_t handler']],
                [0x31,  'geteuid', []], # geteuid16
                [0x32,  'getegid', []], # getegid16
                [0x33,  'acct', ['const char *name']],
                [0x34,  'umount2', ['char *name', 'int flags']], # umount
                #0x35,  lock # unimplemented
                [0x36,  'ioctl', ['unsigned int fd', 'unsigned int cmd', 'unsigned long arg']],
                [0x37,  'fcntl', ['unsigned int fd', 'unsigned int cmd', 'unsigned long arg']],
                #0x38,  mpx # unimplemented
                [0x39,  'setpgid', ['pid_t pid', 'pid_t pgid']],
                #0x3a,  ulimit # unimplemented
                [0x3b,  'oldolduname', ['struct oldold_utsname *name']], # olduname
                [0x3c,  'umask', ['int mask']],
                [0x3d,  'chroot', ['const char *filename']],
                [0x3e,  'ustat', ['unsigned dev', 'struct ustat *ubuf']],
                [0x3f,  'dup2', ['unsigned int oldfd', 'unsigned int newfd']],
                [0x40,  'getppid', []],
                [0x41,  'getpgrp', []],
                [0x42,  'setsid', []],
                [0x43,  'sigaction', ['int sig', 'const struct old_sigaction *act', 'struct old_sigaction *oact']],
                [0x44,  'sgetmask', []],
                [0x45,  'ssetmask', ['int newmask']],
                [0x46,  'setreuid', ['old_uid_t ruid', 'old_uid_t euid']], # setreuid16
                [0x47,  'setregid', ['old_gid_t rgid', 'old_gid_t egid']], # setregid16
                [0x48,  'sigsuspend', ['old_sigset_t mask']],
                [0x49,  'sigpending', ['old_sigset_t *uset']],
                [0x4a,  'sethostname', ['char *name', 'int len']],
                [0x4b,  'setrlimit', ['unsigned int resource', 'struct rlimit *rlim']],
                [0x4c,  'getrlimit', ['unsigned int resource', 'struct rlimit *rlim']], # old_getrlimit
                [0x4d,  'getrusage', ['int who', 'struct rusage *ru']],
                [0x4e,  'gettimeofday', ['struct __kernel_old_timeval *tv', 'struct timezone *tz']],
                [0x4f,  'settimeofday', ['struct __kernel_old_timeval *tv', 'struct timezone *tz']],
                [0x50,  'getgroups', ['int gidsetsize', 'old_gid_t *grouplist']], # getgroups16
                [0x51,  'setgroups', ['int gidsetsize', 'old_gid_t *grouplist']], # setgroups16
                [0x52,  'select', ['struct sel_arg_struct *arg']], # old_select
                [0x53,  'symlink', ['const char *oldname', 'const char *newname']],
                [0x54,  'oldlstat', ['const char *filename', 'struct __old_kernel_stat *statbuf']], # lstat
                [0x55,  'readlink', ['const char *path', 'char *buf', 'int bufsiz']],
                [0x56,  'uselib', ['const char *library']],
                [0x57,  'swapon', ['const char *specialfile', 'int swap_flags']],
                [0x58,  'reboot', ['int magic1', 'int magic2', 'unsigned int cmd', 'void *arg']],
                [0x59,  'readdir', ['unsigned int fd', 'struct old_linux_dirent *dirent', 'unsigned int count']], # old_readdir
                [0x5a,  'mmap', ['struct mmap_arg_struct *arg']], # old_mmap
                [0x5b,  'munmap', ['unsigned long addr', 'size_t len']],
                [0x5c,  'truncate', ['const char *path', 'long length']],
                [0x5d,  'ftruncate', ['unsigned int fd', 'unsigned long length']],
                [0x5e,  'fchmod', ['unsigned int fd', 'umode_t mode']],
                [0x5f,  'fchown', ['unsigned int fd', 'old_uid_t user', 'old_gid_t group']], # fchown16
                [0x60,  'getpriority', ['int which', 'int who']],
                [0x61,  'setpriority', ['int which', 'int who', 'int niceval']],
                #0x62,  profil # unimplemented
                [0x63,  'statfs', ['const char *pathname', 'struct statfs *buf']],
                [0x64,  'fstatfs', ['unsigned int fd', 'struct statfs *buf']],
                [0x65,  'ioperm', ['unsigned long from', 'unsigned long num', 'int turn_on']],
                [0x66,  'socketcall', ['int call', 'unsigned long *args']],
                [0x67,  'syslog', ['int type', 'char *buf', 'int len']],
                [0x68,  'setitimer', ['int which', 'struct __kernel_old_itimerval *value', 'struct __kernel_old_itimerval *ovalue']],
                [0x69,  'getitimer', ['int which', 'struct __kernel_old_itimerval *value']],
                [0x6a,  'stat', ['const char *filename', 'struct stat *statbuf']], # newstat
                [0x6b,  'lstat', ['const char *filename', 'struct stat *statbuf']], # newlstat
                [0x6c,  'fstat', ['unsigned int fd', 'struct stat *statbuf']], # newfstat
                [0x6d,  'olduname', ['struct old_utsname *name']], # uname
                [0x6e,  'iopl', ['unsigned int level']],
                [0x6f,  'vhangup', []],
                #0x70,  idle # deleted from kernel 2.3.13
                [0x71,  'vm86old', ['struct vm86_struct *user_vm86']],
                [0x72,  'wait4', ['pid_t upid', 'int *stat_addr', 'int options', 'struct rusage *ru']],
                [0x73,  'swapoff', ['const char *specialfile']],
                [0x74,  'sysinfo', ['struct sysinfo *info']],
                [0x75,  'ipc', ['unsigned int call', 'int first', 'unsigned long second', 'unsigned long third', 'void *ptr', 'long fifth']],
                [0x76,  'fsync', ['unsigned int fd']],
                [0x77,  'sigreturn', []],
                [0x78,  'clone', ['unsigned long clone_flags', 'unsigned long newsp', 'int *parent_tidptr', 'int *child_tidptr', 'unsigned long tls']],
                [0x79,  'setdomainname', ['char *name', 'int len']],
                [0x7a,  'uname', ['struct new_utsname *name']], # newuname
                [0x7b,  'modify_ldt', ['int func', 'void *ptr', 'unsigned long bytecount']],
                [0x7c,  'adjtimex', ['struct old_timex32 *utp']], # adjtimex_time32
                [0x7d,  'mprotect', ['unsigned long start', 'size_t len', 'unsigned long prot']],
                [0x7e,  'sigprocmask', ['int how', 'old_sigset_t *nset', 'old_sigset_t *oset']],
                #0x7f,  create_module # deleted from kernel 2.6
                [0x80,  'init_module', ['void *umod', 'unsigned long len', 'const char *uargs']],
                [0x81,  'delete_module', ['const char *name_user', 'unsigned int flags']],
                #0x82,  get_kernel_syms # deleted from kernel 2.6
                [0x83,  'quotactl', ['unsigned int cmd', 'const char *special', 'qid_t id', 'void *addr']],
                [0x84,  'getpgid', ['pid_t pid']],
                [0x85,  'fchdir', ['unsigned int fd']],
                [0x86,  'bdflush', ['int func', 'long data']],
                [0x87,  'sysfs', ['int option', 'unsigned long arg1', 'unsigned long arg2']],
                [0x88,  'personality', ['unsigned int personality']],
                #0x89,  afs_syscall # unimplemented
                [0x8a,  'setfsuid', ['old_uid_t uid']], # setfsuid16
                [0x8b,  'setfsgid', ['old_gid_t gid']], # setfsgid16
                [0x8c,  '_llseek', ['unsigned int fd', 'unsigned long offset_high', 'unsigned long offset_low', 'loff_t *result', 'unsigned int whence']], # llseek
                [0x8d,  'getdents', ['unsigned int fd', 'struct linux_dirent *dirent', 'unsigned int count']],
                [0x8e,  '_newselect', ['int n', 'fd_set *inp', 'fd_set *outp', 'fd_set *exp', 'struct __kernel_old_timeval *tvp']], # select
                [0x8f,  'flock', ['unsigned int fd', 'unsigned int cmd']],
                [0x90,  'msync', ['unsigned long start', 'size_t len', 'int flags']],
                [0x91,  'readv', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen']],
                [0x92,  'writev', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen']],
                [0x93,  'getsid', ['pid_t pid']],
                [0x94,  'fdatasync', ['unsigned int fd']],
                [0x95,  '_sysctl', ['struct __sysctl_args *args']], # sysctl # deleted from kenrel 5.5 ?
                [0x96,  'mlock', ['unsigned long start', 'size_t len']],
                [0x97,  'munlock', ['unsigned long start', 'size_t len']],
                [0x98,  'mlockall', ['int flags']],
                [0x99,  'munlockall', []],
                [0x9a,  'sched_setparam', ['pid_t pid', 'struct sched_param *param']],
                [0x9b,  'sched_getparam', ['pid_t pid', 'struct sched_param *param']],
                [0x9c,  'sched_setscheduler', ['pid_t pid', 'int policy', 'struct sched_param *param']],
                [0x9d,  'sched_getscheduler', ['pid_t pid']],
                [0x9e,  'sched_yield', []],
                [0x9f,  'sched_get_priority_max', ['int policy']],
                [0xa0,  'sched_get_priority_min', ['int policy']],
                [0xa1,  'sched_rr_get_interval', ['pid_t pid', 'struct old_timespec32 *interval']], # sched_rr_get_interval_time32
                [0xa2,  'nanosleep', ['struct old_timespec32 *rqtp', 'struct old_timespec32 *rmtp']], # nanosleep_time32
                [0xa3,  'mremap', ['unsigned long addr', 'unsigned long old_len', 'unsigned long new_len', 'unsigned long flags', 'unsigned long new_addr']],
                [0xa4,  'setresuid', ['old_uid_t ruid', 'old_uid_t euid', 'old_uid_t suid']], # setresuid16
                [0xa5,  'getresuid', ['old_uid_t *ruidp', 'old_uid_t *euidp', 'old_uid_t *suidp']], # getresuid16
                [0xa6,  'vm86', ['unsigned long cmd', 'unsigned long arg']],
                #0xa7,  query_module # deleted from kernel 2.6
                [0xa8,  'poll', ['struct pollfd *ufds', 'unsigned int nfds', 'int timeout_msecs']],
                #0xa9,  nfsservctl # deleted from kernel 3.1
                [0xaa,  'setresgid', ['old_gid_t rgid', 'old_gid_t egid', 'old_gid_t sgid']], # setresgid16
                [0xab,  'getresgid', ['old_gid_t *rgidp', 'old_gid_t *egidp', 'old_gid_t *sgidp']], # getresgid16
                [0xac,  'prctl', ['int option', 'unsigned long arg2', 'unsigned long arg3', 'unsigned long arg4', 'unsigned long arg5']],
                [0xad,  'rt_sigreturn', []],
                [0xae,  'rt_sigaction', ['int sig', 'const struct sigaction *act', 'struct sigaction *oact', 'size_t sigsetsize']],
                [0xaf,  'rt_sigprocmask', ['int how', 'sigset_t *nset', 'sigset_t *oset', 'size_t sigsetsize']],
                [0xb0,  'rt_sigpending', ['sigset_t *uset', 'size_t sigsetsize']],
                [0xb1,  'rt_sigtimedwait', ['const sigset_t *uthese', 'siginfo_t *uinfo', 'const struct old_timespec32 *uts', 'size_t sigsetsize']], # rt_sigtimedwait_time32
                [0xb2,  'rt_sigqueueinfo', ['pid_t pid', 'int sig', 'siginfo_t *uinfo']],
                [0xb3,  'rt_sigsuspend', ['sigset_t *unewset', 'size_t sigsetsize']],
                [0xb4,  'pread64', ['unsigned int fd', 'char *ubuf', 'u32 count', 'u32 poslo', 'u32 poshi']], # ia32_pread64
                [0xb5,  'pwrite64', ['unsigned int fd', 'const char *ubuf', 'u32 count', 'u32 poslo', 'u32 poshi']], # ia32_pwrite64
                [0xb6,  'chown', ['const char *filename', 'old_uid_t user', 'old_gid_t group']], # chown16
                [0xb7,  'getcwd', ['char *buf', 'unsigned long size']],
                [0xb8,  'capget', ['cap_user_header_t header', 'cap_user_data_t dataptr']],
                [0xb9,  'capset', ['cap_user_header_t header', 'const cap_user_data_t data']],
                [0xba,  'sigaltstack', ['const stack_t *uss', 'stack_t *uoss']],
                [0xbb,  'sendfile', ['int out_fd', 'int in_fd', 'off_t *offset', 'size_t count']],
                #0xbc,  getpmsg # unimplemented
                #0xbd,  putpmsg # unimplemented
                [0xbe,  'vfork', []],
                [0xbf,  'ugetrlimit', ['unsigned int resource', 'struct rlimit *rlim']], # getrlimit
                [0xc0,  'mmap2', ['unsigned long addr', 'unsigned long len', 'unsigned long prot', 'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff']], # mmap_pgoff
                [0xc1,  'truncate64', ['const char *filename', 'unsigned long offset_low', 'unsigned long offset_high']], # ia32_truncate64
                [0xc2,  'ftruncate64', ['unsigned int fd', 'unsigned long offset_low', 'unsigned long offset_high']], # ia32_ftruncate64
                [0xc3,  'stat64', ['const char *filename', 'struct stat64 *statbuf']], # stat64
                [0xc4,  'lstat64', ['const char *filename', 'struct stat64 *statbuf']], # lstat64
                [0xc5,  'fstat64', ['unsigned long fd', 'struct stat64 *statbuf']], # fstat64
                [0xc6,  'lchown32', ['const char *filename', 'uid_t user', 'gid_t group']], # lchown
                [0xc7,  'getuid32', []], # getuid
                [0xc8,  'getgid32', []], # getgid
                [0xc9,  'geteuid32', []], # geteuid
                [0xca,  'getegid32', []], # getegid
                [0xcb,  'setreuid32', ['uid_t ruid', 'uid_t euid']], # setreuid32
                [0xcc,  'setregid32', ['gid_t rgid', 'gid_t egid']], # setregid32
                [0xcd,  'getgroups32', ['int gidsetsize', 'gid_t *grouplist']], # getgroups32
                [0xce,  'setgroups32', ['int gidsetsize', 'gid_t *grouplist']], # setgroups32
                [0xcf,  'fchown32', ['unsigned int fd', 'uid_t user', 'gid_t group']], # fchown
                [0xd0,  'setresuid32', ['uid_t ruid', 'uid_t euid', 'uid_t suid']], # setresuid
                [0xd1,  'getresuid32', ['uid_t *ruidp', 'uid_t *euidp', 'uid_t *suidp']], # getresuid
                [0xd2,  'setresgid32', ['gid_t rgid', 'gid_t egid', 'gid_t sgid']], # setresgid
                [0xd3,  'getresgid32', ['gid_t *rgidp', 'gid_t *egidp', 'gid_t *sgidp']], # getresgid
                [0xd4,  'chown32', ['const char *filename', 'uid_t user', 'gid_t group']], # chown
                [0xd5,  'setuid32', ['uid_t uid']], # setuid
                [0xd6,  'setgid32', ['gid_t gid']], # setgid
                [0xd7,  'setfsuid32', ['uid_t uid']], # setfsuid
                [0xd8,  'setfsgid32', ['gid_t gid']], # setfsgid
                [0xd9,  'pivot_root', ['const char *new_root', 'const char *put_old']],
                [0xda,  'mincore', ['unsigned long start', 'size_t len', 'unsigned char *vec']],
                [0xdb,  'madvise', ['unsigned long start', 'size_t len_in', 'int behavior']],
                [0xdc,  'getdents64', ['unsigned int fd', 'struct linux_dirent64 *dirent', 'unsigned int count']],
                [0xdd,  'fcntl64', ['unsigned int fd', 'unsigned int cmd', 'unsigned long arg']],
                #0xde,  unused
                #0xdf,  unused
                [0xe0,  'gettid', []],
                [0xe1,  'readahead', ['int fd', 'unsigned int off_lo', 'unsigned int off_high', 'size_t count']], # ia32_readahead
                [0xe2,  'setxattr', ['const char *pathname', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0xe3,  'lsetxattr', ['const char *pathname', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0xe4,  'fsetxattr', ['int fd', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0xe5,  'getxattr', ['const char *pathname', 'const char *name', 'void *value', 'size_t size']],
                [0xe6,  'lgetxattr', ['const char *pathname', 'const char *name', 'void *value', 'size_t size']],
                [0xe7,  'fgetxattr', ['int fd', 'const char *name', 'void *value', 'size_t size']],
                [0xe8,  'listxattr', ['const char *pathname', 'char *list', 'size_t size']],
                [0xe9,  'llistxattr', ['const char *pathname', 'char *list', 'size_t size']],
                [0xea,  'flistxattr', ['int fd', 'char *list', 'size_t size']],
                [0xeb,  'removexattr', ['const char *pathname', 'const char *name']],
                [0xec,  'lremovexattr', ['const char *pathname', 'const char *name']],
                [0xed,  'fremovexattr', ['int fd', 'const char *name']],
                [0xee,  'tkill', ['pid_t pid', 'int sig']],
                [0xef,  'sendfile64', ['int out_fd', 'int in_fd', 'loff_t *offset', 'size_t count']],
                [0xf0,  'futex', ['u32 *uaddr', 'int op', 'u32 val', 'struct old_timespec32 *utime', 'u32 *uaddr2', 'u32 val3']], # futex_time32
                [0xf1,  'sched_setaffinity', ['pid_t pid', 'unsigned int len', 'unsigned long *user_mask_ptr']],
                [0xf2,  'sched_getaffinity', ['pid_t pid', 'unsigned int len', 'unsigned long *user_mask_ptr']],
                [0xf3,  'set_thread_area', ['struct user_desc *u_info']],
                [0xf4,  'get_thread_area', ['struct user_desc *u_info']],
                [0xf5,  'io_setup', ['unsigned nr_events', 'aio_context_t *ctxp']],
                [0xf6,  'io_destroy', ['aio_context_t ctx']],
                [0xf7,  'io_getevents', ['__u32 ctx_id', '__s32 min_nr', '__s32 nr', 'struct io_event *events', 'struct old_timespec32 *timeout']], # io_getevents_time32
                [0xf8,  'io_submit', ['aio_context_t ctx_id', 'long nr', 'struct iocb *iocbpp']],
                [0xf9,  'io_cancel', ['aio_context_t ctx_id', 'struct iocb *iocb', 'struct io_event *result']],
                [0xfa,  'fadvise64', ['int fd', 'unsigned int offset_lo', 'unsigned int offset_hi', 'size_t len', 'int advice']], # ia32_fadvise64
                #0xfb,  set_zone_reclaim
                [0xfc,  'exit_group', ['int error_code']],
                [0xfd,  'lookup_dcookie', ['u64 cookie64', 'char *buf', 'size_t len']],
                [0xfe,  'epoll_create', ['int size']],
                [0xff,  'epoll_ctl', ['int epfd', 'int op', 'int fd', 'struct epoll_event *event']],
                [0x100, 'epoll_wait', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'int timeout']],
                [0x101, 'remap_file_pages', ['unsigned long start', 'unsigned long size', 'unsigned long prot', 'unsigned long pgoff', 'unsigned long flags']],
                [0x102, 'set_tid_address', ['int *tidptr']],
                [0x103, 'timer_create', ['clockid_t which_clock', 'struct sigevent *timer_event_spec', 'timer_t *created_timer_id']],
                [0x104, 'timer_settime', ['timer_t timer_id', 'int flags', 'struct old_itimerspec32 *new', 'struct old_itimerspec32 *old']], # timer_settime32
                [0x105, 'timer_gettime', ['timer_t timer_id', 'struct old_itimerspec32 *setting']],
                [0x106, 'timer_getoverrun', ['timer_t timer_id']],
                [0x107, 'timer_delete', ['timer_t timer_id']],
                [0x108, 'clock_settime', ['clockid_t which_clock', 'struct old_timespec32 *tp']], # clock_settime32
                [0x109, 'clock_gettime', ['clockid_t which_clock', 'struct old_timespec32 *tp']], # clock_gettime32
                [0x10a, 'clock_getres', ['clockid_t which_clock', 'struct old_timespec32 *tp']], # clock_getres_time32
                [0x10b, 'clock_nanosleep', ['clockid_t which_clock', 'int flags', 'struct old_timespec32 *rqtp', 'struct old_timespec32 *rmtp']], # clock_nanosleep_time32
                [0x10c, 'statfs64', ['const char *pathname', 'size_t sz', 'struct statfs64 *buf']],
                [0x10d, 'fstatfs64', ['unsigned int fd', 'size_t sz', 'struct statfs64 *buf']],
                [0x10e, 'tgkill', ['pid_t tgid', 'pid_t pid', 'int sig']],
                [0x10f, 'utimes', ['char *filename', 'struct old_timeval32 *utimes']], # utimes_time32
                [0x110, 'fadvise64_64', ['int fd', '__u32 offset_low', '__u32 offset_high', '__u32 len_low', '__u32 len_high', 'int advice']], # ia32_fadvise64_64
                #0x111, vserver # unimplemented
                [0x112, 'mbind', ['unsigned long start', 'unsigned long len', 'unsigned long mode', 'const unsigned long *nmask', 'unsigned long maxnode', 'unsigned int flags']],
                [0x113, 'get_mempolicy', ['int *policy', 'unsigned long *nmask', 'unsigned long maxnode', 'unsigned long addr', 'unsigned long flags']],
                [0x114, 'set_mempolicy', ['int mode', 'const unsigned long *nmask', 'unsigned long maxnode']],
                [0x115, 'mq_open', ['const char *u_name', 'int oflag', 'umode_t mode', 'struct mq_attr *u_attr']],
                [0x116, 'mq_unlink', ['const char *u_name']],
                [0x117, 'mq_timedsend', ['mqd_t mqdes', 'const char *u_msg_ptr', 'unsigned int msg_len', 'unsigned int msg_prio', 'const struct old_timespec32 *u_abs_timeout']], # mq_timedsend_time32
                [0x118, 'mq_timedreceive', ['mqd_t mqdes', 'char *u_msg_ptr', 'unsigned int msg_len', 'unsigned int *u_msg_prio', 'const struct old_timespec32 *u_abs_timeout']], # mq_timedreceive_time32
                [0x119, 'mq_notify', ['mqd_t mqdes', 'const struct sigevent *u_notification']],
                [0x11a, 'mq_getsetattr', ['mqd_t mqdes', 'const struct mq_attr *u_mqstat', 'struct mq_attr *u_omqstat']],
                [0x11b, 'kexec_load', ['unsigned long entry', 'unsigned long nr_segments', 'struct kexec_segment *segments', 'unsigned long flags']],
                [0x11c, 'waitid', ['int which', 'pid_t upid', 'struct siginfo *infop', 'int options', 'struct rusage *ru']],
                #0x11d, unused
                [0x11e, 'add_key', ['const char *_type', 'const char *_description', 'const void *_payload', 'size_t plen', 'key_serial_t ringid']],
                [0x11f, 'request_key', ['const char *_type', 'const char *_description', 'const char *_callout_info', 'key_serial_t destringid']],
                [0x120, 'keyctl', ['int option', 'unsigned long arg2', 'unsigned long arg3', 'unsigned long arg4', 'unsigned long arg5']],
                [0x121, 'ioprio_set', ['int which', 'int who', 'int ioprio']],
                [0x122, 'ioprio_get', ['int which', 'int who']],
                [0x123, 'inotify_init', []],
                [0x124, 'inotify_add_watch', ['int fd', 'const char *pathname', 'u32 mask']],
                [0x125, 'inotify_rm_watch', ['int fd', '__s32 wd']],
                [0x126, 'migrate_pages', ['pid_t pid', 'unsigned long maxnode', 'const unsigned long *old_nodes', 'const unsigned long *new_nodes']],
                [0x127, 'openat', ['int dfd', 'const char *filename', 'int flags', 'umode_t mode']],
                [0x128, 'mkdirat', ['int dfd', 'const char *pathname', 'umode_t mode']],
                [0x129, 'mknodat', ['int dfd', 'const char *filename', 'umode_t mode', 'unsigned int dev']],
                [0x12a, 'fchownat', ['int dfd', 'const char *filename', 'uid_t user', 'gid_t group', 'int flag']],
                [0x12b, 'futimesat', ['unsigned int dfd', 'const char *filename', 'struct old_timeval32 *t']], # futimesat_time32
                [0x12c, 'fstatat64', ['unsigned int dfd', 'const char *filename', 'struct stat64 *statbuf', 'int flag']], # fstatat64
                [0x12d, 'unlinkat', ['int dfd', 'const char *pathname', 'int flag']],
                [0x12e, 'renameat', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname']],
                [0x12f, 'linkat', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname', 'int flags']],
                [0x130, 'symlinkat', ['const char *oldname', 'int newdfd', 'const char *newname']],
                [0x131, 'readlinkat', ['int dfd', 'const char *pathname', 'char *buf', 'int bufsiz']],
                [0x132, 'fchmodat', ['int dfd', 'const char *filename', 'umode_t mode']],
                [0x133, 'faccessat', ['int dfd', 'const char *filename', 'int mode']],
                [0x134, 'pselect6', ['int n', 'fd_set *inp', 'fd_set *outp', 'fd_set *exp', 'struct old_timespec32 *tsp', 'void *sig']], # pselect6_time32
                [0x135, 'ppoll', ['struct pollfd *ufds', 'unsigned int nfds', 'struct old_timespec32 *tsp', 'const sigset_t *sigmask', 'size_t sigsetsize']], # ppoll_time32
                [0x136, 'unshare', ['unsigned long unshare_flags']],
                [0x137, 'set_robust_list', ['struct robust_list_head *head', 'size_t len']],
                [0x138, 'get_robust_list', ['int pid', 'struct robust_list_head **head_ptr', 'size_t *len_ptr']],
                [0x139, 'splice', ['int fd_in', 'loff_t *off_in', 'int fd_out', 'loff_t *off_out', 'size_t len', 'unsigned int flags']],
                [0x13a, 'sync_file_range', ['int fd', 'unsigned int off_low', 'unsigned int off_hi', 'unsigned int n_low', 'unsigned int n_hi', 'unsigned int flags']], # ia32_sync_file_range
                [0x13b, 'tee', ['int fdin', 'int fdout', 'size_t len', 'unsigned int flags']],
                [0x13c, 'vmsplice', ['int fd', 'const struct iovec *uiov', 'unsigned long nr_segs', 'unsigned int flags']],
                [0x13d, 'move_pages', ['pid_t pid', 'unsigned long nr_pages', 'const void **pages', 'const int *nodes', 'int *status', 'int flags']],
                [0x13e, 'getcpu', ['unsigned *cpup', 'unsigned *nodep', 'struct getcpu_cache *unused']],
                [0x13f, 'epoll_pwait', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'int timeout', 'const sigset_t *sigmask', 'size_t sigsetsize']],
                [0x140, 'utimensat', ['unsigned int dfd', 'const char *filename', 'struct old_timespec32 *t', 'int flags']], # utimensat_time32
                [0x141, 'signalfd', ['int ufd', 'sigset_t *user_mask', 'size_t sizemask']],
                [0x142, 'timerfd_create', ['int clockid', 'int flags']],
                [0x143, 'eventfd', ['unsigned int count']],
                [0x144, 'fallocate', ['int fd', 'int mode', 'unsigned int offset_lo', 'unsigned int offset_hi', 'unsigned int len_lo', 'unsigned int len_hi']], # ia32_fallocate
                [0x145, 'timerfd_settime', ['int ufd', 'int flags', 'const struct old_itimerspec32 *utmr', 'struct old_itimerspec32 *otmr']], # timerfd_settime32
                [0x146, 'timerfd_gettime', ['int ufd', 'struct old_itimerspec32 *otmr']], # timerfd_gettime32
                [0x147, 'signalfd4', ['int ufd', 'sigset_t *user_mask', 'size_t sizemask', 'int flags']],
                [0x148, 'eventfd2', ['unsigned int count', 'int flags']],
                [0x149, 'epoll_create1', ['int flags']],
                [0x14a, 'dup3', ['unsigned int oldfd', 'unsigned int newfd', 'int flags']],
                [0x14b, 'pipe2', ['int *fildes', 'int flags']],
                [0x14c, 'inotify_init1', ['int flags']],
                [0x14d, 'preadv', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen', 'unsigned long pos_l', 'unsigned long pos_h']],
                [0x14e, 'pwritev', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen', 'unsigned long pos_l', 'unsigned long pos_h']],
                [0x14f, 'rt_tgsigqueueinfo', ['pid_t tgid', 'pid_t pid', 'int sig', 'siginfo_t *uinfo']],
                [0x150, 'perf_event_open', ['struct perf_event_attr *attr_uptr', 'pid_t pid', 'int cpu', 'int group_fd', 'unsigned long flags']],
                [0x151, 'recvmmsg', ['int fd', 'struct mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags', 'struct old_timespec32 *timeout']], # recvmmsg_time32
                [0x152, 'fanotify_init', ['unsigned int flags', 'unsigned int event_f_flags']],
                [0x153, 'fanotify_mark', ['int fanotify_fd', 'unsigned int flags', '__u64 mask', 'int dfd', 'const char *pathname']],
                [0x154, 'prlimit64', ['pid_t pid', 'unsigned int resource', 'const struct rlimit64 *new_rlim', 'struct rlimit64 *old_rlim']],
                [0x155, 'name_to_handle_at', ['int dfd', 'const char *name', 'struct file_handle *handle', 'int *mnt_id', 'int flag']],
                [0x156, 'open_by_handle_at', ['int mountdirfd', 'struct file_handle *handle', 'int flags']],
                [0x157, 'clock_adjtime', ['clockid_t which_clock', 'struct old_timex32 *utp']], # clock_adjtime32
                [0x158, 'syncfs', ['int fd']],
                [0x159, 'sendmmsg', ['int fd', 'struct mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags']],
                [0x15a, 'setns', ['int fd', 'int flags']],
                [0x15b, 'process_vm_readv', ['pid_t pid', 'const struct iovec *lvec', 'unsigned long liovcnt', 'const struct iovec *rvec', 'unsigned long riovcnt', 'unsigned long flags']],
                [0x15c, 'process_vm_writev', ['pid_t pid', 'const struct iovec *lvec', 'unsigned long liovcnt', 'const struct iovec *rvec', 'unsigned long riovcnt', 'unsigned long flags']],
                [0x15d, 'kcmp', ['pid_t pid1', 'pid_t pid2', 'int type', 'unsigned long idx1', 'unsigned long idx2']],
                [0x15e, 'finit_module', ['int fd', 'const char *uargs', 'int flags']],
                [0x15f, 'sched_setattr', ['pid_t pid', 'struct sched_attr *uattr', 'unsigned int flags']],
                [0x160, 'sched_getattr', ['pid_t pid', 'struct sched_attr *uattr', 'unsigned int usize', 'unsigned int flags']],
                [0x161, 'renameat2', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname', 'unsigned int flags']],
                [0x162, 'seccomp', ['unsigned int op', 'unsigned int flags', 'void *uargs']],
                [0x163, 'getrandom', ['char *buf', 'size_t count', 'unsigned int flags']],
                [0x164, 'memfd_create', ['const char *uname', 'unsigned int flags']],
                [0x165, 'bpf', ['int cmd', 'union bpf_attr *uattr', 'unsigned int size']],
                [0x166, 'execveat', ['int fd', 'const char *filename', 'const char *const *argv', 'const char *const *envp', 'int flags']],
                [0x167, 'socket', ['int family', 'int type', 'int protocol']],
                [0x168, 'socketpair', ['int family', 'int type', 'int protocol', 'int *usockvec']],
                [0x169, 'bind', ['int fd', 'struct sockaddr *umyaddr', 'int addrlen']],
                [0x16a, 'connect', ['int fd', 'struct sockaddr *uservaddr', 'int addrlen']],
                [0x16b, 'listen', ['int fd', 'int backlog']],
                [0x16c, 'accept4', ['int fd', 'struct sockaddr *upeer_sockaddr', 'int *upeer_addrlen', 'int flags']],
                [0x16d, 'getsockopt', ['int fd', 'int level', 'int optname', 'char *optval', 'int *optlen']],
                [0x16e, 'setsockopt', ['int fd', 'int level', 'int optname', 'char *optval', 'int optlen']],
                [0x16f, 'getsockname', ['int fd', 'struct sockaddr *usockaddr', 'int *usockaddr_len']],
                [0x170, 'getpeername', ['int fd', 'struct sockaddr *usockaddr', 'int *usockaddr_len']],
                [0x171, 'sendto', ['int fd', 'void *buff', 'size_t len', 'unsigned int flags', 'struct sockaddr *addr', 'int addr_len']],
                [0x172, 'sendmsg', ['int fd', 'struct user_msghdr *msg', 'unsigned int flags']],
                [0x173, 'recvfrom', ['int fd', 'void *ubuf', 'size_t size', 'unsigned int flags', 'struct sockaddr *addr', 'int *addr_len']],
                [0x174, 'recvmsg', ['int fd', 'struct user_msghdr *msg', 'unsigned int flags']],
                [0x175, 'shutdown', ['int fd', 'int how']],
                [0x176, 'userfaultfd', ['int flags']],
                [0x177, 'membarrier', ['int cmd', 'int flags']],
                [0x178, 'mlock2', ['unsigned long start', 'size_t len', 'int flags']],
                [0x179, 'copy_file_range', ['int fd_in', 'loff_t *off_in', 'int fd_out', 'loff_t *off_out', 'size_t len', 'unsigned int flags']],
                [0x17a, 'preadv2', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen', 'unsigned long pos_l', 'unsigned long pos_h', 'rwf_t flags']],
                [0x17b, 'pwritev2', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen', 'unsigned long pos_l', 'unsigned long pos_h', 'rwf_t flags']],
                [0x17c, 'pkey_mprotect', ['unsigned long start', 'size_t len', 'unsigned long prot', 'int pkey']],
                [0x17d, 'pkey_alloc', ['unsigned long flags', 'unsigned long init_val']],
                [0x17e, 'pkey_free', ['int pkey']],
                [0x17f, 'statx', ['int dfd', 'const char *filename', 'unsigned flags', 'unsigned int mask', 'struct statx *buffer']],
                [0x180, 'arch_prctl', ['int option', 'unsigned long arg2']],
                [0x181, 'io_pgetevents', ['aio_context_t ctx_id', 'long min_nr', 'long nr', 'struct io_event *events', 'struct __kernel_timespec *timeout', 'const struct __aio_sigset *usig']],
                [0x182, 'rseq', ['struct rseq *rseq', 'u32 rseq_len', 'int flags', 'u32 sig']],
                # 0x183-0x188, don't use
                [0x189, 'semget', ['key_t key', 'int nsems', 'int semflg']],
                [0x18a, 'semctl', ['int semid', 'int semnum', 'int cmd', 'unsigned long arg']],
                [0x18b, 'shmget', ['key_t key', 'size_t size', 'int shmflg']],
                [0x18c, 'shmctl', ['int shmid', 'int cmd', 'struct shmid_ds *buf']],
                [0x18d, 'shmat', ['int shmid', 'char *shmaddr', 'int shmflg']],
                [0x18e, 'shmdt', ['char *shmaddr']],
                [0x18f, 'msgget', ['key_t key', 'int msgflg']],
                [0x190, 'msgsnd', ['int msqid', 'struct msgbuf *msgp', 'size_t msgsz', 'int msgflg']],
                [0x191, 'msgrcv', ['int msqid', 'struct msgbuf *msgp', 'size_t msgsz', 'long msgtyp', 'int msgflg']],
                [0x192, 'msgctl', ['int msqid', 'int cmd', 'struct msqid_ds *buf']],
                [0x193, 'clock_gettime_time64', ['const clockid_t which_clock', 'struct __kernel_timespec *tp']], # clock_gettime
                [0x194, 'clock_settime_time64', ['const clockid_t which_clock', 'struct __kernel_timespec *tp']], # clock_settime
                [0x195, 'clock_adjtime_time64', ['const clockid_t which_clock', 'struct __kernel_timex *utx']], # clock_adjtime
                [0x196, 'clock_getres_time64', ['const clockid_t which_clock', 'struct __kernel_timespec *tp']], # clock_getres
                [0x197, 'clock_nanosleep_time64', ['const clockid_t which_clock', 'int flags', 'const struct __kernel_timespec *rqtp', 'struct __kernel_timespec *rmtp']], # clock_nanosleep
                [0x198, 'timer_gettime_time64', ['timer_t timer_id', 'struct __kernel_itimerspec *setting']], # timer_gettime
                [0x199, 'timer_settime_time64', ['timer_t timer_id', 'int flags', 'const struct __kernel_itimerspec *new_setting', 'struct __kernel_itimerspec *old_setting']], # timer_settime
                [0x19a, 'timerfd_gettime_time64', ['int ufd', 'struct __kernel_itimerspec *otmr']], # timerfd_gettime
                [0x19b, 'timerfd_settime_time64', ['int ufd', 'int flags', 'const struct __kernel_itimerspec *utmr', 'struct __kernel_itimerspec *otmr']], # timerfd_settime
                [0x19c, 'utimensat_time64', ['int dfd', 'const char *filename', 'struct __kernel_timespec *utimes', 'int flags']], # utimensat
                [0x19d, 'pselect6_time64', ['int n', 'fd_set *inp', 'fd_set *outp', 'fd_set *exp', 'struct __kernel_timespec *tsp', 'void *sig']], # pselect6
                [0x19e, 'ppoll_time64', ['struct pollfd *ufds', 'unsigned int nfds', 'struct __kernel_timespec *tsp', 'const sigset_t *sigmask', 'size_t sigsetsize']], # ppoll
                #0x19f, unused
                [0x1a0, 'io_pgetevents_time64', ['aio_context_t ctx_id', 'long min_nr', 'long nr', 'struct io_event *events', 'struct __kernel_timespec *timeout', 'const struct __aio_sigset *usig']], # io_pgetevents
                [0x1a1, 'recvmmsg_time64', ['int fd', 'struct mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags', 'struct __kernel_timespec *timeout']], # recvmmsg
                [0x1a2, 'mq_timedsend_time64', ['mqd_t mqdes', 'const char *u_msg_ptr', 'size_t msg_len', 'unsigned int msg_prio', 'const struct __kernel_timespec *u_abs_timeout']], # mq_timedsend
                [0x1a3, 'mq_timedreceive_time64', ['mqd_t mqdes', 'char *u_msg_ptr', 'size_t msg_len', 'unsigned int *u_msg_prio', 'const struct __kernel_timespec *u_abs_timeout']], # mq_timedreceive
                [0x1a4, 'semtimedop_time64', ['int semid', 'struct sembuf *tsops', 'unsigned int nsops', 'const struct __kernel_timespec *timeout']], # semtimedop
                [0x1a5, 'rt_sigtimedwait_time64', ['const sigset_t *uthese', 'siginfo_t *uinfo', 'const struct __kernel_timespec *uts', 'size_t sigsetsize']], # rt_sigtimedwait
                [0x1a6, 'futex_time64', ['u32 *uaddr', 'int op', 'u32 val', 'struct __kernel_timespec *utime', 'u32 *uaddr2', 'u32 val3']], # futex
                [0x1a7, 'sched_rr_get_interval_time64', ['pid_t pid', 'struct __kernel_timespec *interval']], # sched_rr_get_interval
                [0x1a8, 'pidfd_send_signal', ['int pidfd', 'int sig', 'siginfo_t *info', 'unsigned int flags']],
                [0x1a9, 'io_uring_setup', ['u32 entries', 'struct io_uring_params *params']],
                [0x1aa, 'io_uring_enter', ['unsigned int fd', 'u32 to_submit', 'u32 min_complete', 'u32 flags', 'const sigset_t *sig', 'size_t sigsz']],
                [0x1ab, 'io_uring_register', ['unsigned int fd', 'unsigned int opcode', 'void *arg', 'unsigned int nr_args']],
                [0x1ac, 'open_tree', ['int dfd', 'const char *filename', 'unsigned flags']],
                [0x1ad, 'move_mount', ['int from_dfd', 'const char *from_pathname', 'int to_dfd', 'const char *to_pathname', 'unsigned int flags']],
                [0x1ae, 'fsopen', ['const char *_fs_name', 'unsigned int flags']],
                [0x1af, 'fsconfig', ['int fd', 'unsigned int cmd', 'const char *_key', 'const void *_value', 'int aux']],
                [0x1b0, 'fsmount', ['int fs_fd', 'unsigned int flags', 'unsigned int attr_flags']],
                [0x1b1, 'fspick', ['int, dfd', 'const char *path', 'unsigned int flags']],
                [0x1b2, 'pidfd_open', ['pid_t pid', 'unsigned int flags']],
                [0x1b3, 'clone3', ['struct clone_args *uargs', 'size_t size']],
                [0x1b4, 'close_range', ['unsigned int fd', 'unsigned int max_fd', 'unsigned int flag']],
                [0x1b5, 'openat2', ['int dfd', 'const char *filename', 'struct open_how *how', 'size_t usize']],
                [0x1b6, 'pidfd_getfd', ['int pidfd', 'int fd', 'unsigned int flags']],
                [0x1b7, 'faccessat2', ['int dfd', 'const char *filename', 'int mode', 'int flags']],
                [0x1b8, 'process_madvise', ['int pidfd', 'const struct iovec *vec', 'size_t vlen', 'int behavior', 'unsigned int flags']],
                [0x1b9, 'epoll_pwait2', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'const struct __kernel_timespec *timeout', 'const sigset_t *sigmask', 'size_t sigsetsize']],
                [0x1ba, 'mount_setattr', ['int dfd', 'const char *path', 'unsigned int flags', 'struct mount_attr *uattr', 'size_t usize']],
                [0x1bb, 'quotactl_fd', ['unsigned int fd', 'unsigned int cmd', 'qid_t id', 'void __user *addr']],
                [0x1bc, 'landlock_create_ruleset', ['const struct landlock_ruleset_attr *const attr', 'const size_t size', 'const __u32 flags']],
                [0x1bd, 'landlock_add_rule', ['const int ruleset_fd', 'const enum landlock_rule_type rule_type', 'const void *const rule_attr', 'const __u32 flags']],
                [0x1be, 'landlock_restrict_self', ['const int ruleset_fd', 'const __u32 flags']],
                [0x1bf, 'memfd_secret', ['unsigned int, flags']],
                [0x1c0, 'process_mrelease', ['int pidfd', 'unsigned int flags']],
                [0x1c1, 'futex_waitv', ['struct futex_waitv *waiters', 'unsigned int nr_futexes', 'unsigned int flags', 'struct __kernel_timespec *timeout', 'clockid_t clockid']],
                [0x1c2, 'set_mempolicy_home_node', ['unsigned long start', 'unsigned long len', 'unsigned long home_node', 'unsigned long flags']],
            ]

        elif arch == "ARM64":
            register_list = ["$x0", "$x1", "$x2", "$x3", "$x4", "$x5"]
            # arch/arm64/include/asm/unistd.h
            # arch/arm64/include/uapi/asm/unistd.h
            # include/uapi/asm-generic/unistd.h
            syscall_list = [
                [0x0,   'io_setup', ['unsigned nr_events', 'aio_context_t *ctxp']],
                [0x1,   'io_destroy', ['aio_context_t ctx']],
                [0x2,   'io_submit', ['aio_context_t ctx_id', 'long nr', 'struct iocb **iocbpp']],
                [0x3,   'io_cancel', ['aio_context_t ctx_id', 'struct iocb *iocb', 'struct io_event *result']],
                [0x4,   'io_getevents', ['aio_context_t ctx_id', 'long min_nr', 'long nr', 'struct io_event *events', 'struct __kernel_timespec *timeout']],
                [0x5,   'setxattr', ['const char *pathname', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0x6,   'lsetxattr', ['const char *pathname', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0x7,   'fsetxattr', ['int fd', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0x8,   'getxattr', ['const char *pathname', 'const char *name', 'void *value', 'size_t size']],
                [0x9,   'lgetxattr', ['const char *pathname', 'const char *name', 'void *value', 'size_t size']],
                [0xa,   'fgetxattr', ['int fd', 'const char *name', 'void *value', 'size_t size']],
                [0xb,   'listxattr', ['const char *pathname', 'char *list', 'size_t size']],
                [0xc,   'llistxattr', ['const char *pathname', 'char *list', 'size_t size']],
                [0xd,   'flistxattr', ['int fd', 'char *list', 'size_t size']],
                [0xe,   'removexattr', ['const char *pathname', 'const char *name']],
                [0xf,   'lremovexattr', ['const char *pathname', 'const char *name']],
                [0x10,  'fremovexattr', ['int fd', 'const char *name']],
                [0x11,  'getcwd', ['char *buf', 'unsigned long size']],
                [0x12,  'lookup_dcookie', ['u64 cookie64', 'char *buf', 'size_t len']],
                [0x13,  'eventfd2', ['unsigned int count', 'int flags']],
                [0x14,  'epoll_create1', ['int flags']],
                [0x15,  'epoll_ctl', ['int epfd', 'int op', 'int fd', 'struct epoll_event *event']],
                [0x16,  'epoll_pwait', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'int timeout', 'const sigset_t *sigmask', 'size_t sigsetsize']],
                [0x17,  'dup', ['unsigned int fildes']],
                [0x18,  'dup3', ['unsigned int oldfd', 'unsigned int newfd', 'int flags']],
                [0x19,  'fcntl', ['unsigned int fd', 'unsigned int cmd', 'unsigned long arg']],
                [0x1a,  'inotify_init1', ['int flags']],
                [0x1b,  'inotify_add_watch', ['int fd', 'const char *pathname', 'u32 mask']],
                [0x1c,  'inotify_rm_watch', ['int fd', '__s32 wd']],
                [0x1d,  'ioctl', ['unsigned int fd', 'unsigned int cmd', 'unsigned long arg']],
                [0x1e,  'ioprio_set', ['int which', 'int who', 'int ioprio']],
                [0x1f,  'ioprio_get', ['int which', 'int who']],
                [0x20,  'flock', ['unsigned int fd', 'unsigned int cmd']],
                [0x21,  'mknodat', ['int dfd', 'const char *filename', 'umode_t mode', 'unsigned int dev']],
                [0x22,  'mkdirat', ['int dfd', 'const char *pathname', 'umode_t mode']],
                [0x23,  'unlinkat', ['int dfd', 'const char *pathname', 'int flag']],
                [0x24,  'symlinkat', ['const char *oldname', 'int newdfd', 'const char *newname']],
                [0x25,  'linkat', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname', 'int flags']],
                [0x26,  'renameat', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname']],
                [0x27,  'umount2', ['char *name', 'int flags']],
                [0x28,  'mount', ['char *dev_name', 'char *dir_name', 'char *type', 'unsigned long flags', 'void *data']],
                [0x29,  'pivot_root', ['const char *new_root', 'const char *put_old']],
                #0x2a,  nfsservctl # deleted from kernel 3.1
                [0x2b,  'statfs', ['const char *pathname', 'struct statfs *buf']],
                [0x2c,  'fstatfs', ['unsigned int fd', 'struct statfs *buf']],
                [0x2d,  'truncate', ['const char *path', 'long length']],
                [0x2e,  'ftruncate', ['unsigned int fd', 'unsigned long length']],
                [0x2f,  'fallocate', ['int fd', 'int mode', 'loff_t offset', 'loff_t len']],
                [0x30,  'faccessat', ['int dfd', 'const char *filename', 'int mode']],
                [0x31,  'chdir', ['const char *filename']],
                [0x32,  'fchdir', ['unsigned int fd']],
                [0x33,  'chroot', ['const char *filename']],
                [0x34,  'fchmod', ['unsigned int fd', 'umode_t mode']],
                [0x35,  'fchmodat', ['int dfd', 'const char *filename', 'umode_t mode']],
                [0x36,  'fchownat', ['int dfd', 'const char *filename', 'uid_t user', 'gid_t group', 'int flag']],
                [0x37,  'fchown', ['unsigned int fd', 'uid_t user', 'gid_t group']],
                [0x38,  'openat', ['int dfd', 'const char *filename', 'int flags', 'umode_t mode']],
                [0x39,  'close', ['unsigned int fd']],
                [0x3a,  'vhangup', []],
                [0x3b,  'pipe2', ['int *fildes', 'int flags']],
                [0x3c,  'quotactl', ['unsigned int cmd', 'const char *special', 'qid_t id', 'void *addr']],
                [0x3d,  'getdents64', ['unsigned int fd', 'struct linux_dirent64 *dirent', 'unsigned int count']],
                [0x3e,  'lseek', ['unsigned int fd', 'off_t offset', 'unsigned int whence']],
                [0x3f,  'read', ['unsigned int fd', 'char *buf', 'size_t count']],
                [0x40,  'write', ['unsigned int fd', 'const char *buf', 'size_t count']],
                [0x41,  'readv', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen']],
                [0x42,  'writev', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen']],
                [0x43,  'pread64', ['unsigned int fd', 'char *buf', 'size_t count', 'loff_t pos']],
                [0x44,  'pwrite64', ['unsigned int fd', 'const char *buf', 'size_t count', 'loff_t pos']],
                [0x45,  'preadv', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen', 'unsigned long pos_l', 'unsigned long pos_h']],
                [0x46,  'pwritev', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen', 'unsigned long pos_l', 'unsigned long pos_h']],
                [0x47,  'sendfile', ['int out_fd', 'int in_fd', 'off_t *offset', 'size_t count']], # sendfile64
                [0x48,  'pselect6', ['int n', 'fd_set *inp', 'fd_set *outp', 'fd_set *exp', 'struct __kernel_timespec *tsp', 'void *sig']],
                [0x49,  'ppoll', ['struct pollfd *ufds', 'unsigned int nfds', 'struct __kernel_timespec *tsp', 'const sigset_t *sigmask', 'size_t sigsetsize']],
                [0x4a,  'signalfd4', ['int ufd', 'sigset_t *user_mask', 'size_t sizemask', 'int flags']],
                [0x4b,  'vmsplice', ['int fd', 'const struct iovec *uiov', 'unsigned long nr_segs', 'unsigned int flags']],
                [0x4c,  'splice', ['int fd_in', 'loff_t *off_in', 'int fd_out', 'loff_t *off_out', 'size_t len', 'unsigned int flags']],
                [0x4d,  'tee', ['int fdin', 'int fdout', 'size_t len', 'unsigned int flags']],
                [0x4e,  'readlinkat', ['int dfd', 'const char *pathname', 'char *buf', 'int bufsiz']],
                [0x4f,  'fstatat', ['int dfd', 'const char *filename', 'struct stat *statbuf', 'int flag']], # newfstatat
                [0x50,  'fstat', ['unsigned int fd', 'struct stat *statbuf']], # newfstat
                [0x51,  'sync', []],
                [0x52,  'fsync', ['unsigned int fd']],
                [0x53,  'fdatasync', ['unsigned int fd']],
                [0x54,  'sync_file_range', ['int fd', 'loff_t offset', 'loff_t nbytes', 'unsigned int flags']], # sync_file_range2 is unimplemented
                [0x55,  'timerfd_create', ['int clockid', 'int flags']],
                [0x56,  'timerfd_settime', ['int ufd', 'int flags', 'const struct __kernel_itimerspec *utmr', 'struct __kernel_itimerspec *otmr']],
                [0x57,  'timerfd_gettime', ['int ufd', 'struct __kernel_itimerspec *otmr']],
                [0x58,  'utimensat', ['int dfd', 'const char *filename', 'struct __kernel_timespec *utimes', 'int flags']],
                [0x59,  'acct', ['const char *name']],
                [0x5a,  'capget', ['cap_user_header_t header', 'cap_user_data_t dataptr']],
                [0x5b,  'capset', ['cap_user_header_t header', 'const cap_user_data_t data']],
                [0x5c,  'personality', ['unsigned int personality']],
                [0x5d,  'exit', ['int error_code']],
                [0x5e,  'exit_group', ['int error_code']],
                [0x5f,  'waitid', ['int which', 'pid_t upid', 'struct siginfo *infop', 'int options', 'struct rusage *ru']],
                [0x60,  'set_tid_address', ['int *tidptr']],
                [0x61,  'unshare', ['unsigned long unshare_flags']],
                [0x62,  'futex', ['u32 *uaddr', 'int op', 'u32 val', 'struct __kernel_timespec *utime', 'u32 *uaddr2', 'u32 val3']],
                [0x63,  'set_robust_list', ['struct robust_list_head *head', 'size_t len']],
                [0x64,  'get_robust_list', ['int pid', 'struct robust_list_head **head_ptr', 'size_t *len_ptr']],
                [0x65,  'nanosleep', ['struct __kernel_timespec *rqtp', 'struct __kernel_timespec *rmtp']],
                [0x66,  'getitimer', ['int which', 'struct __kernel_old_itimerval *value']],
                [0x67,  'setitimer', ['int which', 'struct __kernel_old_itimerval *value', 'struct __kernel_old_itimerval *ovalue']],
                [0x68,  'kexec_load', ['unsigned long entry', 'unsigned long nr_segments', 'struct kexec_segment *segments', 'unsigned long flags']],
                [0x69,  'init_module', ['void *umod', 'unsigned long len', 'const char *uargs']],
                [0x6a,  'delete_module', ['const char *name_user', 'unsigned int flags']],
                [0x6b,  'timer_create', ['clockid_t which_clock', 'struct sigevent *timer_event_spec', 'timer_t *created_timer_id']],
                [0x6c,  'timer_gettime', ['timer_t timer_id', 'struct __kernel_itimerspec *setting']],
                [0x6d,  'timer_getoverrun', ['timer_t timer_id']],
                [0x6e,  'timer_settime', ['timer_t timer_id', 'int flags', 'const struct __kernel_itimerspec *new_setting', 'struct __kernel_itimerspec *old_setting']],
                [0x6f,  'timer_delete', ['timer_t timer_id']],
                [0x70,  'clock_settime', ['clockid_t which_clock', 'const struct __kernel_timespec *tp']],
                [0x71,  'clock_gettime', ['clockid_t which_clock', 'struct __kernel_timespec *tp']],
                [0x72,  'clock_getres', ['clockid_t which_clock', 'struct __kernel_timespec *tp']],
                [0x73,  'clock_nanosleep', ['clockid_t which_clock', 'int flags', 'const struct __kernel_timespec *rqtp', 'struct __kernel_timespec *rmtp']],
                [0x74,  'syslog', ['int type', 'char *buf', 'int len']],
                [0x75,  'ptrace', ['long request', 'long pid', 'unsigned long addr', 'unsigned long data']],
                [0x76,  'sched_setparam', ['pid_t pid', 'struct sched_param *param']],
                [0x77,  'sched_setscheduler', ['pid_t pid', 'int policy', 'struct sched_param *param']],
                [0x78,  'sched_getscheduler', ['pid_t pid']],
                [0x79,  'sched_getparam', ['pid_t pid', 'struct sched_param *param']],
                [0x7a,  'sched_setaffinity', ['pid_t pid', 'unsigned int len', 'unsigned long *user_mask_ptr']],
                [0x7b,  'sched_getaffinity', ['pid_t pid', 'unsigned int len', 'unsigned long *user_mask_ptr']],
                [0x7c,  'sched_yield', []],
                [0x7d,  'sched_get_priority_max', ['int policy']],
                [0x7e,  'sched_get_priority_min', ['int policy']],
                [0x7f,  'sched_rr_get_interval', ['pid_t pid', 'struct __kernel_timespec *interval']],
                [0x80,  'restart_syscall', []],
                [0x81,  'kill', ['pid_t pid', 'int sig']],
                [0x82,  'tkill', ['pid_t pid', 'int sig']],
                [0x83,  'tgkill', ['pid_t tgid', 'pid_t pid', 'int sig']],
                [0x84,  'sigaltstack', ['const stack_t *uss', 'stack_t *uoss']],
                [0x85,  'rt_sigsuspend', ['sigset_t *unewset', 'size_t sigsetsize']],
                [0x86,  'rt_sigaction', ['int sig', 'const struct sigaction *act', 'struct sigaction *oact', 'size_t sigsetsize']],
                [0x87,  'rt_sigprocmask', ['int how', 'sigset_t *nset', 'sigset_t *oset', 'size_t sigsetsize']],
                [0x88,  'rt_sigpending', ['sigset_t *uset', 'size_t sigsetsize']],
                [0x89,  'rt_sigtimedwait', ['const sigset_t *uthese', 'siginfo_t *uinfo', 'const struct __kernel_timespec *uts', 'size_t sigsetsize']],
                [0x8a,  'rt_sigqueueinfo', ['pid_t pid', 'int sig', 'siginfo_t *uinfo']],
                [0x8b,  'rt_sigreturn', []],
                [0x8c,  'setpriority', ['int which', 'int who', 'int niceval']],
                [0x8d,  'getpriority', ['int which', 'int who']],
                [0x8e,  'reboot', ['int magic1', 'int magic2', 'unsigned int cmd', 'void *arg']],
                [0x8f,  'setregid', ['gid_t rgid', 'gid_t egid']],
                [0x90,  'setgid', ['gid_t gid']],
                [0x91,  'setreuid', ['uid_t ruid', 'uid_t euid']],
                [0x92,  'setuid', ['uid_t uid']],
                [0x93,  'setresuid', ['uid_t ruid', 'uid_t euid', 'uid_t suid']],
                [0x94,  'getresuid', ['uid_t *ruidp', 'uid_t *euidp', 'uid_t *suidp']],
                [0x95,  'setresgid', ['gid_t rgid', 'gid_t egid', 'gid_t sgid']],
                [0x96,  'getresgid', ['gid_t *rgidp', 'gid_t *egidp', 'gid_t *sgidp']],
                [0x97,  'setfsuid', ['uid_t uid']],
                [0x98,  'setfsgid', ['gid_t gid']],
                [0x99,  'times', ['struct tms *tbuf']],
                [0x9a,  'setpgid', ['pid_t pid', 'pid_t pgid']],
                [0x9b,  'getpgid', ['pid_t pid']],
                [0x9c,  'getsid', ['pid_t pid']],
                [0x9d,  'setsid', []],
                [0x9e,  'getgroups', ['int gidsetsize', 'gid_t *grouplist']],
                [0x9f,  'setgroups', ['int gidsetsize', 'gid_t *grouplist']],
                [0xa0,  'uname', ['struct new_utsname *name']], # newuname
                [0xa1,  'sethostname', ['char *name', 'int len']],
                [0xa2,  'setdomainname', ['char *name', 'int len']],
                [0xa3,  'getrlimit', ['unsigned int resource', 'struct rlimit *rlim']],
                [0xa4,  'setrlimit', ['unsigned int resource', 'struct rlimit *rlim']],
                [0xa5,  'getrusage', ['int who', 'struct rusage *ru']],
                [0xa6,  'umask', ['int mask']],
                [0xa7,  'prctl', ['int option', 'unsigned long arg2', 'unsigned long arg3', 'unsigned long arg4', 'unsigned long arg5']],
                [0xa8,  'getcpu', ['unsigned *cpup', 'unsigned *nodep', 'struct getcpu_cache *unused']],
                [0xa9,  'gettimeofday', ['struct __kernel_old_timeval *tv', 'struct timezone *tz']],
                [0xaa,  'settimeofday', ['struct __kernel_old_timeval *tv', 'struct timezone *tz']],
                [0xab,  'adjtimex', ['struct __kernel_timex *txc_p']],
                [0xac,  'getpid', []],
                [0xad,  'getppid', []],
                [0xae,  'getuid', []],
                [0xaf,  'geteuid', []],
                [0xb0,  'getgid', []],
                [0xb1,  'getegid', []],
                [0xb2,  'gettid', []],
                [0xb3,  'sysinfo', ['struct sysinfo *info']],
                [0xb4,  'mq_open', ['const char *u_name', 'int oflag', 'umode_t mode', 'struct mq_attr *u_attr']],
                [0xb5,  'mq_unlink', ['const char *u_name']],
                [0xb6,  'mq_timedsend', ['mqd_t mqdes', 'const char *u_msg_ptr', 'size_t msg_len', 'unsigned int msg_prio', 'const struct __kernel_timespec *u_abs_timeout']],
                [0xb7,  'mq_timedreceive', ['mqd_t mqdes', 'char *u_msg_ptr', 'size_t msg_len', 'unsigned int *msg_prio', 'const struct __kernel_timespec *u_abs_timeout']],
                [0xb8,  'mq_notify', ['mqd_t mqdes', 'const struct sigevent *u_notification']],
                [0xb9,  'mq_getsetattr', ['mqd_t mqdes', 'const struct mq_attr *u_mqstat', 'struct mq_attr *u_omqstat']],
                [0xba,  'msgget', ['key_t key', 'int msgflg']],
                [0xbb,  'msgctl', ['int msqid', 'int cmd', 'struct msqid_ds *buf']],
                [0xbc,  'msgrcv', ['int msqid', 'struct msgbuf *msgp', 'size_t msgsz', 'long msgtyp', 'int msgflg']],
                [0xbd,  'msgsnd', ['int msqid', 'struct msgbuf *msgp', 'size_t msgsz', 'int msgflg']],
                [0xbe,  'semget', ['key_t key', 'int nsems', 'int semflg']],
                [0xbf,  'semctl', ['int semid', 'int semnum', 'int cmd', 'unsigned long arg']],
                [0xc0,  'semtimedop', ['int semid', 'struct sembuf *tsops', 'unsigned int nsops', 'const struct __kernel_timespec *timeout']],
                [0xc1,  'semop', ['int semid', 'struct sembuf *tsops', 'unsigned nsops']],
                [0xc2,  'shmget', ['key_t key', 'size_t size', 'int shmflg']],
                [0xc3,  'shmctl', ['int shmid', 'int cmd', 'struct shmid_ds *buf']],
                [0xc4,  'shmat', ['int shmid', 'char *shmaddr', 'int shmflg']],
                [0xc5,  'shmdt', ['char *shmaddr']],
                [0xc6,  'socket', ['int family', 'int type', 'int protocol']],
                [0xc7,  'socketpair', ['int family', 'int type', 'int protocol', 'int *usockvec']],
                [0xc8,  'bind', ['int fd', 'struct sockaddr *umyaddr', 'int addrlen']],
                [0xc9,  'listen', ['int fd', 'int backlog']],
                [0xca,  'accept', ['int fd', 'struct sockaddr *upeer_sockaddr', 'int *upeer_addrlen']],
                [0xcb,  'connect', ['int fd', 'struct sockaddr *uservaddr', 'int addrlen']],
                [0xcc,  'getsockname', ['int fd', 'struct sockaddr *usockaddr', 'int *usockaddr_len']],
                [0xcd,  'getpeername', ['int fd', 'struct sockaddr *usockaddr', 'int *usockaddr_len']],
                [0xce,  'sendto', ['int fd', 'void *buff', 'size_t len', 'unsigned int flags', 'struct sockaddr *addr', 'int addr_len']],
                [0xcf,  'recvfrom', ['int fd', 'void *ubuf', 'size_t size', 'unsigned int flags', 'struct sockaddr *addr', 'int *addr_len']],
                [0xd0,  'setsockopt', ['int fd', 'int level', 'int optname', 'char *optval', 'int optlen']],
                [0xd1,  'getsockopt', ['int fd', 'int level', 'int optname', 'char *optval', 'int *optlen']],
                [0xd2,  'shutdown', ['int fd', 'int how']],
                [0xd3,  'sendmsg', ['int fd', 'struct user_msghdr *msg', 'unsigned int flags']],
                [0xd4,  'recvmsg', ['int fd', 'struct user_msghdr *msg', 'unsigned int flags']],
                [0xd5,  'readahead', ['int fd', 'loff_t offset', 'size_t count']],
                [0xd6,  'brk', ['unsigned long brk']],
                [0xd7,  'munmap', ['unsigned long addr', 'size_t len']],
                [0xd8,  'mremap', ['unsigned long addr', 'unsigned long old_len', 'unsigned long new_len', 'unsigned long flags', 'unsigned long new_addr']],
                [0xd9,  'add_key', ['const char *_type', 'const char *_description', 'const void *_payload', 'size_t plen', 'key_serial_t ringid']],
                [0xda,  'request_key', ['const char *_type', 'const char *_description', 'const char *_callout_info', 'key_serial_t destringid']],
                [0xdb,  'keyctl', ['int option', 'unsigned long arg2', 'unsigned long arg3', 'unsigned long arg4', 'unsigned long arg5']],
                [0xdc,  'clone', ['unsigned long clone_flags', 'unsigned long newsp', 'int *parent_tidptr', 'unsigned long tls', 'int *child_tidptr']],
                [0xdd,  'execve', ['const char *filename', 'const char *const *argv', 'const char *const *envp']],
                [0xde,  'mmap', ['unsigned long addr', 'unsigned long len', 'unsigned long prot', 'unsigned long flags', 'unsigned long fd', 'unsigned long off']],
                [0xdf,  'fadvise64', ['int fd', 'loff_t offset', 'loff_t len', 'int advice']], # fadvise64_64
                [0xe0,  'swapon', ['const char *specialfile', 'int swap_flags']],
                [0xe1,  'swapoff', ['const char *specialfile']],
                [0xe2,  'mprotect', ['unsigned long start', 'size_t len', 'unsigned long prot']],
                [0xe3,  'msync', ['unsigned long start', 'size_t len', 'int flags']],
                [0xe4,  'mlock', ['unsigned long start', 'size_t len']],
                [0xe5,  'munlock', ['unsigned long start', 'size_t len']],
                [0xe6,  'mlockall', ['int flags']],
                [0xe7,  'munlockall', []],
                [0xe8,  'mincore', ['unsigned long start', 'size_t len', 'unsigned char *vec']],
                [0xe9,  'madvise', ['unsigned long start', 'size_t len_in', 'int behavior']],
                [0xea,  'remap_file_pages', ['unsigned long start', 'unsigned long size', 'unsigned long prot', 'unsigned long pgoff', 'unsigned long flags']],
                [0xeb,  'mbind', ['unsigned long start', 'unsigned long len', 'unsigned long mode', 'const unsigned long *nmask', 'unsigned long maxnode', 'unsigned flags']],
                [0xec,  'get_mempolicy', ['int *policy', 'unsigned long *nmask', 'unsigned long maxnode', 'unsigned long addr', 'unsigned long flags']],
                [0xed,  'set_mempolicy', ['int mode', 'const unsigned long *nmask', 'unsigned long maxnode']],
                [0xee,  'migrate_pages', ['pid_t pid', 'unsigned long maxnode', 'const unsigned long *old_nodes', 'const unsigned long *new_nodes']],
                [0xef,  'move_pages', ['pid_t pid', 'unsigned long nr_pages', 'const void **pages', 'const int *nodes', 'int *status', 'int flags']],
                [0xf0,  'rt_tgsigqueueinfo', ['pid_t tgid', 'pid_t pid', 'int sig', 'siginfo_t *uinfo']],
                [0xf1,  'perf_event_open', ['struct perf_event_attr *attr_uptr', 'pid_t pid', 'int cpu', 'int group_fd', 'unsigned long flags']],
                [0xf2,  'accept4', ['int fd', 'struct sockaddr *upeer_sockaddr', 'int *upeer_addrlen', 'int flags']],
                [0xf3,  'recvmmsg', ['int fd', 'struct mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags', 'struct __kernel_timespec *timeout']],
                [0xf4,  'arch_specific_syscall', []],
                #0xf5-0x103, unused
                [0x104, 'wait4', ['pid_t upid', 'int *stat_addr', 'int options', 'struct rusage *ru']],
                [0x105, 'prlimit64', ['pid_t pid', 'unsigned int resource', 'const struct rlimit64 *new_rlim', 'struct rlimit64 *old_rlim']],
                [0x106, 'fanotify_init', ['unsigned int flags', 'unsigned int event_f_flags']],
                [0x107, 'fanotify_mark', ['int fanotify_fd', 'unsigned int flags', '__u64 mask', 'int dfd', 'const char *pathname']],
                [0x108, 'name_to_handle_at', ['int dfd', 'const char *name', 'struct file_handle *handle', 'int *mnt_id', 'int flag']],
                [0x109, 'open_by_handle_at', ['int mountdirfd', 'struct file_handle *handle', 'int flags']],
                [0x10a, 'clock_adjtime', ['clockid_t which_clock', 'struct __kernel_timex *tx']],
                [0x10b, 'syncfs', ['int fd']],
                [0x10c, 'setns', ['int fd', 'int flags']],
                [0x10d, 'sendmmsg', ['int fd', 'struct mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags']],
                [0x10e, 'process_vm_readv', ['pid_t pid', 'const struct iovec *lvec', 'unsigned long liovcnt', 'const struct iovec *rvec', 'unsigned long riovcnt', 'unsigned long flags']],
                [0x10f, 'process_vm_writev', ['pid_t pid', 'const struct iovec *lvec', 'unsigned long liovcnt', 'const struct iovec *rvec', 'unsigned long riovcnt', 'unsigned long flags']],
                [0x110, 'kcmp', ['pid_t pid1', 'pid_t pid2', 'int type', 'unsigned long idx1', 'unsigned long idx2']],
                [0x111, 'finit_module', ['int fd', 'const char *uargs', 'int flags']],
                [0x112, 'sched_setattr', ['pid_t pid', 'struct sched_attr *uattr', 'unsigned int flags']],
                [0x113, 'sched_getattr', ['pid_t pid', 'struct sched_attr *uattr', 'unsigned int usize', 'unsigned int flags']],
                [0x114, 'renameat2', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname', 'unsigned int flags']],
                [0x115, 'seccomp', ['unsigned int op', 'unsigned int flags', 'void *uargs']],
                [0x116, 'getrandom', ['char *buf', 'size_t count', 'unsigned int flags']],
                [0x117, 'memfd_create', ['const char *uname', 'unsigned int flags']],
                [0x118, 'bpf', ['int cmd', 'union bpf_attr *uattr', 'unsigned int size']],
                [0x119, 'execveat', ['int fd', 'const char *filename', 'const char *const *argv', 'const char *const *envp', 'int flags']],
                [0x11a, 'userfaultfd', ['int flags']],
                [0x11b, 'membarrier', ['int cmd', 'int flags']],
                [0x11c, 'mlock2', ['unsigned long start', 'size_t len', 'int flags']],
                [0x11d, 'copy_file_range', ['int fd_in', 'loff_t *off_in', 'int fd_out', 'loff_t *off_out', 'size_t len', 'unsigned int flags']],
                [0x11e, 'preadv2', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen', 'unsigned long pos_l', 'unsigned long pos_h', 'rwf_t flags']],
                [0x11f, 'pwritev2', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen', 'unsigned long pos_l', 'unsigned long pos_h', 'rwf_t flags']],
                [0x120, 'pkey_mprotect', ['unsigned long start', 'size_t len', 'unsigned long prot', 'int pkey']],
                [0x121, 'pkey_alloc', ['unsigned long flags', 'unsigned long init_val']],
                [0x122, 'pkey_free', ['int pkey']],
                [0x123, 'statx', ['int dfd', 'const char *filename', 'unsigned flags', 'unsigned int mask', 'struct statx *buffer']],
                [0x124, 'io_pgetevents', ['aio_context_t ctx_id', 'long min_nr', 'long nr', 'struct io_event *events', 'struct __kernel_timespec *timeout', 'const struct __aio_sigset *usig']],
                [0x125, 'rseq', ['struct rseq *rseq', 'u32 rseq_len', 'int flags', 'u32 sig']],
                [0x126, 'kexec_file_load', ['int kernel_fd', 'int initrd_fd', 'unsigned long cmdline_len', 'const char *cmdline_ptr', 'unsigned long flags']],
                #0x127-0x1a7, unused
                [0x1a8, 'pidfd_send_signal', ['int pidfd', 'int sig', 'siginfo_t *info', 'unsigned int flags']],
                [0x1a9, 'io_uring_setup', ['u32 entries', 'struct io_uring_params *params']],
                [0x1aa, 'io_uring_enter', ['unsigned int fd', 'u32 to_submit', 'u32 min_complete', 'u32 flags', 'const sigset_t *sig', 'size_t sigsz']],
                [0x1ab, 'io_uring_register', ['unsigned int fd', 'unsigned int opcode', 'void *arg', 'unsigned int nr_args']],
                [0x1ac, 'open_tree', ['int dfd', 'const char *filename', 'unsigned flags']],
                [0x1ad, 'move_mount', ['int from_dfd', 'const char *from_pathname', 'int to_dfd', 'const char *to_pathname', 'unsigned int flags']],
                [0x1ae, 'fsopen', ['const char *_fs_name', 'unsigned int flags']],
                [0x1af, 'fsconfig', ['int fd', 'unsigned int cmd', 'const char *_key', 'const void *_value', 'int aux']],
                [0x1b0, 'fsmount', ['int fs_fd', 'unsigned int flags', 'unsigned int attr_flags']],
                [0x1b1, 'fspick', ['int, dfd', 'const char *path', 'unsigned int flags']],
                [0x1b2, 'pidfd_open', ['pid_t pid', 'unsigned int flags']],
                [0x1b3, 'clone3', ['struct clone_args *uargs', 'size_t size']],
                [0x1b4, 'close_range', ['unsigned int fd', 'unsigned int max_fd', 'unsigned int flag']],
                [0x1b5, 'openat2', ['int dfd', 'const char *filename', 'struct open_how *how', 'size_t usize']],
                [0x1b6, 'pidfd_getfd', ['int pidfd', 'int fd', 'unsigned int flags']],
                [0x1b7, 'faccessat2', ['int dfd', 'const char *filename', 'int mode', 'int flags']],
                [0x1b8, 'process_madvise', ['int pidfd', 'const struct iovec *vec', 'size_t vlen', 'int behavior', 'unsigned int flags']],
                [0x1b9, 'epoll_pwait2', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'const struct __kernel_timespec *timeout', 'const sigset_t *sigmask', 'size_t sigsetsize']],
                [0x1ba, 'mount_setattr', ['int dfd', 'const char *path', 'unsigned int flags', 'struct mount_attr *uattr', 'size_t usize']],
                [0x1bb, 'quotactl_fd', ['unsigned int fd', 'unsigned int cmd', 'qid_t id', 'void __user *addr']],
                [0x1bc, 'landlock_create_ruleset', ['const struct landlock_ruleset_attr *const attr', 'const size_t size', 'const __u32 flags']],
                [0x1bd, 'landlock_add_rule', ['const int ruleset_fd', 'const enum landlock_rule_type rule_type', 'const void *const rule_attr', 'const __u32 flags']],
                [0x1be, 'landlock_restrict_self', ['const int ruleset_fd', 'const __u32 flags']],
                [0x1bf, 'memfd_secret', ['unsigned int, flags']],
                [0x1c0, 'process_mrelease', ['int pidfd', 'unsigned int flags']],
                [0x1c1, 'futex_waitv', ['struct futex_waitv *waiters', 'unsigned int nr_futexes', 'unsigned int flags', 'struct __kernel_timespec *timeout', 'clockid_t clockid']],
                [0x1c2, 'set_mempolicy_home_node', ['unsigned long start', 'unsigned long len', 'unsigned long home_node', 'unsigned long flags']],
            ]

        elif arch == "ARM" and mode == "32":
            register_list = ["$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6"]
            # arch/arm64/include/asm/unistd.h
            # arch/arm64/include/asm/unistd32.h
            syscall_list = [
                [0x0,   'restart_syscall', []],
                [0x1,   'exit', ['int error_code']],
                [0x2,   'fork', []],
                [0x3,   'read', ['unsigned int fd', 'char *buf', 'size_t count']],
                [0x4,   'write', ['unsigned int fd', 'const char *buf', 'size_t count']],
                [0x5,   'open', ['const char *filename', 'int flags', 'umode_t mode']], # compat
                [0x6,   'close', ['unsigned int fd']],
                #0x7,   waitpid # unimplemented
                [0x8,   'creat', ['const char *pathname', 'umode_t mode']],
                [0x9,   'link', ['const char *oldname', 'const char *newname']],
                [0xa,   'unlink', ['const char *pathname']],
                [0xb,   'execve', ['const char *filename', 'const compat_uptr_t *argv', 'const compat_uptr_t *envp']], # compat
                [0xc,   'chdir', ['const char *filename']],
                #0xd,   time # unimplemented
                [0xe,   'mknod', ['const char *filename', 'umode_t mode', 'unsigned dev']],
                [0xf,   'chmod', ['const char *filename', 'umode_t mode']],
                [0x10,  'lchown', ['const char *filename', 'old_uid_t user', 'old_gid_t group']], # lchown16
                #0x11,  break # unimplemented
                #0x12,  stat # unimplemented
                [0x13,  'lseek', ['unsigned int fd', 'compat_off_t offset', 'unsigned int whence']], # compat
                [0x14,  'getpid', []],
                [0x15,  'mount', ['char *dev_name', 'char *dir_name', 'char *type', 'unsigned long flags', 'void *data']],
                #0x16,  umount # unimplemented
                [0x17,  'setuid', ['old_uid_t uid']], # setuid16
                [0x18,  'getuid', []], # getuid16
                #0x19,  stime # unimplemented
                [0x1a,  'ptrace', ['compat_long_t request', 'compat_long_t pid', 'compat_long_t addr', 'compat_long_t data']], # compat
                #0x1b,  alarm # unimplemented
                #0x1c,  fstat # unimplemented
                [0x1d,  'pause', []],
                #0x1e,  utime # unimplemented
                #0x1f,  stty # unimplemented
                #0x20,  gtty # unimplemented
                [0x21,  'access', ['const char *filename', 'int mode']],
                [0x22,  'nice', ['int increment']],
                #0x23,  ftime # unimplemented
                [0x24,  'sync', []],
                [0x25,  'kill', ['pid_t pid', 'int sig']],
                [0x26,  'rename', ['const char *oldname', 'const char *newname']],
                [0x27,  'mkdir', ['const char *pathname', 'umode_t mode']],
                [0x28,  'rmdir', ['const char *pathname']],
                [0x29,  'dup', ['unsigned int fildes']],
                [0x2a,  'pipe', ['int *fildes']],
                [0x2b,  'times', ['struct compat_tms *tbuf']], # compat
                #0x2c,  prof # unimplemented
                [0x2d,  'brk', ['unsigned long brk']],
                [0x2e,  'setgid', ['old_gid_t gid']], # setgid16
                [0x2f,  'getgid', []], # getgid16
                #0x30,  signal # unimplemented
                [0x31,  'geteuid', []], # geteuid16
                [0x32,  'getegid', []], # getegid16
                [0x33,  'acct', ['const char *name']],
                [0x34,  'umount2', ['char *name', 'int flags']], # umount
                #0x35,  lock # unimplemented
                [0x36,  'ioctl', ['unsigned int fd', 'unsigned int cmd', 'compat_ulong_t arg']], # compat
                [0x37,  'fcntl', ['unsigned int fd', 'unsigned int cmd', 'compat_ulong_t arg']], # compat
                #0x38,  mpx # unimplemented
                [0x39,  'setpgid', ['pid_t pid', 'pid_t pgid']],
                #0x3a,  ulimit # unimplemented
                #0x3b,  olduname # unimplemented
                [0x3c,  'umask', ['int mask']],
                [0x3d,  'chroot', ['const char *filename']],
                [0x3e,  'ustat', ['unsigned dev', 'struct compat_ustat *u']], # compat
                [0x3f,  'dup2', ['unsigned int oldfd', 'unsigned int newfd']],
                [0x40,  'getppid', []],
                [0x41,  'getpgrp', []],
                [0x42,  'setsid', []],
                [0x43,  'sigaction', ['int sig', 'const struct compat_old_sigaction *act', 'struct compat_old_sigaction *oact']], # compat
                #0x44,  sgetmask # unimplemented
                #0x45,  ssetmask # unimplemented
                [0x46,  'setreuid', ['old_uid_t ruid', 'old_uid_t euid']], # setreuid16
                [0x47,  'setregid', ['old_gid_t rgid', 'old_gid_t egid']], # setregid16
                [0x48,  'sigsuspend', ['old_sigset_t mask']],
                [0x49,  'sigpending', ['compat_old_sigset_t *set32']], # compat
                [0x4a,  'sethostname', ['char *name', 'int len']],
                [0x4b,  'setrlimit', ['unsigned int resource', 'struct compat_rlimit *rlim']], # compat
                #0x4c,  getrlimit # unimplemented
                [0x4d,  'getrusage', ['int who', 'struct compat_rusage *ru']], # compat
                [0x4e,  'gettimeofday', ['struct old_timeval32 *tv', 'struct timezone *tz']], # compat
                [0x4f,  'settimeofday', ['struct old_timeval32 *tv', 'struct timezone *tz']], # compat
                [0x50,  'getgroups', ['int gidsetsize', 'old_gid_t *grouplist']], # setgroups16
                [0x51,  'setgroups', ['int gidsetsize', 'old_gid_t *grouplist']], # getgroups16
                #0x52,  select # unimplemented
                [0x53,  'symlink', ['const char *oldname', 'const char *newname']],
                #0x54,  lstat # unimplemented
                [0x55,  'readlink', ['const char *path', 'char *buf', 'int bufsiz']],
                [0x56,  'uselib', ['const char *library']],
                [0x57,  'swapon', ['const char *specialfile', 'int swap_flags']],
                [0x58,  'reboot', ['int magic1', 'int magic2', 'unsigned int cmd', 'void *arg']],
                #0x59,  readdir # unimplemented
                #0x5a,  mmap # unimplemented
                [0x5b,  'munmap', ['unsigned long addr', 'size_t len']],
                [0x5c,  'truncate', ['const char *path', 'compat_off_t length']], # compat
                [0x5d,  'ftruncate', ['unsigned int fd', 'compat_ulong_t length']], # compat
                [0x5e,  'fchmod', ['unsigned int fd', 'umode_t mode']],
                [0x5f,  'fchown', ['unsigned int fd', 'old_uid_t user', 'old_gid_t group']], # fchown16
                [0x60,  'getpriority', ['int which', 'int who']],
                [0x61,  'setpriority', ['int which', 'int who', 'int niceval']],
                #0x62,  profil # unimplemented
                [0x63,  'statfs', ['const char *pathname', 'struct compat_statfs *buf']], # compat
                [0x64,  'fstatfs', ['unsigned int fd', 'struct compat_statfs *buf']], # compat
                #0x65,  ioperm # unimplemented
                #0x66,  socketcall # unimplemented
                [0x67,  'syslog', ['int type', 'char *buf', 'int len']],
                [0x68,  'setitimer', ['int which', 'struct old_itimerval32 *value', 'struct old_itimerval32 *ovalue']], # compat
                [0x69,  'getitimer', ['int which', 'struct old_itimerval32 *value']], # compat
                [0x6a,  'stat', ['const char *filename', 'struct compat_stat *statbuf']], # compat newstat
                [0x6b,  'lstat', ['const char *filename', 'struct compat_stat *statbuf']], # compat newlstat
                [0x6c,  'fstat', ['unsigned int fd', 'struct compat_stat *statbuf']], # compat newfstat
                #0x6d,  uname # unimplemented
                #0x6e,  iopl # unimplemented
                [0x6f,  'vhangup', []],
                #0x70,  idle # deleted from kernel 2.3.13
                #0x71,  syscall # unimplemented
                [0x72,  'wait4', ['compat_pid_t upid', 'compat_uint_t *stat_addr', 'int options', 'struct compat_rusage *ru']], # compat
                [0x73,  'swapoff', ['const char *specialfile']],
                [0x74,  'sysinfo', ['struct compat_sysinfo *info']], # compat
                #0x75,  ipc # unimplemented
                [0x76,  'fsync', ['unsigned int fd']],
                [0x77,  'sigreturn', []], # compat
                [0x78,  'clone', ['unsigned long clone_flags', 'unsigned long newsp', 'int *parent_tidptr', 'unsigned long tls', 'int *child_tidptr']], # arg4,5 are swapped
                [0x79,  'setdomainname', ['char *name', 'int len']],
                [0x7a,  'uname', ['struct new_utsname *name']], # newuname
                #0x7b,  modify_ldt # unimplemented
                [0x7c,  'adjtimex', ['struct old_timex32 *utp']], # adjtimex_time32
                [0x7d,  'mprotect', ['unsigned long start', 'size_t len', 'unsigned long prot']],
                [0x7e,  'sigprocmask', ['int how', 'compat_old_sigset_t *nset', 'compat_old_sigset_t *oset']], # compat
                #0x7f,  create_module # dereted from kernel 2.6
                [0x80,  'init_module', ['void *umod', 'unsigned long len', 'const char *uargs']],
                [0x81,  'delete_module', ['const char *name_user', 'unsigned int flags']],
                #0x82,  get_kernel_syms # dereted from kernel 2.6
                [0x83,  'quotactl', ['unsigned int cmd', 'const char *special', 'qid_t id', 'void *addr']],
                [0x84,  'getpgid', ['pid_t pid']],
                [0x85,  'fchdir', ['unsigned int fd']],
                [0x86,  'bdflush', ['int func', 'long data']],
                [0x87,  'sysfs', ['int option', 'unsigned long arg1', 'unsigned long arg2']],
                [0x88,  'personality', ['unsigned int personality']],
                #0x89,  afs_syscall # unimplemented
                [0x8a,  'setfsuid', ['old_uid_t uid']], # setfsuid16
                [0x8b,  'setfsgid', ['old_gid_t gid']], # setfsgid16
                [0x8c,  '_llseek', ['unsigned int fd', 'unsigned long offset_high', 'unsigned long offset_low', 'loff_t *result', 'unsigned int whence']], # llseek
                [0x8d,  'getdents', ['unsigned int fd', 'struct compat_linux_dirent *dirent', 'unsigned int count']], # compat
                [0x8e,  '_newselect', ['int n', 'compat_ulong_t *inp', 'compat_ulong_t *outp', 'compat_ulong_t *exp', 'struct old_timeval32 *tvp']], # compat select
                [0x8f,  'flock', ['unsigned int fd', 'unsigned int cmd']],
                [0x90,  'msync', ['unsigned long start', 'size_t len', 'int flags']],
                [0x91,  'readv', ['compat_ulong_t fd', 'const struct compat_iovec *vec', 'compat_ulong_t vlen']], # compat
                [0x92,  'writev', ['compat_ulong_t fd', 'const struct compat_iovec *vec', 'compat_ulong_t vlen']], # compat
                [0x93,  'getsid', ['pid_t pid']],
                [0x94,  'fdatasync', ['unsigned int fd']],
                #0x95,  _sysctl # unimplemented
                [0x96,  'mlock', ['unsigned long start', 'size_t len']],
                [0x97,  'munlock', ['unsigned long start', 'size_t len']],
                [0x98,  'mlockall', ['int flags']],
                [0x99,  'munlockall', []],
                [0x9a,  'sched_setparam', ['pid_t pid', 'struct sched_param *param']],
                [0x9b,  'sched_getparam', ['pid_t pid', 'struct sched_param *param']],
                [0x9c,  'sched_setscheduler', ['pid_t pid', 'int policy', 'struct sched_param *param']],
                [0x9d,  'sched_getscheduler', ['pid_t pid']],
                [0x9e,  'sched_yield', []],
                [0x9f,  'sched_get_priority_max', ['int policy']],
                [0xa0,  'sched_get_priority_min', ['int policy']],
                [0xa1,  'sched_rr_get_interval', ['pid_t pid', 'struct old_timespec32 *interval']], # sched_rr_get_interval_time32
                [0xa2,  'nanosleep', ['struct old_timespec32 *rqtp', 'struct old_timespec32 *rmtp']], # nanosleep_time32
                [0xa3,  'mremap', ['unsigned long addr', 'unsigned long old_len', 'unsigned long new_len', 'unsigned long flags', 'unsigned long new_addr']],
                [0xa4,  'setresuid', ['old_uid_t ruid', 'old_uid_t euid', 'old_uid_t suid']], # setresuid16
                [0xa5,  'getresuid', ['old_uid_t *ruidp', 'old_uid_t *euidp', 'old_uid_t *suidp']], # getresuid16
                #0xa6,  vm86 # unimplemented
                #0xa7,  query_module # dereted from kernel 2.6
                [0xa8,  'poll', ['struct pollfd *ufds', 'unsigned int nfds', 'int timeout_msecs']],
                #0xa9,  nfsservctl # deleted from kernel 3.1
                [0xaa,  'setresgid', ['old_gid_t rgid', 'old_gid_t egid', 'old_gid_t sgid']], # setresgid16
                [0xab,  'getresgid', ['old_gid_t *rgidp', 'old_gid_t *egidp', 'old_gid_t *sgidp']], # getresgid16
                [0xac,  'prctl', ['int option', 'unsigned long arg2', 'unsigned long arg3', 'unsigned long arg4', 'unsigned long arg5']],
                [0xad,  'rt_sigreturn', []], # compat
                [0xae,  'rt_sigaction', ['int sig', 'const struct compat_sigaction *act', 'struct compat_sigaction *oact', 'compat_size_t sigsetsize']], # compat
                [0xaf,  'rt_sigprocmask', ['int how', 'compat_sigset_t *nset', 'compat_sigset_t *oset', 'compat_size_t sigsetsize']], # compat
                [0xb0,  'rt_sigpending', ['compat_sigset_t *uset', 'compat_size_t sigsetsize']], # compat
                [0xb1,  'rt_sigtimedwait', ['compat_sigset_t *uthese', 'struct compat_siginfo_t *uinfo', 'struct old_timespec32 *uts', 'compat_size_t sigsetsize']], # compat rt_sigtimedwait_time32
                [0xb2,  'rt_sigqueueinfo', ['compat_pid_t pid', 'int sig', 'struct compat_siginfo *uinfo']], # compat
                [0xb3,  'rt_sigsuspend', ['compat_sigset_t *unewset', 'compat_size_t sigsetsize']], # compat
                [0xb4,  'pread64', ['unsigned int fd', 'char *buf', 'size_t count', 'u32 __pad', 'arg_u32p(pos)']], # compat aarch32_pread64
                [0xb5,  'pwrite64', ['unsigned int fd', 'const char *buf', 'size_t count', 'u32 __pad', 'arg_u32p(pos)']], # compat aarch32_pwrite64
                [0xb6,  'chown', ['const char *filename', 'old_uid_t user', 'old_gid_t group']], # chown16
                [0xb7,  'getcwd', ['char *buf', 'unsigned long size']],
                [0xb8,  'capget', ['cap_user_header_t header', 'cap_user_data_t dataptr']],
                [0xb9,  'capset', ['cap_user_header_t header', 'const cap_user_data_t data']],
                [0xba,  'sigaltstack', ['const compat_stack_t *uss_ptr', 'compat_stack_t *uoss_ptr']], # compat
                [0xbb,  'sendfile', ['int out_fd', 'int in_fd', 'compat_off_t *offset', 'compat_size_t count']], # compat
                #0xbc,  reserved
                #0xbd,  reserved
                [0xbe,  'vfork', []],
                [0xbf,  'ugetrlimit', ['unsigned int resource', 'struct compat_rlimit *rlim']], # compat getrlimit
                [0xc0,  'mmap2', ['unsigned long addr', 'unsigned long len', 'unsigned long prot', 'unsigned long flags', 'unsigned long fd', 'unsigned long off_4k']], # compat aarch32_mmap2
                [0xc1,  'truncate64', ['const char *path', 'u32 __pad', 'arg_u32p(length)']], # aarch32_truncate64
                [0xc2,  'ftruncate64', ['unsigned int fd', 'u32 __pad', 'arg_u32p(length)']], # aarch32_ftruncate64
                [0xc3,  'stat64', ['const char *filename', 'struct stat64 *statbuf']],
                [0xc4,  'lstat64', ['const char *filename', 'struct stat64 *statbuf']],
                [0xc5,  'fstat64', ['unsigned long fd', 'struct stat64 *statbuf']],
                [0xc6,  'lchown32', ['const char *filename', 'uid_t user', 'gid_t group']], # lchown
                [0xc7,  'getuid32', []], # getiud
                [0xc8,  'getgid32', []], # getgid
                [0xc9,  'geteuid32', []], # geteuid
                [0xca,  'getegid32', []], # getegid
                [0xcb,  'setreuid32', ['uid_t ruid', 'uid_t euid']], # setreuid
                [0xcc,  'setregid32', ['gid_t rgid', 'gid_t egid']], # setregid
                [0xcd,  'getgroups32', ['int gidsetsize', 'gid_t *grouplist']], # getgroups
                [0xce,  'setgroups32', ['int gidsetsize', 'gid_t *grouplist']], # setgroups
                [0xcf,  'fchown32', ['unsigned int fd', 'uid_t user', 'gid_t group']], # fchown
                [0xd0,  'setresuid32', ['uid_t ruid', 'uid_t euid', 'uid_t suid']], # setresuid
                [0xd1,  'getresuid32', ['uid_t *ruidp', 'uid_t *euidp', 'uid_t *suidp']], # getresuid
                [0xd2,  'setresgid32', ['gid_t rgid', 'gid_t egid', 'gid_t sgid']], # setresgid
                [0xd3,  'getresgid32', ['gid_t *rgidp', 'gid_t *egidp', 'gid_t *sgidp']], # getresgid
                [0xd4,  'chown32', ['const char *filename', 'uid_t user', 'gid_t group']], # chown
                [0xd5,  'setuid32', ['uid_t uid']], # setuid
                [0xd6,  'setgid32', ['gid_t gid']], # setgid
                [0xd7,  'setfsuid32', ['uid_t uid']], # setfsuid
                [0xd8,  'setfsgid32', ['gid_t gid']], # setfsgid
                [0xd9,  'getdents64', ['unsigned int fd', 'struct linux_dirent64 *dirent', 'unsigned int count']],
                [0xda,  'pivot_root', ['const char *new_root', 'const char *put_old']],
                [0xdb,  'mincore', ['unsigned long start', 'size_t len', 'unsigned char *vec']],
                [0xdc,  'madvise', ['unsigned long start', 'size_t len_in', 'int behavior']],
                [0xdd,  'fcntl64', ['unsigned int fd', 'unsigned int cmd', 'compat_ulong_t arg']], # compat
                #0xde,  tux # unimplemented
                #0xdf,  unused
                [0xe0,  'gettid', []],
                [0xe1,  'readahead', ['int fd', 'u32 __pad', 'arg_u32(offset)', 'size_t count']], # compat aarch32_readahead
                [0xe2,  'setxattr', ['const char *pathname', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0xe3,  'lsetxattr', ['const char *pathname', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0xe4,  'fsetxattr', ['int fd', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0xe5,  'getxattr', ['const char *pathname', 'const char *name', 'void *value', 'size_t size']],
                [0xe6,  'lgetxattr', ['const char *pathname', 'const char *name', 'void *value', 'size_t size']],
                [0xe7,  'fgetxattr', ['int fd', 'const char *name', 'void *value', 'size_t size']],
                [0xe8,  'listxattr', ['const char *pathname', 'char *list', 'size_t size']],
                [0xe9,  'llistxattr', ['const char *pathname', 'char *list', 'size_t size']],
                [0xea,  'flistxattr', ['int fd', 'char *list', 'size_t size']],
                [0xeb,  'removexattr', ['const char *pathname', 'const char *name']],
                [0xec,  'lremovexattr', ['const char *pathname', 'const char *name']],
                [0xed,  'fremovexattr', ['int fd', 'const char *name']],
                [0xee,  'tkill', ['pid_t pid', 'int sig']],
                [0xef,  'sendfile64', ['int out_fd', 'int in_fd', 'loff_t *offset', 'size_t count']],
                [0xf0,  'futex', ['u32 *uaddr', 'int op', 'u32 val', 'struct old_timespec32 *utime', 'u32 *uaddr2', 'u32 val3']], # futex_time32
                [0xf1,  'sched_setaffinity', ['compat_pid_t pid', 'unsigned int len', 'compat_ulong_t *user_mask_ptr']], # compat
                [0xf2,  'sched_getaffinity', ['compat_pid_t pid', 'unsigned int len', 'compat_ulong_t *user_mask_ptr']], # compat
                [0xf3,  'io_setup', ['unsigned nr_events', 'u32 *ctx32p']], # compat
                [0xf4,  'io_destroy', ['aio_context_t ctx']],
                [0xf5,  'io_getevents', ['__u32 ctx_id', '__s32 min_nr', '__s32 nr', 'struct io_event *events', 'struct old_timespec32 *timeout']], # io_getevents_time32
                [0xf6,  'io_submit', ['compat_aio_context_t ctx_id', 'int nr', 'compat_uptr_t *iocbpp']], # compat
                [0xf7,  'io_cancel', ['aio_context_t ctx_id', 'struct iocb *iocb', 'struct io_event *result']],
                [0xf8,  'exit_group', ['int error_code']],
                [0xf9,  'lookup_dcookie', ['u32 w0', 'u32 w1', 'char *buf', 'compat_size_t len']], # compat
                [0xfa,  'epoll_create', ['int size']],
                [0xfb,  'epoll_ctl', ['int epfd', 'int op', 'int fd', 'struct epoll_event *event']],
                [0xfc,  'epoll_wait', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'int timeout']],
                [0xfd,  'remap_file_pages', ['unsigned long start', 'unsigned long size', 'unsigned long prot', 'unsigned long pgoff', 'unsigned long flags']],
                #0xfe,  set_thread_area # unimplemented
                #0xff,  get_thread_area # unimplemented
                [0x100, 'set_tid_address', ['int *tidptr']],
                [0x101, 'timer_create', ['clockid_t which_clock', 'struct compat_sigevent *timer_event_spec', 'timer_t *created_timer_id']], # compat
                [0x102, 'timer_settime', ['timer_t timer_id', 'int flags', 'struct old_itimerspec32 *new', 'struct old_itimerspec32 *old']], # timer_settime32
                [0x103, 'timer_gettime', ['timer_t timer_id', 'struct old_itimerspec32 *setting']], # timer_gettime32
                [0x104, 'timer_getoverrun', ['timer_t timer_id']],
                [0x105, 'timer_delete', ['timer_t timer_id']],
                [0x106, 'clock_settime', ['clockid_t which_clock', 'struct old_timespec32 *tp']], # clock_settime32
                [0x107, 'clock_gettime', ['clockid_t which_clock', 'struct old_timespec32 *tp']], # clock_gettime32
                [0x108, 'clock_getres', ['clockid_t which_clock', 'struct old_timespec32 *tp']], # clock_getres_time32
                [0x109, 'clock_nanosleep', ['clockid_t which_clock', 'int flags', 'struct old_timespec32 *rqtp', 'struct old_timespec32 *rmtp']], # clock_nanosleep_time32
                [0x10a, 'statfs64', ['const char *pathname', 'compat_size_t sz', 'struct compat_statfs64 *buf']], # aarch32_statfs64
                [0x10b, 'fstatfs64', ['unsigned int fd', 'compat_size_t sz', 'struct compat_statfs64 *buf']], # aarch32_fstatfs64
                [0x10c, 'tgkill', ['pid_t tgid', 'pid_t pid', 'int sig']],
                [0x10d, 'utimes', ['const char *filename', 'struct old_timeval32 *t']], # utimes_time32
                [0x10e, 'arm_fadvise64_64', ['int fd', 'int advice', 'arg_u32p(offset)', 'arg_u32p(len)']], # compat aarch32_fadvise64_64
                [0x10f, 'pciconfig_iobase', ['long which', 'unsigned long bus', 'unsigned long devfn']],
                [0x110, 'pciconfig_read', ['unsigned long bus', 'unsigned long dfn', 'unsigned long off', 'unsigned long len', 'void *buf']],
                [0x111, 'pciconfig_write', ['unsigned long bus', 'unsigned long dfn', 'unsigned long off', 'unsigned long len', 'void *buf']],
                [0x112, 'mq_open', ['const char *u_name', 'int oflag', 'compat_mode_t mode', 'struct compat_mq_attr *u_attr']], # compat
                [0x113, 'mq_unlink', ['const char *u_name']],
                [0x114, 'mq_timedsend', ['mqd_t mqdes', 'const char *u_msg_ptr', 'unsigned int msg_len', 'unsigned int msg_prio', 'const struct old_timespec32 *u_abs_timeout']], # mq_timedsend_time32
                [0x115, 'mq_timedreceive', ['mqd_t mqdes', 'const char *u_msg_ptr', 'unsigned int msg_len', 'unsigned int *msg_prio', 'const struct old_timespec32 *u_abs_timeout']], # mq_timedreceive_time32
                [0x116, 'mq_notify', ['mqd_t mqdes', 'const struct compat_sigevent *u_notification']], # compat
                [0x117, 'mq_getsetattr', ['mqd_t mqdes', 'const struct compat_mq_attr *u_mqstat', 'struct compat_mq_attr *u_omqstat']], # compat
                [0x118, 'waitid', ['int which', 'compat_pid_t pid', 'struct compat_siginfo *infop', 'int options', 'struct compat_rusage *uru']], # compat
                [0x119, 'socket', ['int family', 'int type', 'int protocol']],
                [0x11a, 'bind', ['int fd', 'struct sockaddr *umyaddr', 'int addrlen']],
                [0x11b, 'connect', ['int fd', 'struct sockaddr *uservaddr', 'int addrlen']],
                [0x11c, 'listen', ['int fd', 'int backlog']],
                [0x11d, 'accept', ['int fd', 'struct sockaddr *upeer_sockaddr', 'int *upeer_addrlen']],
                [0x11e, 'getsockname', ['int fd', 'struct sockaddr *usockaddr', 'int *usockaddr_len']],
                [0x11f, 'getpeername', ['int fd', 'struct sockaddr *usockaddr', 'int *usockaddr_len']],
                [0x120, 'socketpair', ['int family', 'int type', 'int protocol', 'int *usockvec']],
                [0x121, 'send', ['int fd', 'void *buff', 'size_t len', 'unsigned int flags']],
                [0x122, 'sendto', ['int fd', 'void *buff', 'size_t len', 'unsigned int flags', 'struct sockaddr *addr', 'int addr_len']],
                [0x123, 'recv', ['int fd', 'void *ubuf', 'compat_size_t size', 'unsigned int flags']], # compat
                [0x124, 'recvfrom', ['int fd', 'void *ubuf', 'compat_size_t size', 'unsigned int flags', 'struct sockaddr *addr', 'int *addr_len']], # compat
                [0x125, 'shutdown', ['int fd', 'int how']],
                [0x126, 'setsockopt', ['int fd', 'int level', 'int optname', 'char *optval', 'int optlen']],
                [0x127, 'getsockopt', ['int fd', 'int level', 'int optname', 'char *optval', 'int *optlen']],
                [0x128, 'sendmsg', ['int fd', 'struct compat_msghdr *msg', 'unsigned int flags']], # compat
                [0x129, 'recvmsg', ['int fd', 'struct compat_msghdr *msg', 'unsigned int flags']], # compat
                [0x12a, 'semop', ['int semid', 'struct sembuf *tsops', 'unsigned nsops']],
                [0x12b, 'semget', ['key_t key', 'int nsems', 'int semflg']],
                [0x12c, 'semctl', ['int semid', 'int semnum', 'int cmd', 'int arg']], # compat old_semctl
                [0x12d, 'msgsnd', ['int msqid', 'struct compat_uptr_t *msgp', 'compat_ssize_t msgsz', 'int msgflg']], # compat
                [0x12e, 'msgrcv', ['int msqid', 'struct compat_uptr_t *msgp', 'compat_ssize_t msgsz', 'compat_long_t msgtyp', 'int msgflg']], # compat
                [0x12f, 'msgget', ['key_t key', 'int msgflg']],
                [0x130, 'msgctl', ['int msqid', 'int cmd', 'void *uptr']], # compat old_msgctl
                [0x131, 'shmat', ['int shmid', 'compat_uptr_t *shmaddr', 'int shmflg']], # compat
                [0x132, 'shmdt', ['char *shmaddr']],
                [0x133, 'shmget', ['key_t key', 'size_t size', 'int shmflg']],
                [0x134, 'shmctl', ['int shmid', 'int cmd', 'void *uptr']], # compat old_shmctl
                [0x135, 'add_key', ['const char *_type', 'const char *_description', 'const void *_payload', 'size_t plen', 'key_serial_t ringid']],
                [0x136, 'request_key', ['const char *_type', 'const char *_description', 'const char *_callout_info', 'key_serial_t destringid']],
                [0x137, 'keyctl', ['u32 option', 'u32 arg2', 'u32 arg3', 'u32 arg4', 'u32 arg5']], # compat
                [0x138, 'semtimedop', ['int semid', 'struct sembuf *tsems', 'unsigned nsops', 'const struct old_timespec32 *timeout']], # semtimedop_time32
                #0x139, vserver # unimplemented
                [0x13a, 'ioprio_set', ['int which', 'int who', 'int ioprio']],
                [0x13b, 'ioprio_get', ['int which', 'int who']],
                [0x13c, 'inotify_init', []],
                [0x13d, 'inotify_add_watch', ['int fd', 'const char *pathname', 'u32 mask']],
                [0x13e, 'inotify_rm_watch', ['int fd', '__s32 wd']],
                [0x13f, 'mbind', ['compat_ulong_t start', 'compat_ulong_t len', 'compat_ulong_t mode', 'compat_ulong_t *nmask', 'compat_ulong_t maxnode', 'compat_ulong_t flags']], # compat
                [0x140, 'get_mempolicy', ['int *policy', 'compat_ulong_t *nmask', 'compat_ulong_t maxnode', 'compat_ulong_t addr', 'compat_ulong_t flags']], # compat
                [0x141, 'set_mempolicy', ['int mode', 'compat_ulong_t *nmask', 'compat_ulong_t maxnode']], # compat
                [0x142, 'openat', ['int dfd', 'const char *filename', 'int flags', 'umode_t mode']], # compat
                [0x143, 'mkdirat', ['int dfd', 'const char *pathname', 'umode_t mode']],
                [0x144, 'mknodat', ['int dfd', 'const char *filename', 'umode_t mode', 'unsigned int dev']],
                [0x145, 'fchownat', ['int dfd', 'const char *filename', 'uid_t user', 'gid_t group', 'int flag']],
                [0x146, 'futimesat', ['unsigned int dfd', 'const char *filename', 'struct old_timeval32 *t']], # futimesat_time32
                [0x147, 'fstatat64', ['int dfd', 'const char *filename', 'struct stat64 *statbuf', 'int flag']],
                [0x148, 'unlinkat', ['int dfd', 'const char *pathname', 'int flag']],
                [0x149, 'renameat', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname']],
                [0x14a, 'linkat', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname', 'int flags']],
                [0x14b, 'symlinkat', ['const char *oldname', 'int newdfd', 'const char *newname']],
                [0x14c, 'readlinkat', ['int dfd', 'const char *pathname', 'char *buf', 'int bufsiz']],
                [0x14d, 'fchmodat', ['int dfd', 'const char *filename', 'umode_t mode']],
                [0x14e, 'faccessat', ['int dfd', 'const char *filename', 'int mode']],
                [0x14f, 'pselect6', ['int n', 'compat_ulong_t *inp', 'compat_ulong_t *outp', 'compat_ulong_t *exp', 'struct old_timespec32 *tsp', 'void *sig']], # compat pselect6_time32
                [0x150, 'ppoll', ['struct pollfd *ufds', 'unsigned int nfds', 'struct old_timespec32 *tsp', 'const compat_sigset_t *sigmask', 'compat_size_t sigsetsize']], # compat ppoll_time32
                [0x151, 'unshare', ['unsigned long unshare_flags']],
                [0x152, 'set_robust_list', ['struct compat_robust_list_head *head', 'compat_size_t len']], # compat,
                [0x153, 'get_robust_list', ['int pid', 'compat_uptr_t *head_ptr', 'compat_size_t *len_ptr']], # compat
                [0x154, 'splice', ['int fd_in', 'loff_t *off_in', 'int fd_out', 'loff_t *off_out', 'size_t len', 'unsigned int flags']],
                [0x155, 'sync_file_range2', ['int fd', 'unsigned int flags', 'arg_u32p(offset)', 'arg_u32p(nbytes)']], # compat aarch32_sync_file_range2
                [0x156, 'tee', ['int fdin', 'int fdout', 'size_t len', 'unsigned int flags']],
                [0x157, 'vmsplice', ['int fd', 'const struct compat_iovec *iov32', 'unsigned int nr_segs', 'unsigned int flags']], # compat
                [0x158, 'move_pages', ['pid_t pid', 'compat_ulong_t nr_pages', 'compat_uptr_t *pages32', 'const int *nodes', 'int *status', 'int flags']], # compat
                [0x159, 'getcpu', ['unsigned *cpup', 'unsigned *nodep', 'struct getcpu_cache *unused']],
                [0x15a, 'epoll_pwait', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'int timeout', 'const compat_sigset_t *sigmask', 'compat_size_t sigsetsize']], # compat
                [0x15b, 'kexec_load', ['compat_ulong_t entry', 'compat_ulong_t nr_segments', 'struct compat_kexec_segment *segments', 'compat_ulong_t flags']], # compat
                [0x15c, 'utimensat', ['unsigned int dfd', 'const char *filename', 'struct old_timespec32 *t', 'int flags']], # utimensat_time32
                [0x15d, 'signalfd', ['int ufd', 'const compat_sigset_t *user_mask', 'compat_size_t sizemask']], # compat
                [0x15e, 'timerfd_create', ['int clockid', 'int flags']],
                [0x15f, 'eventfd', ['unsigned int count']],
                [0x160, 'fallocate', ['int fd', 'int mode', 'arg_u32p(offset)', 'arg_u32p(len)']], # compat aarch32_fallocate
                [0x161, 'timerfd_settime', ['int ufd', 'int flags', 'const struct old_itimerspec32 *utmr', 'struct old_itimerspec32 *otmr']], # timerfd_settime32
                [0x162, 'timerfd_gettime', ['int ufd', 'struct old_itimerspec32 *otmr']], # timerfd_gettime32
                [0x163, 'signalfd4', ['int ufd', 'const compat_sigset_t *user_mask', 'compat_size_t sizemask', 'int flags']], # compat
                [0x164, 'eventfd2', ['unsigned int count', 'int flags']],
                [0x165, 'epoll_create1', ['int flags']],
                [0x166, 'dup3', ['unsigned int oldfd', 'unsigned int newfd', 'int flags']],
                [0x167, 'pipe2', ['int *fildes', 'int flags']],
                [0x168, 'inotify_init1', ['int flags']],
                [0x169, 'preadv', ['compat_ulong_t fd', 'const struct compat_iovec *vec', 'compat_ulong_t vlen', 'u32 pos_low', 'u32 pos_high']], # compat
                [0x16a, 'pwritev', ['compat_ulong_t fd', 'const struct compat_iovec *vec', 'compat_ulong_t vlen', 'u32 pos_low', 'u32 pos_high']], # compat
                [0x16b, 'rt_tgsigqueueinfo', ['compat_pid_t tgid', 'compat_pid_t pid', 'int sig', 'struct compat_siginfo_t *uinfo']], # compat
                [0x16c, 'perf_event_open', ['struct perf_event_attr *attr_uptr', 'pid_t pid', 'int cpu', 'int group_fd', 'unsigned long flags']],
                [0x16d, 'recvmmsg', ['int fd', 'struct compat_mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags', 'struct old_timespec32 *timeout']], # compat recvmmsg_time32
                [0x16e, 'accept4', ['int fd', 'struct sockaddr *upeer_sockaddr', 'int *upeer_addrlen', 'int flags']],
                [0x16f, 'fanotify_init', ['unsigned int flags', 'unsigned int event_f_flags']],
                [0x170, 'fanotify_mark', ['int fanotify_fd', 'unsigned int flags', '__u32 mask0', '__u32 mask1', 'int dfd', 'const char *pathname']], # compat
                [0x171, 'prlimit64', ['pid_t pid', 'unsigned int resource', 'const struct rlimit64 *new_rlim', 'struct rlimit64 *old_rlim']],
                [0x172, 'name_to_handle_at', ['int dfd', 'const char *name', 'struct file_handle *handle', 'int *mnt_id', 'int flag']],
                [0x173, 'open_by_handle_at', ['int mountdirfd', 'struct file_handle *handle', 'int flags']], # compat
                [0x174, 'clock_adjtime', ['clockid_t which_clock', 'struct old_timex32 *tx']], # clock_adjtime32
                [0x175, 'syncfs', ['int fd']],
                [0x176, 'sendmmsg', ['int fd', 'struct compat_mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags']], # compat
                [0x177, 'setns', ['int fd', 'int flags']],
                [0x178, 'process_vm_readv', ['compat_pid_t pid', 'const struct compat_iovec *lvec', 'compat_ulong_t liovcnt', 'const struct compat_iovec *rvec', 'compat_ulong_t riovcnt', 'compat_ulong_t flags']], # compat
                [0x179, 'process_vm_writev', ['compat_pid_t pid', 'const struct compat_iovec *lvec', 'compat_ulong_t liovcnt', 'const struct compat_iovec *rvec', 'compat_ulong_t riovcnt', 'compat_ulong_t flags']], # compat
                [0x17a, 'kcmp', ['pid_t pid1', 'pid_t pid2', 'int type', 'unsigned long idx1', 'unsigned long idx2']],
                [0x17b, 'finit_module', ['int fd', 'const char *uargs', 'int flags']],
                [0x17c, 'sched_setattr', ['pid_t pid', 'struct sched_attr *uattr', 'unsigned int flags']],
                [0x17d, 'sched_getattr', ['pid_t pid', 'struct sched_attr *uattr', 'unsigned int usize', 'unsigned int flags']],
                [0x17e, 'renameat2', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname', 'unsigned int flags']],
                [0x17f, 'seccomp', ['unsigned int op', 'unsigned int flags', 'void *uargs']],
                [0x180, 'getrandom', ['char *buf', 'size_t count', 'unsigned int flags']],
                [0x181, 'memfd_create', ['const char *uname', 'unsigned int flags']],
                [0x182, 'bpf', ['int cmd', 'union bpf_attr *uattr', 'unsigned int size']],
                [0x183, 'execveat', ['int fd', 'const char *filename', 'const compat_uptr_t *argv', 'const compat_uptr_t *envp', 'int flags']], # compat
                [0x184, 'userfaultfd', ['int flags']],
                [0x185, 'membarrier', ['int cmd', 'int flags']],
                [0x186, 'mlock2', ['unsigned long start', 'size_t len', 'int flags']],
                [0x187, 'copy_file_range', ['int fd_in', 'loff_t *off_in', 'int fd_out', 'loff_t *off_out', 'size_t len', 'unsigned int flags']],
                [0x188, 'preadv2', ['compat_ulong_t fd', 'const struct compat_iovec *vec', 'compat_ulong_t vlen', 'u32 pos_low', 'u32 pos_high']], # compat
                [0x189, 'pwritev2', ['compat_ulong_t fd', 'const struct compat_iovec *vec', 'compat_ulong_t vlen', 'u32 pos_low', 'u32 pos_high']], # compat
                [0x18a, 'pkey_mprotect', ['unsigned long start', 'size_t len', 'unsigned long prot', 'int pkey']],
                [0x18b, 'pkey_alloc', ['unsigned long flags', 'unsigned long init_val']],
                [0x18c, 'pkey_free', ['int pkey']],
                [0x18d, 'statx', ['int dfd', 'const char *filename', 'unsigned flags', 'unsigned int mask', 'struct statx *buffer']],
                [0x18e, 'rseq', ['struct rseq *rseq', 'u32 rseq_len', 'int flags', 'u32 sig']],
                [0x18f, 'io_pgetevents', ['compat_aio_context_t ctx_id', 'compat_long_t min_nr', 'compat_long_t nr', 'struct io_event *events', 'struct old_timespec32 *timeout', 'const struct __compat_aio_sigset *usig']], # compat
                [0x190, 'migrate_pages', ['compat_pid_t pid', 'compat_ulong_t maxnode', 'const compat_ulong_t *old_nodes', 'const compat_ulong_t *new_nodes']], # compat
                [0x191, 'kexec_file_load', ['int kernel_fd', 'int initrd_fd', 'unsigned long cmdline_len', 'const char *cmdline_ptr', 'unsigned long flags']],
                #0x192, unused
                [0x193, 'clock_gettime_time64', ['const clockid_t which_clock', 'const struct __kernel_timespec *tp']], # clock_gettime
                [0x194, 'clock_settime_time64', ['const clockid_t which_clock', 'const struct __kernel_timespec *tp']], # clock_settime
                [0x195, 'clock_adjtime_time64', ['const clockid_t which_clock', 'struct __kernel_timex *utx']], # clock_adjtime
                [0x196, 'clock_getres_time64', ['const clockid_t which_clock', 'struct __kernel_timespec *tp']], # clock_getres
                [0x197, 'clock_nanosleep_time64', ['const clockid_t which_clock', 'int flags', 'const struct __kernel_timespec *rqtp', 'struct __kernel_timespec *rmtp']], # clock_nanosleep
                [0x198, 'timer_gettime_time64', ['timer_t timer_id', 'struct __kernel_itimerspec *setting']], # timer_gettime
                [0x199, 'timer_settime_time64', ['timer_t timer_id', 'int flags', 'const struct __kernel_itimerspec *new_setting', 'struct __kernel_itimerspec *old_setting']], # timer_settime
                [0x19a, 'timerfd_gettime_time64', ['int ufd', 'struct __kernel_itimerspec *otmr']], # timerfd_gettime
                [0x19b, 'timerfd_settime_time64', ['int ufd', 'int flags', 'const struct __kernel_itimerspec *utmr', 'struct __kernel_itimerspec *otmr']], # timerfd_settime
                [0x19c, 'utimensat_time64', ['int dfd', 'const char *filename', 'struct __kernel_timespec *utimes', 'int flags']], # utimensat
                [0x19d, 'pselect6_time64', ['int n', 'compat_ulong_t *inp', 'compat_ulong_t *outp', 'compat_ulong_t *exp', 'struct __kernel_timespec *tsp', 'void *sig']], # compat
                [0x19e, 'ppoll_time64', ['struct pollfd *ufds', 'unsigned int nfds', 'struct __kernel_timespec *tsp', 'const compat_sigset_t *sigmask', 'compat_size_t sigsetsize']], # compat
                #0x19f, unused
                [0x1a0, 'io_pgetevents_time64', ['aio_context_t ctx_id', 'long min_nr', 'long nr', 'struct io_event *events', 'struct __kernel_timespec *timeout', 'const struct __aio_sigset *usig']], # io_pgetevents
                [0x1a1, 'recvmmsg_time64', ['int fd', 'struct compat_mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags', 'struct __kernel_timespec *timeout']], # compat
                [0x1a2, 'mq_timedsend_time64', ['mqd_t mqdes', 'const char *u_msg_ptr', 'size_t msg_len', 'unsigned int msg_prio', 'const struct __kernel_timespec *u_abs_timeout']], # mq_timedsend
                [0x1a3, 'mq_timedreceive_time64', ['mqd_t mqdes', 'const char *u_msg_ptr', 'size_t msg_len', 'unsigned int *u_msg_prio', 'const struct __kernel_timespec *u_abs_timeout']], # mq_timedreceive
                [0x1a4, 'semtimedop_time64', ['int semid', 'struct sembuf *tsops', 'unsigned int nsops', 'const struct __kernel_timespec *timeout']], # semtimedop
                [0x1a5, 'rt_sigtimedwait_time64', ['compat_sigset_t *uthese', 'struct compat_siginfo *uinfo', 'struct __kernel_timespec *uts', 'compat_size_t sigsetsize']], # compat
                [0x1a6, 'futex_time64', ['u32 *uaddr', 'int op', 'u32 val', 'struct __kernel_timespec *utime', 'u32 *uaddr2', 'u32 val3']], # futex
                [0x1a7, 'sched_rr_get_interval_time64', ['pid_t pid', 'struct __kernel_timespec *interval']], # sched_rr_get_interval
                [0x1a8, 'pidfd_send_signal', ['int pidfd', 'int sig', 'siginfo_t *info', 'unsigned int flags']],
                [0x1a9, 'io_uring_setup', ['u32 entries', 'struct io_uring_params *params']],
                [0x1aa, 'io_uring_enter', ['unsigned int fd', 'u32 to_submit', 'u32 min_complete', 'u32 flags', 'const sigset_t *sig', 'size_t sigsz']],
                [0x1ab, 'io_uring_register', ['unsigned int fd', 'unsigned int opcode', 'void *arg', 'unsigned int nr_args']],
                [0x1ac, 'open_tree', ['int dfd', 'const char *filename', 'unsigned flags']],
                [0x1ad, 'move_mount', ['int from_dfd', 'const char *from_pathname', 'int to_dfd', 'const char *to_pathname', 'unsigned int flags']],
                [0x1ae, 'fsopen', ['const char *_fs_name', 'unsigned int flags']],
                [0x1af, 'fsconfig', ['int fd', 'unsigned int cmd', 'const char *_key', 'const void *_value', 'int aux']],
                [0x1b0, 'fsmount', ['int fs_fd', 'unsigned int flags', 'unsigned int attr_flags']],
                [0x1b1, 'fspick', ['int, dfd', 'const char *path', 'unsigned int flags']],
                [0x1b2, 'pidfd_open', ['pid_t pid', 'unsigned int flags']],
                [0x1b3, 'clone3', ['struct clone_args *uargs', 'size_t size']],
                [0x1b4, 'close_range', ['unsigned int fd', 'unsigned int max_fd', 'unsigned int flag']],
                [0x1b5, 'openat2', ['int dfd', 'const char *filename', 'struct open_how *how', 'size_t usize']],
                [0x1b6, 'pidfd_getfd', ['int pidfd', 'int fd', 'unsigned int flags']],
                [0x1b7, 'faccessat2', ['int dfd', 'const char *filename', 'int mode', 'int flags']],
                [0x1b8, 'process_madvise', ['int pidfd', 'const struct iovec *vec', 'size_t vlen', 'int behavior', 'unsigned int flags']],
                [0x1b9, 'epoll_pwait2', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'const struct __kernel_timespec *timeout', 'const compat_sigset_t *sigmask', 'compat_size_t sigsetsize']], # compat
                [0x1ba, 'mount_setattr', ['int dfd', 'const char *path', 'unsigned int flags', 'struct mount_attr *uattr', 'size_t usize']],
                [0x1bb, 'quotactl_fd', ['unsigned int fd', 'unsigned int cmd', 'qid_t id', 'void __user *addr']],
                [0x1bc, 'landlock_create_ruleset', ['const struct landlock_ruleset_attr *const attr', 'const size_t size', 'const __u32 flags']],
                [0x1bd, 'landlock_add_rule', ['const int ruleset_fd', 'const enum landlock_rule_type rule_type', 'const void *const rule_attr', 'const __u32 flags']],
                [0x1be, 'landlock_restrict_self', ['const int ruleset_fd', 'const __u32 flags']],
                [0x1bf, 'memfd_secret', ['unsigned int, flags']],
                [0x1c0, 'process_mrelease', ['int pidfd', 'unsigned int flags']],
                [0x1c1, 'futex_waitv', ['struct futex_waitv *waiters', 'unsigned int nr_futexes', 'unsigned int flags', 'struct __kernel_timespec *timeout', 'clockid_t clockid']],
                [0x1c2, 'set_mempolicy_home_node', ['unsigned long start', 'unsigned long len', 'unsigned long home_node', 'unsigned long flags']],
                [0xf0002, 'cacheflush', ['unsigned long start', 'unsigned long end', 'int flags']], # arch/arm/kernel/traps.c
                [0xf0005, 'set_tls', ['unsigned long val']], # arch/arm/kernel/traps.c
            ]

        elif arch == "ARM" and mode == "N32":
            register_list = ["$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6"]
            # arch/arm/include/asm/unistd.h
            # arch/arm/include/generated/uapi/asm/unistd-common.h
            # arch/arm/include/generated/uapi/asm/unistd-oabi.h
            # arch/arm/include/generated/uapi/asm/unistd-eabi.h
            # arch/arm/tools/syscall.tbl
            syscall_list = [ # EABI
                [0x0,   'restart_syscall', []],
                [0x1,   'exit', ['int error_code']],
                [0x2,   'fork', []],
                [0x3,   'read', ['unsigned int fd', 'char *buf', 'size_t count']],
                [0x4,   'write', ['unsigned int fd', 'const char *buf', 'size_t count']],
                [0x5,   'open', ['const char *filename', 'int flags', 'umode_t mode']],
                [0x6,   'close', ['unsigned int fd']],
                #0x7,   waitpid # unimplemented
                [0x8,   'creat', ['const char *pathname', 'umode_t mode']],
                [0x9,   'link', ['const char *oldname', 'const char *newname']],
                [0xa,   'unlink', ['const char *pathname']],
                [0xb,   'execve', ['const char *filename', 'const char *const *argv', 'const char *const *envp']],
                [0xc,   'chdir', ['const char *filename']],
                #0xd,   time # unimplemented by EABI
                [0xe,   'mknod', ['const char *filename', 'umode_t mode', 'unsigned dev']],
                [0xf,   'chmod', ['const char *filename', 'umode_t mode']],
                [0x10,  'lchown', ['const char *filename', 'old_uid_t user', 'old_gid_t group']], # lchown16
                #0x11,  break # unimplemented
                #0x12,  stat # unimplemented
                [0x13,  'lseek', ['unsigned int fd', 'off_t offset', 'unsigned int whence']],
                [0x14,  'getpid', []],
                [0x15,  'mount', ['char *dev_name', 'char *dir_name', 'char *type', 'unsigned long flags', 'void *data']],
                #0x16,  umount # unimplemented by EABI
                [0x17,  'setuid', ['old_uid_t uid']], # setuid16
                [0x18,  'getuid', []], # getuid16
                #0x19,  stime # unimplemented by EABI
                [0x1a,  'ptrace', ['long request', 'long pid', 'unsigned long addr', 'unsigned long data']],
                #0x1b,  alarm # unimplemented by EABI
                #0x1c,  fstat # unimplemented
                [0x1d,  'pause', []],
                #0x1e,  utime # unimplemented by EABI
                #0x1f,  stty # unimplemented
                #0x20,  gtty # unimplemented
                [0x21,  'access', ['const char *filename', 'int mode']],
                [0x22,  'nice', ['int increment']],
                #0x23,  ftime # unimplemented
                [0x24,  'sync', []],
                [0x25,  'kill', ['pid_t pid', 'int sig']],
                [0x26,  'rename', ['const char *oldname', 'const char *newname']],
                [0x27,  'mkdir', ['const char *pathname', 'umode_t mode']],
                [0x28,  'rmdir', ['const char *pathname']],
                [0x29,  'dup', ['unsigned int fildes']],
                [0x2a,  'pipe', ['int *fildes']],
                [0x2b,  'times', ['struct tms *tbuf']],
                #0x2c,  prof # unimplemented
                [0x2d,  'brk', ['unsigned long brk']],
                [0x2e,  'setgid', ['old_gid_t gid']], # setgid16
                [0x2f,  'getgid', []], # getgid16
                #0x30,  signal # unimplemented
                [0x31,  'geteuid', []], # geteuid16
                [0x32,  'getegid', []], # getegid16
                [0x33,  'acct', ['const char *name']],
                [0x34,  'umount2', ['char *name', 'int flags']], # umount
                #0x35,  lock # unimplemented
                [0x36,  'ioctl', ['unsigned int fd', 'unsigned int cmd', 'unsigned long arg']],
                [0x37,  'fcntl', ['unsigned int fd', 'unsigned int cmd', 'unsigned long arg']],
                #0x38,  mpx # unimplemented
                [0x39,  'setpgid', ['pid_t pid', 'pid_t pgid']],
                #0x3a,  ulimit # unimplemented
                #0x3b,  olduname # unimplemented
                [0x3c,  'umask', ['int mask']],
                [0x3d,  'chroot', ['const char *filename']],
                [0x3e,  'ustat', ['unsigned dev', 'struct ustat *ubuf']],
                [0x3f,  'dup2', ['unsigned int oldfd', 'unsigned int newfd']],
                [0x40,  'getppid', []],
                [0x41,  'getpgrp', []],
                [0x42,  'setsid', []],
                [0x43,  'sigaction', ['int sig', 'const struct old_sigaction *act', 'struct old_sigaction *oact']],
                #0x44,  sgetmask # unimplemented
                #0x45,  ssetmask # unimplemented
                [0x46,  'setreuid', ['old_uid_t ruid', 'old_uid_t euid']], # setreuid16
                [0x47,  'setregid', ['old_gid_t rgid', 'old_gid_t egid']], # setregid16
                [0x48,  'sigsuspend', ['old_sigset_t mask']],
                [0x49,  'sigpending', ['old_sigset_t *uset']],
                [0x4a,  'sethostname', ['char *name', 'int len']],
                [0x4b,  'setrlimit', ['unsigned int resource', 'struct rlimit *rlim']],
                #0x4c,  getrlimit # unimplemented by EABI
                [0x4d,  'getrusage', ['int who', 'struct rusage *ru']],
                [0x4e,  'gettimeofday', ['struct __kernel_old_timeval *tv', 'struct timezone *tz']],
                [0x4f,  'settimeofday', ['struct __kernel_old_timeval *tv', 'struct timezone *tz']],
                [0x50,  'getgroups', ['int gidsetsize', 'old_gid_t *grouplist']], # setgroups16
                [0x51,  'setgroups', ['int gidsetsize', 'old_gid_t *grouplist']], # getgroups16
                #0x52,  select # unimplemented by EABI
                [0x53,  'symlink', ['const char *oldname', 'const char *newname']],
                #0x54,  lstat # unimplemented
                [0x55,  'readlink', ['const char *path', 'char *buf', 'int bufsiz']],
                [0x56,  'uselib', ['const char *library']],
                [0x57,  'swapon', ['const char *specialfile', 'int swap_flags']],
                [0x58,  'reboot', ['int magic1', 'int magic2', 'unsigned int cmd', 'void *arg']],
                #0x59,  readdir # unimplemented by EABI
                #0x5a,  mmap # unimplemented by EABI
                [0x5b,  'munmap', ['unsigned long addr', 'size_t len']],
                [0x5c,  'truncate', ['const char *path', 'long length']],
                [0x5d,  'ftruncate', ['unsigned int fd', 'unsigned long length']],
                [0x5e,  'fchmod', ['unsigned int fd', 'umode_t mode']],
                [0x5f,  'fchown', ['unsigned int fd', 'old_uid_t user', 'old_gid_t group']], # fchown16
                [0x60,  'getpriority', ['int which', 'int who']],
                [0x61,  'setpriority', ['int which', 'int who', 'int niceval']],
                #0x62,  profil # unimplemented
                [0x63,  'statfs', ['const char *pathname', 'struct statfs *buf']],
                [0x64,  'fstatfs', ['unsigned int fd', 'struct statfs *buf']],
                #0x65,  ioperm # unimplemented
                #0x66,  socketcall # unimplemented by EABI
                [0x67,  'syslog', ['int type', 'char *buf', 'int len']],
                [0x68,  'setitimer', ['int which', 'struct __kernel_old_itimerval *value', 'struct __kernel_old_itimerval *ovalue']],
                [0x69,  'getitimer', ['int which', 'struct __kernel_old_itimerval *value']],
                [0x6a,  'stat', ['const char *filename', 'struct stat *statbuf']], # newstat
                [0x6b,  'lstat', ['const char *filename', 'struct stat *statbuf']], # newlstat
                [0x6c,  'fstat', ['unsigned int fd', 'struct stat *statbuf']], # newfstat
                #0x6d,  uname # unimplemented
                #0x6e,  iopl # unimplemented
                [0x6f,  'vhangup', []],
                #0x70,  idle # deleted from kernel 2.3.13
                #0x71,  syscall # unimplemented by EABI (entry point exists at arch/arm/kernel/entry-common.S, but jump to sys_ni_syscall)
                [0x72,  'wait4', ['pid_t upid', 'int *stat_addr', 'int options', 'struct rusage *ru']],
                [0x73,  'swapoff', ['const char *specialfile']],
                [0x74,  'sysinfo', ['struct sysinfo *info']],
                #0x75,  ipc # unimplemented by EABI
                [0x76,  'fsync', ['unsigned int fd']],
                [0x77,  'sigreturn', []], # sigreturn_wrapper # arch/arm/kernel/entry-common.S
                [0x78,  'clone', ['unsigned long clone_flags', 'unsigned long newsp', 'int *parent_tidptr', 'unsigned long tls', 'int *child_tidptr']], # arg4,5 are swapped
                [0x79,  'setdomainname', ['char *name', 'int len']],
                [0x7a,  'uname', ['struct new_utsname *name']], # newuname
                #0x7b,  modify_ldt # unimplemented
                [0x7c,  'adjtimex', ['struct old_timex32 *utp']], # adjtimex_time32
                [0x7d,  'mprotect', ['unsigned long start', 'size_t len', 'unsigned long prot']],
                [0x7e,  'sigprocmask', ['int how', 'old_sigset_t *nset', 'old_sigset_t *oset']],
                #0x7f,  create_module # dereted from kernel 2.6
                [0x80,  'init_module', ['void *umod', 'unsigned long len', 'const char *uargs']],
                [0x81,  'delete_module', ['const char *name_user', 'unsigned int flags']],
                #0x82,  get_kernel_syms # dereted from kernel 2.6
                [0x83,  'quotactl', ['unsigned int cmd', 'const char *special', 'qid_t id', 'void *addr']],
                [0x84,  'getpgid', ['pid_t pid']],
                [0x85,  'fchdir', ['unsigned int fd']],
                [0x86,  'bdflush', ['int func', 'long data']],
                [0x87,  'sysfs', ['int option', 'unsigned long arg1', 'unsigned long arg2']],
                [0x88,  'personality', ['unsigned int personality']],
                #0x89,  afs_syscall # unimplemented
                [0x8a,  'setfsuid', ['old_uid_t uid']], # setfsuid16
                [0x8b,  'setfsgid', ['old_gid_t gid']], # setfsgid16
                [0x8c,  '_llseek', ['unsigned int fd', 'unsigned long offset_high', 'unsigned long offset_low', 'loff_t *result', 'unsigned int whence']], # llseek
                [0x8d,  'getdents', ['unsigned int fd', 'struct linux_dirent *dirent', 'unsigned int count']],
                [0x8e,  '_newselect', ['int n', 'fd_set *inp', 'fd_set *outp', 'fd_set *exp', 'struct __kernel_old_timeval *tvp']], # select
                [0x8f,  'flock', ['unsigned int fd', 'unsigned int cmd']],
                [0x90,  'msync', ['unsigned long start', 'size_t len', 'int flags']],
                [0x91,  'readv', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen']],
                [0x92,  'writev', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen']],
                [0x93,  'getsid', ['pid_t pid']],
                [0x94,  'fdatasync', ['unsigned int fd']],
                #0x95,  _sysctl # unimplemented
                [0x96,  'mlock', ['unsigned long start', 'size_t len']],
                [0x97,  'munlock', ['unsigned long start', 'size_t len']],
                [0x98,  'mlockall', ['int flags']],
                [0x99,  'munlockall', []],
                [0x9a,  'sched_setparam', ['pid_t pid', 'struct sched_param *param']],
                [0x9b,  'sched_getparam', ['pid_t pid', 'struct sched_param *param']],
                [0x9c,  'sched_setscheduler', ['pid_t pid', 'int policy', 'struct sched_param *param']],
                [0x9d,  'sched_getscheduler', ['pid_t pid']],
                [0x9e,  'sched_yield', []],
                [0x9f,  'sched_get_priority_max', ['int policy']],
                [0xa0,  'sched_get_priority_min', ['int policy']],
                [0xa1,  'sched_rr_get_interval', ['pid_t pid', 'struct old_timespec32 *interval']], # sched_rr_get_interval_time32
                [0xa2,  'nanosleep', ['struct old_timespec32 *rqtp', 'struct old_timespec32 *rmtp']], # nanosleep_time32
                [0xa3,  'mremap', ['unsigned long addr', 'unsigned long old_len', 'unsigned long new_len', 'unsigned long flags', 'unsigned long new_addr']],
                [0xa4,  'setresuid', ['old_uid_t ruid', 'old_uid_t euid', 'old_uid_t suid']], # setresuid16
                [0xa5,  'getresuid', ['old_uid_t *ruidp', 'old_uid_t *euidp', 'old_uid_t *suidp']], # getresuid16
                #0xa6,  vm86 # unimplemented
                #0xa7,  query_module # dereted from kernel 2.6
                [0xa8,  'poll', ['struct pollfd *ufds', 'unsigned int nfds', 'int timeout_msecs']],
                #0xa9,  nfsservctl # deleted from kernel 3.1
                [0xaa,  'setresgid', ['old_gid_t rgid', 'old_gid_t egid', 'old_gid_t sgid']], # setresgid16
                [0xab,  'getresgid', ['old_gid_t *rgidp', 'old_gid_t *egidp', 'old_gid_t *sgidp']], # getresgid16
                [0xac,  'prctl', ['int option', 'unsigned long arg2', 'unsigned long arg3', 'unsigned long arg4', 'unsigned long arg5']],
                [0xad,  'rt_sigreturn', []], # rt_sigreturn_wrapper # arch/arm/kernel/entry-common.S
                [0xae,  'rt_sigaction', ['int sig', 'const struct sigaction *act', 'struct sigaction *oact', 'size_t sigsetsize']],
                [0xaf,  'rt_sigprocmask', ['int how', 'sigset_t *nset', 'sigset_t *oset', 'size_t sigsetsize']],
                [0xb0,  'rt_sigpending', ['sigset_t *uset', 'size_t sigsetsize']],
                [0xb1,  'rt_sigtimedwait', ['const sigset_t *uthese', 'siginfo_t *uinfo', 'const struct old_timespec32 *uts', 'size_t sigsetsize']], # sigtimedwait_time32
                [0xb2,  'rt_sigqueueinfo', ['pid_t pid', 'int sig', 'siginfo_t *uinfo']],
                [0xb3,  'rt_sigsuspend', ['sigset_t *unewset', 'size_t sigsetsize']],
                [0xb4,  'pread64', ['unsigned int fd', 'char *buf', 'size_t count', 'loff_t pos']],
                [0xb5,  'pwrite64', ['unsigned int fd', 'const char *buf', 'size_t count', 'loff_t pos']],
                [0xb6,  'chown', ['const char *filename', 'old_uid_t user', 'old_gid_t group']], # chown16
                [0xb7,  'getcwd', ['char *buf', 'unsigned long size']],
                [0xb8,  'capget', ['cap_user_header_t header', 'cap_user_data_t dataptr']],
                [0xb9,  'capset', ['cap_user_header_t header', 'const cap_user_data_t data']],
                [0xba,  'sigaltstack', ['const stack_t *uss', 'stack_t *uoss']],
                [0xbb,  'sendfile', ['int out_fd', 'int in_fd', 'off_t *offset', 'size_t count']],
                #0xbc,  reserved
                #0xbd,  reserved
                [0xbe,  'vfork', []],
                [0xbf,  'ugetrlimit', ['unsigned int resource', 'struct rlimit *rlim']], # getrlimit
                [0xc0,  'mmap2', ['unsigned long addr', 'unsigned long len', 'unsigned long prot', 'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff']], # arch/arm/kernel/entry-common.S
                [0xc1,  'truncate64', ['const char *path', 'loff_t length']],
                [0xc2,  'ftruncate64', ['unsigned int fd', 'loff_t length']],
                [0xc3,  'stat64', ['const char *filename', 'struct stat64 *statbuf']],
                [0xc4,  'lstat64', ['const char *filename', 'struct stat64 *statbuf']],
                [0xc5,  'fstat64', ['unsigned long fd', 'struct stat64 *statbuf']],
                [0xc6,  'lchown32', ['const char *filename', 'uid_t user', 'gid_t group']], # lchown
                [0xc7,  'getuid32', []], # getiud
                [0xc8,  'getgid32', []], # getgid
                [0xc9,  'geteuid32', []], # geteuid
                [0xca,  'getegid32', []], # getegid
                [0xcb,  'setreuid32', ['uid_t ruid', 'uid_t euid']], # setreuid
                [0xcc,  'setregid32', ['gid_t rgid', 'gid_t egid']], # setregid
                [0xcd,  'getgroups32', ['int gidsetsize', 'gid_t *grouplist']], # getgroups
                [0xce,  'setgroups32', ['int gidsetsize', 'gid_t *grouplist']], # setgroups
                [0xcf,  'fchown32', ['unsigned int fd', 'uid_t user', 'gid_t group']], # fchown
                [0xd0,  'setresuid32', ['uid_t ruid', 'uid_t euid', 'uid_t suid']], # setresuid
                [0xd1,  'getresuid32', ['uid_t *ruidp', 'uid_t *euidp', 'uid_t *suidp']], # getresuid
                [0xd2,  'setresgid32', ['gid_t rgid', 'gid_t egid', 'gid_t sgid']], # setresgid
                [0xd3,  'getresgid32', ['gid_t *rgidp', 'gid_t *egidp', 'gid_t *sgidp']], # getresgid
                [0xd4,  'chown32', ['const char *filename', 'uid_t user', 'gid_t group']], # chown
                [0xd5,  'setuid32', ['uid_t uid']], # setuid
                [0xd6,  'setgid32', ['gid_t gid']], # setgid
                [0xd7,  'setfsuid32', ['uid_t uid']], # setfsuid
                [0xd8,  'setfsgid32', ['gid_t gid']], # setfsgid
                [0xd9,  'getdents64', ['unsigned int fd', 'struct linux_dirent64 *dirent', 'unsigned int count']],
                [0xda,  'pivot_root', ['const char *new_root', 'const char *put_old']],
                [0xdb,  'mincore', ['unsigned long start', 'size_t len', 'unsigned char *vec']],
                [0xdc,  'madvise', ['unsigned long start', 'size_t len_in', 'int behavior']],
                [0xdd,  'fcntl64', ['unsigned int fd', 'unsigned int cmd', 'unsigned long arg']],
                #0xde,  tux # unimplemented
                #0xdf,  unused
                [0xe0,  'gettid', []],
                [0xe1,  'readahead', ['int fd', 'loff_t offset', 'size_t count']],
                [0xe2,  'setxattr', ['const char *pathname', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0xe3,  'lsetxattr', ['const char *pathname', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0xe4,  'fsetxattr', ['int fd', 'const char *name', 'const void *value', 'size_t size', 'int flags']],
                [0xe5,  'getxattr', ['const char *pathname', 'const char *name', 'void *value', 'size_t size']],
                [0xe6,  'lgetxattr', ['const char *pathname', 'const char *name', 'void *value', 'size_t size']],
                [0xe7,  'fgetxattr', ['int fd', 'const char *name', 'void *value', 'size_t size']],
                [0xe8,  'listxattr', ['const char *pathname', 'char *list', 'size_t size']],
                [0xe9,  'llistxattr', ['const char *pathname', 'char *list', 'size_t size']],
                [0xea,  'flistxattr', ['int fd', 'char *list', 'size_t size']],
                [0xeb,  'removexattr', ['const char *pathname', 'const char *name']],
                [0xec,  'lremovexattr', ['const char *pathname', 'const char *name']],
                [0xed,  'fremovexattr', ['int fd', 'const char *name']],
                [0xee,  'tkill', ['pid_t pid', 'int sig']],
                [0xef,  'sendfile64', ['int out_fd', 'int in_fd', 'loff_t *offset', 'size_t count']],
                [0xf0,  'futex', ['u32 *uaddr', 'int op', 'u32 val', 'struct old_timespec32 *utime', 'u32 *uaddr2', 'u32 val3']], # futex_time32
                [0xf1,  'sched_setaffinity', ['pid_t pid', 'unsigned int len', 'unsigned long *user_mask_ptr']],
                [0xf2,  'sched_getaffinity', ['pid_t pid', 'unsigned int len', 'unsigned long *user_mask_ptr']],
                [0xf3,  'io_setup', ['unsigned nr_events', 'aio_context_t *ctxp']],
                [0xf4,  'io_destroy', ['aio_context_t ctx']],
                [0xf5,  'io_getevents', ['__u32 ctx_id', '__s32 min_nr', '__s32 nr', 'struct io_event *events', 'struct old_timespec32 *timeout']], # io_getevents_time32
                [0xf6,  'io_submit', ['aio_context_t ctx_id', 'long nr', 'struct iocb **iocbpp']],
                [0xf7,  'io_cancel', ['aio_context_t ctx_id', 'struct iocb *iocb', 'struct io_event *result']],
                [0xf8,  'exit_group', ['int error_code']],
                [0xf9,  'lookup_dcookie', ['u64 cookie64', 'char *buf', 'size_t len']],
                [0xfa,  'epoll_create', ['int size']],
                [0xfb,  'epoll_ctl', ['int epfd', 'int op', 'int fd', 'struct epoll_event *event']],
                [0xfc,  'epoll_wait', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'int timeout']],
                [0xfd,  'remap_file_pages', ['unsigned long start', 'unsigned long size', 'unsigned long prot', 'unsigned long pgoff', 'unsigned long flags']],
                #0xfe,  set_thread_area # unimplemented
                #0xff,  get_thread_area # unimplemented
                [0x100, 'set_tid_address', ['int *tidptr']],
                [0x101, 'timer_create', ['clockid_t which_clock', 'struct sigevent *timer_event_spec', 'timer_t *created_timer_id']],
                [0x102, 'timer_settime', ['timer_t timer_id', 'int flags', 'struct old_itimerspec32 *new', 'struct old_itimerspec32 *old']], # timer_settime32
                [0x103, 'timer_gettime', ['timer_t timer_id', 'struct old_itimerspec32 *setting']], # timer_gettime32
                [0x104, 'timer_getoverrun', ['timer_t timer_id']],
                [0x105, 'timer_delete', ['timer_t timer_id']],
                [0x106, 'clock_settime', ['clockid_t which_clock', 'struct old_timespec32 *tp']], # clock_settime32
                [0x107, 'clock_gettime', ['clockid_t which_clock', 'struct old_timespec32 *tp']], # clock_gettime32
                [0x108, 'clock_getres', ['clockid_t which_clock', 'struct old_timespec32 *tp']], # clock_getres_time32
                [0x109, 'clock_nanosleep', ['clockid_t which_clock', 'int flags', 'struct old_timespec32 *rqtp', 'struct old_timespec32 *rmtp']], # clock_nanosleep_time32
                [0x10a, 'statfs64', ['const char *path', 'size_t sz', 'struct statfs64 *buf']], # statfs64_wrapper # arch/arm/kernel/entry-common.S
                [0x10b, 'fstatfs64', ['unsigned int fd', 'size_t sz', 'struct statfs64 *buf']], # fstatfs64_wrapper # arch/arm/kernel/entry-common.S
                [0x10c, 'tgkill', ['pid_t tgid', 'pid_t pid', 'int sig']],
                [0x10d, 'utimes', ['const char *filename', 'struct old_timeval32 *t']], # utimes_time32
                [0x10e, 'arm_fadvise64_64', ['int fd', 'int advice', 'loff_t offset', 'loff_t len']], # arch/arm/kernel/sys_arm.c
                [0x10f, 'pciconfig_iobase', ['long which', 'unsigned long bus', 'unsigned long devfn']],
                [0x110, 'pciconfig_read', ['unsigned long bus', 'unsigned long dfn', 'unsigned long off', 'unsigned long len', 'void *buf']],
                [0x111, 'pciconfig_write', ['unsigned long bus', 'unsigned long dfn', 'unsigned long off', 'unsigned long len', 'void *buf']],
                [0x112, 'mq_open', ['const char *u_name', 'int oflag', 'umode_t mode', 'struct mq_attr *u_attr']],
                [0x113, 'mq_unlink', ['const char *u_name']],
                [0x114, 'mq_timedsend', ['mqd_t mqdes', 'const char *u_msg_ptr', 'unsigned int msg_len', 'unsigned int msg_prio', 'const struct old_timespec32 *u_abs_timeout']], # mq_timedsend_time32
                [0x115, 'mq_timedreceive', ['mqd_t mqdes', 'const char *u_msg_ptr', 'unsigned int msg_len', 'unsigned int *msg_prio', 'const struct old_timespec32 *u_abs_timeout']], # mq_timedreceive_time32
                [0x116, 'mq_notify', ['mqd_t mqdes', 'const struct sigevent *u_notification']],
                [0x117, 'mq_getsetattr', ['mqd_t mqdes', 'const struct mq_attr *u_mqstat', 'struct mq_attr *u_omqstat']],
                [0x118, 'waitid', ['int which', 'pid_t upid', 'struct siginfo *infop', 'int options', 'struct rusage *ru']],
                [0x119, 'socket', ['int family', 'int type', 'int protocol']],
                [0x11a, 'bind', ['int fd', 'struct sockaddr *umyaddr', 'int addrlen']],
                [0x11b, 'connect', ['int fd', 'struct sockaddr *uservaddr', 'int addrlen']],
                [0x11c, 'listen', ['int fd', 'int backlog']],
                [0x11d, 'accept', ['int fd', 'struct sockaddr *upeer_sockaddr', 'int *upeer_addrlen']],
                [0x11e, 'getsockname', ['int fd', 'struct sockaddr *usockaddr', 'int *usockaddr_len']],
                [0x11f, 'getpeername', ['int fd', 'struct sockaddr *usockaddr', 'int *usockaddr_len']],
                [0x120, 'socketpair', ['int family', 'int type', 'int protocol', 'int *usockvec']],
                [0x121, 'send', ['int fd', 'void *buff', 'size_t len', 'unsigned int flags']],
                [0x122, 'sendto', ['int fd', 'void *buff', 'size_t len', 'unsigned int flags', 'struct sockaddr *addr', 'int addr_len']],
                [0x123, 'recv', ['int fd', 'void *ubuf', 'size_t size', 'unsigned int flags']],
                [0x124, 'recvfrom', ['int fd', 'void *ubuf', 'size_t size', 'unsigned int flags', 'struct sockaddr *addr', 'int *addr_len']],
                [0x125, 'shutdown', ['int fd', 'int how']],
                [0x126, 'setsockopt', ['int fd', 'int level', 'int optname', 'char *optval', 'int optlen']],
                [0x127, 'getsockopt', ['int fd', 'int level', 'int optname', 'char *optval', 'int *optlen']],
                [0x128, 'sendmsg', ['int fd', 'struct user_msghdr *msg', 'unsigned int flags']],
                [0x129, 'recvmsg', ['int fd', 'struct user_msghdr *msg', 'unsigned int flags']],
                [0x12a, 'semop', ['int semid', 'struct sembuf *tsops', 'unsigned nsops']],
                [0x12b, 'semget', ['key_t key', 'int nsems', 'int semflg']],
                [0x12c, 'semctl', ['int semid', 'int semnum', 'int cmd', 'unsigned long arg']], # old_semctl
                [0x12d, 'msgsnd', ['int msqid', 'struct msgbuf *msgp', 'size_t msgsz', 'int msgflg']],
                [0x12e, 'msgrcv', ['int msqid', 'struct msgbuf *msgp', 'size_t msgsz', 'long msgtyp', 'int msgflg']],
                [0x12f, 'msgget', ['key_t key', 'int msgflg']],
                [0x130, 'msgctl', ['int msqid', 'int cmd', 'struct msqid_ds *buf']], # old_msgctl
                [0x131, 'shmat', ['int shmid', 'char *shmaddr', 'int shmflg']],
                [0x132, 'shmdt', ['char *shmaddr']],
                [0x133, 'shmget', ['key_t key', 'size_t size', 'int shmflg']],
                [0x134, 'shmctl', ['int shmid', 'int cmd', 'struct shmid_ds *buf']], # old_shmctl
                [0x135, 'add_key', ['const char *_type', 'const char *_description', 'const void *_payload', 'size_t plen', 'key_serial_t ringid']],
                [0x136, 'request_key', ['const char *_type', 'const char *_description', 'const char *_callout_info', 'key_serial_t destringid']],
                [0x137, 'keyctl', ['int option', 'unsigned long arg2', 'unsigned long arg3', 'unsigned long arg4', 'unsigned long arg5']],
                [0x138, 'semtimedop', ['int semid', 'struct sembuf *tsems', 'unsigned nsops', 'const struct old_timespec32 *timeout']], # semtimedop_time32
                #0x139, vserver # unimplemented
                [0x13a, 'ioprio_set', ['int which', 'int who', 'int ioprio']],
                [0x13b, 'ioprio_get', ['int which', 'int who']],
                [0x13c, 'inotify_init', []],
                [0x13d, 'inotify_add_watch', ['int fd', 'const char *pathname', 'u32 mask']],
                [0x13e, 'inotify_rm_watch', ['int fd', '__s32 wd']],
                [0x13f, 'mbind', ['unsigned long start', 'unsigned long len', 'unsigned long mode', 'const unsigned long *nmask', 'unsigned long maxnode', 'unsigned int flags']],
                [0x140, 'get_mempolicy', ['int *policy', 'unsigned long *nmask', 'unsigned long maxnode', 'unsigned long addr', 'unsigned long flags']],
                [0x141, 'set_mempolicy', ['int mode', 'const unsigned long *nmask', 'unsigned long maxnode']],
                [0x142, 'openat', ['int dfd', 'const char *filename', 'int flags', 'umode_t mode']],
                [0x143, 'mkdirat', ['int dfd', 'const char *pathname', 'umode_t mode']],
                [0x144, 'mknodat', ['int dfd', 'const char *filename', 'umode_t mode', 'unsigned int dev']],
                [0x145, 'fchownat', ['int dfd', 'const char *filename', 'uid_t user', 'gid_t group', 'int flag']],
                [0x146, 'futimesat', ['unsigned int dfd', 'const char *filename', 'struct old_timeval32 *t']], # futimesat_time32
                [0x147, 'fstatat64', ['int dfd', 'const char *filename', 'struct stat64 *statbuf', 'int flag']],
                [0x148, 'unlinkat', ['int dfd', 'const char *pathname', 'int flag']],
                [0x149, 'renameat', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname']],
                [0x14a, 'linkat', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname', 'int flags']],
                [0x14b, 'symlinkat', ['const char *oldname', 'int newdfd', 'const char *newname']],
                [0x14c, 'readlinkat', ['int dfd', 'const char *pathname', 'char *buf', 'int bufsiz']],
                [0x14d, 'fchmodat', ['int dfd', 'const char *filename', 'umode_t mode']],
                [0x14e, 'faccessat', ['int dfd', 'const char *filename', 'int mode']],
                [0x14f, 'pselect6', ['int n', 'fd_set *inp', 'fd_set *outp', 'fd_set *exp', 'struct old_timespec32 *tsp', 'void *sig']], # pselect6_time32
                [0x150, 'ppoll', ['struct pollfd *ufds', 'unsigned int nfds', 'struct old_timespec32 *tsp', 'const sigset_t *sigmask', 'size_t sigsetsize']],
                [0x151, 'unshare', ['unsigned long unshare_flags']],
                [0x152, 'set_robust_list', ['struct robust_list_head *head', 'size_t len']],
                [0x153, 'get_robust_list', ['int pid', 'struct robust_list_head **head_ptr', 'size_t *len_ptr']],
                [0x154, 'splice', ['int fd_in', 'loff_t *off_in', 'int fd_out', 'loff_t *off_out', 'size_t len', 'unsigned int flags']],
                [0x155, 'sync_file_range2', ['int fd', 'unsigned int flags', 'loff_t offset', 'loff_t nbytes']],
                [0x156, 'tee', ['int fdin', 'int fdout', 'size_t len', 'unsigned int flags']],
                [0x157, 'vmsplice', ['int fd', 'const struct iovec *uiov', 'unsigned long nr_segs', 'unsigned int flags']],
                [0x158, 'move_pages', ['pid_t pid', 'unsigned long nr_pages', 'const void **pages', 'const int *nodes', 'int *status', 'int flags']],
                [0x159, 'getcpu', ['unsigned *cpup', 'unsigned *nodep', 'struct getcpu_cache *unused']],
                [0x15a, 'epoll_pwait', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'int timeout', 'const sigset_t *sigmask', 'size_t sigsetsize']],
                [0x15b, 'kexec_load', ['unsigned long entry', 'unsigned long nr_segments', 'struct kexec_segment *segments', 'unsigned long flags']],
                [0x15c, 'utimensat', ['unsigned int dfd', 'const char *filename', 'struct old_timespec32 *t', 'int flags']], # utimensat_time32
                [0x15d, 'signalfd', ['int ufd', 'sigset_t *user_mask', 'size_t sizemask']],
                [0x15e, 'timerfd_create', ['int clockid', 'int flags']],
                [0x15f, 'eventfd', ['unsigned int count']],
                [0x160, 'fallocate', ['int fd', 'int mode', 'loff_t offset', 'loff_t len']],
                [0x161, 'timerfd_settime', ['int ufd', 'int flags', 'const struct old_itimerspec32 *utmr', 'struct old_itimerspec32 *otmr']], # timerfd_settime32
                [0x162, 'timerfd_gettime', ['int ufd', 'struct old_itimerspec32 *otmr']], # timerfd_gettime32
                [0x163, 'signalfd4', ['int ufd', 'sigset_t *user_mask', 'size_t sizemask', 'int flags']],
                [0x164, 'eventfd2', ['unsigned int count', 'int flags']],
                [0x165, 'epoll_create1', ['int flags']],
                [0x166, 'dup3', ['unsigned int oldfd', 'unsigned int newfd', 'int flags']],
                [0x167, 'pipe2', ['int *fildes', 'int flags']],
                [0x168, 'inotify_init1', ['int flags']],
                [0x169, 'preadv', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen', 'unsigned long pos_l', 'unsigned long pos_h']],
                [0x16a, 'pwritev', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen', 'unsigned long pos_l', 'unsigned long pos_h']],
                [0x16b, 'rt_tgsigqueueinfo', ['pid_t tgid', 'pid_t pid', 'int sig', 'siginfo_t *uinfo']],
                [0x16c, 'perf_event_open', ['struct perf_event_attr *attr_uptr', 'pid_t pid', 'int cpu', 'int group_fd', 'unsigned long flags']],
                [0x16d, 'recvmmsg', ['int fd', 'struct mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags', 'struct old_timespec32 *timeout']], # recvmmsg_time32
                [0x16e, 'accept4', ['int fd', 'struct sockaddr *upeer_sockaddr', 'int *upeer_addrlen', 'int flags']],
                [0x16f, 'fanotify_init', ['unsigned int flags', 'unsigned int event_f_flags']],
                [0x170, 'fanotify_mark', ['int fanotify_fd', 'unsigned int flags', '__u64 mask', 'int dfd', 'const char *pathname']],
                [0x171, 'prlimit64', ['pid_t pid', 'unsigned int resource', 'const struct rlimit64 *new_rlim', 'struct rlimit64 *old_rlim']],
                [0x172, 'name_to_handle_at', ['int dfd', 'const char *name', 'struct file_handle *handle', 'int *mnt_id', 'int flag']],
                [0x173, 'open_by_handle_at', ['int mountdirfd', 'struct file_handle *handle', 'int flags']],
                [0x174, 'clock_adjtime', ['clockid_t which_clock', 'struct old_timex32 *tx']], # clock_adjtime32
                [0x175, 'syncfs', ['int fd']],
                [0x176, 'sendmmsg', ['int fd', 'struct mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags']],
                [0x177, 'setns', ['int fd', 'int flags']],
                [0x178, 'process_vm_readv', ['pid_t pid', 'const struct iovec *lvec', 'unsigned long liovcnt', 'const struct iovec *rvec', 'unsigned long riovcnt', 'unsigned long flags']],
                [0x179, 'process_vm_writev', ['pid_t pid', 'const struct iovec *lvec', 'unsigned long liovcnt', 'const struct iovec *rvec', 'unsigned long riovcnt', 'unsigned long flags']],
                [0x17a, 'kcmp', ['pid_t pid1', 'pid_t pid2', 'int type', 'unsigned long idx1', 'unsigned long idx2']],
                [0x17b, 'finit_module', ['int fd', 'const char *uargs', 'int flags']],
                [0x17c, 'sched_setattr', ['pid_t pid', 'struct sched_attr *uattr', 'unsigned int flags']],
                [0x17d, 'sched_getattr', ['pid_t pid', 'struct sched_attr *uattr', 'unsigned int usize', 'unsigned int flags']],
                [0x17e, 'renameat2', ['int olddfd', 'const char *oldname', 'int newdfd', 'const char *newname', 'unsigned int flags']],
                [0x17f, 'seccomp', ['unsigned int op', 'unsigned int flags', 'void *uargs']],
                [0x180, 'getrandom', ['char *buf', 'size_t count', 'unsigned int flags']],
                [0x181, 'memfd_create', ['const char *uname', 'unsigned int flags']],
                [0x182, 'bpf', ['int cmd', 'union bpf_attr *uattr', 'unsigned int size']],
                [0x183, 'execveat', ['int fd', 'const char *filename', 'const char *const *argv', 'const char *const *envp', 'int flags']],
                [0x184, 'userfaultfd', ['int flags']],
                [0x185, 'membarrier', ['int cmd', 'int flags']],
                [0x186, 'mlock2', ['unsigned long start', 'size_t len', 'int flags']],
                [0x187, 'copy_file_range', ['int fd_in', 'loff_t *off_in', 'int fd_out', 'loff_t *off_out', 'size_t len', 'unsigned int flags']],
                [0x188, 'preadv2', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen', 'unsigned long pos_l', 'unsigned long pos_h', 'rwf_t flags']],
                [0x189, 'pwritev2', ['unsigned long fd', 'const struct iovec *vec', 'unsigned long vlen', 'unsigned long pos_l', 'unsigned long pos_h', 'rwf_t flags']],
                [0x18a, 'pkey_mprotect', ['unsigned long start', 'size_t len', 'unsigned long prot', 'int pkey']],
                [0x18b, 'pkey_alloc', ['unsigned long flags', 'unsigned long init_val']],
                [0x18c, 'pkey_free', ['int pkey']],
                [0x18d, 'statx', ['int dfd', 'const char *filename', 'unsigned flags', 'unsigned int mask', 'struct statx *buffer']],
                [0x18e, 'rseq', ['struct rseq *rseq', 'u32 rseq_len', 'int flags', 'u32 sig']],
                [0x18f, 'io_pgetevents', ['aio_context_t ctx_id', 'long min_nr', 'long nr', 'struct io_event *events', 'struct old_timespec32 *timeout', 'const struct __aio_sigset *usig']], # io_pgetevents_time32
                [0x190, 'migrate_pages', ['pid_t pid', 'unsigned long maxnode', 'const unsigned long *old_nodes', 'const unsigned long *new_nodes']],
                [0x191, 'kexec_file_load', ['int kernel_fd', 'int initrd_fd', 'unsigned long cmdline_len', 'const char *cmdline_ptr', 'unsigned long flags']],
                #0x192, unused
                [0x193, 'clock_gettime_time64', ['const clockid_t which_clock', 'const struct __kernel_timespec *tp']], # clock_gettime
                [0x194, 'clock_settime_time64', ['const clockid_t which_clock', 'const struct __kernel_timespec *tp']], # clock_settime
                [0x195, 'clock_adjtime_time64', ['const clockid_t which_clock', 'struct __kernel_timex *utx']], # clock_adjtime
                [0x196, 'clock_getres_time64', ['const clockid_t which_clock', 'struct __kernel_timespec *tp']], # clock_getres
                [0x197, 'clock_nanosleep_time64', ['const clockid_t which_clock', 'int flags', 'const struct __kernel_timespec *rqtp', 'struct __kernel_timespec *rmtp']], # clock_nanosleep
                [0x198, 'timer_gettime_time64', ['timer_t timer_id', 'struct __kernel_itimerspec *setting']], # timer_gettime
                [0x199, 'timer_settime_time64', ['timer_t timer_id', 'int flags', 'const struct __kernel_itimerspec *new_setting', 'struct __kernel_itimerspec *old_setting']], # timer_settime
                [0x19a, 'timerfd_gettime_time64', ['int ufd', 'struct __kernel_itimerspec *otmr']], # timerfd_gettime
                [0x19b, 'timerfd_settime_time64', ['int ufd', 'int flags', 'const struct __kernel_itimerspec *utmr', 'struct __kernel_itimerspec *otmr']], # timerfd_settime
                [0x19c, 'utimensat_time64', ['int dfd', 'const char *filename', 'struct __kernel_timespec *utimes', 'int flags']], # utimensat
                [0x19d, 'pselect6_time64', ['int n', 'fd_set *inp', 'fd_set *outp', 'fd_set *exp', 'struct __kernel_timespec *tsp', 'void *sig']], # pselect6
                [0x19e, 'ppoll_time64', ['struct pollfd *ufds', 'unsigned int nfds', 'struct __kernel_timespec *tsp', 'const sigset_t *sigmask', 'size_t sigsetsize']], # ppoll
                #0x19f, unused
                [0x1a0, 'io_pgetevents_time64', ['aio_context_t ctx_id', 'long min_nr', 'long nr', 'struct io_event *events', 'struct __kernel_timespec *timeout', 'const struct __aio_sigset *usig']], # io_pgetevents
                [0x1a1, 'recvmmsg_time64', ['int fd', 'struct mmsghdr *mmsg', 'unsigned int vlen', 'unsigned int flags', 'struct __kernel_timespec *timeout']], # recvmmsg
                [0x1a2, 'mq_timedsend_time64', ['mqd_t mqdes', 'const char *u_msg_ptr', 'size_t msg_len', 'unsigned int msg_prio', 'const struct __kernel_timespec *u_abs_timeout']], # mq_timedsend
                [0x1a3, 'mq_timedreceive_time64', ['mqd_t mqdes', 'const char *u_msg_ptr', 'size_t msg_len', 'unsigned int *u_msg_prio', 'const struct __kernel_timespec *u_abs_timeout']], # mq_timedreceive
                [0x1a4, 'semtimedop_time64', ['int semid', 'struct sembuf *tsops', 'unsigned int nsops', 'const struct __kernel_timespec *timeout']], # semtimedop
                [0x1a5, 'rt_sigtimedwait_time64', ['const sigset_t *uthese', 'siginfo *uinfo', 'struct struct __kernel_timespec *uts', 'size_t sigsetsize']], # rt_sigtimedwait
                [0x1a6, 'futex_time64', ['u32 *uaddr', 'int op', 'u32 val', 'struct __kernel_timespec *utime', 'u32 *uaddr2', 'u32 val3']], # futex
                [0x1a7, 'sched_rr_get_interval_time64', ['pid_t pid', 'struct __kernel_timespec *interval']], # sched_rr_get_interval
                [0x1a8, 'pidfd_send_signal', ['int pidfd', 'int sig', 'siginfo_t *info', 'unsigned int flags']],
                [0x1a9, 'io_uring_setup', ['u32 entries', 'struct io_uring_params *params']],
                [0x1aa, 'io_uring_enter', ['unsigned int fd', 'u32 to_submit', 'u32 min_complete', 'u32 flags', 'const sigset_t *sig', 'size_t sigsz']],
                [0x1ab, 'io_uring_register', ['unsigned int fd', 'unsigned int opcode', 'void *arg', 'unsigned int nr_args']],
                [0x1ac, 'open_tree', ['int dfd', 'const char *filename', 'unsigned flags']],
                [0x1ad, 'move_mount', ['int from_dfd', 'const char *from_pathname', 'int to_dfd', 'const char *to_pathname', 'unsigned int flags']],
                [0x1ae, 'fsopen', ['const char *_fs_name', 'unsigned int flags']],
                [0x1af, 'fsconfig', ['int fd', 'unsigned int cmd', 'const char *_key', 'const void *_value', 'int aux']],
                [0x1b0, 'fsmount', ['int fs_fd', 'unsigned int flags', 'unsigned int attr_flags']],
                [0x1b1, 'fspick', ['int, dfd', 'const char *path', 'unsigned int flags']],
                [0x1b2, 'pidfd_open', ['pid_t pid', 'unsigned int flags']],
                [0x1b3, 'clone3', ['struct clone_args *uargs', 'size_t size']],
                [0x1b4, 'close_range', ['unsigned int fd', 'unsigned int max_fd', 'unsigned int flag']],
                [0x1b5, 'openat2', ['int dfd', 'const char *filename', 'struct open_how *how', 'size_t usize']],
                [0x1b6, 'pidfd_getfd', ['int pidfd', 'int fd', 'unsigned int flags']],
                [0x1b7, 'faccessat2', ['int dfd', 'const char *filename', 'int mode', 'int flags']],
                [0x1b8, 'process_madvise', ['int pidfd', 'const struct iovec *vec', 'size_t vlen', 'int behavior', 'unsigned int flags']],
                [0x1b9, 'epoll_pwait2', ['int epfd', 'struct epoll_event *events', 'int maxevents', 'const struct __kernel_timespec *timeout', 'const sigset_t *sigmask', 'size_t sigsetsize']],
                [0x1ba, 'mount_setattr', ['int dfd', 'const char *path', 'unsigned int flags', 'struct mount_attr *uattr', 'size_t usize']],
                [0x1bb, 'quotactl_fd', ['unsigned int fd', 'unsigned int cmd', 'qid_t id', 'void __user *addr']],
                [0x1bc, 'landlock_create_ruleset', ['const struct landlock_ruleset_attr *const attr', 'const size_t size', 'const __u32 flags']],
                [0x1bd, 'landlock_add_rule', ['const int ruleset_fd', 'const enum landlock_rule_type rule_type', 'const void *const rule_attr', 'const __u32 flags']],
                [0x1be, 'landlock_restrict_self', ['const int ruleset_fd', 'const __u32 flags']],
                [0x1bf, 'memfd_secret', ['unsigned int, flags']],
                [0x1c0, 'process_mrelease', ['int pidfd', 'unsigned int flags']],
                [0x1c1, 'futex_waitv', ['struct futex_waitv *waiters', 'unsigned int nr_futexes', 'unsigned int flags', 'struct __kernel_timespec *timeout', 'clockid_t clockid']],
                [0x1c2, 'set_mempolicy_home_node', ['unsigned long start', 'unsigned long len', 'unsigned long home_node', 'unsigned long flags']],
                [0xf0001, 'breakpoint', []], # arch/arm/kernel/traps.c
                [0xf0002, 'cacheflush', ['unsigned long start', 'unsigned long end', 'int flags']], # arch/arm/kernel/traps.c
                [0xf0003, 'usr26', []], # arch/arm/kernel/traps.c
                [0xf0004, 'usr32', []], # arch/arm/kernel/traps.c
                [0xf0005, 'set_tls', ['unsigned long val']], # arch/arm/kernel/traps.c
                [0xf0006, 'get_tls', []], # arch/arm/kernel/traps.c
            ]
            #syscall_list += [ # OABI: obsolete
            #    [0x90000d, 'time', ['old_time32_t *tloc']], # time32
            #    [0x900016, 'umount', ['char *name']], # oldumount
            #    [0x900019, 'stime', ['old_time32_t *tptr']], # stime32
            #    [0x90001b, 'alarm', ['unsigned int seconds']],
            #    [0x90001e, 'utime', ['char *filename', 'struct old_utimbuf32 *t']], # utime32
            #    [0x90004c, 'getrlimit', ['unsigned int resource', 'struct rlimit *rlim']], # old_getrlimit
            #    [0x900052, 'select', ['struct sel_arg_struct *arg']], # old_select
            #    [0x900059, 'readdir', ['unsigned int fd', 'struct old_linux_dirent *dirent', 'unsigned int count']], # old_readdir
            #    [0x90005a, 'mmap', ['struct mmap_arg_struct *arg']], # old_mmap
            #    [0x900066, 'socketcall', ['int call', 'unsigned long *args']], # oabi_socketcall # arch/arm/kernel/sys_oabi-compat.c
            #    [0x900071, 'syscall', ['long number']], # arch/arm/kernel/entry-common.S
            #    [0x900075, 'ipc', ['uint call', 'int first', 'int second', 'int third', 'void *ptr', 'long fifth']], # oabi_ipc # arch/arm/kernel/sys_oabi-compat.c
            #    [0x9000b4, 'pread64', ['unsigned int fd', 'char *buf', 'size_t count', 'loff_t pos']], # oabi_pread64 # arch/arm/kernel/entry-common.S
            #    [0x9000b5, 'pwrite64', ['unsigned int fd', 'const char *buf', 'size_t count', 'loff_t pos']], # oabi_pwrite64 # arch/arm/kernel/entry-common.S
            #    [0x9000c1, 'truncate64', ['const char *path', 'loff_t length']], # oabi_truncate64 # arch/arm/kernel/entry-common.S
            #    [0x9000c2, 'ftruncate64', ['unsigned int fd', 'loff_t length']], # oabi_ftruncate64 # arch/arm/kernel/entry-common.S
            #    [0x9000c3, 'stat64', ['const char *filename', 'struct oldabi_stat64 *statbuf']], # oabi_stat64 # arch/arm/kernel/sys_oabi-compat.c
            #    [0x9000c4, 'lstat64', ['const char *filename', 'struct oldabi_stat64 *statbuf']], # oabi_lstat64 # arch/arm/kernel/sys_oabi-compat.c
            #    [0x9000c5, 'fstat64', ['unsigned long fd', 'struct oldabi_stat64 *statbuf']], # oabi_fstat64 # arch/arm/kernel/sys_oabi-compat.c
            #    [0x9000dd, 'fcntl64', ['unsigned int fd', 'unsigned int cmd', 'unsigned long arg']], # oabi_fcntl64 # arch/arm/kernel/sys_oabi-compat.c
            #    [0x9000e1, 'readahead', ['int fd', 'loff_t offset', 'size_t count']], # oabi_readahead # arch/arm/kernel/entry-common.S
            #    [0x9000fb, 'epoll_ctl', ['int epfd', 'int op', 'int fd', 'struct oabi_epoll_event *event']], # oabi_epoll_ctl # arch/arm/kernel/sys_oabi-compat.c
            #    [0x9000fc, 'epoll_wait', ['int epfd', 'struct oabi_epoll_event *events', 'int maxevents', 'int timeout']], # oabi_epoll_wait # arch/arm/kernel/sys_oabi-compat.c
            #    [0x90011a, 'bind', ['int fd', 'struct sockaddr *addr', 'int addrlen']], # oabi_bind # arch/arm/kernel/sys_oabi-compat.c
            #    [0x90011b, 'connect', ['int fd', 'struct sockaddr *addr', 'int addrlen']], # oabi_connect # arch/arm/kernel/sys_oabi-compat.c
            #    [0x900122, 'sendto', ['int fd', 'void *buff', 'size_t len', 'unsigned int flags', 'struct sockaddr *addr', 'int addrlen']], # oabi_sendto # arch/arm/kernel/sys_oabi-compat.c
            #    [0x900128, 'sendmsg', ['int fd', 'struct user_msghdr *msg', 'unsigned int flags']], # oabi_sendmsg # arch/arm/kernel/sys_oabi-compat.c
            #    [0x90012a, 'semop', ['int semid', 'struct oabi_sembuf *tsops', 'unsigned nsops']], # oabi_semop # arch/arm/kernel/sys_oabi-compat.c
            #    [0x900138, 'semtimedop', ['int semid', 'struct oabi_sembuf *tsops', 'unsigned nsops', 'const struct old_timespec32 *timeout']], # oabi_semtimedop # arch/arm/kernel/sys_oabi-compat.c
            #    [0x900147, 'fstatat64', ['int dfd', 'const char *filename', 'struct oldabi_stat64 *statbuf', 'int flag']], # oabi_fstatat64 # arch/arm/kernel/sys_oabi-compat.c
            #    [0x9f0001, 'breakpoint', []], # arch/arm/kernel/traps.c
            #    [0x9f0002, 'cacheflush', ['unsigned long start', 'unsigned long end', 'int flags']], # arch/arm/kernel/traps.c
            #    [0x9f0003, 'usr26', []], # arch/arm/kernel/traps.c
            #    [0x9f0004, 'usr32', []], # arch/arm/kernel/traps.c
            #    [0x9f0005, 'set_tls', ['unsigned long val']], # arch/arm/kernel/traps.c
            #    [0x9f0006, 'get_tls', []], # arch/arm/kernel/traps.c
            #]
            #name_list = list(zip(*syscall_list))[1]
            #for s in syscall_list[::]:
            #    if name_list.count(s[1]) == 2: # already added
            #        continue
            #    syscall_list += [[s[0]+0x900000, s[1], s[2]]]

        elif arch in ["ARM64", "ARM"] and mode == "S":
            if arch == "ARM64":
                register_list = ["$x0", "$x1", "$x2", "$x3", "$x4", "$x5", "$x6"]
            else:
                register_list = ["$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6"]
            # core/include/tee/tee_svc.h
            # core/include/tee/tee_svc_cryp.h
            # core/include/tee/tee_svc_storage.h
            # core/include/tee/svc_cache.h
            syscall_list = [
                [0x00, 'syscall_sys_return', ['unsigned long ret']],
                [0x01, 'syscall_log', ['const void *buf', 'size_t len']],
                [0x02, 'syscall_panic', ['unsigned long code']],
                [0x03, 'syscall_get_property', ['unsigned long prop_set', 'unsigned long index', 'void *name', 'uint32_t *name_len', 'void *buf', 'uint32_t *blen', 'uint32_t *prop_type']],
                [0x04, 'syscall_get_property_name_to_index', ['unsigned long prop_set', 'void *name', 'unsigned long name_len', 'uint32_t *index']],
                [0x05, 'syscall_open_ta_session', ['const TEE_UUID *dest', 'unsigned long cancel_req_to', 'struct utee_params *params', 'uint32_t *sess', 'uint32_t *ret_orig']],
                [0x06, 'syscall_close_ta_session', ['unsigned long sess']],
                [0x07, 'syscall_invoke_ta_command', ['unsigned long sess', 'unsigned long cancel_req_to', 'unsigned long cmd_id', 'struct utee_params *params', 'uint32_t *ret_orig']],
                [0x08, 'syscall_check_access_rights', ['unsigned long flags', 'const void *buf', 'size_t len']],
                [0x09, 'syscall_get_cancellation_flag', ['uint32_t *cancel', ]],
                [0x0a, 'syscall_unmask_cancellation', ['uint32_t *old_mask']],
                [0x0b, 'syscall_mask_cancellation', ['uint32_t *old_mask']],
                [0x0c, 'syscall_wait', ['unsigned long timeout']],
                [0x0d, 'syscall_get_time', ['unsigned long cat', 'TEE_Time *time']],
                [0x0e, 'syscall_set_ta_time', ['const TEE_Time *time']],
                [0x0f, 'syscall_cryp_state_alloc', ['unsigned long algo', 'unsigned long op_mode', 'unsigned long key1', 'unsigned long key2', 'uint32_t *state']],
                [0x10, 'syscall_cryp_state_copy', ['unsigned long dst', 'unsigned long src']],
                [0x11, 'syscall_cryp_state_free', ['unsigned long state']],
                [0x12, 'syscall_hash_init', ['unsigned long state', 'const void *iv', 'size_t iv_len']],
                [0x13, 'syscall_hash_update', ['unsigned long state', 'const void *chunk', 'size_t chunk_size']],
                [0x14, 'syscall_hash_final', ['unsigned long state', 'const void *chunk', 'size_t chunk_size', 'void *hash', 'uint64_t *hash_len']],
                [0x15, 'syscall_cipher_init', ['unsigned long state', 'const void *iv', 'size_t iv_len']],
                [0x16, 'syscall_cipher_update', ['unsigned long state', 'const void *src', 'size_t src_len', 'void *dest', 'uint64_t *dest_len']],
                [0x17, 'syscall_cipher_final', ['unsigned long state', 'const void *src', 'size_t src_len', 'void *dest', 'uint64_t *dest_len']],
                [0x18, 'syscall_cryp_obj_get_info', ['unsigned long obj', 'TEE_ObjectInfo *info']],
                [0x19, 'syscall_cryp_obj_restrict_usage', ['unsigned long obj', 'unsigned long usage']],
                [0x1a, 'syscall_cryp_obj_get_attr', ['unsigned long obj', 'unsigned long attr_id', 'void *buffer', 'uint64_t *size']],
                [0x1b, 'syscall_cryp_obj_alloc', ['unsigned long obj_type', 'unsigned long max_key_size', 'uint32_t *obj']],
                [0x1c, 'syscall_cryp_obj_close', ['unsigned long obj']],
                [0x1d, 'syscall_cryp_obj_reset', ['unsigned long obj']],
                [0x1e, 'syscall_cryp_obj_populate', ['unsigned long obj', 'struct utee_attribute *attrs', 'unsigned long attr_count']],
                [0x1f, 'syscall_cryp_obj_copy', ['unsigned long dst_obj', 'unsigned long src_obj']],
                [0x20, 'syscall_cryp_derive_key', ['unsigned long state', 'const struct utee_attribute *params', 'unsigned long param_count', 'unsigned long derived_key']],
                [0x21, 'syscall_cryp_random_number_generate', ['void *buf', 'size_t blen']],
                [0x22, 'syscall_authenc_init', ['unsigned long state', 'const void *nonce', 'size_t nonce_len', 'size_t tag_len', 'size_t aad_len', 'size_t payload_len']],
                [0x23, 'syscall_authenc_update_aad', ['unsigned long state', 'const void *aad_data', 'size_t aad_data_len']],
                [0x24, 'syscall_authenc_update_payload', ['unsigned long state', 'const void *src_data', 'size_t src_len', 'void *dest_data', 'uint64_t *dest_len']],
                [0x25, 'syscall_authenc_enc_final', ['unsigned long state', 'const void *src_data', 'size_t src_len', 'void *dest_data', 'uint64_t *dest_len', 'void *tag', 'uint64_t *tag_len']],
                [0x26, 'syscall_authenc_dec_final', ['unsigned long state', 'const void *src_data', 'size_t src_len', 'void *dest_data', 'uint64_t *dest_len', 'const void *tag', 'uint64_t *tag_len']],
                [0x27, 'syscall_asymm_operate', ['unsigned long state', 'const struct utee_attribute *usr_params', 'size_t num_params', 'const void *src_data', 'size_t src_len', 'void *dest_data', 'uint64_t *dest_len']],
                [0x28, 'syscall_asymm_verify', ['unsigned long state', 'const struct utee_attribute *usr_params', 'size_t num_params', 'const void *data', 'size_t data_len', 'const void *sig', 'size_t sig_len']],
                [0x29, 'syscall_storage_obj_open', ['unsigned long storage_id', 'void *object_id', 'size_t object_id_len', 'unsigned long flags', 'uint32_t *obj']],
                [0x2a, 'syscall_storage_obj_create', ['unsigned long storage_id', 'void *object_id', 'size_t object_id_len', 'unsigned long flags', 'unsigned long attr', 'void *data', 'size_t len', 'uint32_t *obj']],
                [0x2b, 'syscall_storage_obj_del', ['unsigned long obj']],
                [0x2c, 'syscall_storage_obj_rename', ['unsigned long obj', 'void *object_id', 'size_t object_id_len']],
                [0x2d, 'syscall_storage_alloc_enum', ['uint32_t *obj_enum']],
                [0x2e, 'syscall_storage_free_enum', ['nsigned long obj_enum']],
                [0x2f, 'syscall_storage_reset_enum', ['unsigned long obj_enum']],
                [0x30, 'syscall_storage_start_enum', ['unsigned long obj_enum', 'unsigned long storage_id']],
                [0x31, 'syscall_storage_next_enum', ['unsigned long obj_enum', 'TEE_ObjectInfo *info', 'void *obj_id', 'uint64_t *len']],
                [0x32, 'syscall_storage_obj_read', ['unsigned long obj', 'void *data', 'size_t len', 'uint64_t *count']],
                [0x33, 'syscall_storage_obj_write', ['unsigned long obj', 'void *data', 'size_t len']],
                [0x34, 'syscall_storage_obj_trunc', ['unsigned long obj, size_t len']],
                [0x35, 'syscall_storage_obj_seek', ['unsigned long obj', 'int32_t offset', 'unsigned long whence']],
                [0x36, 'syscall_obj_generate_key', ['unsigned long obj', 'unsigned long key_size', 'const struct utee_attribute *params', 'unsigned long param_count']],
                [0x37, 'syscall_not_supported', []],
                [0x38, 'syscall_not_supported', []],
                [0x39, 'syscall_not_supported', []],
                [0x3a, 'syscall_not_supported', []],
                [0x3b, 'syscall_not_supported', []],
                [0x3c, 'syscall_not_supported', []],
                [0x3d, 'syscall_not_supported', []],
                [0x3e, 'syscall_not_supported', []],
                [0x3f, 'syscall_not_supported', []],
                [0x40, 'syscall_not_supported', []],
                [0x41, 'syscall_not_supported', []],
                [0x42, 'syscall_not_supported', []],
                [0x43, 'syscall_not_supported', []],
                [0x44, 'syscall_not_supported', []],
                [0x45, 'syscall_not_supported', []],
                [0x46, 'syscall_cache_operation', ['void *va, size_t len', 'unsigned long op']],
            ]
            # ldelf
            # core/include/tee/tee_svc.h
            # core/include/kernel/ldelf_syscalls.h
            #syscall_list += [
            #    [0x00, 'syscall_sys_return', ['unsigned long ret']],
            #    [0x01, 'syscall_log', ['const void *buf', 'size_t len']],
            #    [0x02, 'syscall_panic', ['unsigned long code']],
            #    [0x03, 'ldelf_syscall_map_zi', ['vaddr_t *va', 'size_t num_bytes', 'size_t pad_begin', 'size_t pad_end', 'unsigned long flags']],
            #    [0x04, 'ldelf_syscall_unmap', ['vaddr_t va', 'size_t num_bytes']],
            #    [0x05, 'ldelf_syscall_open_bin', ['const TEE_UUID *uuid', 'size_t uuid_size', 'uint32_t *handle']],
            #    [0x06, 'ldelf_syscall_close_bin', ['unsigned long handle']],
            #    [0x07, 'ldelf_syscall_map_bin', ['vaddr_t *va', 'size_t num_bytes', 'unsigned long handle', 'size_t offs_bytes', 'size_t pad_begin', 'size_t pad_end', 'unsigned long flags']],
            #    [0x08, 'ldelf_syscall_copy_from_bin', ['void *dst', 'size_t offs', 'size_t num_bytes', 'unsigned long handle']],
            #    [0x09, 'ldelf_syscall_set_prot', ['unsigned long va', 'size_t num_bytes', 'unsigned long flags']],
            #    [0x0a, 'ldelf_syscall_remap', ['unsigned long old_va', 'addr_t *new_va', 'size_t num_bytes', 'size_t pad_begin', 'size_t pad_end']],
            #    [0x0b, 'ldelf_syscall_gen_rnd_num', ['void *buf', 'size_t num_bytes']],
            #]

        else:
            raise

        syscall_table = {}
        for nr, name, args in syscall_list:
            args = list(zip(register_list[:len(args)], args))
            syscall_table[nr] = Entry(name, [Param(*p) for p in args])
        return syscall_table


@lru_cache()
def get_section_base_address(name):
    section = process_lookup_path(name)
    if section:
        return section.page_start
    # Fail, retry with real path
    section = process_lookup_path(os.path.realpath(name))
    if section:
        return section.page_start
    return None


def get_section_base_address_by_list(names):
    for name in names:
        page_start = get_section_base_address(name)
        if page_start is not None:
            return page_start
    return None


@lru_cache()
def get_zone_base_address(name):
    zone = file_lookup_name_path(name, get_filepath())
    if zone:
        return zone.zone_start
    return None


@register_command
class SmartCppFunctionNameCommand(GenericCommand):
    """Toggle the setting of `config context.smart_cpp_function_name`"""
    _cmdline_ = "smart-cpp-function-name"
    _syntax_ = "{:s}".format(_cmdline_)
    _category_ = "Misc"

    def do_invoke(self, argv):
        self.dont_repeat()
        setting = gdb.execute("gef config context.smart_cpp_function_name", to_string=True)
        if "False" in setting:
            gdb.execute("gef config context.smart_cpp_function_name true", to_string=True)
        else:
            gdb.execute("gef config context.smart_cpp_function_name false", to_string=True)
        return


@register_command
class FollowCommand(GenericCommand):
    """View/modify the follow-fork-mode setting of GDB. By default, GDB will follow parent when it starts the process.
    This command allows to change that setting."""
    _cmdline_ = "follow"
    _syntax_ = "{:s} (child|parent)".format(_cmdline_)
    _category_ = "Misc"

    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        argc = len(argv)

        if argc == 0:
            ret = gdb.execute("show follow-fork-mode", to_string=True)
            i = ret.find("\"child\"")
            if i >= 0:
                msg = "follow " + Color.redify("Child")
            else:
                msg = "follow " + Color.redify("Parent")
            gef_print(msg)
            return

        elif argc == 1:
            if argv[0] == "child":
                info("Follow child")
                gdb.execute("set follow-fork-mode child")
                return
            elif argv[0] == "parent":
                info("Follow parent")
                gdb.execute("set follow-fork-mode parent")
                return
            warn("Invalid command")
        self.usage()
        return


@register_command
class CodebaseCommand(GenericCommand):
    """Show code base address."""
    _cmdline_ = "codebase"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        codebase = get_section_base_address(get_filepath())
        if codebase is None:
            gef_print("codebase not found")
            return
        gef_print(titlify("Code base"))
        gdb.execute(f"set $codebase = {codebase}")
        gef_print(f"$codebase = {codebase:#x}")

        if is_pie(get_filepath()):
            gdb.execute(f"set $piebase = {codebase}")
            gef_print(f"$piebase = {codebase:#x}")
        return


@register_command
class HeapbaseCommand(GenericCommand):
    """Show heap base address."""
    _cmdline_ = "heapbase"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        heap = HeapBaseFunction.heap_base()
        if heap is None:
            gef_print("heap not found")
            return

        gef_print(titlify("Heap base"))
        gdb.execute(f"set $heapbase = {heap}")
        gef_print(f"$heapbase = {heap:#x}")
        return


@register_command
class LibcCommand(GenericCommand):
    """Show `libc.so` base address."""
    _cmdline_ = "libc"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        libc = get_section_base_address_by_list(("libc-2.", "libc.so.6"))
        if libc is None:
            err("libc is not found")
            return
        gef_print(titlify("libc info"))
        gdb.execute(f"set $libc = {libc}")
        gef_print(f"$libc = {libc:#x}")

        libc = process_lookup_path_by_list(("libc-2.", "libc.so.6"))
        gef_print("path:\t" + libc.path)
        data = open(libc.path, "rb").read()

        gef_print("sha512:\t" + hashlib.sha512(data).hexdigest())
        gef_print("sha256:\t" + hashlib.sha256(data).hexdigest())
        gef_print("sha1:\t" + hashlib.sha1(data).hexdigest())
        gef_print("md5:\t" + hashlib.md5(data).hexdigest())

        try:
            strings = which("strings")
        except IOError:
            err("Missing `strings`")
            return
        result = gef_execute_external([strings, "-a", libc.path], as_list=True)
        version = [line for line in result if line.startswith("GNU C Library")]
        gef_print("ver:\t" + version[0])
        return


@register_command
class LdCommand(GenericCommand):
    """Show `ld.so` base address."""
    _cmdline_ = "ld"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        ld = get_section_base_address_by_list(("ld-2.", "ld-linux-"))
        if ld is None:
            gef_print("ld not found")
            return
        gef_print(titlify("ld info"))
        gdb.execute(f"set $ld = {ld}")
        gef_print(f"$ld = {ld:#x}")

        ld = process_lookup_path_by_list(("ld-2.", "ld-linux-"))
        gef_print("path:\t" + ld.path)
        data = open(ld.path, "rb").read()
        gef_print("sha512:\t" + hashlib.sha512(data).hexdigest())
        gef_print("sha256:\t" + hashlib.sha256(data).hexdigest())
        gef_print("sha1:\t" + hashlib.sha1(data).hexdigest())
        gef_print("md5:\t" + hashlib.md5(data).hexdigest())
        return


@register_command
class MagicCommand(GenericCommand):
    """Show Magic addresses / offsets."""
    _cmdline_ = "magic"
    _syntax_ = "{:s} [-h] [FILTER]".format(_cmdline_)
    _category_ = "Exploit Development"

    def should_be_print(self, sym):
        if not self.filter:
            return True

        for filt in self.filter:
            if filt in sym:
                return True
        return False

    def resolve_and_print(self, sym, base):
        def get_permission(addr):
            maps = get_process_maps()
            for m in maps:
                if m.page_start <= addr and addr < m.page_end:
                    return str(m.permission)
            return "???"

        if not self.should_be_print(sym):
            return

        try:
            addr = int(gdb.parse_and_eval(f"&{sym}"))
            perm = get_permission(addr)
            if is_ascii_string(addr):
                val = read_ascii_string(addr)
                gef_print(f"{sym:42s}: {addr:#18x} [{perm:3s}] ({base:#18x} + {addr - base:#10x}) -> {val:>18s}")
            else:
                val = read_int_from_memory(addr)
                val_sym = get_symbol_string(val)
                gef_print(f"{sym:42s}: {addr:#18x} [{perm:3s}] ({base:#18x} + {addr - base:#10x}) -> {val:#18x}{val_sym}")
        except:
            gef_print(f"{sym:42s}: {'Not found':>18s}")
        return

    def magic(self):
        codebase = get_section_base_address(get_filepath())
        libc = get_section_base_address_by_list(("libc-2.", "libc.so.6"))
        ld = get_section_base_address_by_list(("ld-2.", "ld-linux-", "ld-linux.so.2"))
        if libc is None or ld is None:
            gef_print("libc/ld not found")
            return

        gef_print(titlify("Legend"))
        msg = f"{'symbol':42s}: {'addr':>18s} {'perm':5s} ({'base':>18s} + {'offset':>10s}) -> {'val':>18s}"
        gef_print(Color.colorify(msg, get_gef_setting("theme.table_heading")))

        gef_print(titlify("Heap"))
        self.resolve_and_print("main_arena", libc)
        self.resolve_and_print("mp_", libc)
        self.resolve_and_print("__malloc_hook", libc)
        self.resolve_and_print("__free_hook", libc)
        self.resolve_and_print("__realloc_hook", libc)
        self.resolve_and_print("__memalign_hook", libc)
        self.resolve_and_print("__after_morecore_hook", libc)
        self.resolve_and_print("_dl_open_hook", libc)
        self.resolve_and_print("global_max_fast", libc)
        self.resolve_and_print("malloc", libc)
        self.resolve_and_print("free", libc)
        self.resolve_and_print("calloc", libc)
        self.resolve_and_print("realloc", libc)
        gef_print(titlify("I/O"))
        self.resolve_and_print("*stdin", libc)
        self.resolve_and_print("*stdout", libc)
        self.resolve_and_print("*stderr", libc)
        self.resolve_and_print("_IO_list_all", libc)
        self.resolve_and_print("_IO_file_jumps", libc)
        self.resolve_and_print("_IO_file_jumps_mmap", libc)
        self.resolve_and_print("_IO_file_jumps_maybe_mmap", libc)
        self.resolve_and_print("_IO_wfile_jumps", libc)
        self.resolve_and_print("_IO_wfile_jumps_mmap", libc)
        self.resolve_and_print("_IO_wfile_jumps_maybe_mmap", libc)
        self.resolve_and_print("_IO_old_file_jumps", libc)
        self.resolve_and_print("_IO_mem_jumps", libc)
        self.resolve_and_print("_IO_wmem_jumps", libc)
        self.resolve_and_print("_IO_str_jumps", libc)
        self.resolve_and_print("_IO_strn_jumps", libc)
        self.resolve_and_print("_IO_str_chk_jumps", libc)
        self.resolve_and_print("_IO_wstr_jumps", libc)
        self.resolve_and_print("_IO_wstrn_jumps", libc)
        self.resolve_and_print("_IO_streambuf_jumps", libc)
        self.resolve_and_print("_IO_proc_jumps", libc)
        self.resolve_and_print("_IO_old_proc_jumps", libc)
        self.resolve_and_print("_IO_helper_jumps", libc)
        self.resolve_and_print("_IO_cookie_jumps", libc)
        self.resolve_and_print("_IO_obstack_jumps", libc)
        self.resolve_and_print("open", libc)
        self.resolve_and_print("read", libc)
        self.resolve_and_print("write", libc)
        self.resolve_and_print("dup", libc)
        self.resolve_and_print("dup2", libc)
        self.resolve_and_print("dup3", libc)
        self.resolve_and_print("puts", libc)
        self.resolve_and_print("gets", libc)
        self.resolve_and_print("fputs", libc)
        self.resolve_and_print("fgets", libc)
        self.resolve_and_print("printf", libc)
        self.resolve_and_print("fprintf", libc)
        self.resolve_and_print("dprintf", libc)
        self.resolve_and_print("sprintf", libc)
        self.resolve_and_print("snprintf", libc)
        self.resolve_and_print("__printf_chk", libc)
        self.resolve_and_print("__fprintf_chk", libc)
        self.resolve_and_print("__dprintf_chk", libc)
        self.resolve_and_print("__sprintf_chk", libc)
        self.resolve_and_print("__snprintf_chk", libc)
        self.resolve_and_print("__printf_function_table", libc)
        self.resolve_and_print("__printf_arginfo_table", libc)
        self.resolve_and_print("scanf", libc)
        self.resolve_and_print("fscanf", libc)
        self.resolve_and_print("sscanf", libc)
        gef_print(titlify("Process"))
        self.resolve_and_print("system", libc)
        self.resolve_and_print("do_system", libc)
        self.resolve_and_print("execve", libc)
        self.resolve_and_print("setcontext", libc)
        self.resolve_and_print("__libc_start_main", libc)
        self.resolve_and_print("syscall", libc)
        self.resolve_and_print("ptrace", libc)
        self.resolve_and_print("prctl", libc)
        gef_print(titlify("Memory"))
        self.resolve_and_print("mmap", libc)
        self.resolve_and_print("munmap", libc)
        self.resolve_and_print("mremap", libc)
        self.resolve_and_print("mprotect", libc)
        gef_print(titlify("Stack"))
        self.resolve_and_print("__libc_argv", libc)
        self.resolve_and_print("__environ", libc)
        gef_print(titlify("Destructor"))
        self.resolve_and_print("_rtld_global->_dl_rtld_lock_recursive", ld)
        self.resolve_and_print("_rtld_global->_dl_rtld_unlock_recursive", ld)
        gef_print(titlify("Unwind"))
        self.resolve_and_print("'DW.ref.__gxx_personality_v0'", codebase)
        return

    def resolve_and_print_kernel(self, sym, base, maps, external_func=None):
        def get_permission(addr, maps):
            for vaddr, size, perm in maps:
                if vaddr <= addr and addr < vaddr + size:
                    return perm
            return "???"

        if not self.should_be_print(sym):
            return

        try:
            if external_func:
                addr = external_func()
            else:
                if isinstance(sym, str):
                    addr = get_ksymaddr(sym)
                    if addr is None:
                        raise # goto Not found/recognized
                elif isinstance(sym, list):
                    for s in sym:
                        addr = get_ksymaddr(s)
                        if addr:
                            sym = s
                            break
                    else: # Not found
                        sym = sym[0]
                        raise # goto Not found/recognized
            perm = get_permission(addr, maps)
            if is_ascii_string(addr):
                val = read_ascii_string(addr)
                gef_print(f"{sym:42s}: {addr:#18x} [{perm:3s}] ({base:#18x} + {addr - base:#10x}) -> {val:>18s}")
            else:
                val = read_int_from_memory(addr)
                gef_print(f"{sym:42s}: {addr:#18x} [{perm:3s}] ({base:#18x} + {addr - base:#10x}) -> {val:#18x}")
        except:
            gef_print(f"{sym:42s}: {'Not found/recognized':>18s}")
        return

    def magic_kernel(self):
        info("Wait for memory scan")
        maps = KernelbaseCommand.get_maps()
        if maps is None:
            return
        kbase, kbase_size = KernelbaseCommand.get_kernel_base(maps)
        gef_print("{:42s}: {:#x} ({:#x} bytes)".format("kernel_base", kbase, kbase_size))

        gef_print(titlify("Legend"))
        msg = f"{'symbol':42s}: {'addr':>18s} {'perm':5s} ({'base':>18s} + {'offset':>10s}) -> {'val':>18s}"
        gef_print(Color.colorify(msg, get_gef_setting("theme.table_heading")))

        gef_print(titlify("Credential"))
        self.resolve_and_print_kernel("commit_creds", kbase, maps)
        self.resolve_and_print_kernel("prepare_kernel_cred", kbase, maps)
        self.resolve_and_print_kernel("init_cred", kbase, maps, KernelAddressHeuristicFinder.get_init_cred)
        self.resolve_and_print_kernel(["sys_setuid", "__sys_setuid"], kbase, maps)
        self.resolve_and_print_kernel("init_task", kbase, maps, KernelAddressHeuristicFinder.get_init_task)
        gef_print(titlify("Usermode helper"))
        self.resolve_and_print_kernel("call_usermodehelper", kbase, maps)
        self.resolve_and_print_kernel("run_cmd", kbase, maps)
        self.resolve_and_print_kernel("modprobe_path", kbase, maps, KernelAddressHeuristicFinder.get_modprobe_path)
        self.resolve_and_print_kernel("orderly_poweroff", kbase, maps)
        self.resolve_and_print_kernel("poweroff_cmd", kbase, maps, KernelAddressHeuristicFinder.get_poweroff_cmd)
        self.resolve_and_print_kernel("orderly_reboot", kbase, maps)
        self.resolve_and_print_kernel("reboot_cmd", kbase, maps, KernelAddressHeuristicFinder.get_reboot_cmd)
        self.resolve_and_print_kernel("core_pattern", kbase, maps, KernelAddressHeuristicFinder.get_core_pattern)
        gef_print(titlify("ROP finalizer"))
        if is_x86():
            self.resolve_and_print_kernel("swapgs_restore_regs_and_return_to_usermode", kbase, maps)
        self.resolve_and_print_kernel("msleep", kbase, maps)
        gef_print(titlify("Memory protection modifier"))
        if is_x86():
            self.resolve_and_print_kernel("native_write_cr0", kbase, maps)
            self.resolve_and_print_kernel("native_write_cr4", kbase, maps)
        self.resolve_and_print_kernel("set_memory_rw", kbase, maps)
        self.resolve_and_print_kernel("set_memory_x", kbase, maps)
        gef_print(titlify("Memory patcher"))
        self.resolve_and_print_kernel("text_poke", kbase, maps)
        self.resolve_and_print_kernel("memcpy", kbase, maps)
        self.resolve_and_print_kernel("_copy_to_user", kbase, maps)
        self.resolve_and_print_kernel("_copy_from_user", kbase, maps)
        if is_arm64():
            self.resolve_and_print_kernel("__arch_copy_to_user", kbase, maps)
            self.resolve_and_print_kernel("__arch_copy_from_user", kbase, maps)
        gef_print(titlify("Memory remapper"))
        self.resolve_and_print_kernel(["ioremap", "__ioremap"], kbase, maps)
        self.resolve_and_print_kernel(["iounmap", "__iounmap"], kbase, maps)
        self.resolve_and_print_kernel("phys_base", kbase, maps)
        gef_print(titlify("Automatically called function pointer"))
        self.resolve_and_print_kernel("kvm_clock", kbase, maps)
        self.resolve_and_print_kernel("clocksource_tsc", kbase, maps)
        gef_print(titlify("Function pointer table"))
        self.resolve_and_print_kernel("ptmx_fops", kbase, maps)
        self.resolve_and_print_kernel("perf_fops", kbase, maps)
        self.resolve_and_print_kernel("capability_hooks", kbase, maps)
        self.resolve_and_print_kernel("n_tty_ops", kbase, maps, KernelAddressHeuristicFinder.get_n_tty_ops)
        gef_print(titlify("Function pointer table array"))
        self.resolve_and_print_kernel("tty_ldiscs", kbase, maps, KernelAddressHeuristicFinder.get_tty_ldiscs)
        gef_print(titlify("SLUB"))
        self.resolve_and_print_kernel("__kmalloc", kbase, maps)
        self.resolve_and_print_kernel("kzalloc", kbase, maps)
        self.resolve_and_print_kernel("kfree", kbase, maps)
        self.resolve_and_print_kernel("kzfree", kbase, maps)
        self.resolve_and_print_kernel("slab_caches", kbase, maps, KernelAddressHeuristicFinder.get_slab_caches)
        gef_print(titlify("Dynamic resolver"))
        self.resolve_and_print_kernel("kallsyms_lookup_name", kbase, maps)
        gef_print(titlify("vDSO"))
        if is_x86():
            self.resolve_and_print_kernel("vdso_image_64", kbase, maps)
            self.resolve_and_print_kernel("vdso_image_32", kbase, maps)
            self.resolve_and_print_kernel("vdso_image_x32", kbase, maps)
        elif is_arm64():
            self.resolve_and_print_kernel("vdso_info", kbase, maps, KernelAddressHeuristicFinder.get_vdso_info)
        elif is_arm32():
            self.resolve_and_print_kernel("vdso_start", kbase, maps)
        gef_print(titlify("Others"))
        self.resolve_and_print_kernel("do_fchmodat", kbase, maps)
        self.resolve_and_print_kernel("mmap_min_addr", kbase, maps, KernelAddressHeuristicFinder.get_mmap_min_addr)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.filter = argv

        if is_qemu_system():
            self.magic_kernel()
        else:
            self.magic()
        return


@register_command
class OneGadgetCommand(GenericCommand):
    """Exec `one_gadget`."""
    _cmdline_ = "onegadget"
    _syntax_ = _cmdline_
    _category_ = "Exploit Development"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        libc = process_lookup_path_by_list(("libc-2.", "libc.so.6"))
        if libc is None:
            err("libc is not found")
            return

        try:
            one_gadget = which("one_gadget")
            gef_print(titlify(f"{one_gadget} '{libc.path}' -l 1"))
            os.system(f"{one_gadget} '{libc.path}' -l 1")
        except:
            err("Missing `one_gadget`, install with: `gem install one_gadget`.")
        return


@register_command
class SeccompCommand(GenericCommand):
    """Exec `seccomp-tools`."""
    _cmdline_ = "seccomp"
    _syntax_ = _cmdline_
    _category_ = "Exploit Development"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        path = get_filepath()
        try:
            seccomp = which("seccomp-tools")
            gef_print(titlify(f"{seccomp} dump '{path}'"))
            os.system(f"{seccomp} dump '{path}'")
        except:
            err("Missing `seccomp-tools`, install with: `gem install seccomp-tools`.")
        return


@register_command
class SysregCommand(GenericCommand):
    """Pretty-print system registers (not general parpose) from `info regiser`"""
    _cmdline_ = "sysreg"
    _syntax_ = "{:s} [-h] [FILTER[, FILTER, ...]]".format(_cmdline_)
    _category_ = "Show/Modify Register"

    def get_non_generic_regs(self, filt):
        res = gdb.execute("info register", to_string=True)
        res = res.strip()
        regs = {}
        for line in res.splitlines():
            m = re.match(r"(\S+)\s*(0x\S+)\s+(0x\S+|\[.+\])", line)
            if not m:
                continue
            regname, regvalue = m.group(1), m.group(2)
            if filt and not any([f.lower() in regname.lower() for f in filt]):
                continue
            regs[regname] = int(regvalue, 16)
        regs = list(filter(lambda x: "$"+x[0] not in current_arch.all_registers, sorted(regs.items())))
        return regs # [[regname, regvalue], ...]

    def print_sysreg_compact(self, filt):
        regs = self.get_non_generic_regs(filt)
        if regs:
            gef_print(titlify("System registers"))
        else:
            gef_print("Not found non generic regs")
            return
        COLUMN = 3
        length = len(regs)
        length_of_each_bank = (length+COLUMN-1)//COLUMN
        for i in range(length_of_each_bank):
            out = []
            for j in range(COLUMN):
                if len(regs) > i + j*length_of_each_bank:
                    if is_32bit():
                        msg = "{:16s} = {:#10x}".format(*regs[i + j*length_of_each_bank])
                    else:
                        msg = "{:25s} = {:#18x}".format(*regs[i + j*length_of_each_bank])
                    if regs[i + j*length_of_each_bank][1] > 0:
                        msg = Color.boldify(msg)
                    out.append(msg)
                else:
                    out.append("")
            gef_print("  |  ".join(out))
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.print_sysreg_compact(argv)
        return


@register_command
class MmxSetCommand(GenericCommand):
    """Simply set the value to mm."""
    _cmdline_ = "mmxset"
    _syntax_ = "{:s} $mm0=0x1122334455667788".format(_cmdline_)
    _category_ = "Show/Modify Register"

    def get_state(self, code_len):
        d = {}
        d["pc"] = get_register("$pc")
        d["code"] = read_memory(d["pc"], code_len)
        if is_x86_64():
            d["rax"] = get_register("$rax")
        else:
            d["eax"] = get_register("$eax")
        return d

    def revert_state(self, d):
        write_memory(d["pc"], d["code"], len(d["code"]))
        gdb.execute("set $pc = {:#x}".format(d["pc"]), to_string=True)
        if is_x86_64():
            gdb.execute("set $rax = {:#x}".format(d["rax"]), to_string=True)
        else:
            gdb.execute("set $eax = {:#x}".format(d["eax"]), to_string=True)
        return

    def close_stdout(self):
        self.stdout = 1
        self.stdout_bak = os.dup(self.stdout)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stdout)
        f.close()
        return

    def revert_stdout(self):
        os.dup2(self.stdout_bak, self.stdout)
        os.close(self.stdout_bak)
        return

    def execute_movq_mm(self, value, reg):
        REG_CODE = {
            "$mm0": b"\x0f\x6f\x00",
            "$mm1": b"\x0f\x6f\x08",
            "$mm2": b"\x0f\x6f\x10",
            "$mm3": b"\x0f\x6f\x08",
            "$mm4": b"\x0f\x6f\x20",
            "$mm5": b"\x0f\x6f\x28",
            "$mm6": b"\x0f\x6f\x30",
            "$mm7": b"\x0f\x6f\x38",
        }
        code = b"\xeb\xfe" + REG_CODE[reg] + p64(value) # inf-loop (to stop another thread); movq mm0, [rax]; db value
        gef_on_stop_unhook(hook_stop_handler)
        d = self.get_state(len(code))
        write_memory(d["pc"], code, len(code))
        if is_x86_64():
            gdb.execute("set $rax = {:#x}".format(d["pc"]+5), to_string=True) # points to p64(value)
        else:
            gdb.execute("set $eax = {:#x}".format(d["pc"]+5), to_string=True) # points to p64(value)
        gdb.execute("set $pc = {:#x}".format(d["pc"]+2), to_string=True) # skip "\xeb\xfe"
        self.close_stdout()
        gdb.execute("stepi", to_string=True)
        self.revert_stdout()
        self.revert_state(d)
        gef_on_stop_hook(hook_stop_handler)
        return

    @only_if_gdb_running
    @only_if_x86_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        # arg parse
        try:
            reg, value = ''.join(argv).split("=")
            value = int(value, 0)
        except:
            self.usage()
            return

        # check register is valid or not
        if not reg in ["$mm{:d}".format(i) for i in range(8)]:
            err("Invalid register name")
            return

        # modify
        self.execute_movq_mm(value, reg)
        return


@register_command
class MmxCommand(GenericCommand):
    """Show MMX registers."""
    _cmdline_ = "mmx"
    _syntax_ = _cmdline_
    _category_ = "Show/Modify Register"

    def print_mmx(self):
        gef_print(titlify("MMX Register (from fpu register)"))
        regs = []

        for i in range(8):
            regname = "$st{:d}".format(i)
            result = gdb.execute(f"info registers $st{i}", to_string=True)
            r = re.findall(r"\(raw (0x[0-9a-f]+)\)", result)
            if r:
                reg = int(r[0], 16) & 0xffffffffffffffff
                regs.append(reg)

        fstat = get_register("$fstat")
        top_of_stack = (fstat >> 11) & 0b111
        regs = regs[-top_of_stack:] + regs[:-top_of_stack] # need rotate. because mmx0 != st(0)

        fmt = "{:5s}: {:s}"
        legend = ["Name", "64-bit hex"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        red = lambda x: Color.colorify("{:4s}".format(x), "red bold")
        for i in range(len(regs)):
            regname = "$mm{:d}".format(i)
            reghex = ""
            for j in range(8):
                c = (regs[i] >> (8*j)) & 0xff
                reghex += chr(c) if 0x20 <= c < 0x7f else '.'
            gef_print("{:s} : {:#018x}  |  {:s}".format(red(regname), regs[i], reghex))
        return

    @only_if_gdb_running
    @only_if_x86_32_64
    def do_invoke(self, argv):
        self.dont_repeat()
        self.print_mmx()
        return


@register_command
class XmmSetCommand(GenericCommand):
    """Simply set the value to xmm / ymm."""
    _cmdline_ = "xmmset"
    _syntax_ = "{:s} $ymm0=0x11223344556677889900aabbccddeeff9876543210".format(_cmdline_)
    _category_ = "Show/Modify Register"

    @only_if_gdb_running
    @only_if_x86_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        # arg parse
        try:
            reg, value = ''.join(argv).split("=")
            value = int(value, 0)
        except:
            self.usage()
            return

        # check register is valid or not
        try:
            gdb.execute(f"info register {reg}", to_string=True)
        except:
            err("Invalid register name")
            return

        # modify
        if "$xmm" in reg:
            for i in range(2):
                v = (value >> (64*i)) & ((1<<64) - 1)
                gdb.execute(f"set {reg}.v2_int64[{i}]={v:#x}", to_string=True)
        elif "$ymm" in reg:
            for i in range(4):
                v = (value >> (64*i)) & ((1<<64) - 1)
                gdb.execute(f"set {reg}.v4_int64[{i}]={v:#x}", to_string=True)
        else:
            err("Unsupported")
        return


@register_command
class SseCommand(GenericCommand):
    """Show SSE registers."""
    _cmdline_ = "sse"
    _syntax_ = "{:s} [-h] [-v]".format(_cmdline_)
    _aliases_ = ["xmm",]
    _category_ = "Show/Modify Register"

    def print_sse(self):
        gef_print(titlify("SSE Data Register"))

        # xmm0-15
        regs = []
        for i in range(16 if is_x86_64() else 8):
            result = gdb.execute(f"info registers $xmm{i}", to_string=True)
            r = re.findall(r"uint128 = (0x[0-9a-f]+)", result)
            if r:
                reg = int(r[0], 16)
                regs.append(reg)
        fmt = "{:7s}: {:s}"
        legend = ["Name", "128-bit hex"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        red = lambda x: Color.colorify("{:4s}".format(x), "red bold")
        for i in range(len(regs)):
            if i == 8:
                gef_print("* xmm8-15 are introduced by AVX")
            reghex = ""
            for j in range(16):
                c = (regs[i] >> (8*j)) & 0xff
                reghex += chr(c) if 0x20 <= c < 0x7f else '.'
            regname = "$xmm{:<2d}".format(i)
            gef_print("{:s} : {:#034x}  |  {:s}".format(red(regname), regs[i], reghex))
        return

    def print_sse_other(self):
        red = lambda x: Color.colorify("{:4s}".format(x), "red bold")

        # mxcsr
        gef_print(titlify("MXCSR (MXCSR Control and Status Register)"))
        bit_info = [
            [15, "FZ", "Flush To Zero", ""],
            [[13,14], "RC", "Rounding Control", "00: Round To Nearest, 01: Round Negative, 10: Round Positive, 11: Round To Zero"],
            [12, "PM", "Precision Exception Mask", ""],
            [11, "UM", "Underflow Exception Mask", ""],
            [10, "OM", "Overflow Exception Mask", ""],
            [9, "ZM", "Zero Divide Exception Mask", ""],
            [8, "DM", "Denormalized Opernad Exception Mask", ""],
            [7, "IM", "Invalid Operation Exception Mask", ""],
            [6, "DAZ", "Use as 0.0 if input data is denormalized", ""],
            [5, "PE", "Precision Exception", ""],
            [4, "UE", "Underflow Exception", ""],
            [3, "OE", "Overflow Exception", ""],
            [2, "ZE", "Zero Divide Exception", ""],
            [1, "DE", "Denormalized Operand Exception", ""],
            [0, "IE", "Invalid Operation Exception", ""],
        ]
        reg = int(gdb.execute("info registers $mxcsr", to_string=True).split()[1],16)
        PrintBitInfo("$mxcsr", 32, None, bit_info).print(reg)
        return

    @only_if_gdb_running
    @only_if_x86_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.print_sse()
        if "-v" in argv:
            self.print_sse_other()
        else:
            info("for $mxcsr flags description, use `-v`")
        return


@register_command
class AvxCommand(GenericCommand):
    """Show AVX registers."""
    _cmdline_ = "avx"
    _syntax_ = _cmdline_
    _aliases_ = ["ymm",]
    _category_ = "Show/Modify Register"

    def print_avx(self):
        regs = []
        for i in range(16 if is_x86_64() else 8):
            try:
                result = gdb.execute(f"info registers $ymm{i}", to_string=True)
            except:
                continue
            result = result.replace("\n", "")
            r = re.findall(r"v2_int128 = \{.*?\[0x0\] = (0x[0-9a-f]+),.*?\[0x1\] = (0x[0-9a-f]+).*?\}", result)
            if r:
                reg = (int(r[0][1], 16) << 128) + int(r[0][0], 16)
                regs.append(reg)
        if regs:
            gef_print(titlify("AVX Register"))
            fmt = "{:7s}: {:s}"
            legend = ["Name", "256-bit hex"]
            gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
            red = lambda x: Color.colorify("{:4s}".format(x), "red bold")
            for i in range(len(regs)):
                regname = "$ymm{:<2d}".format(i)
                reghex = ""
                for j in range(32):
                    c = (regs[i] >> (8*j)) & 0xff
                    reghex += chr(c) if 0x20 <= c < 0x7f else '.'
                gef_print("{:s} : {:#066x}  |  {:s}".format(red(regname), regs[i], reghex))
        else:
            err("Not found avx registers")
        return

    @only_if_gdb_running
    @only_if_x86_32_64
    def do_invoke(self, argv):
        self.dont_repeat()
        self.print_avx()
        return


@register_command
class FpuCommand(GenericCommand):
    """Show fpu registers.(x86/x64:x57-fpu, ARM/ARM64:vfp-d16)"""
    _cmdline_ = "fpu"
    _syntax_ = "{:s} [-h] [-v]".format(_cmdline_)
    _category_ = "Show/Modify Register"

    def f2u(self, a):
        def u(a):
            return struct.unpack("<I",a)[0]
        def pf(a):
            return struct.pack("<f",a)
        return u(pf(a))

    def u2f(self, a):
        def p(a):
            return struct.pack("<I",a&0xffffffff)
        def uf(a):
            return struct.unpack("<f",a)[0]
        return uf(p(a))

    def d2u(self, a):
        def uQ(a):
            return struct.unpack("<Q",a)[0]
        def pd(a):
            return struct.pack("<d",a)
        return uQ(pd(a))

    def u2d(self, a):
        def pQ(a):
            return struct.pack("<Q",a&0xffffffffffffffff)
        def ud(a):
            return struct.unpack("<d",a)[0]
        return ud(pQ(a))

    def d2u80(self, a):
        value = ctypes.c_longdouble(a)
        BYTES = ctypes.POINTER(ctypes.c_byte * 10)
        ptr = ctypes.cast(ctypes.addressof(value), BYTES)
        x = ["{:02x}".format(int(x)&0xff) for x in ptr[0][::-1]]
        return int(''.join(x), 16)

    def bits_split(self, x, bits=32):
        # 0xaaaabbbb -> 0xaaaa_bbbb
        out = ""
        for i in range(bits):
            if x & (1 << i):
                out = "1" + out
            else:
                out = "0" + out
            if i % 4 == 3:
                out = "_" + out
        return "0b" + out[1:]

    def print_fpu_arm(self):
        red = lambda x: Color.colorify("{:4s}".format(x), "red bold")

        # s0-s31, d0-d31, q0-q15
        gef_print(titlify("FPU/NEON Data Register"))
        fmt = "{:4s}: {:15s} {:10s} | {:4s}: {:28s} {:18s} | {:4s} {:34s}"
        legend = ["Name", "Value", "32-bit hex", "Name", "Value", "64-bit hex", "Name", "128-bit hex"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for i in range(32):
            regname1 = "$s{:d}".format(i)
            regname2 = "$d{:d}".format(i)
            regname3 = "$q{:d}".format(i)
            if is_32bit():
                reg1 = self.f2u(float(gdb.execute("p {}".format(regname1), to_string=True).split()[2]))
                reg2 = int(gdb.execute("p {}.u64".format(regname2), to_string=True).split()[2], 16)
                try:
                    reg3h = int(gdb.execute("p {}.u64[0]".format(regname3), to_string=True).split()[2], 16)
                    reg3l = int(gdb.execute("p {}.u64[1]".format(regname3), to_string=True).split()[2], 16)
                    reg3 = (reg3h << 64) + reg3l
                except:
                    reg3 = None
            else:
                reg1 = int(gdb.execute("p {}.u".format(regname1), to_string=True).split()[2], 16)
                reg2 = int(gdb.execute("p {}.u".format(regname2), to_string=True).split()[2], 16)
                try:
                    reg3 = int(gdb.execute("p {}.u".format(regname3), to_string=True).split()[2], 16)
                except:
                    reg3 = None

            fmt1 = "{:s}: {:15s} {:<#10x}".format(red(regname1), "{:<+.8e}".format(self.u2f(reg1)), reg1)
            fmt2 = "{:s}: {:28s} {:<#18x}".format(red(regname2), "{:<+.20e}".format(self.u2d(reg2)), reg2)
            if reg3 is None:
                fmt3 = "{:s}: {:s}".format(red(regname3), "Access denied")
            else:
                fmt3 = "{:s}: {:<#34x}".format(red(regname3), reg3)
            gef_print("{:s} | {:s} | {:s}".format(fmt1, fmt2, fmt3))
        return

    def print_fpu_x86(self):
        red = lambda x: Color.colorify("{:4s}".format(x), "red bold")

        # st0-7
        gef_print(titlify("FPU Data Register"))
        fmt = "{:9s} : {:27s}\t{:24s} {:18s} {:10s}"
        legend = ["Name", "Value", "80-bit hex(TWORD/XWORD)", "64-bit hex(QWORD)", "32-bit Hex(DWORD)"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))

        fstat = get_register("$fstat")
        top_of_stack = (fstat >> 11) & 0b111
        regs = ["mm{:d}".format(i) for i in range(8)]
        regs = regs[top_of_stack:] + regs[:top_of_stack] # need rotate. because mmx0 != st(0)

        for i in range(8):
            regname = "$st{:d}".format(i)
            result = gdb.execute("info registers {}".format(regname), to_string=True)
            if "invalid" in result:
                r = re.findall(r"\(raw (0x[0-9a-f]+)\)", result)
                u80 = int(r[0], 16)
                u64 = 0xfff8000000000000 # nan
                u32 = 0xffc00000 # nan
                gef_print("{:4s}({:3s}) : {:<27s}\t{:<#24x} {:<#18x} {:<#10x}".format(red(regname), regs[i], "<invalid>", u80, u64, u32))
            else:
                reg = float(result.split()[1])
                u80 = self.d2u80(reg)
                u64 = self.d2u(reg)
                u32 = self.f2u(reg)
                gef_print("{:4s}({:3s}) : {:<+.20e}\t{:<#24x} {:<#18x} {:<#10x}".format(red(regname), regs[i], reg, u80, u64, u32))
        info('XWORD: Real register value; Used at "fstp xword ptr [rax]".')
        info('QWORD: Used at "fst/fstp qword ptr [rax]".')
        info('DWORD: Used at "fst/fstp dword ptr [rax]".')
        return

    def print_fpu_arm_other(self):
        # fpscr
        gef_print(titlify("FPSCR (Floating-Point Status and Control Register)"))
        bit_info = [
            [31, "N", "Negative condition flag", ""],
            [30, "Z", "Zero condition flag", ""],
            [29, "C", "Carry condition flag", ""],
            [28, "V", "Overflow condition flag", ""],
            [27, "QC", "Cumulative saturation bit", ""],
            [26, "AHP", "Alternative Half-Precision Control", ""],
            [25, "DN", "Default NaN mode Control", ""],
            [24, "FZ", "Flush-to-zero mode Control", ""],
            [[22,23], "RMode", "Rounding Control", "00: Round To Nearest, 01: Round Positive, 10: Round Negative, 11: Round To Zero"],
            [[20,21], "Stride", "", "IMPLEMENTATION DEFINED"],
            [19, "FZ16", "Flush-to-zero mode Control", "When FEAT_FP16 is implemented"],
            [[16,17,18], "Len", "", "IMPLEMENTATION DEFINED"],
            [15, "IDE", "Input Denormal floating-point Exception trap enable", ""],
            [12, "IXE", "Inexact floating-point Exception trap enable", ""],
            [11, "UFE", "Underflow floating-point Exception trap enable", ""],
            [10, "OFE", "Overflow floating-point Exception trap enable", ""],
            [9, "DZE", "Divide by Zero floating-point Exception trap enable", ""],
            [8, "IOE", "Invalid Operation floating-point Exception trap enable", ""],
            [7, "IDC", "Input Denormal Cumulative floating-point exception bit", ""],
            [4, "IXC", "Inexact Cumulative floating-point exception bit", ""],
            [3, "UFC", "Underflow Cumulative floating-point exception bit", ""],
            [2, "OFC", "Overflow Cumulative floating-point exception bit", ""],
            [1, "DZC", "Divide by Zero Cumulative floating-point exception bit", ""],
            [0, "IOC", "Invalid Operation Cumulative floating-point exception bit", ""],
        ]
        reg = int(gdb.execute("info registers $fpscr", to_string=True).split()[1],16)
        PrintBitInfo("$fpscr", 32, None, bit_info).print(reg)

        # fpsid
        gef_print(titlify("FPSID (Floating-Point System ID Register)"))
        bit_info = [
            [list(range(24,32)), "Implementer", "Implementer code", ""],
            [23, "SW", "Software bit", "Implementation of floating point instructions, 0:HW, 1:SW"],
            [list(range(16,23)), "Subarchitecture", "Subarchitecture version number", ""],
            [list(range(8,16)), "PartNum", "Part number", "IMPLEMENTATION DEFINED"],
            [[4,5,6,7], "Variant", "Variant number", "IMPLEMENTATION DEFINED"],
            [[0,1,2,3], "Revision", "Revisino number","IMPLEMENTATION DEFINED"],
        ]
        impl = {
            0x00: "Reserved for software use",
            0xc0: "Ampere Computing",
            0x41: "Arm Limited",
            0x42: "Broadcom Corporation",
            0x43: "Cavium Inc.",
            0x44: "Digital Equipment Corporation",
            0x46: "Fujitsu Ltd.",
            0x49: "Infineon Technologies AG",
            0x4d: "Motorola or Freescale Semiconductor Inc.",
            0x4e: "NVIDIA Corporation",
            0x50: "Applied Micro Circuits Corporation",
            0x51: "Qualcomm Inc.",
            0x56: "Marvell International Ltd.",
            0x69: "Intel Corporation",
        }
        reg = int(gdb.execute("info registers $fpsid", to_string=True).split()[1],16)
        PrintBitInfo("$fpsid", 32, None, bit_info).print(reg)
        gef_print("Implementer code")
        for k, v in impl.items():
            gef_print("  {:#02x}: {:s}".format(k, v))

        # fpexc
        gef_print(titlify("FPEXC (Floating-Point Exception Control Register)"))
        bit_info = [
            [31, "EX", "Exception bit", ""],
            [30, "EN", "Enables access to the Advanced SIMD and floating-point functionality from all Exception levels", ""],
            [29, "DEX", "Defined synchronous exception on floating-point execution", ""],
            [28, "FP2V", "FPINST2 instruction valid bit", ""],
            [27, "VV", "VECITR valid bit", ""],
            [26, "TFV", "Trapped Fault Valid bit", ""],
            [[8,9,10], "VECITR", "Vector iteration count", ""],
            [7, "IDF", "Input Denormal trapped exception bit", ""],
            [4, "IXF", "Inexact trapped exception bit", ""],
            [3, "UFF", "Underflow trapped exception bit", ""],
            [2, "OFF", "Overflow trapped exception bit", ""],
            [1, "DZF", "Divide by Zero trapped exception bit", ""],
            [0, "IOF", "Invalid Operation trapped exception bit", ""],
        ]
        reg = int(gdb.execute("info registers $fpexc", to_string=True).split()[1],16)
        PrintBitInfo("$fpexc", 32, None, bit_info).print(reg)
        return

    def print_fpu_arm64_other(self):
        # fpcr
        gef_print(titlify("FPCR (Floating-Point Control Register)"))
        bit_info = [
            [26, "AHP", "Alternative Half-Precision Control", ""],
            [25, "DN", "Default NaN mode Control", ""],
            [24, "FZ", "Flush-to-zero mode Control", ""],
            [[22,23], "RMode", "Rounding Control", "00: Round To Nearest, 01: Round Positive, 10: Round Negative, 11: Round To Zero"],
            [[20,21], "Stride", "", "Unused"],
            [19, "FZ16", "Flush-to-zero mode Control", "When FEAT_FP16 is implemented"],
            [[16,17,18], "Len", "", "Unused"],
            [15, "IDE", "Input Denormal floating-point Exception trap enable", ""],
            [12, "IXE", "Inexact floating-point Exception trap enable", ""],
            [11, "UFE", "Underflow floating-point Exception trap enable", ""],
            [10, "OFE", "Overflow floating-point Exception trap enable", ""],
            [9, "DZE", "Divide by Zero floating-point Exception trap enable", ""],
            [8, "IOE", "Invalid Operation floating-point Exception trap enable", ""],
        ]
        reg = int(gdb.execute("info registers $fpcr", to_string=True).split()[1],16)
        PrintBitInfo("$fpcr", 32, None, bit_info).print(reg)

        # fpsr
        gef_print(titlify("FPCR (Floating-Point Status Register)"))
        bit_info = [
            [31, "N", "", "Unused, see $cpsr"],
            [30, "Z", "", "Unused, see $cpsr"],
            [29, "C", "", "Unused, see $cpsr"],
            [28, "V", "", "Unused, see $cpsr"],
            [27, "QC", "Cumulative saturation bit", ""],
            [7, "IDC", "Input Denormal Cumulative floating-point exception bit", ""],
            [4, "IXC", "Inexact Cumulative floating-point exception bit", ""],
            [3, "UFC", "Underflow Cumulative floating-point exception bit", ""],
            [2, "OFC", "Overflow Cumulative floating-point exception bit", ""],
            [1, "DZC", "Divide by Zero Cumulative floating-point exception bit", ""],
            [0, "IOC", "Invalid Operation Cumulative floating-point exception bit", ""],
        ]
        reg = int(gdb.execute("info registers $fpsr", to_string=True).split()[1],16)
        PrintBitInfo("$fpsr", 32, None, bit_info).print(reg)
        return

    def print_fpu_x86_other(self):
        # fctrl
        gef_print(titlify("FCTRL (x87 FPU Control Word)"))
        bit_info = [
            [12, "X", "Infinity Control", ""],
            [[10, 11], "RC", "Rounding Control", "00: Round To Nearest, 01: Round Negative, 10: Round Positive, 11: Round To Zero"],
            [[8,9], "PC", "Precision Control", "00: Signle Precison, 01: Reserved, 10: Double Precision, 11: Double-Extended Precision"],
            [5, "PM", "Precision Exception Mask", ""],
            [4, "UM", "Underflow Exception Mask", ""],
            [3, "OM", "Overflow Exception Mask", ""],
            [2, "ZM", "Zero Divide Exception Mask", ""],
            [1, "DM", "Denormalized Opernd Exception Mask", ""],
            [0, "IM", "Invalid Operation Exception Mask", ""],
        ]
        reg = int(gdb.execute("info registers $fctrl", to_string=True).split()[1],16)
        PrintBitInfo("$fctrl", 16, None, bit_info).print(reg)

        # fstat
        gef_print(titlify("FSTAT (x87 FPU Status Word)"))
        bit_info = [
            [15, "B",  "FPU Busy", ""],
            [14, "C3", "Condition Code", ""],
            [[11,12,13], "TOP","Top of Stack Pointer", ""],
            [10, "C2", "Condition Code", ""],
            [9, "C1", "Condition Code", ""],
            [8, "C0", "Condition Code", ""],
            [7, "ES", "Exception Summary Status", ""],
            [6, "SF", "Stack Fault", ""],
            [5, "PE", "Precision Exception", ""],
            [4, "UE", "Underflow Exception", ""],
            [3, "OE", "Overflow Exception", ""],
            [2, "ZE", "Zero Divide Exception", ""],
            [1, "DE", "Denormalized Operand Exception", ""],
            [0, "IE", "Invalid Operation Exception", ""],
        ]
        reg = int(gdb.execute("info registers $fstat", to_string=True).split()[1],16)
        PrintBitInfo("$fstat", 16, None, bit_info).print(reg)

        # ftag
        gef_print(titlify("FTAG (x87 FPU Tag Word)"))
        bit_info = [
            [[14,15], "TAG(7)", "Reg7 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[12,13], "TAG(6)", "Reg6 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[10,11], "TAG(5)", "Reg5 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[8,9], "TAG(4)", "Reg4 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[6,7], "TAG(3)", "Reg3 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[4,5], "TAG(2)", "Reg2 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[2,3], "TAG(1)", "Reg1 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[0,1], "TAG(0)", "Reg0 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
        ]
        reg = int(gdb.execute("info registers $ftag", to_string=True).split()[1],16)
        PrintBitInfo("$ftag", 16, None, bit_info).print(reg)

        # $fiseg, $fioff
        gef_print(titlify("FCS:FIP (x87 FPU Last Instruction Pointer)"))
        reg = int(gdb.execute("info registers $fiseg", to_string=True).split()[1],16)
        reg = int(gdb.execute("info registers $fioff", to_string=True).split()[1],16)
        PrintBitInfo("$fiseg(FCS)", 16, None, bit_info=[]).print(reg, split=False)
        PrintBitInfo("$fioff(FIP)", 32, None, bit_info=[]).print(reg, split=False)

        # $foseg, $fooff
        gef_print(titlify("FDS:FDP (x87 FPU Last Data(Operand) Pointer)"))
        reg = int(gdb.execute("info registers $foseg", to_string=True).split()[1],16)
        reg = int(gdb.execute("info registers $fooff", to_string=True).split()[1],16)
        PrintBitInfo("$foseg(FDS)", 16, None, bit_info=[]).print(reg, split=False)
        PrintBitInfo("$fooff(FDP)", 32, None, bit_info=[]).print(reg, split=False)

        # $fop
        gef_print(titlify("FOP (x87 FPU Last Instruction Opcode)"))
        reg = int(gdb.execute("info registers $fop", to_string=True).split()[1],16)
        PrintBitInfo("$fop", 11, None, bit_info=[]).print(reg, split=False)
        return

    @only_if_gdb_running
    @only_if_x86_32_64_or_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if is_x86():
            self.print_fpu_x86()
        elif is_arm32() or is_arm64():
            self.print_fpu_arm()

        if "-v" in argv:
            if is_x86():
                self.print_fpu_x86_other()
            elif is_arm32():
                self.print_fpu_arm_other()
            elif is_arm64():
                self.print_fpu_arm64_other()
        else:
            info("for fpu other register's flags description, use `-v`")
        return


@register_command
class ErrnoCommand(GenericCommand):
    """Converts errno (or argument) to its string representation."""
    _cmdline_ = "errno"
    _syntax_ = "{:s} [errno] [all]".format(_cmdline_)
    _category_ = "Process Information"

    # /usr/include/asm-generic/errno.h
    ERRNO_DICT = {
        0   : ["-",               "No error"],
        1   : ["EPERM",           "Operation not permitted"],
        2   : ["ENOENT",          "No such file or directory"],
        3   : ["ESRCH",           "No such process"],
        4   : ["EINTR",           "Interrupted system call"],
        5   : ["EIO",             "I/O error"],
        6   : ["ENXIO",           "No such device or address"],
        7   : ["E2BIG",           "Argument list too long"],
        8   : ["ENOEXEC",         "Exec format error"],
        9   : ["EBADF",           "Bad file number"],
        10  : ["ECHILD",          "No child processes"],
        11  : ["EAGAIN",          "Try again"],
        12  : ["ENOMEM",          "Out of memory"],
        13  : ["EACCES",          "Permission denied"],
        14  : ["EFAULT",          "Bad address"],
        15  : ["ENOTBLK",         "Block device required"],
        16  : ["EBUSY",           "Device or resource busy"],
        17  : ["EEXIST",          "File exists"],
        18  : ["EXDEV",           "Cross-device link"],
        19  : ["ENODEV",          "No such device"],
        20  : ["ENOTDIR",         "Not a directory"],
        21  : ["EISDIR",          "Is a directory"],
        22  : ["EINVAL",          "Invalid argument"],
        23  : ["ENFILE",          "File table overflow"],
        24  : ["EMFILE",          "Too many open files"],
        25  : ["ENOTTY",          "Not a typewriter"],
        26  : ["ETXTBSY",         "Text file busy"],
        27  : ["EFBIG",           "File too large"],
        28  : ["ENOSPC",          "No space left on device"],
        29  : ["ESPIPE",          "Illegal seek"],
        30  : ["EROFS",           "Read-only file system"],
        31  : ["EMLINK",          "Too many links"],
        32  : ["EPIPE",           "Broken pipe"],
        33  : ["EDOM",            "Math argument out of domain of func"],
        34  : ["ERANGE",          "Math result not representable"],
        35  : ["EDEADLK",         "Resource deadlock would occur"],
        36  : ["ENAMETOOLONG",    "File name too long"],
        37  : ["ENOLCK",          "No record locks available"],
        38  : ["ENOSYS",          "Invalid system call number"],
        39  : ["ENOTEMPTY",       "Directory not empty"],
        40  : ["ELOOP",           "Too many symbolic links encountered"],
        42  : ["ENOMSG",          "No message of desired type"],
        43  : ["EIDRM",           "Identifier removed"],
        44  : ["ECHRNG",          "Channel number out of range"],
        45  : ["EL2NSYNC",        "Level 2 not synchronized"],
        46  : ["EL3HLT",          "Level 3 halted"],
        47  : ["EL3RST",          "Level 3 reset"],
        48  : ["ELNRNG",          "Link number out of range"],
        49  : ["EUNATCH",         "Protocol driver not attached"],
        50  : ["ENOCSI",          "No CSI structure available"],
        51  : ["EL2HLT",          "Level 2 halted"],
        52  : ["EBADE",           "Invalid exchange"],
        53  : ["EBADR",           "Invalid request descriptor"],
        54  : ["EXFULL",          "Exchange full"],
        55  : ["ENOANO",          "No anode"],
        56  : ["EBADRQC",         "Invalid request code"],
        57  : ["EBADSLT",         "Invalid slot"],
        59  : ["EBFONT",          "Bad font file format"],
        60  : ["ENOSTR",          "Device not a stream"],
        61  : ["ENODATA",         "No data available"],
        62  : ["ETIME",           "Timer expired"],
        63  : ["ENOSR",           "Out of streams resources"],
        64  : ["ENONET",          "Machine is not on the network"],
        65  : ["ENOPKG",          "Package not installed"],
        66  : ["EREMOTE",         "Object is remote"],
        67  : ["ENOLINK",         "Link has been severed"],
        68  : ["EADV",            "Advertise error"],
        69  : ["ESRMNT",          "Srmount error"],
        70  : ["ECOMM",           "Communication error on send"],
        71  : ["EPROTO",          "Protocol error"],
        72  : ["EMULTIHOP",       "Multihop attempted"],
        73  : ["EDOTDOT",         "RFS specific error"],
        74  : ["EBADMSG",         "Not a data message"],
        75  : ["EOVERFLOW",       "Value too large for defined data type"],
        76  : ["ENOTUNIQ",        "Name not unique on network"],
        77  : ["EBADFD",          "File descriptor in bad state"],
        78  : ["EREMCHG",         "Remote address changed"],
        79  : ["ELIBACC",         "Can not access a needed shared library"],
        80  : ["ELIBBAD",         "Accessing a corrupted shared library"],
        81  : ["ELIBSCN",         ".lib section in a.out corrupted"],
        82  : ["ELIBMAX",         "Attempting to link in too many shared libraries"],
        83  : ["ELIBEXEC",        "Cannot exec a shared library directly"],
        84  : ["EILSEQ",          "Illegal byte sequence"],
        85  : ["ERESTART",        "Interrupted system call should be restarted"],
        86  : ["ESTRPIPE",        "Streams pipe error"],
        87  : ["EUSERS",          "Too many users"],
        88  : ["ENOTSOCK",        "Socket operation on non-socket"],
        89  : ["EDESTADDRREQ",    "Destination address required"],
        90  : ["EMSGSIZE",        "Message too long"],
        91  : ["EPROTOTYPE",      "Protocol wrong type for socket"],
        92  : ["ENOPROTOOPT",     "Protocol not available"],
        93  : ["EPROTONOSUPPORT", "Protocol not supported"],
        94  : ["ESOCKTNOSUPPORT", "Socket type not supported"],
        95  : ["EOPNOTSUPP",      "Operation not supported on transport endpoint"],
        96  : ["EPFNOSUPPORT",    "Protocol family not supported"],
        97  : ["EAFNOSUPPORT",    "Address family not supported by protocol"],
        98  : ["EADDRINUSE",      "Address already in use"],
        99  : ["EADDRNOTAVAIL",   "Cannot assign requested address"],
        100 : ["ENETDOWN",        "Network is down"],
        101 : ["ENETUNREACH",     "Network is unreachable"],
        102 : ["ENETRESET",       "Network dropped connection because of reset"],
        103 : ["ECONNABORTED",    "Software caused connection abort"],
        104 : ["ECONNRESET",      "Connection reset by peer"],
        105 : ["ENOBUFS",         "No buffer space available"],
        106 : ["EISCONN",         "Transport endpoint is already connected"],
        107 : ["ENOTCONN",        "Transport endpoint is not connected"],
        108 : ["ESHUTDOWN",       "Cannot send after transport endpoint shutdown"],
        109 : ["ETOOMANYREFS",    "Too many references: cannot splice"],
        110 : ["ETIMEDOUT",       "Connection timed out"],
        111 : ["ECONNREFUSED",    "Connection refused"],
        112 : ["EHOSTDOWN",       "Host is down"],
        113 : ["EHOSTUNREACH",    "No route to host"],
        114 : ["EALREADY",        "Operation already in progress"],
        115 : ["EINPROGRESS",     "Operation now in progress"],
        116 : ["ESTALE",          "Stale file handle"],
        117 : ["EUCLEAN",         "Structure needs cleaning"],
        118 : ["ENOTNAM",         "Not a XENIX named type file"],
        119 : ["ENAVAIL",         "No XENIX semaphores available"],
        120 : ["EISNAM",          "Is a named type file"],
        121 : ["EREMOTEIO",       "Remote I/O error"],
        122 : ["EDQUOT",          "Quota exceeded"],
        123 : ["ENOMEDIUM",       "No medium found"],
        124 : ["EMEDIUMTYPE",     "Wrong medium type"],
        125 : ["ECANCELED",       "Operation Canceled"],
        126 : ["ENOKEY",          "Required key not available"],
        127 : ["EKEYEXPIRED",     "Key has expired"],
        128 : ["EKEYREVOKED",     "Key has been revoked"],
        129 : ["EKEYREJECTED",    "Key was rejected by service"],
        130 : ["EOWNERDEAD",      "Owner died"],
        131 : ["ENOTRECOVERABLE", "State not recoverable"],
        132 : ["ERFKILL",         "Operation not possible due to RF-kill"],
        133 : ["EHWPOISON",       "Memory page has hardware error"],
    }

    def do_invoke(self, argv):
        self.dont_repeat()

        if "all" in argv:
            for val, es in sorted(self.ERRNO_DICT.items()):
                gef_print("{:3d} (={:#4x}): {:<15s}: \"{:s}\"".format(val, val, es[0], es[1]))
            return

        try:
            if len(argv) == 0:
                if is_alive():
                    val = parse_address("*__errno_location()")
                else:
                    warn("No debugging session active")
                    return
            else:
                val = int(argv[0], 0)
        except:
            self.usage()
            return

        if val > 0xffff:
            if current_arch and current_arch.ptrsize == 4:
                val = struct.unpack("<i", struct.pack("<I", val))[0]
            elif current_arch and current_arch.ptrsize == 8:
                val = struct.unpack("<q", struct.pack("<Q", val))[0]
            elif current_arch is None:
                val = struct.unpack("<q", struct.pack("<Q", val))[0]
            else:
                err("not support this pointer size.")
                return

        if val < 0:
            val = -val

        if val in self.ERRNO_DICT:
            es = self.ERRNO_DICT[val]
            gef_print("{:3d} (={:#4x}): {:<15s}: \"{:s}\"".format(val, val, es[0], es[1]))
        else:
            err("not found value in ERRNO_DICT (1~{:d})".format(len(self.ERRNO_DICT)))
        return


@register_command
class ExtractHeapAddrCommand(GenericCommand):
    """Extract heap address from protected `fd` pointer of single linked-list. This will be introduced from glibc 2.32."""
    _cmdline_ = "extract-heap-addr"
    _syntax_ = "{:s} [-h] VALUE|--source".format(_cmdline_)
    _example_ = "{:s} 0x000055500000C7F9".format(_cmdline_)
    _category_ = "Heap"

    # https://smallkirby.hatenablog.com/entry/safeunlinking
    def reveal(self, fd):
        L = fd >> 36
        for i in range(3):
            temp = (fd >> (36-(i+1)*8)) & 0xff
            element = ((L>>4) ^ temp) & 0xff
            L = (L<<8) + element
        return L << 12

    def print_source(self):
        s = ""
        s += "def reveal(fd):\n"
        s += "    L = fd >> 36\n"
        s += "    for i in range(3):\n"
        s += "        temp = (fd >> (36-(i+1)*8)) & 0xff\n"
        s += "        element = ((L>>4) ^ temp) & 0xff\n"
        s += "        L = (L<<8) + element\n"
        s += "    return L << 12"
        gef_print(s)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if not argv:
            self.usage()
            return

        if "-h" in argv:
            self.usage()
            return

        if "--source" in argv:
            self.print_source()
            return

        ptr = int(argv[0], 16)
        extracted_ptr = self.reveal(ptr)
        gef_print("Protected fd pointer: {:#x} -> Extracted heap address: {:#x} (=fd & ~0xfff)".format(ptr, extracted_ptr))
        return


@register_command
class U2dCommand(GenericCommand):
    """Translate type (unsigned long <-> double/float)."""
    _cmdline_ = "u2d"
    _syntax_ = "{:s} [-h] [HEX_VALUE|DOUBLE_VALUE]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} 0xdeadbeef\n".format(_cmdline_)
    _example_ += "{:s} 0.12345\n".format(_cmdline_)
    _example_ += "{:s} 1.2345e-1\n".format(_cmdline_)
    _example_ += " * only ~64bit supported (Unsupported 80bit, 128bit)"
    _category_ = "Misc"

    def f2u(self, a):
        def u(a):
            return struct.unpack("<I",a)[0]
        def pf(a):
            return struct.pack("<f",a)
        return u(pf(a))

    def u2f(self, a):
        def p(a):
            return struct.pack("<I",a&0xffffffff)
        def uf(a):
            return struct.unpack("<f",a)[0]
        return uf(p(a))

    def d2u(self, a):
        def uQ(a):
            return struct.unpack("<Q",a)[0]
        def pd(a):
            return struct.pack("<d",a)
        return uQ(pd(a))

    def u2d(self, a):
        def pQ(a):
            return struct.pack("<Q",a&0xffffffffffffffff)
        def ud(a):
            return struct.unpack("<d",a)[0]
        return ud(pQ(a))

    def translate_from_float(self, n):
        gef_print(titlify("double -> unsigned long long"))
        gef_print(Color.cyanify("double -> ull (reinterpret_cast)"))
        gef_print("  {:.20e} ---> {:#018x}".format(n, self.d2u(n)))
        gef_print(titlify("float -> float"))
        gef_print(Color.cyanify("float -> uint (reinterpret_cast)"))
        gef_print("  {:.20e} ---> {:#010x}".format(n, self.f2u(n)))
        return

    def translate_from_int(self, n):
        n &= 0xffffffffffffffff
        gef_print(titlify("unsigned long long <-> double"))
        gef_print(Color.cyanify("ull -> double (reinterpret_cast)"))
        gef_print("  {:#018x} ---> {:.20e}".format(n, self.u2d(n)))
        gef_print(Color.cyanify("ull -> double -> ull (static_cast)"))
        gef_print("  {:#018x} ---> {:#018x} ---> {:#018x}".format(n, self.d2u(float(n)), int(self.u2d(self.d2u(float(n))))))

        n &= 0xffffffff
        gef_print(titlify("unsigned int <-> float"))
        gef_print(Color.cyanify("uint -> float (reinterpret_cast)"))
        gef_print("  {:#010x} ---> {:.20e}".format(n, self.u2f(n)))
        gef_print(Color.cyanify("uint -> float -> uint (static_cast)"))
        gef_print("  {:#010x} ---> {:#010x} ---> {:#010x}".format(n, self.f2u(float(n)), int(self.u2f(self.f2u(float(n))))))
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 0:
            self.usage()
            return

        if "-h" in argv:
            self.usage()
            return

        try:
            if "." in argv[0]:
                n = float(argv[0])
                self.translate_from_float(n)
            else:
                n = int(argv[0], 0)
                self.translate_from_int(n)
        except:
            self.usage()
        return


@register_command
class PackCommand(GenericCommand):
    """Translate integer -> string."""
    _cmdline_ = "pack"
    _syntax_ = "{:s} [-h] VALUE".format(_cmdline_)
    _example_ = "{:s} 0xdeadbeef".format(_cmdline_)
    _category_ = "Misc"

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 0:
            self.usage()
            return

        if "-h" in argv:
            self.usage()
            return

        try:
            value = int(argv[0], 0)
        except:
            self.usage()
            return
        gef_print("pack8:   {}".format(p8(value & 0xff)))
        gef_print("pack16:  {}".format(p16(value & 0xffff)))
        gef_print("pack32:  {}".format(p32(value & 0xffffffff)))
        gef_print("pack64:  {}".format(p64(value & 0xffffffffffffffff)))
        low = value & 0xffffffffffffffff
        high = (value >> 64) & 0xffffffffffffffff
        val128 = p64(low) + p64(high)
        gef_print("pack128: {}".format(val128))

        gef_print("pack8-hex:   {}".format(p8(value & 0xff).hex()))
        gef_print("pack16-hex:  {}".format(p16(value & 0xffff).hex()))
        gef_print("pack32-hex:  {}".format(p32(value & 0xffffffff).hex()))
        gef_print("pack64-hex:  {}".format(p64(value & 0xffffffffffffffff).hex()))
        gef_print("pack128-hex: {}".format(val128.hex()))
        return


@register_command
class UnpackCommand(GenericCommand):
    """Translate string -> integer"""
    _cmdline_ = "unpack"
    _syntax_ = '{:s} [-h] "double-escaped string"'.format(_cmdline_)
    _example_ = '{:s} "\\\\x41\\\\x42\\\\x43\\\\x44"'.format(_cmdline_)
    _category_ = "Misc"

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 0:
            self.usage()
            return

        if "-h" in argv:
            self.usage()
            return

        try:
            value = codecs.escape_decode(argv[0])[0] + b"\0"*16
        except binascii.Error:
            gef_print("Could not decode '\\xXX' encoded string \"{}\"".format(argv[0]))
            return
        gef_print("unpack8:   {:#04x}".format(u8(value[:1])))
        gef_print("unpack16:  {:#06x}".format(u16(value[:2])))
        gef_print("unpack32:  {:#010x}".format(u32(value[:4])))
        gef_print("unpack64:  {:#018x}".format(u64(value[:8])))
        low, high = value[:8], value[8:16]
        gef_print("unpack128: {:#034x}".format((u64(high) << 64) | u64(low)))
        return


@register_command
class TohexCommand(GenericCommand):
    """Translate bytes -> hex"""
    _cmdline_ = "tohex"
    _syntax_ = '{:s} [-h] "double-escaped string"'.format(_cmdline_)
    _example_ = '{:s} "\\\\x41\\\\x42\\\\x43\\\\x44"'.format(_cmdline_)
    _category_ = "Misc"

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 0:
            self.usage()
            return

        if "-h" in argv:
            self.usage()
            return

        try:
            value = codecs.escape_decode(argv[0])[0]
        except binascii.Error:
            gef_print("Could not decode '\\xXX' encoded string \"{}\"".format(argv[0]))
            return

        gef_print(binascii.hexlify(value))
        return


@register_command
class UnhexCommand(GenericCommand):
    """Translate hex -> bytes"""
    _cmdline_ = "unhex"
    _syntax_ = '{:s} [-h] "hex string"'.format(_cmdline_)
    _example_ = "{:s} 41414242 43434444".format(_cmdline_)
    _category_ = "Misc"

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 0:
            self.usage()
            return

        if "-h" in argv:
            self.usage()
            return

        code = argv[0].replace(" ", "")
        try:
            value = binascii.unhexlify(code)
        except binascii.Error:
            gef_print("Could not unhexlify")
            return

        gef_print(value)
        return


@register_command
class ByteswapCommand(GenericCommand):
    """Translate endian (little-endian <-> big-endian)."""
    _cmdline_ = "byteswap"
    _syntax_ = "{:s} [-h] VALUE".format(_cmdline_)
    _example_ = "{:s} 0xdeadbeef".format(_cmdline_)
    _category_ = "Misc"

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 0:
            self.usage()
            return

        if "-h" in argv:
            self.usage()
            return

        try:
            x = int(argv[0], 0)
        except:
            self.usage()
            return

        def p(a):
            return struct.pack("<I",a&0xffffffff)

        def ube(a):
            return struct.unpack(">I",a)[0]

        def pQ(a):
            return struct.pack("<Q",a&0xffffffffffffffff)

        def uQbe(a):
            return struct.unpack(">Q",a)[0]

        converted32 = ube(p(x))
        converted64 = uQbe(pQ(x))

        gef_print("{:#x} -> 64bit byteswap -> {:#x}".format(x, converted64))
        gef_print("{:#x} -> 32bit byteswap -> {:#x}".format(x & 0xffffffff, converted32))
        return


@register_command
class VersionCommand(GenericCommand):
    """Display GEF version info."""
    _cmdline_ = "version"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}".format(_cmdline_)
    _category_ = "GEF Maintenance Command"

    def gef_version(self):
        gef_fpath = os.path.abspath(os.path.realpath(os.path.expanduser(inspect.stack()[0][1])))
        gef_dir = os.path.dirname(gef_fpath)
        gef_hash = hashlib.sha1(open(gef_fpath, "rb").read()).hexdigest()

        if os.access("{}/.git".format(gef_dir), os.X_OK):
            ver = subprocess.check_output('git log --format="%H" -n 1 HEAD', cwd=gef_dir, shell=True).decode("utf8").strip()
            extra = "dirty" if len(subprocess.check_output('git ls-files -m', cwd=gef_dir, shell=True).decode("utf8").strip()) else "clean"
            return "rev:{} (Git - {}) SHA1: {}".format(ver, extra, gef_hash)
        else:
            return "(Standalone) SHA1:{}".format(gef_hash)

    def gdb_version(self):
        try:
            return gdb.VERSION # GDB >= 8.1 (or earlier?)
        except AttributeError:
            return gdb.execute('show version', to_string=True).split('\n')[0]

    def python_version(self):
        return sys.version.replace('\n', ' ')

    def capstone_version(self):
        try:
            capstone = sys.modules['capstone']
            return '.'.join(map(str, capstone.cs_version()))
        except KeyError:
            return 'not found'

    def keystone_version(self):
        try:
            keystone = sys.modules['keystone']
            return '.'.join(map(str, keystone.ks_version()))
        except KeyError:
            return 'not found'

    def unicorn_version(self):
        try:
            unicorn = sys.modules['unicorn']
            return unicorn.__version__
        except KeyError:
            return 'not found'

    def ropper_version(self):
        try:
            ropper = sys.modules['ropper']
            return '.'.join(map(str, ropper.VERSION))
        except KeyError:
            return 'not found'

    def readelf_version(self):
        try:
            command = which("readelf")
            res = gef_execute_external([command, "-v"], as_list=True)
            return res[0]
        except IOError:
            return 'not found'

    def objdump_version(self):
        try:
            command = which("objdump")
            res = gef_execute_external([command, "-v"], as_list=True)
            return res[0]
        except IOError:
            return 'not found'

    def seccomp_tools_version(self):
        try:
            command = which("seccomp-tools")
            res = gef_execute_external([command, "--version"], as_list=True)
            return res[0]
        except IOError:
            return 'not found'

    def one_gadget_version(self):
        try:
            command = which("one_gadget")
            res = gef_execute_external([command, "--version"], as_list=True)
            return res[0]
        except IOError:
            return 'not found'

    def qemu_version(self):
        return gdb.execute('monitor info version', to_string=True).strip()

    def kernel_version(self):
        try:
            command = which("uname")
            res = gef_execute_external([command, "-a"], as_list=True)
            return res[0]
        except IOError:
            return 'not found'

    def do_invoke(self, argv):
        self.dont_repeat()

        gef_print("Kernel:        \t{:s}".format(self.kernel_version()))
        gef_print("GEF:           \t{:s}".format(self.gef_version()))
        gef_print("Gdb:           \t{:s}".format(self.gdb_version()))
        gef_print("Python:        \t{:s}".format(self.python_version()))
        gef_print("Capstone:      \t{:s}".format(self.capstone_version()))
        gef_print("Keystone:      \t{:s}".format(self.keystone_version()))
        gef_print("Unicorn:       \t{:s}".format(self.unicorn_version()))
        gef_print("Ropper:        \t{:s}".format(self.ropper_version()))
        gef_print("readelf:       \t{:s}".format(self.readelf_version()))
        gef_print("objdump:       \t{:s}".format(self.objdump_version()))
        gef_print("seccomp-tools: \t{:s}".format(self.seccomp_tools_version()))
        gef_print("one_gadget:    \t{:s}".format(self.one_gadget_version()))

        if is_qemu_system():
            gef_print("qemu:          \t{:s}".format(self.qemu_version()))
        return


class KernelAddressHeuristicFinder:
    """A class that heuristically finds a specific symbol in the kernel."""

    @staticmethod
    def get_saved_command_line():
        # plan 1
        cmdline_proc_show = get_ksymaddr("cmdline_proc_show")
        if cmdline_proc_show:
            res = gdb.execute("x/10i {:#x}".format(cmdline_proc_show), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"DWORD PTR ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"ldr\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_init_task():
        # plan 1 (directly)
        init_task = get_ksymaddr("init_task")
        if init_task:
            return init_task

        # plan 2 (available v2.6.29.3 or later)
        chroot_fs_refs = get_ksymaddr("chroot_fs_refs")
        if chroot_fs_refs:
            res = gdb.execute("x/30i {:#x}".format(chroot_fs_refs), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                count = 0
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            addr = base + int(m.group(1), 16) # add 1 time
                            if count == 1:
                                return addr # 2nd pair of (adrp + add) is target
                            else:
                                base = None
                                count += 1
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_init_cred():
        # plan 1 (directly)
        init_cred = get_ksymaddr("init_cred")
        if init_cred:
            return init_cred

    @staticmethod
    def get_modules():
        # plan 1 (directly)
        modules = get_ksymaddr("modules")
        if modules:
            return modules

        # plan 2 (available v3.7.5 or later)
        find_module_all = get_ksymaddr("find_module_all")
        if find_module_all:
            res = gdb.execute("x/20i {:#x}".format(find_module_all), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                bases = {}
                add1time = {}
                for line in res.splitlines():
                    m = re.search(r"adrp\s+(\S+),\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        base = int(m.group(2), 16)
                        bases[reg] = base
                        continue
                    m = re.search(r"add\s+(\S+),\s*(\S+),\s*#(0x\w+)", line)
                    if m:
                        dstreg = m.group(1)
                        srcreg = m.group(2)
                        v = int(m.group(3), 16)
                        if srcreg in bases:
                            add1time[dstreg] = bases[srcreg] + v
                            continue
                    m = re.search(r"ldr\s+\S+,\s*\[(\S+),\s*#(\d+)\]", line)
                    if m:
                        srcreg = m.group(1)
                        v = int(m.group(2), 0)
                        if srcreg in add1time:
                            return add1time[srcreg] + v
            elif is_arm32():
                bases = {}
                add1time = {}
                for line in res.splitlines():
                    m = re.search(r"movw\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        base = int(m.group(2), 16)
                        bases[reg] = base
                        continue
                    m = re.search(r"movt\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        v = int(m.group(2), 16) << 16
                        if reg in bases:
                            add1time[reg] = bases[reg] + v
                            continue
                    m = re.search(r"ldr\s+\S+,\s*\[(\S+),\s*#(\d+)\]", line)
                    if m:
                        reg = m.group(1)
                        v = int(m.group(2), 0)
                        if reg in add1time:
                            return add1time[reg] + v
        return None

    @staticmethod
    def get_chrdevs():
        # plan 1 (directly)
        chrdevs = get_ksymaddr("chrdevs")
        if chrdevs:
            return chrdevs

        # plan 2
        chrdev_show = get_ksymaddr("chrdev_show")
        if chrdev_show:
            res = gdb.execute("x/30i {:#x}".format(chrdev_show), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[.*\*8([-+]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"\[.*\*4([+-]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                count = 0
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            addr = base + int(m.group(1), 16) # add 1 time
                            if count == 1:
                                return addr # 2nd pair of (adrp + add) is target
                            else:
                                base = None
                                count += 1
            elif is_arm32():
                bases = {}
                add1time = {}
                for line in res.splitlines():
                    m = re.search(r"movw\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        base = int(m.group(2), 16)
                        bases[reg] = base
                        continue
                    m = re.search(r"movt\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        v = int(m.group(2), 16) << 16
                        if reg in bases:
                            add1time[reg] = bases[reg] + v
                            continue
                    m = re.search(r"ldr\s+\S+,\s*\[(\S+),.*#\d+\]", line)
                    if m:
                        reg = m.group(1)
                        if reg in add1time:
                            return add1time[reg]
            return None

    @staticmethod
    def get_cdev_map():
        # plan 1 (directly)
        cdev_map = get_ksymaddr("cdev_map")
        if cdev_map:
            return cdev_map

        # plan 2
        cdev_del = get_ksymaddr("cdev_del")
        if cdev_del:
            res = gdb.execute("x/30i {:#x}".format(cdev_del), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"ldr\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                bases = {}
                add1time = {}
                for line in res.splitlines():
                    m = re.search(r"movw\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        base = int(m.group(2), 16)
                        bases[reg] = base
                        continue
                    m = re.search(r"movt\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        v = int(m.group(2), 16) << 16
                        if reg in bases:
                            add1time[reg] = bases[reg] + v
                            continue
                    m = re.search(r"ldr\s+\S+,\s*\[(\S+),\s*#(\d+)\]", line)
                    if m:
                        reg = m.group(1)
                        v = int(m.group(2), 0)
                        if reg in add1time:
                            return add1time[reg] + v
        return None

    @staticmethod
    def get_sys_call_table():
        # plan 1 (directly)
        sys_call_table = get_ksymaddr("sys_call_table")
        if sys_call_table:
            return sys_call_table

        if is_x86_64():
            # plan 2 (available v4.6-rc1 or later)
            do_syscall_64 = get_ksymaddr("do_syscall_64")
            if do_syscall_64:
                res = gdb.execute("x/30i {:#x}".format(do_syscall_64), to_string=True)
                for line in res.splitlines():
                    m = re.search(r"[DQ]WORD PTR \[.*\*8([-+]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
        elif is_x86_32():
            # plan 2 (available v4.6-rc1 or later)
            do_int80_syscall_32 = get_ksymaddr("do_int80_syscall_32")
            if do_int80_syscall_32:
                res = gdb.execute("x/20i {:#x}".format(do_int80_syscall_32), to_string=True)
                for line in res.splitlines():
                    m = re.search(r"\[eax\*4([+-]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
        elif is_arm32():
            # plan 2 is nothing
            # because `sys_call_table` symbol is embeded in .text area
            pass
        elif is_arm64():
            # plan 2 (available v4.19-rc1 or later)
            el0_svc_handler = get_ksymaddr("el0_svc_handler")
            if el0_svc_handler:
                res = gdb.execute("x/20i {:#x}".format(el0_svc_handler), to_string=True)
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 16)
            # plan 3 (available v3.7-rc1 or later)
            el0_svc = get_ksymaddr("el0_svc")
            if el0_svc:
                res = gdb.execute("x/20i {:#x}".format(el0_svc), to_string=True)
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 16)
        return None

    @staticmethod
    def get_per_cpu_offset():
        # plan 1 (directly)
        __per_cpu_offset = get_ksymaddr("__per_cpu_offset")
        if __per_cpu_offset:
            return __per_cpu_offset

        # plan 2
        nr_iowait_cpu = get_ksymaddr("nr_iowait_cpu")
        if nr_iowait_cpu:
            res = gdb.execute("x/10i {:#x}".format(nr_iowait_cpu), to_string=True)
            if is_x86():
                # pattern 1
                for line in res.splitlines():
                    m = re.search(r"add.*[DQ]WORD PTR \[.*([-+]0x\S+)\]", line)
                    if m:
                        if is_64bit():
                            v = int(m.group(1), 16) & 0xffffffffffffffff
                            if v != 0:
                                return v
                        else:
                            v = int(m.group(1), 16) & 0xffffffff
                            if v != 0:
                                return v
                # pattern 2
                for line in res.splitlines():
                    m = re.search(r"DWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 16)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_slab_caches():
        # plan 1 (directly)
        slab_caches = get_ksymaddr("slab_caches")
        if slab_caches:
            return slab_caches

        # plan 2 (available v4.9-rc1 or later)
        slub_cpu_dead = get_ksymaddr("slub_cpu_dead")
        if slub_cpu_dead:
            res = gdb.execute("x/20i {:#x}".format(slub_cpu_dead), to_string=True)
            if is_x86():
                count = 0
                for line in res.splitlines():
                    m = re.search(r"(?:# |,)(0x\S{8,})", line)
                    if not m:
                        continue
                    if count == 1:
                        return int(m.group(1), 16)
                    count += 1
            elif is_arm64():
                count = 0
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            addr = base + int(m.group(1), 16) # add 1 time
                            if count == 1:
                                return addr # 2nd pair of (adrp + add) is target
                            else:
                                base = None
                                count += 1
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)

        # plan 3 (available v4.10.17 or before)
        memcg_update_all_caches = get_ksymaddr("memcg_update_all_caches")
        if memcg_update_all_caches:
            res = gdb.execute("x/20i {:#x}".format(memcg_update_all_caches), to_string=True)
            if is_x86():
                for line in res.splitlines():
                    m = re.search(r"(?:# |,)(0x\S{8,})", line)
                    if m:
                        if is_64bit():
                            return int(m.group(1), 16) & 0xffffffffffffffff
                        else:
                            return int(m.group(1), 16) & 0xffffffff
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 16)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_modprobe_path():
        # plan 1 (directly)
        modprobe_path = get_ksymaddr("modprobe_path")
        if modprobe_path:
            return modprobe_path

        # plan 2 (available v3.11-rc1 or later)
        request_module = get_ksymaddr("__request_module")
        if request_module:
            res = gdb.execute("x/30i {:#x}".format(request_module), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"ldrb\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                addr = 0
                for line in res.splitlines():
                    m = re.search(r"movw.*;\s*(0x\S+)", line)
                    if m:
                        addr_high = addr & 0xffff0000
                        addr = addr_high | int(m.group(1), 16)
                        continue
                    m = re.search(r"movt.*;\s*(0x\S+)", line)
                    if m:
                        addr_low = addr & 0xffff
                        addr = (int(m.group(1), 16) << 16) | addr_low
                        continue
                    if "ldrb" in line:
                        return addr
        return None

    @staticmethod
    def get_poweroff_cmd():
        # plan 1 (directly)
        poweroff_cmd = get_ksymaddr("poweroff_cmd")
        if poweroff_cmd:
            return poweroff_cmd

        # plan 2 (available v4.1-rc1 or later)
        poweroff_work_func = get_ksymaddr("poweroff_work_func")
        if poweroff_work_func:
            res = gdb.execute("x/20i {:#x}".format(poweroff_work_func), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"mov\s+rdi\s*,\s*(0x\w+)", line) # search run_cmd
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
                for line in res.splitlines():
                    m = re.search(r"mov\s+rsi\s*,\s*(0x\w+)", line) # search argv_split
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"mov\s+e[a-d]x\s*,\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                bases = {}
                add1time = {}
                for line in res.splitlines():
                    m = re.search(r"adrp\s+(\S+),\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        base = int(m.group(2), 16)
                        bases[reg] = base
                        continue
                    m = re.search(r"add\s+(\S+),\s*(\S+),\s*#(0x\w+)", line)
                    if m:
                        dstreg = m.group(1)
                        srcreg = m.group(2)
                        v = int(m.group(3), 16)
                        if srcreg in add1time:
                            return add1time[srcreg] + v
                        if srcreg in bases:
                            add1time[dstreg] = bases[srcreg] + v
                            continue
            elif is_arm32():
                addr = 0
                for line in res.splitlines():
                    m = re.search(r"ldr.*;\s*(0x\S+)", line)
                    if m:
                        addr = int(m.group(1), 16)
                        try:
                            return read_int_from_memory(addr)
                        except:
                            pass
        return None

    @staticmethod
    def get_reboot_cmd():
        # plan 1 (directly)
        reboot_cmd = get_ksymaddr("reboot_cmd")
        if reboot_cmd:
            return reboot_cmd

        # plan 2 (available v4.1-rc1 or later)
        reboot_work_func = get_ksymaddr("reboot_work_func")
        if reboot_work_func:
            res = gdb.execute("x/10i {:#x}".format(reboot_work_func), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"mov\s+rdi\s*,\s*(0x\w+)", line) # search run_cmd
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
                for line in res.splitlines():
                    m = re.search(r"mov\s+rsi\s*,\s*(0x\w+)", line) # search argv_split
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"mov\s+e[a-d]x\s*,\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 16)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_core_pattern():
        # plan 1 (directly)
        core_pattern = get_ksymaddr("core_pattern")
        if core_pattern:
            return core_pattern

        # plan 2 (available v3.6-rc1 or later)
        validate_coredump_safety = get_ksymaddr("validate_coredump_safety.part.0")
        if validate_coredump_safety:
            res = gdb.execute("x/10i {:#x}".format(validate_coredump_safety), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"ldrb\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                addr = 0
                for line in res.splitlines():
                    m = re.search(r"movw.*;\s*(0x\S+)", line)
                    if m:
                        addr_high = addr & 0xffff0000
                        addr = addr_high | int(m.group(1), 16)
                        continue
                    m = re.search(r"movt.*;\s*(0x\S+)", line)
                    if m:
                        addr_low = addr & 0xffff
                        addr = (int(m.group(1), 16) << 16) | addr_low
                        continue
                    if "ldrb" in line:
                        return addr

        # plan 3 (available v3.6-rc1 or later)
        proc_dostring_coredump = get_ksymaddr("proc_dostring_coredump")
        if proc_dostring_coredump:
            res = gdb.execute("x/50i {:#x}".format(proc_dostring_coredump), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                    if m:
                        base = int(m.group(1), 16)
                        continue
                    if base:
                        m = re.search(r"ldrb\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                addr = 0
                for line in res.splitlines():
                    m = re.search(r"movw.*;\s*(0x\S+)", line)
                    if m:
                        addr_high = addr & 0xffff0000
                        addr = addr_high | int(m.group(1), 16)
                        continue
                    m = re.search(r"movt.*;\s*(0x\S+)", line)
                    if m:
                        addr_low = addr & 0xffff
                        addr = (int(m.group(1), 16) << 16) | addr_low
                        continue
                    if "ldrb" in line:
                        return addr
        return None

    @staticmethod
    def get_n_tty_ops():
        # plan 1 (directly)
        n_tty_ops = get_ksymaddr("n_tty_ops")
        if n_tty_ops:
            return n_tty_ops

        # plan 2 (available v4.6-rc1 or later)
        n_tty_inherit_ops = get_ksymaddr("n_tty_inherit_ops")
        if n_tty_inherit_ops:
            res = gdb.execute("x/20i {:#x}".format(n_tty_inherit_ops), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"mov\s+r\S+,\s*(0x\S+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r",\s*DWORD PTR \[.*([+-]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
                for line in res.splitlines():
                    m = re.search(r"mov\s+\S+,\s*(0x[0-9a-f]{8})", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_tty_ldiscs():
        # plan 1 (directly)
        tty_ldiscs = get_ksymaddr("tty_ldiscs")
        if tty_ldiscs:
            return tty_ldiscs

        # plan 2 (available v2.6.37-rc2 or later)
        tty_register_ldisc = get_ksymaddr("tty_register_ldisc")
        if tty_register_ldisc:
            res = gdb.execute("x/20i {:#x}".format(tty_register_ldisc), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[.*\*8([-+]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"DWORD PTR \[.*\*4([+-]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 0) + 8
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16) + 4
        return None

    @staticmethod
    def get_mmap_min_addr():
        # plan 1 (directly)
        mmap_min_addr = get_ksymaddr("mmap_min_addr")
        if mmap_min_addr:
            return mmap_min_addr

        # plan 2 (available v4.19.27 or later)
        expand_downwards = get_ksymaddr("expand_downwards")
        if expand_downwards:
            res = gdb.execute("x/20i {:#x}".format(expand_downwards), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"ldr\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_vdso_info():
        # plan 1 (directly)
        vdso_info = get_ksymaddr("vdso_info")
        if vdso_info:
            return vdso_info

        # plan 2 (available v5.3-rc1 or later)
        if is_arm64():
            vdso_init = get_ksymaddr("__vdso_init")
            if vdso_init:
                res = gdb.execute("x/20i {:#x}".format(vdso_init), to_string=True)
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 0)
        return None


@register_command
class KernelbaseCommand(GenericCommand):
    """Show kernel base address."""
    _cmdline_ = "kbase"
    _syntax_ = _cmdline_
    _category_ = "Qemu-system Cooperation"

    @staticmethod
    @lru_cache()
    def get_maps():
        maps = []
        res = get_maps_by_pagewalk("pagewalk -q --simple")
        res = sorted(set(res.splitlines()))
        res = list(filter(lambda line: line.endswith("]"), res))
        res = list(filter(lambda line: not "[+]" in line, res))
        res = list(filter(lambda line: not "*" in line, res))

        if is_x86():
            for line in res:
                line = line.split()
                if line[6] != "KERN":
                    continue
                vaddr = int(line[0].split("-")[0], 16)
                size = int(line[2], 16)
                perm = line[5][1:] # [xxx
                maps.append([vaddr, size, perm])

        elif is_arm32():
            for line in res:
                line = line.split()
                if line[5] != "[PL0/---":
                    continue
                vaddr = int(line[0].split("-")[0], 16)
                size = int(line[2], 16)
                perm = line[6][4:7] # PL1/xxx
                maps.append([vaddr, size, perm])

        elif is_arm64():
            for line in res:
                line = line.split()
                if line[5] != "[EL0/---":
                    continue
                vaddr = int(line[0].split("-")[0], 16)
                size = int(line[2], 16)
                perm = line[6][4:7] # EL1/xxx
                maps.append([vaddr, size, perm])

        if maps == []:
            if is_x86():
                warn("Make sure you are in ring0 (=kernel mode)")
            elif is_arm32():
                warn("Make sure you are in supervisor mode (=kernel mode)")
                warn("Make sure qemu 3.x or higher")
            elif is_arm64():
                warn("Make sure you are in EL1 (=kernel mode)")
                warn("Make sure qemu 3.x or higher")
            return None
        else:
            return maps

    @staticmethod
    def get_kernel_base(maps):
        for vaddr, size, perm in maps:
            if perm == "R-X" and size >= 0x100000:
                return vaddr, size
        # not found, maybe old kernel
        for vaddr, size, perm in maps:
            if perm == "RWX" and size >= 0x100000:
                return vaddr, size
        return None, None

    @staticmethod
    def get_kernel_rodata_base(maps, kbase):
        def search_perm(target_perm):
            found = False
            ro = None
            for vaddr, size, perm in maps:
                if found == False:
                    if vaddr == kbase: # search kernel base
                        found = True
                    continue
                if found == True:
                    if perm == target_perm: # kernel data is next to kernel base
                        if ro is None:
                            ro = [vaddr, size]
                        elif ro[0] + ro[1] == vaddr:
                            ro = [ro[0], ro[1] + size] # merge contiguous region
            return ro

        res = search_perm("R--")
        if res is None:
            res = search_perm("R-X") # old kernel
            if res is None:
                res = search_perm("RWX") # old kernel
                if res is None:
                    return None, None

        return res[0], res[1]

    @staticmethod
    def get_kernel_rwdata_base(maps, krobase):
        def search_perm(target_perm):
            found = False
            rw = None
            for vaddr, size, perm in maps:
                if found == False:
                    if vaddr == krobase: # search kernel rodata base
                        found = True
                    continue
                if found == True:
                    if perm == target_perm: # kernel data is next to kernel base
                        if rw is None:
                            rw = [vaddr, size]
                        elif rw[0] + rw[1] == vaddr:
                            rw = [rw[0], rw[1] + size] # merge contiguous region
            return rw

        res = search_perm("RW-")
        if res is None:
            res = search_perm("RWX") # old kernel
            if res is None:
                return None, None

        return res[0], res[1]

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        # resolve kbase, krobase
        info("Wait for memory scan")
        maps = self.get_maps() # [vaddr, size, perm]
        if maps is None:
            return None
        kbase, kbase_size = self.get_kernel_base(maps)
        if kbase is None:
            return None
        krobase, krobase_size = self.get_kernel_rodata_base(maps, kbase)
        if krobase is None:
            return None
        krwbase, krwbase_size = self.get_kernel_rwdata_base(maps, krobase)
        if krwbase is None:
            return None

        gef_print(titlify("Kernel base (heuristic)"))
        gef_print("kernel text:   {:#x} ({:#x} bytes)".format(kbase, kbase_size))
        gef_print("kernel rodata: {:#x} ({:#x} bytes)".format(krobase, krobase_size))
        gef_print("kernel data:   {:#x} ({:#x} bytes)".format(krwbase, krwbase_size))
        return


@register_command
class KernelVersionCommand(GenericCommand):
    """Display kernel version string under qemu-system."""
    _cmdline_ = "kversion"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def kernel_version(self):
        info("Wait for memory scan")
        maps = KernelbaseCommand.get_maps() # [vaddr, size, perm]
        if maps is None:
            return None
        kbase, kbase_size = KernelbaseCommand.get_kernel_base(maps)
        if kbase is None:
            return None
        krobase, krobase_size = KernelbaseCommand.get_kernel_rodata_base(maps, kbase)
        if krobase is None:
            return None
        krwbase, krwbase_size = KernelbaseCommand.get_kernel_rwdata_base(maps, krobase)
        if krwbase is None:
            return None

        # resolve area
        area = []
        for addr in maps:
            if addr[0] < kbase:
                continue
            if addr[0] >= krwbase:
                continue
            area.append([addr[0], addr[0]+addr[1]])
        if area == []:
            return None

        for start, end in area:
            data = read_memory(start, end-start)
            data = ''.join([chr(x) for x in data])
            r = re.findall("(Linux version (?:\d+\.[\d.]*\d)[ -~]+)", data)
            if not r:
                continue
            kernel_version_string = r[0]
            idx = data.find(kernel_version_string)
            return start + idx, kernel_version_string
        return None

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        ret = self.kernel_version()
        if ret is None:
            err("Parse failed")
            return
        addr, kernel_version_string = ret
        gef_print("{:#x}: {:s}".format(addr, kernel_version_string))
        return


@register_command
class KernelCmdlineCommand(GenericCommand):
    """Display kernel cmdline string under qemu-system."""
    _cmdline_ = "kcmdline"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def kernel_cmdline(self):
        saved_command_line = KernelAddressHeuristicFinder.get_saved_command_line()
        if saved_command_line is None:
            return None
        try:
            ptr = read_int_from_memory(saved_command_line)
            cmdline = read_cstring_from_memory(ptr)
            return ptr, cmdline
        except:
            return None

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        info("Wait for memory scan")

        ret = self.kernel_cmdline()
        if ret is None:
            err("Parse failed")
            return
        addr, kernel_cmdline_string = ret
        gef_print("{:#x}: '{:s}'".format(addr, kernel_cmdline_string))
        return


@register_command
class KernelTaskCommand(GenericCommand):
    """Display process list under qemu-system."""
    _cmdline_ = "ktask"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def get_task_list(self):
        init_task = KernelAddressHeuristicFinder.get_init_task()
        if init_task is None:
            err("Not found symbol")
            return None
        info("init_task: {:#x}".format(init_task))

        # search init_task->tasks
        for i in range(0x200):
            offset_tasks = i * current_arch.ptrsize
            pos = init_task + offset_tasks
            value_list = [pos]
            # validating candidate offset
            while True:
                # read check
                try:
                    pos = read_int_from_memory(pos)
                except: # memory read error
                    found = False
                    break
                # list validate
                if pos in value_list[1:]: # incomplete infinity loop detected
                    found = False
                    break
                if pos == value_list[0] and len(value_list) == 1: # self reference
                    found = False
                    break
                if pos == value_list[0] and len(value_list) > 1: # maybe link list
                    found = True
                    break
                value_list.append(pos)
            if found:
                info("offsetof(task_struct, tasks): {:#x}".format(offset_tasks))
                info("Number of tasks: {:d}".format(len(value_list)))
                return [x - offset_tasks for x in value_list]
        err("Not found init_task->tasks")
        return None

    def get_offset_comm(self, task_addrs):
        for i in range(0x300):
            offset_comm = i * current_arch.ptrsize
            valid = True
            for task in task_addrs:
                if not is_ascii_string(task + offset_comm):
                    valid = False
                    break
                s = read_cstring_from_memory(task + offset_comm)
                if s == "swapper/0": # Very common name, so for speeding up, we assume that offset is found
                    break
                if len(s) < 2:
                    valid = False
                    break
            if valid:
                info("offsetof(task_struct, comm): {:#x}".format(offset_comm))
                return offset_comm
        err("Not found task->comm[TASK_CMM_LEN]")
        return None

    def get_offset_cred(self, task_addrs, offset_comm):
        """
        struct task_struct {
        ...
            const struct cred __rcu        *real_cred;    // These may point to the same address
            const struct cred __rcu        *cred;         // These may point to the same address
        #ifdef CONFIG_KEYS
            struct key                     *cached_requested_key;
        #endif
            char                           comm[TASK_COMM_LEN];
        """
        # backward search from `comm`
        for i in range(0x100):
            offset_cred = offset_comm - ((i+1) * current_arch.ptrsize)
            for task in task_addrs:
                val1 = read_int_from_memory(task + offset_cred)
                val2 = read_int_from_memory(task + offset_cred - current_arch.ptrsize)
                if val1 == val2 and val1 != 0:
                    info("offsetof(task_struct, cred): {:#x}".format(offset_cred))
                    return offset_cred
        err("Not found task->cred")
        return None

    def get_offset_uid(self, init_task_cred_ptr):
        """
        struct cred {
            atomic_t    usage;
        #ifdef CONFIG_DEBUG_CREDENTIALS
            atomic_t    subscribers;    /* number of processes subscribed */
            void        *put_addr;
            unsigned    magic;
        #endif
            kuid_t        uid;         /* real UID of the task */
            kgid_t        gid;         /* real GID of the task */
            kuid_t        suid;        /* saved UID of the task */
            kgid_t        sgid;        /* saved GID of the task */
            kuid_t        euid;        /* effective UID of the task */
            kgid_t        egid;        /* effective GID of the task */
            kuid_t        fsuid;       /* UID for VFS ops */
            kgid_t        fsgid;       /* GID for VFS ops */
            unsigned    securebits;    /* SUID-less security management */
            kernel_cap_t    cap_inheritable; /* caps our children can inherit */
            kernel_cap_t    cap_permitted;    /* caps we're permitted */

        [Example x64]
            0xffffffff820460c0:     0x0000000000000004      0x0000000000000000
            0xffffffff820460d0:     0x0000000000000000      0x0000000000000000
            0xffffffff820460e0:     0x0000000000000000      0x0000000000000000
            0xffffffff820460f0:     0x0000003fffffffff      0x0000003fffffffff
            0xffffffff82046100:     0x0000003fffffffff      0x0000000000000000
            0xffffffff82046110:     0x0000000000000000      0x0000000000000000
        """
        init_task_cred = read_int_from_memory(init_task_cred_ptr)
        uid_gid_size = 4 * 8 # uid_t:4byte. len([uid,gid,suid,sgid,euid,egid,fsuid,fsgid]) == 8
        offset_uid = 4
        ret = read_memory(init_task_cred + offset_uid, uid_gid_size)
        if ret == b"\0"*uid_gid_size:
            pass
        else:
            offset_uid += 4 + current_arch.ptrsize + 4
        info("offsetof(cred, uid): {:#x}".format(offset_uid))
        return offset_uid

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        info("Wait for memory scan")

        task_addrs = self.get_task_list()
        if task_addrs is None:
            return

        offset_comm = self.get_offset_comm(task_addrs)
        if offset_comm is None:
            return

        offset_cred = self.get_offset_cred(task_addrs, offset_comm)
        if offset_cred is None:
            return

        offset_uid = self.get_offset_uid(task_addrs[0] + offset_cred)
        if offset_uid is None:
            return

        ids_str = ','.join(["uid","gid","suid","sgid","euid","egid","fsuid","fsgid"])
        fmt = "{:<18s}: {:<16s} {:<18s} [{}]"
        legend = ["task", "task->comm", "task->cred", ids_str]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for task in task_addrs:
            comm_string = read_cstring_from_memory(task + offset_comm)
            cred = read_int_from_memory(task + offset_cred)
            uids = [u32(read_memory(cred + offset_uid + j * 4, 4)) for j in range(8)]
            gef_print("{:#018x}: {:<16s} {:#018x} {}".format(task, comm_string, cred, uids))
        return

@register_command
class KernelModuleCommand(GenericCommand):
    """Display module list under qemu-system."""
    _cmdline_ = "kmod"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def get_modules_list(self):
        modules = KernelAddressHeuristicFinder.get_modules()
        if modules is None:
            err("Not found symbol")
            return None
        info("modules: {:#x}".format(modules))

        module_addrs = []
        current = modules
        while True:
            addr = read_int_from_memory(current)
            if addr == modules:
                break
            module_addrs.append(addr)
            current = addr
        return module_addrs

    def get_offset_name(self, module_addrs):
        for i in range(0x100):
            offset_name = i * current_arch.ptrsize
            valid = True
            for module in module_addrs:
                if not is_ascii_string(module + offset_name):
                    valid = False
                    break
                s = read_cstring_from_memory(module + offset_name)
                if len(s) < 2:
                    valid = False
                    break
            if valid:
                info("offsetof(module, name): {:#x}".format(offset_name))
                return offset_name
        err("Not found module->name[MODULE_NAME_LEN]]")
        return None

    def get_offset_layout(self, module_addrs):
        """
            struct module {
                enum module_state state;
                /* Member of list of modules */
                struct list_head list;
                /* Unique handle for this module */
                char name[MODULE_NAME_LEN];
            #ifdef CONFIG_STACKTRACE_BUILD_ID
                /* Module build ID */
                unsigned char build_id[BUILD_ID_SIZE_MAX];
            #endif
                /* Sysfs stuff. */
                struct module_kobject mkobj;
                struct module_attribute *modinfo_attrs;
                const char *version;
                const char *srcversion;
                struct kobject *holders_dir;
                /* Exported symbols */
                const struct kernel_symbol *syms;
                const s32 *crcs;
                unsigned int num_syms;
            #ifdef CONFIG_CFI_CLANG
                cfi_check_fn cfi_check;
            #endif
                /* Kernel parameters. */
            #ifdef CONFIG_SYSFS
                struct mutex param_lock;
            #endif
                struct kernel_param *kp;
                unsigned int num_kp;
                /* GPL-only exported symbols. */
                unsigned int num_gpl_syms;
                const struct kernel_symbol *gpl_syms;
                const s32 *gpl_crcs;
                bool using_gplonly_symbols;
            #ifdef CONFIG_MODULE_SIG
                /* Signature was verified. */
                bool sig_ok;
            #endif
                bool async_probe_requested;
                /* Exception table */
                unsigned int num_exentries;
                struct exception_table_entry *extable;
                /* Startup function. */
                int (*init)(void);
                /* Core layout: rbtree is accessed frequently, so keep together. */
                struct module_layout core_layout __module_layout_align;
                struct module_layout init_layout;
                ...
        }

        struct module_layout {
            /* The actual code + data. */
            void *base;
            /* Total size. */
            unsigned int size;
            /* The size of the executable code.  */
            unsigned int text_size;
            /* Size of RO section of the module (text+rodata) */
            unsigned int ro_size;
            /* Size of RO after init section */
            unsigned int ro_after_init_size;
        #ifdef CONFIG_MODULES_TREE_LOOKUP
            struct mod_tree_node mtn;
        #endif
        };

        [Example arm32]
            gef> x/128xw 0x00000000bf22b084
            0xbf22b084:     0xbf1bb044      0xc1696530      0x00006773      0x00000000
            0xbf22b094:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b0a4:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b0b4:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b0c4:     0x00000000      0xc1ec2d00      0xc1a11d80      0xbf1bb08c
            0xbf22b0d4:     0xc1a11d8c      0xc1a11d80      0xc1628e38      0xc8e0b2c0
            0xbf22b0e4:     0x00000003      0x00000007      0xbf22b080      0x00000000
            0xbf22b0f4:     0xc8d4f380      0x00000000      0xc1e47400      0xc8f6d900
            0xbf22b104:     0xc8f6d080      0xc8004300      0x00000000      0x00000000
            0xbf22b114:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b124:     0xbf22b124      0xbf22b124      0xbf22a990      0x00000003
            0xbf22b134:     0x00000000      0x00000000      0x00000000      0x00000001
            0xbf22b144:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b154:     0x00000000      0xbf17e000      0x00000000      0x00000000
            0xbf22b164:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b174:     0x00000000      0x00000000      0x00000000      0xbf225000 <- init_layout.base
            0xbf22b184:     0x00008000      0x00005000      0x00006000      0x00006000
        """
        for i in range(300):
            offset_layout = i * current_arch.ptrsize
            valid = True
            for module in module_addrs:
                # base align check
                cand_base = read_int_from_memory(module + offset_layout)
                if cand_base == 0 or cand_base & 0xfff:
                    valid = False
                    break
                # size align check
                cand_size = u32(read_memory(module + offset_layout + current_arch.ptrsize + 4*0, 4))
                if cand_size == 0 or cand_size & 0xfff:
                    valid = False
                    break
                # text_size align check
                cand_text_size = u32(read_memory(module + offset_layout + current_arch.ptrsize + 4*1, 4))
                if cand_text_size == 0 or cand_text_size & 0xfff:
                    valid = False
                    break
                # ro_size align check
                cand_ro_size = u32(read_memory(module + offset_layout + current_arch.ptrsize + 4*2, 4))
                if cand_ro_size == 0 or cand_ro_size & 0xfff:
                    valid = False
                    break
                # ro_after_init_size align check
                cand_ro_after_init_size = u32(read_memory(module + offset_layout + current_arch.ptrsize + 4*3, 4))
                if cand_ro_after_init_size == 0 or cand_ro_after_init_size & 0xfff:
                    valid = False
                    break
            if valid:
                info("offsetof(module, init_layout): {:#x}".format(offset_layout))
                return offset_layout
        err("Not found module->init_layout")
        return None

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        info("Wait for memory scan")

        module_addrs = self.get_modules_list()
        if module_addrs is None:
            return

        offset_name = self.get_offset_name(module_addrs)
        if offset_name is None:
            return

        offset_layout = self.get_offset_layout(module_addrs)
        if offset_layout is None:
            return

        fmt = "{:<18s}: {:<18s} {:<18s} {:<18s}"
        legend = ["module", "module->name", "base", "size"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for module in module_addrs:
            name_string = read_cstring_from_memory(module + offset_name)
            base = read_int_from_memory(module + offset_layout)
            size = u32(read_memory(module + offset_layout + 4, 4))
            gef_print("{:#018x}: {:<18s} {:#018x} {:#018x}".format(module, name_string, base, size))
        return


@register_command
class KernelCharacterDevicesCommand(GenericCommand):
    """Display character device list under qemu-system."""
    _cmdline_ = "kcdev"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    # character device is managed at chrdevs[] and cdev_map.
    # we use each of them for getting structure information.

    def get_chrdev_list(self): # [chrdev, chrdev, chrdev, ...]
        """
        #define CHRDEV_MAJOR_HASH_SIZE 255
        static struct char_device_struct {
            struct char_device_struct *next;
            unsigned int major;
            unsigned int baseminor;
            int minorct;
            char name[64];
            struct cdev *cdev;		/* will die */
        } *chrdevs[CHRDEV_MAJOR_HASH_SIZE];
        """
        chrdevs = KernelAddressHeuristicFinder.get_chrdevs()
        if chrdevs is None:
            err("Not found symbol")
            return None
        info("chrdevs: {:#x}".format(chrdevs))

        chrdev_addrs = []
        for i in range(255):
            addr = read_int_from_memory(chrdevs + i * current_arch.ptrsize)
            while addr and addr not in chrdev_addrs:
                chrdev_addrs.append(addr)
                addr = read_int_from_memory(addr)
        return chrdev_addrs

    def get_cdev_list(self): # [[cdev, major, minor], [...] ...]
        """
        struct kobj_map {
            struct probe {
                struct probe *next;
                dev_t dev;
                unsigned long range;
                struct module *owner;
                kobj_probe_t *get;
                int (*lock)(dev_t, void *);
                void *data;                  // -> cdev
            } *probes[255];
            struct mutex *lock;
        };
        static struct kobj_map *cdev_map;

        struct cdev {
            struct kobject kobj;
            struct module *owner;
            const struct file_operations *ops;
            struct list_head list;
            dev_t dev;
            unsigned int count;
        } __randomize_layout;

        struct kobject {
            const char *name;
            struct list_head entry;
            struct kobject *parent;
            struct kset *kset;
            const struct kobj_type *ktype;
            struct kernfs_node *sd; /* sysfs directory entry */
            struct kref kref;
        #ifdef CONFIG_DEBUG_KOBJECT_RELEASE
            struct delayed_work release;
        #endif
            unsigned int state_initialized:1;
            unsigned int state_in_sysfs:1;
            unsigned int state_add_uevent_sent:1;
            unsigned int state_remove_uevent_sent:1;
            unsigned int uevent_suppress:1;
        };
        """
        cdev_map = KernelAddressHeuristicFinder.get_cdev_map()
        if cdev_map is None:
            err("Not found symbol")
            return None
        info("cdev_map: {:#x}".format(cdev_map))

        try:
            cdev_map_ = read_int_from_memory(cdev_map)
            info("*cdev_map: {:#x}".format(cdev_map_))
        except:
            err("cdev_map is not initialized")
            return None

        cdev_addrs = []
        seen = []
        for i in range(255):
            addr = read_int_from_memory(cdev_map_ + i * current_arch.ptrsize)
            while addr:
                cdev = read_int_from_memory(addr + 6 * current_arch.ptrsize)
                dev = u32(read_memory(addr + current_arch.ptrsize, 4))
                major = dev >> 20
                minor = dev & ((1<<20) - 1)
                if cdev and cdev not in seen:
                    cdev_addrs.append([cdev, major, minor])
                    seen.append(cdev)
                addr = read_int_from_memory(addr)
        return cdev_addrs

    def get_offset_ops(self, cdevs):
        for i in range(3, 0x20):
            offset_list = i * current_arch.ptrsize
            valid = True
            for cdev in cdevs:
                pos_next = cdev + offset_list
                pos_prev = cdev + offset_list + current_arch.ptrsize
                list_entry_next = [pos_next]
                list_entry_prev = [pos_prev]
                while valid:
                    # read check
                    try:
                        pos_next = read_int_from_memory(pos_next)
                        pos_prev = read_int_from_memory(pos_prev) + current_arch.ptrsize
                    except: # memory read error
                        valid = False
                        break
                    # list validate
                    if pos_next in list_entry_next[1:]: # incomplete infinity loop detected
                        valid = False
                        break
                    if pos_prev in list_entry_prev[1:]: # incomplete infinity loop detected
                        valid = False
                        break
                    if pos_next == list_entry_next[0] and pos_prev == list_entry_prev[0]:
                        break
                    list_entry_next.append(pos_next)
                    list_entry_prev.append(pos_prev)
                if not valid:
                    break
            else:
                # for loop is finished until last element
                if valid:
                    offset_ops = offset_list - current_arch.ptrsize
                    info("offsetof(cdev, ops): {:#x}".format(offset_ops))
                    return offset_ops
        err("Not found offsetof(cdev, ops)")
        return None

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        info("Wait for memory scan")

        chrdev_addrs = self.get_chrdev_list()
        if chrdev_addrs is None:
            return
        cdev_addrs = self.get_cdev_list()
        if cdev_addrs is None:
            return

        # merge chrdev (from chrdevs)
        merged = {}
        for chrdev in chrdev_addrs:
            major = u32(read_memory(chrdev + current_arch.ptrsize, 4))
            minor = u32(read_memory(chrdev + current_arch.ptrsize + 4, 4))
            name_string = read_cstring_from_memory(chrdev + current_arch.ptrsize + 4*3) or "<None>"
            off = chrdev + current_arch.ptrsize + 4*3 + 64
            while off % current_arch.ptrsize: # align
                off += 1
            cdev = read_int_from_memory(off)
            merged[major, minor] = {"chrdev":chrdev, "name":name_string, "cdev":cdev}

        # merge cdev (from cdev_map)
        for cdev, major, minor in cdev_addrs:
            kobj = read_int_from_memory(cdev)
            name_string = read_cstring_from_memory(kobj) or "<None>"

            if (major, minor) in merged:
                if merged[major, minor]["cdev"] == 0:
                    merged[major, minor]["cdev"] = cdev
                if merged[major, minor]["name"] == "<None>":
                    merged[major, minor]["name"] = name_string
            else:
                merged[major, minor] = {"chrdev": 0x0, "name":name_string, "cdev":cdev}

        # add ops info
        off_ops = self.get_offset_ops([v["cdev"] for k,v in merged.items() if v["cdev"]])
        if off_ops is None:
            return
        for k in merged.keys():
            if merged[k]["cdev"]:
                merged[k]["ops"] = read_int_from_memory(merged[k]["cdev"] + off_ops)
            else:
                merged[k]["ops"] = 0x0
            merged[k]["ops_sym"] = get_symbol_string(merged[k]["ops"])

        # add parent info
        for k in merged.keys():
            if merged[k]["cdev"]:
                parent = read_int_from_memory(merged[k]["cdev"] + current_arch.ptrsize * 3)
                merged[k]["parent"] = parent
                if parent:
                    name = read_int_from_memory(parent)
                    if name:
                        merged[k]["parent_name"] = read_cstring_from_memory(name) or "<None>"
                    else:
                        merged[k]["parent_name"] = "<None>"
                else:
                    merged[k]["parent_name"] = "<None>"
            else:
                merged[k]["parent"] = 0x0
                merged[k]["parent_name"] = "<None>"

        # print
        fmt = "{:<18s}: {:<18s} {:<6s} {:<6s} {:<18s} {:<18s} {:18s} {:<s}"
        legend = ["chrdev", "name", "major", "minor", "cdev", "cdev->kobj.parent", "parent_name", "cdev->ops"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for (major, minor), m in sorted(merged.items()):
            fmt = "{:#018x}: {:<18s} {:6d} {:6d} {:#018x} {:#018x} {:<18s} {:#018x}{:s}"
            gef_print(fmt.format(m["chrdev"], m["name"], major, minor, m["cdev"], m["parent"], m["parent_name"], m["ops"], m["ops_sym"]))
        return


@register_command
class KernelFopsCommand(GenericCommand):
    """Display fops members under qemu-system."""
    _cmdline_ = "kfops"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def get_member(self):
        members = [
            ["ptr", "owner"],
            ["func_ptr", "llseek"],
            ["func_ptr", "read"],
            ["func_ptr", "write"],
            ["func_ptr", "read_iter"],
            ["func_ptr", "write_iter"],
            ["func_ptr", "iopoll"],
            ["func_ptr", "iterate"],
            ["func_ptr", "iterate_shared"],
            ["func_ptr", "poll"],
            ["func_ptr", "unlocked_ioctl"],
            ["func_ptr", "compat_ioctl"],
            ["func_ptr", "mmap"],
            ["ulong",    "mmap_supported_flags"],
            ["func_ptr", "open"],
            ["func_ptr", "flush"],
            ["func_ptr", "release"],
            ["func_ptr", "fsync"],
            ["func_ptr", "fasync"],
            ["func_ptr", "lock"],
            ["func_ptr", "sendpage"],
            ["func_ptr", "get_unmapped_area"],
            ["func_ptr", "check_flags"],
            ["func_ptr", "flock"],
            ["func_ptr", "splice_write"],
            ["func_ptr", "splice_read"],
            ["func_ptr", "setlease"],
            ["func_ptr", "fallocate"],
            ["func_ptr", "show_fdinfo"],
            ["(func_ptr)", "(mmap_capabilities)"], # only exists when CONFIG_MMU
            ["func_ptr", "copy_file_range"],
            ["func_ptr", "remap_file_range"],
            ["func_ptr", "fadvise"],
        ]
        return members

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        members = self.get_member()

        if argv:
            try:
                addr = int(argv[0], 16)
                addrs = [read_int_from_memory(addr + current_arch.ptrsize * i) for i in range(len(members))]
            except:
                self.usage()
                return
            fmt = "[{:3s}] {:<10s} {:<20s} {:s}"
            legend = ["idx", "type", "name", "value"]
            gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
            for idx, ((type, name), address) in enumerate(zip(members, addrs)):
                sym = get_symbol_string(address)
                gef_print("[{:3d}] {:10s} {:20s} {:#018x}{:s}".format(idx, type, name, address, sym))
        else:
            fmt = "[{:3s}] {:<10s} {:<20s}"
            legend = ["idx", "type", "name"]
            gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
            for idx, (type, name) in enumerate(members):
                gef_print("[{:3d}] {:10s} {:20s}".format(idx, type, name))
        return


@register_command
class SyscallTableViewCommand(GenericCommand):
    """Display syscall_table entries under qemu-system."""
    _cmdline_ = "syscall-table-view"
    _syntax_ = "{:s} [-h] [--filter REGEX]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s}\n".format(_cmdline_)
    _example_ += "{:s} --filter write".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def syscall_table_view(self):
        sys_call_table_addr = KernelAddressHeuristicFinder.get_sys_call_table()
        if sys_call_table_addr is None:
            err("Not found symbol")
            return
        # scan
        i = 0
        seen = {}
        table = []
        while True:
            addr = sys_call_table_addr + i * current_arch.ptrsize
            syscall_function_addr = read_int_from_memory(addr)
            if is_x86() and syscall_function_addr % 0x10: # should be aligned
                break
            elif (is_arm32() or is_arm64()) and syscall_function_addr % current_arch.ptrsize: # should be aligned
                break
            try:
                read_int_from_memory(syscall_function_addr) # if entry is valid, no error
            except:
                break
            symbol = get_symbol_string(syscall_function_addr, nosymbol_string=" <NO_SYMBOL>")
            seen[syscall_function_addr] = seen.get(syscall_function_addr, 0) + 1
            table.append([i, addr, syscall_function_addr, symbol])
            i += 1
        # print
        fmt = "{:5s} {:18s}: {:18s} {:s}"
        legend = ["Index", "Table Address", "Function Address", "Symbol"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for i, addr, syscall_function_addr, symbol in table:
            if seen[syscall_function_addr] == 1: # valid entry
                msg = "[{:03d}] {:#018x}: {:#018x}{:s}".format(i, addr, syscall_function_addr, symbol)
            else: # invalid entry
                msg = "[{:03d}] {:#018x}: ".format(i, addr) + Color.grayify("{:#018x}{:s}".format(syscall_function_addr, symbol))
            if not self.filter:
                gef_print(msg)
            else:
                for filt in self.filter:
                    if re.search(filt, msg):
                        gef_print(msg)
        return

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_x86_32_64_or_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.filter = []
        while "--filter" in argv:
            idx = argv.index("--filter")
            pattern = argv[idx + 1]
            self.filter.append(pattern)
            argv = argv[:idx] + argv[idx+2:]

        if argv:
            self.usage()
            return

        self.syscall_table_view()
        return


@register_command
class AuxvCommand(GenericCommand):
    """Show ELF auxiliary vectors."""
    _cmdline_ = "auxv"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        auxval = gef_get_auxiliary_values()
        if not auxval:
            return None

        gef_print(titlify("ELF auxiliary vector"))
        for k, v in auxval.items():
            for num, name in AT_CONSTANTS.items():
                if k == name:
                    break
            else:
                num = -1
            if k == "AT_NULL":
                gef_print("[{:#4x}] {:16s} {:#x} (End of vector)".format(num, k+":", v))
            elif k in ["AT_EXECFN", "AT_PLATFORM"]:
                s = read_cstring_from_memory(v)
                gef_print("[{:#4x}] {:16s} {:#x}{:s}{}".format(num, k+":", v, RIGHT_ARROW, Color.yellowify(repr(s))))
            elif k in ["AT_RANDOM"]:
                s = read_int_from_memory(v)
                gef_print("[{:#4x}] {:16s} {:#x}{:s}{:#x}".format(num, k+":", v, RIGHT_ARROW, s))
            else:
                gef_print("[{:#4x}] {:16s} {:#x}".format(num, k+":", v))
        return


@register_command
class ArgvCommand(GenericCommand):
    """Show argv."""
    _cmdline_ = "argv"
    _syntax_ = "{:s} [-v]".format(_cmdline_)
    _category_ = "Process Information"

    def get_address_from_symbol(self, symbol):
        try:
            return parse_address(symbol)
        except:
            return None

    def print_from_mem(self, array, verbose):
        i = 0
        while True:
            addr = read_int_from_memory(array + i * current_arch.ptrsize)
            if addr == 0:
                break
            if not verbose and i > 99:
                gef_print("...")
                break
            s = read_cstring_from_memory(addr, DEFAULT_PAGE_SIZE)
            gef_print("[{:3d}]: {:#x}: {:#x}{:s}{:s}".format(i, array + i * current_arch.ptrsize, addr, RIGHT_ARROW, Color.yellowify(repr(s))))
            i += 1
        return

    def print_from_proc(self, filename, verbose):
        lines = open(filename).read()
        for i, elem in enumerate(lines.split("\0")):
            if not elem:
                break
            if not verbose and i > 99:
                gef_print("...")
                break
            gef_print("[{:3d}]: {:s}".format(i, repr(elem)))
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        verbose = (argv and argv[0] == "-v")

        paddr1 = self.get_address_from_symbol("&_dl_argv")
        addr1 = self.get_address_from_symbol("_dl_argv")
        if paddr1 and addr1:
            gef_print(titlify("ARGV from _dl_argv"))
            info("_dl_argv @ {:#x}".format(paddr1))
            self.print_from_mem(addr1, verbose)

        paddr2 = self.get_address_from_symbol("&__libc_argv")
        addr2 = self.get_address_from_symbol("__libc_argv")
        if paddr2 and addr2:
            gef_print(titlify("ARGV from __libc_argv"))
            info("__libc_argv @ {:#x}".format(paddr2))
            self.print_from_mem(addr2, verbose)

        if not is_remote_debug() or is_remote_but_same_host():
            gef_print(titlify("ARGV from /proc/{:d}/cmdline".format(get_pid())))
            self.print_from_proc("/proc/{:d}/cmdline".format(get_pid()), verbose)
        else:
            if not (paddr1 or paddr2):
                err("Not found argv")
        return


@register_command
class EnvpCommand(GenericCommand):
    """Show initial envp from __environ@ld, or modified envp from last_environ@libc."""
    _cmdline_ = "envp"
    _syntax_ = "{:s} [-h] [-v] [libc]".format(_cmdline_)
    _aliases_ = ["envs", "env",]
    _category_ = "Process Information"

    def get_address_from_symbol(self, symbol):
        try:
            return parse_address(symbol)
        except:
            return None

    def print_from_mem(self, array, verbose):
        i = 0
        while True:
            addr = read_int_from_memory(array + i * current_arch.ptrsize)
            if addr == 0:
                break
            if not verbose and i > 99:
                gef_print("...")
                break
            s = read_cstring_from_memory(addr, DEFAULT_PAGE_SIZE)
            gef_print("[{:3d}]: {:#x}: {:#x}{:s}{:s}".format(i, array + i * current_arch.ptrsize, addr, RIGHT_ARROW, Color.yellowify(repr(s))))
            i += 1
        return

    def print_from_proc(self, filename, verbose):
        lines = open(filename).read()
        for i, elem in enumerate(lines.split("\0")):
            if not elem:
                break
            if not verbose and i > 99:
                gef_print("...")
                break
            gef_print("[{:3d}]: {:s}".format(i, repr(elem)))
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        verbose = "-v" in argv

        if "libc" in argv:
            paddr = self.get_address_from_symbol("&last_environ")
            addr = self.get_address_from_symbol("last_environ")
            if paddr and addr:
                gef_print(titlify("ENVP from last_environ"))
                info("last_environ @ {:#x}".format(paddr))
                return self.print_from_mem(addr, verbose)
            else:
                if addr is None:
                    err("Not found last_environ")
                    return
                if addr == 0:
                    err("last_environ is 0x0")
                    return
        else:
            paddr = self.get_address_from_symbol("&__environ")
            addr = self.get_address_from_symbol("__environ")
            if paddr and addr:
                gef_print(titlify("ENVP from __environ"))
                info("__environ @ {:#x}".format(paddr))
                self.print_from_mem(addr, verbose)
                info("to see the result of putenv(), use `env libc`")
                return

            if not is_remote_debug() or is_remote_but_same_host():
                gef_print(titlify("ENVP from /proc/{:d}/environ".format(get_pid())))
                return self.print_from_proc("/proc/{:d}/environ".format(get_pid()), verbose)
        err("Not found envp")
        return


@register_command
class CetStatusCommand(GenericCommand):
    """Show Intel CET settings."""
    _cmdline_ = "cet-status"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    def get_state(self, code_len):
        d = {}
        d["pc"] = get_register("$pc")
        d["sp"] = get_register("$sp")
        d["code"] = read_memory(d["pc"], code_len)
        d["reg"] = {}
        for reg in current_arch.gpr_registers:
            d["reg"][reg] = get_register(reg)
        d["stack"] = {}
        for i in range(3):
            addr = d["sp"] + current_arch.ptrsize * i
            d["stack"][addr] = read_memory(addr, current_arch.ptrsize)
        return d

    def revert_state(self, d):
        write_memory(d["pc"], d["code"], len(d["code"]))
        gdb.execute("set $pc = {:#x}".format(d["pc"]), to_string=True)
        for regname, regvalue in d["reg"].items():
            gdb.execute("set {:s} = {:#x}".format(regname, regvalue), to_string=True)
        for addr, value in d["stack"].items():
            write_memory(addr, value)
        return

    def close_stdout(self):
        self.stdout = 1
        self.stdout_bak = os.dup(self.stdout)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stdout)
        f.close()
        return

    def revert_stdout(self):
        os.dup2(self.stdout_bak, self.stdout)
        os.close(self.stdout_bak)
        return

    def get_result(self):
        r = {}
        r["ret"] = get_register("$rax" if is_x86_64() else "$eax")
        r["data"] = []
        for i in range(3):
            addr = get_register("$rsi" if is_x86_64() else "$ecx") + current_arch.ptrsize * i
            v = read_int_from_memory(addr)
            r["data"].append(v)
        return r

    def execute_get_cet_status(self):
        if is_x86_64():
            code = b"\xeb\xfe\x0f\x05" # inf-loop (to stop another thread); syscall
        else:
            code = b"\xeb\xfe\xcd\x80" # inf-loop (to stop another thread); int 0x80
        gef_on_stop_unhook(hook_stop_handler)
        d = self.get_state(len(code))
        write_memory(d["pc"], code, len(code))
        if is_x86_64():
            gdb.execute("set $rax = 0x9e", to_string=True) # arch_prctl
            gdb.execute("set $rdi = 0x3001", to_string=True) # ARCH_CET_STATUS
            gdb.execute("set $rsi = $rsp", to_string=True) # buffer
        else:
            gdb.execute("set $eax = 0x180", to_string=True) # arch_prctl
            gdb.execute("set $ebx = 0x3001", to_string=True) # ARCH_CET_STATUS
            gdb.execute("set $ecx = $esp", to_string=True) # buffer
        gdb.execute("set $pc = {:#x}".format(d["pc"]+2), to_string=True) # skip "\xeb\xfe"
        self.close_stdout()
        gdb.execute("stepi", to_string=True)
        self.revert_stdout()
        r = self.get_result()
        self.revert_state(d)
        gef_on_stop_hook(hook_stop_handler)
        return r

    @only_if_gdb_running
    @only_if_not_qemu_system
    @only_if_x86_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        try:
            r = self.execute_get_cet_status()
        except:
            err("Execute code fails. Memory write feature may not be supported.")
            return

        if r["ret"] != 0:
            err("OS does not support CET")
            return

        gef_print("ShadowStack/IndirectBranchTracking status: {:#x}".format(r["data"][0]))
        if r["data"][0] & 0b10:
            msg = Color.colorify("Enabled", "green bold")
        else:
            msg = Color.colorify("Disabled", "red bold")
        gef_print("  ShadowStack: {:s}".format(msg))
        if r["data"][0] & 0b01:
            msg = Color.colorify("Enabled", "green bold")
        else:
            msg = Color.colorify("Disabled", "red bold")
        gef_print("  IndirectBrannchTracking: {:s}".format(msg))
        gef_print("ShadowStack Base Address: {:#x}".format(r["data"][1]))
        gef_print("ShadowStack Size: {:#x}".format(r["data"][2]))
        return


@register_command
class TlsCommand(GenericCommand):
    """Show TLS base address."""
    _cmdline_ = "tls"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @staticmethod
    def getfsgs_qemu_usermode():
        def slice_unpack(data, n):
            tmp = [data[i:i+n] for i in range(0, len(data), n)]
            return list(map(u64 if n == 8 else u32, tmp))
        vmmap = get_process_maps()
        for m in vmmap[::-1]:
            if m.path != "<explored>":
                continue
            data = read_memory(m.page_start, m.size)
            data = slice_unpack(data, current_arch.ptrsize)
            addr = [x for x in range(m.page_start, m.page_end, current_arch.ptrsize)]
            assert len(data) == len(addr)
            for i in range(len(data)-2):
                if data[i] == addr[i] and data[i+2] == addr[i] and (data[i+5] & 0xff) == 0 and data[i+5] != 0:
                    return addr[i]
        return 0

    @staticmethod
    def getfs():
        if is_qemu_usermode():
            if is_x86_64():
                return TlsCommand.getfsgs_qemu_usermode()
            else:
                return 0
        # fast path
        fs = get_register("$fs_base")
        if fs is not None:
            return fs
        # slow path
        PTRACE_ARCH_PRCTL = 30
        ARCH_GET_FS = 0x1003
        pid, lwpid, tid = gdb.selected_thread().ptid
        ppvoid = ctypes.POINTER(ctypes.c_void_p)
        value = ppvoid(ctypes.c_void_p())
        value.contents.value = 0
        libc = ctypes.CDLL('libc.so.6')
        result = libc.ptrace(PTRACE_ARCH_PRCTL, lwpid, value, ARCH_GET_FS)
        return value.contents.value or 0

    @staticmethod
    def getgs():
        if is_qemu_usermode():
            if is_x86_64():
                return 0
            else:
                return TlsCommand.getfsgs_qemu_usermode()
        # fast path
        gs = get_register("$gs_base")
        if gs is not None:
            return gs
        # slow path
        PTRACE_ARCH_PRCTL = 30
        ARCH_GET_GS = 0x1004
        pid, lwpid, tid = gdb.selected_thread().ptid
        ppvoid = ctypes.POINTER(ctypes.c_void_p)
        value = ppvoid(ctypes.c_void_p())
        value.contents.value = 0
        libc = ctypes.CDLL('libc.so.6')
        result = libc.ptrace(PTRACE_ARCH_PRCTL, lwpid, value, ARCH_GET_GS)
        return value.contents.value or 0

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    @only_if_x86_32_64_or_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if is_x86_64():
            fsvalue = self.getfs()
            if fsvalue:
                gef_print(titlify("TLS-0x80"))
                gdb.execute("telescope {:#x} 16".format(fsvalue - 0x80))
                gef_print(titlify("TLS"))
                gdb.execute("telescope {:#x} 16".format(fsvalue))
                gef_print("set $tls = {:#x}".format(fsvalue))
                gdb.execute("set $tls = {:#x}".format(fsvalue))
        elif is_x86_32():
            gsvalue = self.getgs()
            if gsvalue:
                gef_print(titlify("TLS-0x40"))
                gdb.execute("telescope {:#x} 16".format(gsvalue - 0x40))
                gef_print(titlify("TLS"))
                gdb.execute("telescope {:#x} 16".format(gsvalue))
                gef_print("set $tls = {:#x}".format(gsvalue))
                gdb.execute("set $tls = {:#x}".format(gsvalue))
        elif is_arm32():
            if not safe_parse_and_eval("__aeabi_read_tp"):
                err("Not found symbol (__aeabi_read_tp)")
                return
            gef_print("p $tls = (unsigned int)__aeabi_read_tp()")
            tls = gdb.execute("p $tls = (unsigned int)__aeabi_read_tp()", to_string=True)
            if tls:
                gef_print(titlify("TLS-0x40"))
                gdb.execute("telescope $tls-0x40 16")
                gef_print(titlify("TLS"))
                gdb.execute("telescope $tls 16")
        elif is_arm64():
            gef_print("p $tls = $TPIDR_EL0")
            tls = gdb.execute("p $tls = $TPIDR_EL0", to_string=True)
            if tls:
                gef_print(titlify("TLS-0x80"))
                gdb.execute("telescope $tls-0x80 16")
                gef_print(titlify("TLS"))
                gdb.execute("telescope $tls 16")
        return


@register_command
class FsbaseCommand(GenericCommand):
    """Show fsbase address."""
    _cmdline_ = "fsbase"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    @only_if_x86_32_64
    def do_invoke(self, argv):
        self.dont_repeat()
        fs_base = TlsCommand.getfs()
        gef_print("$fs_base = {:#x}".format(fs_base))
        return


@register_command
class GsbaseCommand(GenericCommand):
    """Show gsbase address."""
    _cmdline_ = "gsbase"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    @only_if_x86_32_64
    def do_invoke(self, argv):
        self.dont_repeat()
        gs_base = TlsCommand.getgs()
        gef_print("$gs_base = {:#x}".format(gs_base))
        return


@register_command
class GdtInfoCommand(GenericCommand):
    """Print GDT entries sample."""
    _cmdline_ = "gdtinfo"
    _syntax_ = "{:s} [-h] [-v]".format(_cmdline_)
    _category_ = "Misc"

    @staticmethod
    def seg2str(v):
        rpl = v & 0b11
        ti = (v>>2) & 0b1
        index = (v>>3)
        return f"{v:#4x} (=rpl:{rpl}, ti:{ti}, index:{index})"

    # dump segment register
    def print_seg_info(self):
        if not is_alive():
            return
        gef_print(titlify("Current register values"))
        red = lambda x: Color.colorify("{:4s}".format(x), "red bold")
        for k in ['cs', 'ds', 'es', 'fs', 'gs', 'ss']:
            v = int(gdb.selected_frame().read_register(k))
            gef_print("{:s}: {:s}".format(red(k), self.seg2str(v)))
        gef_print(" * rpl: Requested Privilege Level (0:Ring0, 3:Ring3)")
        gef_print(" * ti: Table Indicator (0:GDT, 1:LDT)")
        gef_print(" * index: Index of GDT/LDT")
        return

    # struct desc_struct -> dictionary(each value)
    @staticmethod
    def gdt_unpack(vals):
        if isinstance(vals, list):
            val = vals[0] # for TSS/LDT
        else:
            val = vals # for normal

        # parse
        d = {}
        d['_value'] = val

        d['limit0'] = val & 0xffff
        d['base0'] = (val>>16) & 0xffff
        d['base1'] = (val>>32) & 0xff
        d['_access_bytes'] = (val>>40) & 0xff
        d['limit1'] = (val>>48) & 0x0f
        d['_flag_bytes'] = (val>>52)&0x0f
        d['base2'] = (val>>56) & 0xff

        d['p'] = (d['_access_bytes'] >> 7) & 0x01
        d['dpl'] = (d['_access_bytes'] >> 5) & 0x03
        d['s'] = (d['_access_bytes'] >> 4) & 0x01
        d['_type_bytes'] = d['_access_bytes'] & 0x0f
        d['ex'] = (d['_access_bytes'] >> 3) & 0x01
        d['dc'] = (d['_access_bytes'] >> 2) & 0x01
        d['rw'] = (d['_access_bytes'] >> 1) & 0x01
        d['ac'] = (d['_access_bytes'] >> 0) & 0x01

        d['gr'] = (d['_flag_bytes']>>3) & 0x01
        d['db'] = (d['_flag_bytes']>>2) & 0x01
        d['l'] = (d['_flag_bytes']>>1) & 0x01
        d['avl'] = (d['_flag_bytes']>>0) & 0x01
        d['_FLAGS'] = (d['_flag_bytes']<<12) | d['_access_bytes'] # for easy use

        d['_limit'] = ((d['limit1']<<16) | d['limit0']) * ({0:1, 1:4096}[d['gr']])
        d['_base'] = (d['base2']<<24) | (d['base1']<<16) | d['base0']

        # create memo
        if d['ex'] == 0: # data
            d['_exs'] = "DATA"
            d['_rws'] = ["RO","RW"][d['rw']]
            d['_dcs'] = ["UP","DN"][d['dc']]
        else: # code
            d['_exs'] = "CODE"
            d['_rws'] = ["RO","RX"][d['rw']]
            d['_dcs'] = ["NC","CO"][d['dc']]

        d['_ss'] = ["SYS","C/D"][d['s']]
        d['_dbl'] = "{:d}".format( (d['db']<<1)|d['l'] )
        d['_dbls'] = ["16bit","64bit","32bit","(N/A)"][ (d['db']<<1)|d['l'] ]

        # for TSS/LDT
        if isinstance(vals, list):
            val = vals[1]
            d['_value2'] = d['_value']
            d['_value'] = val
            d['base3'] = val & 0xffffffff
            d['_base'] = (d['base3']<<32) | d['_base']
        return d

    @staticmethod
    def segval2str(d, value_only=False, color=False):
        c = Color.boldify if color else lambda x:x
        if value_only:
            return c(f"{d:#018x}")
        d = GdtInfoCommand.gdt_unpack(d)
        if d['_value'] == 0:
            return c(f"{d['_value']:#018x}")
        else:
            fmt = ""
            fmt += c(f"{d['_value']:#018x}") + " : "
            fmt += c(f"{d['_base']:>#18x}") + " "
            fmt += c(f"{d['_limit']:>#10x}") + " "
            fmt += c(f"{d['gr']:>2d}") + " "
            fmt += c(f"{d['_dbl']:}") + f"({d['_dbls']:s}) "
            fmt += c(f"{d['avl']:>3d}") + " "
            fmt += c(f"{d['p']:d}") + " "
            fmt += c(f"{d['dpl']:>3}") + " "
            fmt += c(f"{d['s']:d}") + f"({d['_ss']:s}) "
            fmt += c(f"{d['ex']:d}") + f"({d['_exs']:s}) "
            fmt += c(f"{d['dc']:d}") + f"({d['_dcs']:s}) "
            fmt += c(f"{d['rw']:d}") + f"({d['_rws']:s}) "
            fmt += c(f"{d['ac']:d}")
            return fmt

    @staticmethod
    def segval2str_legend():
        legend = ""
        legend += f"{'value':18} : {'base':>18} {'limit/size':} "
        legend += f"{'gr':} {'dbl':}      {'avl':>} "
        legend += f"{'p':} {'dpl':} {'s':}      "
        legend += f"{'ex':}      {'dc':}    {'rw':}    {'ac':}"
        return legend

    @staticmethod
    def get_segreg_list():
        regs = {}
        if is_alive():
            for k in ['cs', 'ds', 'es', 'fs', 'gs', 'ss']:
                v = gdb.selected_frame().read_register(k)
                rpl = v & 0b11
                ti = (v>>2) & 0b1
                index = int(v>>3)
                if v != 0 and ti == 0:
                    regs[index] = regs.get(index, []) + [k]
        return regs

    @staticmethod
    def is_emulated32():
        if is_qemu_usermode():
            return False

        if is_qemu_system():
            return False

        for m in get_process_maps():
            # native x86:
            # 0xbffdf000 0xc0000000 0x021000 0x000000 rw- [stack]
            # emulated x86 on x86_64
            # 0xfffdd000 0xffffe000 0x021000 0x000000 rw- [stack]
            if m.path == "[stack]":
                return (m.page_start >> 28) == 0xf
        else:
            return False # by default it considers on native

    # print useful gdt fixed entry
    def print_gdt_entry(self, entries):
        if is_x86_64() or self.is_emulated32():
            gef_print(titlify("GDT Entry (x64 sample)"))
        else:
            gef_print(titlify("GDT Entry (x86 sample)"))
        info("*** This is an {:s} (GDT/LDT exist per-CPU) ***".format(Color.boldify("EXAMPLE")))
        registers_color = get_gef_setting("theme.dereference_register_value")
        # print legend
        legend = f"[ #] {'segment name':17} : " + self.segval2str_legend()
        gef_print(Color.colorify(legend, get_gef_setting("theme.table_heading")))
        # regs check
        regs = self.get_segreg_list()
        # parse entry
        for (i, print_flag, segname, value) in entries:
            # get segment regs value
            reglist = ', '.join(regs.get(i,[]))
            if reglist:
                reglist = LEFT_ARROW + reglist
            # decode and print
            if print_flag:
                fmt = f"[{i:>2}] {segname:17} : " + self.segval2str(value) + " " + Color.colorify(f"{reglist:s}", registers_color)
            else:
                fmt = f"[{i:>2}] {segname:17} : {value:#018x} " + Color.colorify(f"{reglist:s}", registers_color)
            gef_print(fmt)
        return

    @staticmethod
    def print_gdt_entry_legend():
        gef_print(titlify("legend (Normal GDT entry)"))
        gef_print("              <flag_bytes->        <----access_bytes ---->")
        gef_print("                                             <type_bytes->")
        gef_print("31            23          19       15                    7             0bit")
        gef_print("------------------------------------------------------------------------")
        gef_print("|             |G |D |  |A |        |  |   |  |E |D |W |A |             |")
        gef_print("| BASE2 31:24 |  |/ |L |V | LIMIT1 |P |DPL|S |  |  |  |  | BASE1 23:16 | 4byte")
        gef_print("|             |R |B |  |L | 19:16  |  |   |  |X |C |R |C |             |")
        gef_print("------------------------------------------------------------------------")
        gef_print("|            BASE0 15:0            |           LIMIT0 15:0             | 0byte")
        gef_print("------------------------------------------------------------------------")
        gef_print(" * base               : Start address")
        gef_print(" * limit              : Segment size (4KB unit if gr==1)")
        gef_print(" * access_bytes")
        gef_print("   * p                : Segment Present Flag (0:SegmentNotInMemory, 1:SegmentInMemory)")
        gef_print("   * dpl              : Descriptor Privilege Level (0:Ring0, 3:Ring3)")
        gef_print("   * s                : Descriptor Type Flag (0:System Segment, 1:Code/Data Segment)")
        gef_print("   * type_bytes")
        gef_print("     * ex             : Segment type (0:Data, 1:Code)")
        gef_print("     * dc (Code Seg)  : Conforming bit (0:NoConform, 1:Conform)")
        gef_print("     * dc (Data Seg)  : Direction bit (0:Up, 1:Down)")
        gef_print("     * rw (Code Seg)  : Read/Exec bit (0:ReadOnly, 1:Read/Exec)")
        gef_print("     * rw (Data Seg)  : Read/Write bit (0:ReadOnly, 1:Read/Write)")
        gef_print("     * ac             : Access bit (0:NotAccessed, 1:Accessed)")
        gef_print(" * flag_bytes")
        gef_print("   * gr               : Granularity Flag (0:SegLimitAsByte, 1:SegLimitAs4KB)")
        gef_print("   * db               : Default Operation size (0:16bitSeg, 1:32bitSeg)")
        gef_print("   * l (Code Seg)     : 64-bits Code Segment Flag (0:32bit, 1:64bit)")
        gef_print("   * l (Data Seg)     : Reserved (0)")
        gef_print("   * avl              : Available bit (0)")
        gef_print(titlify("legend (GDT entry for TSS/LDT)"))
        gef_print("31            23          19       15                    7             0bit")
        gef_print("------------------------------------------------------------------------")
        gef_print("|                           ZERO1 (x64 only)                           | 12byte")
        gef_print("------------------------------------------------------------------------")
        gef_print("|                        BASE3 47:32 (x64 only)                        | 8byte")
        gef_print("------------------------------------------------------------------------")
        gef_print("|             |G |        |        |  |   |  |E |D |W |A |             |")
        gef_print("| BASE2 31:24 |  | ZERO0  | LIMIT1 |P |DPL|S |  |  |  |  | BASE1 23:16 | 4byte")
        gef_print("|             |R |        | 19:16  |  |   |  |X |C |R |C |             |")
        gef_print("------------------------------------------------------------------------")
        gef_print("|            BASE0 15:0            |           LIMIT0 15:0             | 0byte")
        gef_print("------------------------------------------------------------------------")
        gef_print(" * limit (tss)        : __KERNEL_TSS_LIMIT(=0x206f(x64) / 0x206b(x86))")
        gef_print(" * limit (ldt)        : (LDT entries * 8) - 1")
        return

    def print_gdt(self):
        self.print_seg_info()
        if is_x86_64() or self.is_emulated32():
            self.print_gdt_entry([
                # idx, print flag, segment name,        value
                (0,    True,       "NULL",              0x0000000000000000),
                (1,    True,       "KERNEL32_CS",       0x00cf9b000000ffff),
                (2,    True,       "KERNEL_CS",         0x00af9b000000ffff),
                (3,    True,       "KERNEL_DS",         0x00cf93000000ffff),
                (4,    True,       "DEFAULT_USER32_CS", 0x00cffb000000ffff),
                (5,    True,       "DEFAULT_USER_DS",   0x00cff3000000ffff),
                (6,    True,       "DEFAULT_USER_CS",   0x00affb000000ffff),
                (8,    False,      "TSS-part1",         0x00008b000000206f),
                (9,    True,       "TSS-part2",         [0x00008b000000206f, 0x00000000fffffe00]),
                (10,   True,       "LDT-part1",         0x0000000000000000),
                (11,   True,       "LDT-part2",         0x0000000000000000),
                (12,   True,       "TLS_#1",            0x0000000000000000),
                (13,   True,       "TLS_#2",            0x0000000000000000),
                (14,   True,       "TLS_#3",            0x0000000000000000),
                (15,   True,       "CPUNODE",           0x0040f50000000000),
            ])
        else:
            self.print_gdt_entry([
                # idx, print flag, segment name,        value
                (0,    True,       "NULL",              0x0000000000000000),
                (1,    True,       "RESERVED",          0x0000000000000000),
                (2,    True,       "RESERVED",          0x0000000000000000),
                (3,    True,       "RESERVED",          0x0000000000000000),
                (4,    True,       "UNUSED",            0x0000000000000000),
                (5,    True,       "UNUSED",            0x0000000000000000),
                (6,    True,       "TLS#1",             0x0000000000000000),
                (7,    True,       "TLS#2",             0x0000000000000000),
                (8,    True,       "TLS#3",             0x0000000000000000),
                (9,    True,       "RESERVED",          0x0000000000000000),
                (10,   True,       "RESERVED",          0x0000000000000000),
                (11,   True,       "RESERVED",          0x0000000000000000),
                (12,   True,       "KERNEL_CS",         0x00cf9a000000ffff),
                (13,   True,       "KERNEL_DS",         0x00cf93000000ffff),
                (14,   True,       "DEFAULT_USER_CS",   0x00cffa000000ffff),
                (15,   True,       "DEFAULT_USER_DS",   0x00cff3000000ffff),
                (16,   True,       "TSS",               0xff008b804000206b),
                (17,   True,       "LDT",               0x0000000000000000),
                (18,   True,       "PNPBIOS_CS32",      0x00409a000000ffff),
                (19,   True,       "PNPBIOS_CS16",      0x00009a000000ffff),
                (20,   True,       "PNPBIOS_DS",        0x000092000000ffff),
                (21,   True,       "PNPBIOS_TS1",       0x0000920000000000),
                (22,   True,       "PNPBIOS_TS2",       0x0000920000000000),
                (23,   True,       "APMBIOS_BASE",      0x00409a000000ffff),
                (24,   True,       "APMBIOS",           0x00009a000000ffff),
                (25,   True,       "APMBIOS",           0x004092000000ffff),
                (26,   True,       "ESPFIX_SS",         0x00cf92000000ffff),
                (27,   True,       "PERCPU",            0x038f93708000ffff),
                (28,   True,       "STACK_CANARY",      0x0000000000000000),
                (29,   True,       "UNUSED",            0x0000000000000000),
                (30,   True,       "UNUSED",            0x0000000000000000),
                (31,   True,       "DOUBLEFAULT_TSS",   0xc40089706000206b),
            ])
        if self.print_flags_info:
            self.print_gdt_entry_legend()
        else:
            info("for flags description, use `-v`")
        return

    @only_if_x86_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.print_flags_info = "-v" in argv
        self.print_gdt()
        info("if qemu-system, use `qreg -v` to confirm real GDT value")
        return


@register_command
class MemoryCompareCommand(GenericCommand):
    """Memory Compare."""
    _cmdline_ = "memcmp"
    _syntax_ = "{:s} [-h] [--phys] FROM1 [--phys] FROM2 SIZE".format(_cmdline_)
    _category_ = "Misc"

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        return

    def diff(self, from1data, from2data):
        diff_found = False
        asterisk = True
        for pos in range(0, self.size, 16):
            f1_bin = from1data[pos : pos+16]
            f2_bin = from2data[pos : pos+16]
            if f1_bin == f2_bin:
                if asterisk == False:
                    gef_print("*")
                    asterisk = True
                continue

            addr1 = self.from1 + pos
            addr2 = self.from2 + pos

            diff_found = True
            asterisk = False
            f1_hex = []
            f2_hex = []
            f1_ascii = []
            f2_ascii = []
            for i in range(min(len(f1_bin), 16)):
                if f1_bin[i] == f2_bin[i]:
                    color_func = lambda x:x
                else:
                    color_func = Color.boldify
                f1_hex.append(color_func("{:02x}".format(f1_bin[i])))
                f2_hex.append(color_func("{:02x}".format(f2_bin[i])))
                f1_ascii.append(color_func(chr(f1_bin[i]) if 0x20 <= f1_bin[i] < 0x7f else "."))
                f2_ascii.append(color_func(chr(f2_bin[i]) if 0x20 <= f2_bin[i] < 0x7f else "."))
            f1_hex_s = ' '.join(f1_hex) + " " * ((16 - len(f1_hex))*3)
            f2_hex_s = ' '.join(f2_hex) + " " * ((16 - len(f2_hex))*3)
            f1_ascii_s = ''.join(f1_ascii) + " " * (16 - len(f1_ascii))
            f2_ascii_s = ''.join(f2_ascii) + " " * (16 - len(f2_ascii))
            msg = "{:#018x}: {:s} | {:s} | {:#018x}: {:s} | {:s} |".format(addr1, f1_hex_s, f1_ascii_s, addr2, f2_hex_s, f2_ascii_s)
            gef_print(msg)

        if diff_found == False:
            info("Not found diff")
        return

    def memcmp(self):
        try:
            if self.from1_phys:
                from1data = read_physmem(self.from1, self.size)
            else:
                from1data = read_memory(self.from1, self.size)
        except:
            err("Read error {:#x}".format(self.from1))
            return

        try:
            if self.from2_phys:
                from2data = read_physmem(self.from2, self.size)
            else:
                from2data = read_memory(self.from2, self.size)
        except:
            err("Read error {:#x}".format(self.from2))
            return

        self.diff(from1data, from2data)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "--phys" in argv and not is_qemu_system():
            err("Unsupported")
            return

        if "-h" in argv:
            self.usage()
            return

        try:
            if argv[0] == "--phys":
                self.from1_phys = True
                self.from1 = parse_address(argv[1])
                argv = argv[2:]
            else:
                self.from1_phys = False
                self.from1 = parse_address(argv[0])
                argv = argv[1:]

            if argv[0] == "--phys":
                self.from2_phys = True
                self.from2 = parse_address(argv[1])
                argv = argv[2:]
            else:
                self.from2_phys = False
                self.from2 = parse_address(argv[0])
                argv = argv[1:]

            self.size = int(argv[0], 0)
        except:
            self.usage()
            return

        if self.size == 0:
            info("The size is zero, maybe wrong.")

        self.memcmp()
        return


@register_command
class MemoryCopyCommand(GenericCommand):
    """Memory Copy."""
    _cmdline_ = "memcpy"
    _syntax_ = "{:s} [-h] [--phys] TO [--phys] FROM SIZE".format(_cmdline_)
    _category_ = "Misc"

    def memcpy(self):
        try:
            if self.from_phys:
                data = read_physmem(self.from_addr, self.size)
            else:
                data = read_memory(self.from_addr, self.size)
        except:
            err("Read error {:#x}".format(self.from_addr))
            return

        info("Read count: {:#x}".format(len(data)))

        try:
            if self.to_phys:
                written = write_physmem(self.to_addr, data)
            else:
                written = write_memory(self.to_addr, data, len(data))
        except:
            err("Write error {:#x}".format(self.to_addr))
            return

        info("Write count: {:#x}".format(written))
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "--phys" in argv and not is_qemu_system():
            err("Unsupported")
            return

        if "-h" in argv:
            self.usage()
            return

        try:
            if argv[0] == "--phys":
                self.to_phys = True
                self.to_addr = parse_address(argv[1])
                argv = argv[2:]
            else:
                self.to_phys = False
                self.to_addr = parse_address(argv[0])
                argv = argv[1:]

            if argv[0] == "--phys":
                self.from_phys = True
                self.from_addr = parse_address(argv[1])
                argv = argv[2:]
            else:
                self.from_phys = False
                self.from_addr = parse_address(argv[0])
                argv = argv[1:]

            self.size = int(argv[0], 0)
        except:
            self.usage()
            return

        if self.size == 0:
            info("The size is zero, maybe wrong.")

        self.memcpy()
        return


@register_command
class IsMemoryZeroCommand(GenericCommand):
    """Checks if all the memory in the specified range is 0x00, 0xff."""
    _cmdline_ = "is-mem-zero"
    _syntax_ = "{:s} [-h] [--phys] ADDRESS SIZE".format(_cmdline_)
    _aliases_ = ["is-mem-ff",]
    _category_ = "Misc"

    def memcheck(self):
        current = self.addr
        end = self.addr + self.size
        is_zero = True
        is_ff = True
        while current < end:
            read_size = min(end - current, 0x1000)
            try:
                if self.phys_mode:
                    data = read_physmem(current, read_size)
                else:
                    data = read_memory(current, read_size)
            except:
                err("Read error {:#x}".format(self.addr))
                return
            if data == b"\0" * len(data):
                is_ff = False
            elif data == b"\xff" * len(data):
                is_zero = False
            else:
                is_zero = False
                is_ff = False
            if is_zero == False and is_ff == False:
                break
            current += 0x1000

        if is_zero:
            info("{:#x} - {:#x} is {:s}".format(self.addr, self.addr + self.size, Color.colorify("All 0x00", "bold yellow")))
        elif is_ff:
            info("{:#x} - {:#x} is {:s}".format(self.addr, self.addr + self.size, Color.colorify("All 0xFF", "bold yellow")))
        else:
            info("{:#x} - {:#x} is {:s}".format(self.addr, self.addr + self.size, Color.colorify("NON-ZERO", "bold yellow")))
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.phys_mode = False
        if "--phys" in argv:
            if not is_qemu_system():
                err("Unsupported")
                return
            self.phys_mode = True
            argv.remove("--phys")

        if len(argv) < 2:
            self.usage()
            return
        self.size = int(argv[-1], 16)
        self.addr = int(argv[-2], 16)

        self.memcheck()
        return


@register_command
class FindFakeFastCommand(GenericCommand):
    """Find candidate fake fast chunks from rw memory."""
    _cmdline_ = "find-fake-fast"
    _syntax_ = "{:s} [-h] size [--include-heap]".format(_cmdline_)
    _category_ = "Heap"

    def print_result(self, m, pos, size_candidate):
        path = "unknown" if m.path == "" else m.path
        info("Found at {:#x} in {:s} [{:s}]".format(m.page_start + pos, repr(path), str(m.permission)))

        if current_arch.ptrsize == 4:
            res = gdb.execute("x/6xw {:#x}".format(m.page_start + pos), to_string=True)
        else:
            res = gdb.execute("x/6xg {:#x}".format(m.page_start + pos), to_string=True)
        flag = []
        flag += [Color.colorify("NON_MAIN_ARENA","bold yellow") if (size_candidate&0b100) else Color.colorify("NON_MAIN_ARENA","normal")]
        flag += [Color.colorify("IS_MMAPED", "bold blue") if (size_candidate&0b10) else Color.colorify("IS_MMAPED", "normal")]
        flag += [Color.colorify("PREV_INUSE","bold red") if (size_candidate&0b1) else Color.colorify("PREV_INUSED", "normal")]
        gef_print("    [{:s}]".format(' '.join(flag)))
        for line in res.splitlines():
            gef_print("    {:s}".format(line))

    def find_fake_fast(self, target_size, mask):
        target_size &= mask
        vmmap = get_process_maps()
        unpack = u32 if current_arch.ptrsize == 4 else u64
        slicer = lambda data, n: [data[i:i+n] for i in range(0, len(data), n)]
        for m in vmmap:
            if not (m.permission & Permission.READ) or not (m.permission & Permission.WRITE):
                continue
            if m.path == "[vvar]":
                continue
            if not self.include_heap and m.path == "[heap]":
                continue
            data = read_memory(m.page_start, m.size)
            for pos in range(0, m.size, gef_getpagesize()):
                if b"\0" * gef_getpagesize() == data[pos : pos+gef_getpagesize()]: # for fast check
                    continue
                for posb in range(pos, pos+gef_getpagesize()):
                    size_candidate = data[posb+current_arch.ptrsize : posb+current_arch.ptrsize*2]
                    if len(size_candidate) != current_arch.ptrsize:
                        break
                    size_candidate = unpack(size_candidate)
                    if (size_candidate & mask) != target_size:
                        continue
                    self.print_result(m, posb, size_candidate)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.include_heap = False
        if "--include-heap" in argv:
            self.include_heap = True
            argv.remove("--include-heap")

        if len(argv) == 0:
            self.usage()
            return

        target_size = int(argv[0], 0)
        mask = ~0x7 if current_arch.ptrsize == 4 else ~0xf
        self.find_fake_fast(target_size, mask)
        return


@register_command
class VisualHeapCommand(GenericCommand):
    """Visualize top 10 chunks on a heap (default: main_arena)."""
    _cmdline_ = "visual-heap"
    _syntax_ = "{:s} [-h] [DUMP_START_ADDRESS] [-c CHUNK_PRINT_COUNT|all] [-a ARENA_ADDRESS] [-v]".format(_cmdline_)
    _category_ = "Heap"

    def subinfo(self, addr):
        s = ""
        for k, v in self.tcache_list.items():
            if addr in v:
                s += "{} {}".format(LEFT_ARROW, "tcache[{}]".format(k))
        for k, v in self.fastbin_list.items():
            if addr in v:
                s += "{} {}".format(LEFT_ARROW, "fastbin[{}]".format(k))
        for k, v in self.unsortedbin_list.items():
            if addr in v:
                s += "{} {}".format(LEFT_ARROW, "unsortedbin")
        for k, v in self.smallbin_list.items():
            if addr in v:
                s += "{} {}".format(LEFT_ARROW, "smallbin[{}]".format(k))
        for k, v in self.largebin_list.items():
            if addr in v:
                s += "{} {}".format(LEFT_ARROW, "largebin[{}]".format(k))
        if addr == self.top:
            s += "{} {}".format(LEFT_ARROW, "top chunk")
        return s

    def print_chunk(self, chunk, color_func):
        ptrsize = current_arch.ptrsize
        unpack = u32 if ptrsize == 4 else u64
        slicer = lambda data, n: [data[i:i+n] for i in range(0, len(data), n)]
        data = slicer(chunk.data, ptrsize*2)
        group_line_threshold = 8

        addr = chunk.chunk_base_address
        width = ptrsize*2 + 2
        dump = ""
        done = False
        for blk, blks in itertools.groupby(data):
            repeat_count = len(list(blks))
            d1, d2 = unpack(blk[:ptrsize]), unpack(blk[ptrsize:])
            dascii = ''.join(list(map(lambda x: chr(x) if 0x20<=x<0x7f else '.', list(blk))))

            if repeat_count < group_line_threshold or self.verbose:
                for i in range(repeat_count):
                    dump += f"{addr:#x}: {d1:#0{width:d}x} {d2:#0{width:d}x} | {dascii:s} | " + self.subinfo(addr) + "\n"
                    addr += ptrsize*2
                    if addr > self.top + ptrsize*4:
                        dump += "..."
                        done = True
                        break
            else:
                dump += f"{addr:#x}: {d1:#0{width:d}x} {d2:#0{width:d}x} | {dascii:s} | " + self.subinfo(addr) + "\n"
                dump += "* {:#d} lines, {:#x} bytes \n".format(repeat_count-1, (repeat_count-1)*ptrsize*2)
                addr += ptrsize*2*repeat_count

            if done:
                break

        gef_print(color_func(dump.rstrip()))
        return

    def print_heap(self):
        sect = process_lookup_address(self.dump_start)
        addr = self.dump_start
        i = 0
        color = [Color.redify, Color.greenify, Color.blueify, Color.yellowify]
        while addr < sect.page_end and (self.count is None or i < self.count):
            chunk = GlibcChunk(addr + current_arch.ptrsize*2)
            # corrupt check
            if addr != self.top and addr + chunk.size > self.top:
                err("Corrupted (addr + chunk.size > self.top)")
                chunk.data = read_memory(addr, self.top - addr + 0x10)
                self.print_chunk(chunk, Color.grayify)
                break
            elif addr + chunk.size > sect.page_end:
                err("Corrupted (addr + chunk.size > sect.page_end)")
                chunk.data = read_memory(addr, self.top - addr + 0x10)
                self.print_chunk(chunk, Color.grayify)
                break
            # maybe not corrupted
            try:
                chunk.data = read_memory(addr, chunk.size)
            except:
                break
            color_func = color[ i % len(color) ]
            self.print_chunk(chunk, color_func)
            addr += chunk.size
            i += 1
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if argv and "-h" in argv:
            self.usage()
            return

        # parse verbose
        if argv and "-v" in argv:
            self.verbose = True
            argv.remove("-v")
        else:
            self.verbose = False

        # parse arena
        if "-a" in argv:
            idx = argv.index("-a")
            self.arena = GlibcArena("*{:s}".format(argv[idx + 1]))
            argv = argv[:idx] + argv[idx+2:]
        else:
            self.arena = get_main_arena()
        if self.arena is None:
            err("No valid arena")
            return
        if self.arena.heap_base is None:
            err("No heap section")
            return

        # parse count
        if "-c" in argv:
            idx = argv.index("-c")
            if argv[idx + 1] == "all":
                self.count = None
            else:
                self.count = int(argv[idx + 1], 0)
            argv = argv[:idx] + argv[idx+2:]
        else:
            self.count = 10

        # parse start address
        if len(argv) == 1:
            self.dump_start = int(argv[0], 0)
            argv = None
        elif len(argv) == 0:
            self.dump_start = self.arena.heap_base
            # specific pattern
            if current_arch.ptrsize == 4 and self.arena.is_main_arena():
                self.dump_start += 8
        else:
            self.usage()
            return

        self.tcache_list = self.arena.tcache_list() if self.arena else []
        self.fastbin_list = self.arena.fastbin_list() if self.arena else []
        self.unsortedbin_list = self.arena.unsortedbin_list() if self.arena else []
        self.smallbin_list = self.arena.smallbin_list() if self.arena else []
        self.largebin_list = self.arena.largebin_list() if self.arena else []
        self.top = int(self.arena.top) if self.arena else None

        try:
            self.print_heap()
        except:
            pass
        return


@register_command
class TimeCommand(GenericCommand):
    """Measures the time of the GDB command."""
    _cmdline_ = "time"
    _syntax_ = "{:s} GDB_CMD [, ARG]".format(_cmdline_)
    _category_ = "Misc"

    def do_invoke(self, argv):
        self.dont_repeat()

        start_time_real = time.perf_counter()
        start_time_proc = time.process_time()
        cmd = ' '.join(argv)

        gef_print(titlify(cmd))
        try:
            gdb.execute(cmd)
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            gef_print(exc_value)
            return

        end_time_real = time.perf_counter()
        end_time_proc = time.process_time()
        gef_print(titlify("time elapsed"))
        gef_print("Real: {:.3f} s".format(end_time_real - start_time_real))
        gef_print("CPU:  {:.3f} s".format(end_time_proc - start_time_proc))
        return


@register_command
class LsCommand(GenericCommand):
    """`ls` command wrapper."""
    _cmdline_ = "ls"
    _syntax_ = "{:s} [filename|dirname, ...]".format(_cmdline_)
    _category_ = "Misc"

    def do_invoke(self, argv):
        self.dont_repeat()

        try:
            ls = which("ls")
        except:
            err("Missing `ls` command")
            return

        try:
            result = gef_execute_external([ls, "-la", "--color=always"] + argv, as_list=True)
            for line in result:
                gef_print(line)
        except:
            gef_print("file/dir is not found")
        return


@register_command
class CatCommand(GenericCommand):
    """`cat` command wrapper."""
    _cmdline_ = "cat"
    _syntax_ = "{:s} filename [filename, ...]".format(_cmdline_)
    _category_ = "Misc"

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 0:
            return
        try:
            cat = which("cat")
        except:
            err("Missing `cat` command")
            return

        try:
            result = gef_execute_external([cat] + argv, as_list=True)
            for line in result:
                gef_print(line.replace("\0", "\\x00"))
        except:
            gef_print("file not found")
        return


@register_command
class PdisasCommand(GenericCommand):
    """Shortcut `cs-dis $pc LENGTH=50 OPCODES`."""
    _cmdline_ = "pdisas"
    _syntax_ = "{:s} [addr] [length]".format(_cmdline_)
    _category_ = "Assemble"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        try:
            if len(argv) >= 2:
                length = int(argv[1], 0)
            else:
                length = 50

            if len(argv) >= 1:
                addr = argv[0]
            else:
                addr = "$pc"
        except:
            self.usage()
            return

        gdb.execute("cs-dis {:s} length={:d} OPCODES".format(addr, length))
        return


@register_command
class IiCommand(GenericCommand):
    """Shortcut `x/50i $pc`."""
    _cmdline_ = "ii"
    _syntax_ = "{:s} [addr]".format(_cmdline_)
    _category_ = "Assemble"

    def is_all_zero(self, addr, N):
        res = read_memory(addr, N)
        return res == b"\0"*N

    def is_all_ff(self, addr, N):
        res = read_memory(addr, N)
        return res == b"\xff"*N

    def ii(self, addr, N):
        if isinstance(addr, int):
            if N >= 50 and self.is_all_zero(addr, N):
                info("all targeted area is 0x00")
                return
            if N >= 50 and self.is_all_ff(addr, N):
                info("all targeted area is 0xff")
                return
            res = gdb.execute("x/{:d}i {:#x}".format(N, addr), to_string=True)
        else:
            res = gdb.execute("x/{:d}i {:s}".format(N, addr), to_string=True)

        for line in res.splitlines():
            line = line.rstrip()
            try:
                if is_arm32():
                    addr = int(line.split("; ")[-1], 16)
                elif is_x86_64():
                    addr = int(line.split("# ")[-1], 16)
                else:
                    raise
                val = read_int_from_memory(addr)
                line += " -> [{:#x}]".format(val)
            except:
                pass
            gef_print(line)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        N = 50
        try:
            if len(argv) == 0:
                self.ii("$pc", N)
            else:
                try:
                    self.ii(int(argv[0], 16), N)
                except:
                    self.ii(argv[0], N)
        except:
            self.usage()
        return


@register_command
class ConstGrepCommand(GenericCommand):
    """Grep from `/usr/include`."""
    _cmdline_ = "constgrep"
    _syntax_ = "{:s} GREP_PATTERN".format(_cmdline_)
    _example_ = "constgrep '__NR_*'"
    _category_ = "Misc"

    def read_normalize(self, path):
        try:
            content = open(path, "rb").read()
        except:
            return None
        content = content.replace(b"\\\n", b"")
        content = content.replace(b"\t", b" ")
        content = content.replace(b"  ", b" ")
        for i in range(0x80, 0x100):
            content = content.replace(bytes([i]), b"")
        try:
            content = content.decode("UTF-8")
        except:
            err("decode error: " + path)
            return None
        return content

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 0:
            self.usage()
            return

        srcdir = "/usr/include"
        pattern = re.compile("^#define\s+\S*" + argv[0])
        for cur, dirs, files in os.walk(srcdir):
            for f in files:
                path = os.path.join(cur, f)
                content = self.read_normalize(path)
                if content is None:
                    continue
                for line in content.splitlines():
                    if pattern.search(line):
                        gef_print("{:s}: {:s}".format(Color.redify(path), line))
        return


@register_command
class SlubDumpCommand(GenericCommand):
    """Dump slab freelist with kenrel memory scanning. Thanks to https://github.com/PaoloMonti42/salt"""
    _cmdline_ = "slub-dump"
    _syntax_ = "{:s} [-h] [SLAB_CACHE_NAME] [--cpu N] [--no-xor] [--list]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} kmalloc-256 # dump kmalloc-256 from all cpus\n".format(_cmdline_)
    _example_ += "{:s} kmalloc-256 --cpu 1 # dump kmalloc-256 from cpu 1\n".format(_cmdline_)
    _example_ += "{:s} kmalloc-256 --no-xor # skip xor to chunk->next\n".format(_cmdline_)
    _example_ += "{:s} --list # list up slab cache names\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "Search flow:\n"
    _example_ += "1. get address of `__per_cpu_offset`\n"
    _example_ += "2. get address of `slab_caches`\n"
    _example_ += "3. parse member of `kmem_cache`\n"
    _example_ += "4. walk slub\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC.\n"
    _example_ += "\n"
    _example_ += "Simplified SLUB structure:\n"
    _example_ += "                         +-kmem_cache-+         +-kmem_cache-+   +-kmem_cache-+\n"
    _example_ += "                         | cpu_slab   |---+     | cpu_slab   |   | cpu_slab   |\n"
    _example_ += "                         | obj_size   |   |     | obj_size   |   | obj_size   |\n"
    _example_ += "                         | offset     |---|-+   | offset     |   | offset     |\n"
    _example_ += "       +-slab_caches-+   | name       |   | |   | name       |   | name       |\n"
    _example_ += " ...<->| list_head   |<->| list_head  |<------->| list_head  |<->| list_head  |<-> ...\n"
    _example_ += "       +-------------+   | random     |   | |   | random     |   | random     |\n"
    _example_ += "                         +------------+   | |   +------------+   +------------+\n"
    _example_ += "                                          | |\n"
    _example_ += "    +-__per_cpu_offset-+                  | |\n"
    _example_ += "    | cpu0_offset      |---+--------------+ |\n"
    _example_ += "    | cpu1_offset      |   |                |\n"
    _example_ += "    | cpu2_offset      |   |        +-------+\n"
    _example_ += "    | ...              |   |        |\n"
    _example_ += "    +------------------+   |        |\n"
    _example_ += "                           |        |\n"
    _example_ += "      +--------------------+        |\n"
    _example_ += "      |                             |\n"
    _example_ += "      |                 +-chunk--------+  +-chunk--------+  +-chunk--------+\n"
    _example_ += "      |                 | ^         |  |  | ^            |  | ^            |\n"
    _example_ += "      v                 | |offset <-+  |  | |offset      |  | |offset      |\n"
    _example_ += "    +-kmem_cache_cpu-+  | v            |  | v            |  | v            |\n"
    _example_ += "    | freelist       |->| next         |->| next         |->| next         |->NULL\n"
    _example_ += "    |                |  |              |  |              |  |              |\n"
    _example_ += "    +----------------+  +--------------+  +--------------+  +--------------+\n"
    _example_ += "                        * next has 3 patterns.\n"
    _example_ += "                          1. next\n"
    _example_ += "                          2. xor(next, random)\n"
    _example_ += "                          3. xor(byteswap(next), random)"
    _category_ = "Qemu-system Cooperation"

    """
    struct kmem_cache {
        struct kmem_cache_cpu *cpu_slab;         // In fact, the offset value, not the pointer
        slab_flags_t flags;                      // unsigned int (+ padding 4 byte)
        unsigned long min_partial;
        unsigned int size;
        unsigned int object_size;
        struct reciprocal_value {                //
            u32 m;                               //
            u8 sh1, sh2;                         // (+ padding 2 byte)
        } reciprocal_size;                       // if kernel >= 5.9-rc1
        unsigned int offset;
        unsigned int cpu_partial;                // if CONFIG_SLUB_CPU_PARTIAL=y
        struct kmem_cache_order_objects oo;
        struct kmem_cache_order_objects max;
        struct kmem_cache_order_objects min;
        gfp_t allocflags;
        int refcount;
        void (*ctor)(void *);
        unsigned int inuse;
        unsigned int align;
        unsigned int red_left_pad;
        const char *name;
        struct list_head list; <-----> struct list_head <-----> struct list_head <-----> ...
        struct kobject kobj;                     // if CONFIG_SYSFS=y
        struct work struct kobj_remove_work;     // if CONFIG_SYSFS=y && kernel < 5.9-rc1
        struct memcg_cache_params memcg_params;  // if CONFIG_MEMCG=y && kernel < 5.9-rc1
        unsigned int max_attr_size;              // if CONFIG_MEMCG=y && kernel < 5.9-rc1
        struct kset *memcg_kset;                 // if CONFIG_MEMCG=y && CONFIG_SYSFS=y && kernel < 5.9-rc1
        unsigned long random;                    // if CONFIG_SLAB_FREELIST_HARDENED=y
        unsigned int remote_node_defrag_ratio;   // if CONFIG_NUMA=y
        unsigned int *random_seq;                // if CONFIG_SLAB_FREELIST_RANDOM=y
        struct kasan_cache kasan_info;           // if CONFIG_KASAN=y
        unsigned int useroffset;
        unsigned int usersize;
        struct kmem_cache_node *node[64];
    }

    struct kmem_cache_cpu {
        void **freelist;
        unsigned long tid;
        struct page *page;
        struct page *partial;                    // if CONFIG_SLUB_CPU_PARTIAL=y
        unsigned stat[NR_SLUB_STAT_ITEMS];       // if CONFIG_SLUB_STATS=y
    }
    """

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        return

    def init_offset(self):
        # resolve __per_cpu_offset
        self.__per_cpu_offset = KernelAddressHeuristicFinder.get_per_cpu_offset()
        if self.__per_cpu_offset is None:
            err("Failed to resolve `__per_cpu_offset`")
            return False
        else:
            info("__per_cpu_offset: {:#x}".format(self.__per_cpu_offset))

        # resolve each cpu_offset
        self.cpu_offset = [read_int_from_memory(self.__per_cpu_offset)]
        i = 1
        while True:
            off = read_int_from_memory(self.__per_cpu_offset + i*8)
            if off == self.cpu_offset[-1]:
                self.cpu_offset = self.cpu_offset[:-1]
                break
            self.cpu_offset.append(off)
            i += 1

        # resolve slab_caches
        self.slab_caches = KernelAddressHeuristicFinder.get_slab_caches()
        if self.slab_caches is None:
            err("Failed to resolve `slab_caches`")
            return False
        else:
            info("slab_caches: {:#x}".format(self.slab_caches))

        # offsetof(kmem_cache, list)
        current = list_next = read_int_from_memory(self.slab_caches)
        for off in range(0, 0x70, current_arch.ptrsize): # backward search for the start of `struct kmem_cache`
            val = read_int_from_memory(current - off)
            # saerch condition 1 (rare case)
            if (is_32bit() and (val & 0x80000000)) or (is_64bit() and (val & 0x8000000000000000)):
                try:
                    b = read_memory(val, 0x100)
                    if b == b"\x00"*0x100: # read ok, but data is none. `off` just points `struct kmem_cache->cpu_slab`
                        break
                except: # read error, so this is not address. `off` just points `struct kmem_cache->cpu_slab`
                    break
            # saerch condition 2 (normal case)
            a = read_int_from_memory(current - off - current_arch.ptrsize*1)
            b = read_int_from_memory(current - off - current_arch.ptrsize*2)
            if (a == b == 0) or (a == b == 0xcccccccc) or (a == b == 0xcccccccccccccccc):
                # normal case: [..., 0x0, 0x0, struct kmem_cache, ...]
                # rare case: [..., 0xcccccccc, 0xcccccccc, struct kmem_cache, ...]
                # rare case: [..., 0xcccccccccccccccc, 0xcccccccccccccccc, struct kmem_caches, ...]
                break
        else:
            # not found, so try x64 specific condition
            for diff in [0, 0x40]: # 0x80 or 0x40 align
                off = (current & 0x7f) + diff
                flags = read_int_from_memory(current - off + current_arch.ptrsize)
                if is_x86_64() and (flags & 0xfffffffffbf00fff) == 0x0000000040000000: # heuristic flags value
                    break
            else:
                err("offsetof(kmem_cache, list): Not Found")
                raise
        self.kmem_cache_offset_list = off
        info("offsetof(kmem_cache, list): {:#x}".format(self.kmem_cache_offset_list))

        # offsetof(kmem_cache, name)
        self.kmem_cache_offset_name = self.kmem_cache_offset_list - current_arch.ptrsize
        info("offsetof(kmem_cache, name): {:#x}".format(self.kmem_cache_offset_name))

        # offsetof(kmem_cache, offset)
        top = list_next - self.kmem_cache_offset_list
        objsize = u32(read_memory(top + current_arch.ptrsize*3+4, 4))
        maybe_recip = u32(read_memory(top + current_arch.ptrsize*3+4+4, 4))
        if objsize < maybe_recip or (maybe_recip % 8) != 0:
            self.kmem_cache_offset_offset = current_arch.ptrsize*3+4+4 + current_arch.ptrsize
        else:
            self.kmem_cache_offset_offset = current_arch.ptrsize*3+4+4
        info("offsetof(kmem_cache, offset): {:#x}".format(self.kmem_cache_offset_offset))

        # offsetof(kmem_cache, random)
        if self.no_xor:
            self.kmem_cache_offset_random = None
        else:
            current = top
            for i in range(64): # walk from list for heuristic search
                val = read_int_from_memory(current + i*current_arch.ptrsize)
                if is_64bit():
                    if (val >> 48) in [0, 0xffff, 0xfffe, 0xdead, current>>48]: # for la57: current>>48
                        continue
                    if (val >> 32) == (val & 0xffffffff):
                        continue
                    if "{:064b}".format(val).count("1") < 6: # low entrorpy is not `random`
                        continue
                    if "{:064b}".format(val).count("1") > 64-6: # low entrorpy is not `random`
                        continue
                    self.kmem_cache_offset_random = i*current_arch.ptrsize
                    info("offsetof(kmem_cache, random): {:#x}".format(self.kmem_cache_offset_random))
                    break
                elif is_32bit():
                    if (val >> 8) in [0, 0xffffff]: # 0x000000**, 0xffffff** are not `random`
                        continue
                    if (val & ~0x0f0ff000) == 0x40000000: # flag are not `random`
                        continue
                    if "{:032b}".format(val).count("1") < 6: # low entrorpy is not `random`
                        continue
                    if "{:032b}".format(val).count("1") > 32-6: # low entrorpy is not `random`
                        continue
                    if (val & 0xf) % 4 != 0: # not aligned, it is maybe `random`
                        self.kmem_cache_offset_random = i*current_arch.ptrsize
                        info("offsetof(kmem_cache, random): {:#x}".format(self.kmem_cache_offset_random))
                        break
                    try:
                        read_int_from_memory(val) # if no error, it is not `random`
                        continue
                    except:
                        self.kmem_cache_offset_random = i*current_arch.ptrsize
                        info("offsetof(kmem_cache, random): {:#x}".format(self.kmem_cache_offset_random))
                        break
            else:
                info("offsetof(kmem_cache, random): Not found")
                self.kmem_cache_offset_random = None # maybe CONFIG_SLAB_FREELIST_HARDENED=n

        # offsetof(kmem_cache, cpu_slab)
        self.kmem_cache_offset_cpu_slab = 0
        # offsetof(kmem_cache, object_size)
        self.kmem_cache_offset_object_size = current_arch.ptrsize*3+4
        # offsetof(kmem_cache_cpu, freelist)
        self.kmem_cache_cpu_offset_freelist = 0
        return True

    def get_next_kmem_cache(self, addr, point_to_base=True):
        if point_to_base:
            addr += self.kmem_cache_offset_list
        return read_int_from_memory(addr) - self.kmem_cache_offset_list

    def get_objsize(self, addr):
        return u32(read_memory(addr + self.kmem_cache_offset_object_size, 4))

    def get_offset(self, addr):
        return u32(read_memory(addr + self.kmem_cache_offset_offset, 4))

    def get_name(self, addr):
        name_addr = read_int_from_memory(addr + self.kmem_cache_offset_name)
        return read_cstring_from_memory(name_addr)

    def get_random(self, addr):
        if self.kmem_cache_offset_random is None:
            return 0
        else:
            return read_int_from_memory(addr + self.kmem_cache_offset_random)

    def get_kmem_cache_cpu(self, addr, cpu):
        cpu_slab = read_int_from_memory(addr + self.kmem_cache_offset_cpu_slab)
        kmem_cache_cpu = cpu_slab + self.cpu_offset[cpu]
        if is_64bit():
            return kmem_cache_cpu & 0xffffffffffffffff
        else:
            return kmem_cache_cpu & 0xffffffff

    def get_freelist(self, addr):
        return read_int_from_memory(addr + self.kmem_cache_cpu_offset_freelist)

    def byteswap(self, x):
        bits = 64 if is_64bit() else 32
        s = 0
        for i in range(0, bits, 8):
            s += ((x >> i) & 0xff) << (bits-(i+8))
        return s

    def pointer_xor(self, addr, chunk, cache):
        def pattern1(addr, chunk, cache):
            return chunk ^ addr ^ cache['random']

        def pattern2(addr, chunk, cache):
            return chunk ^ self.byteswap(addr) ^ cache['random']

        shift_bits = 48 if is_64bit() else 24

        if self.swap == False:
            chunk = pattern1(addr, chunk, cache)
        elif self.swap == True:
            chunk = pattern2(addr, chunk, cache)

        elif self.swap is None: # swap type is unknown, try heuristic check
            if pattern1(addr, chunk, cache) == 0:
                chunk = pattern1(addr, chunk, cache)
                self.swap = False
            elif (chunk >> shift_bits) == (cache['random'] >> shift_bits):
                chunk = pattern1(addr, chunk, cache)
                self.swap = False
            else:
                chunk = pattern2(addr, chunk, cache)
                self.swap = True
        return chunk

    def walk_caches(self, cpu):
        current_kmem_cache = self.get_next_kmem_cache(self.slab_caches, point_to_base=False)
        self.parsed_caches = [{'name': 'slab_caches', 'next': current_kmem_cache}]
        self.swap = None

        while current_kmem_cache + self.kmem_cache_offset_list != self.slab_caches:
            new_cache = {}
            # parse member
            new_cache['address'] = current_kmem_cache
            new_cache['objsize'] = objsize = self.get_objsize(current_kmem_cache)
            new_cache['offset'] = offset = self.get_offset(current_kmem_cache)
            new_cache['name'] = name = self.get_name(current_kmem_cache)
            new_cache['random'] = self.get_random(current_kmem_cache)
            # parse free_list
            new_cache['kmem_cache_cpu'] = kmem_cache_cpu = self.get_kmem_cache_cpu(current_kmem_cache, cpu)
            chunk = self.get_freelist(kmem_cache_cpu)
            new_cache['freelist'] = [chunk]
            while chunk:
                try:
                    addr = chunk + offset
                    chunk = read_int_from_memory(addr) # get next chunk
                except:
                    new_cache['freelist'].append("{:s}".format(Color.colorify("Corrupted (Memory access denied)", "bold yellow")))
                    break
                if self.kmem_cache_offset_random is not None: # fix if randomized
                    chunk = self.pointer_xor(addr, chunk, new_cache)
                if chunk % 8:
                    new_cache['freelist'].append("{:#x}: {:s}".format(chunk, Color.colorify("Corrupted (Not aligned)", "bold yellow")))
                    break
                if chunk in new_cache['freelist']:
                    new_cache['freelist'].append("{:#x}: {:s}".format(chunk, Color.colorify("Corrupted (Loop detected)", "bold yellow")))
                    break
                new_cache['freelist'].append(chunk)
            # goto next
            new_cache['next'] = current_kmem_cache = self.get_next_kmem_cache(current_kmem_cache)
            self.parsed_caches.append(new_cache)
        return

    def dump_caches(self, targets, cpu):
        gef_print('  ' + '-'*14)
        gef_print(' | ' + ' '*11 + ' |')
        gef_print(' |        slab_caches @ {:#x}'.format(self.slab_caches))
        gef_print(' | ' + ' '*11 + ' |')
        if targets != []:
            gef_print(' | ' + ' '*10 + ' ...')
            gef_print(' | ' + ' '*11 + ' |')
        gef_print(' | ' + ' '*11 + ' v')
        for c in self.parsed_caches[1:]:
            if targets != [] and not c['name'] in targets:
                continue
            gef_print(' |   name: {:s}'.format(c['name']))
            gef_print(' |   kmem_cache: {:#x}'.format(c['address']))
            gef_print(' |   kmem_cache_cpu (cpu{:d}): {:#x}'.format(cpu, c['kmem_cache_cpu']))
            gef_print(' |   offset (offset to next pointer in chunk): {:#x}'.format(c['offset']))
            gef_print(' |   objsize: {:s}'.format(Color.colorify("{:#x}".format(c['objsize']), "bold pink")))
            if c['random']:
                if self.no_xor == False and self.swap == True:
                    gef_print(' |   random (xor key): {:#x} ^ byteswap(address of chunk->next)'.format(c['random']))
                else:
                    gef_print(' |   random (xor key): {:#x} ^ address of chunk->next'.format(c['random']))
            if len(c['freelist']) > 0:
                if isinstance(c['freelist'][0], str):
                    gef_print(' |   freelist:   {:s}'.format(c['freelist'][0]))
                else:
                    gef_print(' |   freelist:   {:s}'.format(Color.colorify("{:#x}".format(c['freelist'][0]), "bold yellow")))
                for f in c['freelist'][1:]:
                    if isinstance(f, str):
                        gef_print(' | ' + ' '*14 + '{:s}'.format(f))
                    else:
                        gef_print(' | ' + ' '*14 + '{:s}'.format(Color.colorify("{:#x}".format(f), "bold yellow")))
            gef_print(' |   next: {:#x}'.format(c['next']))
            gef_print(' | ' + ' '*11 + ' |')
            if targets != []:
                gef_print(' | ' + ' '*10 + ' ...')
            gef_print(' | ' + ' '*11 + ' |')
            gef_print(' | ' + ' '*11 + ' v')
        gef_print('  <' + '-'*13)
        return

    def dump_names(self):
        gef_print(Color.colorify("Object Size              : Name", get_gef_setting("theme.table_heading")))
        for c in sorted(self.parsed_caches[1:], key=lambda x:x['name']):
            gef_print("{:5d} byte ({:#6x} bytes): {:s}".format(c['objsize'], c['objsize'], c['name']))
        return

    def slabwalk(self, targets):
        if self.init_offset() is False:
            err("Initialize failed")
            return

        if self.listup:
            self.walk_caches(0)
            self.dump_names()
            return

        if self.cpuN is None:
            for i in range(len(self.cpu_offset)):
                gef_print(titlify("CPU {:d}".format(i)))
                self.walk_caches(i)
                self.dump_caches(targets, i)
        else:
            if len(self.cpu_offset) > self.cpuN:
                gef_print(titlify("CPU {:d}".format(self.cpuN)))
                self.walk_caches(self.cpuN)
                self.dump_caches(targets, self.cpuN)
            else:
                err("CPU number is invalid (valid range:{:d}-{:d})".format(0, len(self.cpu_offset)-1))
        return

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_x86_32_64_or_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        try:
            self.cpuN = None
            while "--cpu" in argv:
                idx = argv.index("--cpu")
                self.cpuN = int(argv[idx + 1])
                argv = argv[:idx] + argv[idx+2:]
        except:
            self.usage()
            return

        self.no_xor = False
        if "--no-xor" in argv:
            self.no_xor = True
            argv.remove("--no-xor")

        self.listup = False
        if "--list" in argv:
            self.listup = True
            argv.remove("--list")

        info("Wait for memory scan")

        try:
            self.slabwalk(argv)
        except:
            err("Memory corrupted")
        return


@register_command
class KsymaddrRemoteCommand(GenericCommand):
    """Solve kernel symbols from kallsyms table using kenrel memory scanning.
    See: kernel/kallsyms.c"""
    _cmdline_ = "ksymaddr-remote"
    _syntax_ = "{:s} [-h] KEYWORD|--print-all [--head N] [--silent] [--exact] [--meta]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} --print-all # print all symbols found\n".format(_cmdline_)
    _example_ += "{:s} cred --head 30 # print symbols included \"cred\" with only first 30 hit\n".format(_cmdline_)
    _example_ += "{:s} cred --silent # print symbols included \"cred\" with quiet mode\n".format(_cmdline_)
    _example_ += "{:s} commit_creds prepare_kernel_cred # OR search\n".format(_cmdline_)
    _example_ += "Search flow:\n"
    _example_ += "1. get address of kernel_base\n"
    _example_ += "2. get address of kernel_base_rodata\n"
    _example_ += "3. get address of kallsyms_relative_base\n"
    _example_ += "4. get address of kallsyms_names\n"
    _example_ += "5. get address of kallsyms_offsets\n"
    _example_ += "6. get address of kallsyms_token_table\n"
    _example_ += "7. get address of kallsyms_token_index\n"
    _example_ += "8. walk kallsyms\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC."
    _category_ = "Qemu-system Cooperation"

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        self.initialized = False
        self.maps = None
        self.kallsyms = []
        return

    def expand_symbol(self, off):
        data = off
        len_ = self.kallsyms_names[data]
        data += 1

        string = ""
        skipped_first = False
        off = len_ + 1
        while len_:
            tptr = self.kallsyms_token_index[self.kallsyms_names[data]]
            data += 1
            len_ -= 1

            while True:
                c = self.kallsyms_token_table[tptr]
                if c == 0:
                    break
                if skipped_first:
                    string += chr(c)
                else:
                    skipped_first = True
                tptr += 1
        return off, string

    def kallsyms_sym_address(self, idx):
        if self.kallsyms_relative_base is None:
            relative_base = 0
        else:
            relative_base = self.kallsyms_relative_base

        val = self.kallsyms_offsets[idx]
        if not self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU:
            return relative_base + val
        if val >= 0:
            return val
        else:
            return relative_base - 1 - val

    def kallsyms_get_symbol_type(self, off):
        idx1 = self.kallsyms_names[off + 1]
        idx2 = self.kallsyms_token_index[idx1]
        typ = self.kallsyms_token_table[idx2]
        return chr(typ)

    def resolve_kallsyms(self):
        if self.kallsyms != []: # resolved already
            return
        off = 0
        for i in range(self.kallsyms_num_syms):
            offdiff, string = self.expand_symbol(off)
            typ = self.kallsyms_get_symbol_type(off)
            off += offdiff
            addr = self.kallsyms_sym_address(i)
            self.kallsyms.append([addr, string, typ])
        return

    def print_kallsyms(self, keywords):
        if is_32bit():
            fmt = "{:#010x} {:s} {:s}"
        else:
            fmt = "{:#018x} {:s} {:s}"
        print_count = 0
        for addr, string, typ in self.kallsyms:
            if print_count == self.head:
                break
            if self.print_all:
                gef_print(fmt.format(addr, typ, string))
                print_count += 1
            else:
                for k in keywords:
                    text = fmt.format(addr, typ, string)
                    if self.exact and k == string:
                        gef_print(text)
                        print_count += 1
                        break
                    elif not self.exact and k in text:
                        gef_print(text)
                        print_count += 1
                        break
        return

    # Initialize variables in different ways, depending on the situation.
    #
    # The variables need to find are as follows.
    # 1. kallsyms_relative_base
    # 2. kallsyms_num_syms
    # 3. kallsyms_names
    # 4. CONFIG_KALLSYMS_ABSOLUTE_PERCPU is enabled or not
    # 5. kallsyms_offsets
    # 6. kallsyms_markers
    # 7. kallsyms_token_table
    # 8. kallsyms_token_index
    #
    # The method for searching the above variables is different for 64bit / 32bit.
    # It also depends on whether each variable in memory has a large padding (called sparse) or not (called normal).
    #
    # Variables to use
    #   self.kbase:         address of kernel .text
    #   self.krobase:       address of kernel .rodata
    #   self.RO_REGION:     data of .rodata; bytes([0xef, 0xbe, 0xad, 0xde...])
    #   self.RO_REGION_u32: data of .rodata; [0xdeadbeef, ...]
    #   self.RO_REGION_u64: data of .rodata; [0x00000000deadbeef, ...]

    # 32bit is very complicated. 64bit is simple
    def initialize32_kallsyms_relative_base(self):
        # 1. find kbase from rodata
        if is_x86_32():
            # recent kernel (buildroot:5.4.58, debian11.3:5.10.0-13)
            for idx, tmp in enumerate(self.RO_REGION_u32[:-1]):
                if tmp & 0xfff: # should be aligned
                    continue
                if (tmp & 0xffff0000) != (self.kbase & 0xffff0000): # holds around kbase
                    continue
                if self.RO_REGION_u32[idx + 1] > 0x4ffff: # next address is kallsyms_num_syms. too large number is fail
                    continue
                if 0 < self.RO_REGION_u32[idx + 1] < 0x100 : # next address is kallsyms_num_syms. too small number is fail
                    continue
                self.kallsyms_relative_base = tmp
                self.kallsyms_relative_base_off = idx
                self.kallsyms_relative_base_addr = self.krobase + self.kallsyms_relative_base_off * 4
                return

            # i386 (ooofs:4.4.223)
            for i, val in enumerate(self.RO_REGION_u32[::-1]): # use backward search because if found multiple then select the last one
                if val == self.kbase:
                    pos = len(self.RO_REGION_u32) - i - 1
                    # found contiguous, go prev as possilbe
                    while self.RO_REGION_u32[pos] == self.RO_REGION_u32[pos-1]:
                        pos -= 1
                    self.kallsyms_relative_base = self.kbase
                    self.kallsyms_relative_base_off = pos
                    self.kallsyms_relative_base_addr = self.krobase + self.kallsyms_relative_base_off * 4
                    return

        elif is_arm32():
            # recent kernel (debian 11.3:5.10.0-14)
            for idx, tmp in enumerate(self.RO_REGION_u32[:-1]):
                if tmp & 0xfff: # should be aligned
                    continue
                if (tmp & 0xffff0000) != (self.kbase & 0xffff0000): # holds around kbase
                    continue
                if self.RO_REGION_u32[idx + 1] > 0x4ffff: # next address is kallsyms_num_syms. too large number is fail
                    continue
                if 0 < self.RO_REGION_u32[idx + 1] < 0x100 : # next address is kallsyms_num_syms. too small number is fail
                    continue
                self.kallsyms_relative_base = tmp
                self.kallsyms_relative_base_off = idx
                self.kallsyms_relative_base_addr = self.krobase + self.kallsyms_relative_base_off * 4
                return

            # ARM has specific relative_base (buildroot:5.4.58, debian10.4:4.19.0-9)
            for i in range(4):
                try:
                    kbase_diff = -(0x100000*i + 0xf8000)
                    self.kallsyms_relative_base = self.kbase + kbase_diff
                    self.kallsyms_relative_base_off = self.RO_REGION_u32.index(self.kallsyms_relative_base)
                    self.kallsyms_relative_base_addr = self.krobase + self.kallsyms_relative_base_off * 4
                    if self.meta:
                        info("kbase difference is {:#x}".format(kbase_diff))
                    return
                except:
                    pass

        # not found
        if not self.silent:
            err("Failed to identified kallsyms_relative_base (not found kernel_base in kernel_robase)")
        self.kallsyms_relative_base = None
        self.kallsyms_relative_base_off = None
        self.kallsyms_relative_base_addr = None
        return

    def initialize32_sparse_kallsyms_num_syms(self):
        # 1. next to it (16 bytes aligned)
        self.kallsyms_num_syms_addr = self.kallsyms_relative_base_addr + 0x10
        self.kallsyms_num_syms_off = self.kallsyms_relative_base_off + 4
        self.kallsyms_num_syms = self.RO_REGION_u32[self.kallsyms_num_syms_off]
        return

    def initialize32_sparse_kallsyms_names(self):
        # 1. next to it (16 bytes aligned)
        self.kallsyms_names_addr = self.kallsyms_num_syms_addr + 0x10
        self.kallsyms_names_off = self.kallsyms_num_syms_off + 4
        return

    def initialize32_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU(self):
        # 1. walk to prev and found non-zero value
        # 2. if the MSB of the element is on, then it is pattern 4 at kallsyms_sym_address() in root/kernel/kallsyms.c.
        #    so not pattern 2, therefore, CONFIG_KALLSYMS_ABSOLUTE_PERCPU = True
        pos = self.kallsyms_relative_base_off - 4
        while self.RO_REGION_u32[pos] == 0:
            pos -= 1
        self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU = (((self.RO_REGION_u32[pos] >> 31) & 1) == 1)
        return

    def initialize32_sparse_kallsyms_offsets(self):
        # 1. calc
        if self.kallsyms_relative_base is None:
            self.kallsyms_offsets_addr = self.kallsyms_num_syms_addr - self.kallsyms_num_syms * 4
        else:
            self.kallsyms_offsets_addr = self.kallsyms_relative_base_addr - self.kallsyms_num_syms * 4
        self.kallsyms_offsets_addr &= ~0xf # 16 bytes aligned
        return

    def initialize32_sparse_kallsyms_markers(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_names_off
        while True:
            if self.RO_REGION_u32[pos] == 0 and pos % 4 == 0:
                self.kallsyms_markers_off = pos
                self.kallsyms_markers_addr = self.krobase + pos * 4
                break
            pos += 1
        return

    def initialize32_sparse_kallsyms_token_table(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_markers_off
        while True: # use pos above
            v = self.RO_REGION_u32[pos]
            if v & 0xff000000 > 0 or (self.RO_REGION_u32[pos-1] > 0 and self.RO_REGION_u32[pos-1]*4 < v):
                self.kallsyms_token_table_addr = self.krobase + pos * 4
                break
            pos += 4
        return

    def initialize32_sparse_kallsyms_token_index(self):
        # 1. walk to next until contiguous zero value. it is end of marker of kallsyms_token_table
        # 2. align
        pos = self.kallsyms_token_table_addr - self.krobase
        while True:
            if self.RO_REGION[pos] == 0 and self.RO_REGION[pos+1] == 0:
                pos += 1
                while pos % 16: # need align
                    pos += 1
                self.kallsyms_token_index_addr = self.krobase + pos
                break
            pos += 1
        return

    def initialize32_normal_kallsyms_num_syms(self):
        # 1. next to it
        self.kallsyms_num_syms_addr = self.kallsyms_relative_base_addr + 0x4
        self.kallsyms_num_syms_off = self.kallsyms_relative_base_off + 1
        self.kallsyms_num_syms = self.RO_REGION_u32[self.kallsyms_num_syms_off]
        return

    def initialize32_normal_kallsyms_names(self):
        # 1. next to it
        self.kallsyms_names_addr = self.kallsyms_num_syms_addr + 0x4
        self.kallsyms_names_off = self.kallsyms_num_syms_off + 1
        return

    def initialize32_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU(self):
        # 1. prev to it
        # 2. if the MSB of the element is on, then it is pattern 4 at kallsyms_sym_address() in root/kernel/kallsyms.c.
        #    so not pattern 2, therefore, CONFIG_KALLSYMS_ABSOLUTE_PERCPU = True
        pos = self.kallsyms_relative_base_off - 4
        self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU = (((self.RO_REGION_u32[pos] >> 31) & 1) == 1)
        return

    def initialize32_normal_kallsyms_offsets(self):
        # 1. calc
        if self.kallsyms_relative_base is None:
            self.kallsyms_offsets_addr = self.kallsyms_num_syms_addr - self.kallsyms_num_syms * 4
        else:
            self.kallsyms_offsets_addr = self.kallsyms_relative_base_addr - self.kallsyms_num_syms * 4
        return

    def initialize32_normal_kallsyms_markers(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_names_off
        while True:
            if self.RO_REGION_u32[pos] == 0: # search kallsyms_markers
                self.kallsyms_markers_off = pos
                self.kallsyms_markers_addr = self.krobase + pos * 4 # need not align
                break
            pos += 1
        return

    def initialize32_normal_kallsyms_token_table(self):
        # 1. walk to next until specific value
        # 2. align
        pos = self.kallsyms_markers_off
        pos += 1 # skip first zero
        while True:
            v = self.RO_REGION_u32[pos]
            """
            0xcc7c3ee0:     0x00069468      0x0006a096      0x0006aebe      0x0006baaa
            0xcc7c3ef0:     0x0006c5b4      0x0006d186      0x0006dc59     [0x005f7366] <-- begining of kallsyms_token_table
            0xcc7c3f00:     0x00657374      0x61007474      0x7400646e      0x006e6f69      (heuristic: prev_value * 4 < this_value)
            0xcc7c3f10:     0x66006f66      0x5f656572      0x65735f00      0x656d0074
            0xcc7c3f20:     0x6474006d      0x005f7200      0x74006354      0x63005f6f
            """
            if v == 0 or (v & 0xff000000) > 0 or (self.RO_REGION_u32[pos-1] > 0 and self.RO_REGION_u32[pos-1]*4 < v) :
                self.kallsyms_token_table_addr = self.krobase + pos * 4 # need not align
                break
            pos += 1
        return

    def initialize32_normal_kallsyms_token_index(self):
        # 1. walk to next until contiguous zero value. it is end of marker of kallsyms_token_table
        # 2. align
        pos = self.kallsyms_token_table_addr - self.krobase
        while True:
            if self.RO_REGION[pos] == 0 and self.RO_REGION[pos+1] == 0:
                pos += 1
                while pos % 4: # need align
                    pos += 1
                self.kallsyms_token_index_addr = self.krobase + pos
                break
            pos += 1
        return

    def initialize64_kallsyms_relative_base(self):
        # 1. find kbase from rodata
        for idx, tmp in enumerate(self.RO_REGION_u64[:-1]):
            if tmp & 0xffff: # kbase should be aligned
                continue
            if (tmp & 0xfffffffffff00000) != (self.kbase & 0xfffffffffff00000): # the candidate holds around kbase (usually just kbase)
                continue
            if self.RO_REGION_u64[idx + 1] > 0x4ffff: # next element is kallsyms_num_syms. too large number is fail
                continue
            self.kallsyms_relative_base = tmp
            self.kallsyms_relative_base_off = idx
            self.kallsyms_relative_base_addr = self.krobase + self.kallsyms_relative_base_off * 8
            return
        if not self.silent:
            err("Failed to identified kallsyms_relative_base (not found kernel_base in kernel_robase)")
        self.kallsyms_relative_base = None
        self.kallsyms_relative_base_off = None
        self.kallsyms_relative_base_addr = None
        return

    def initialize64_sparse_kallsyms_num_syms(self):
        # 1. next to it (256 bytes aligned)
        self.kallsyms_num_syms_addr = self.kallsyms_relative_base_addr + 0x100
        self.kallsyms_num_syms_off = self.kallsyms_relative_base_off + 32
        self.kallsyms_num_syms = self.RO_REGION_u64[self.kallsyms_num_syms_off]
        return

    def initialize64_sparse_kallsyms_names(self):
        # 1. next to it (256 bytes aligned)
        self.kallsyms_names_addr = self.kallsyms_num_syms_addr + 0x100
        self.kallsyms_names_off = self.kallsyms_num_syms_off + 32
        return

    def initialize64_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU(self):
        # 1. walk to prev and found non-zero value
        # 2. if the MSB of the element is on, then it is pattern 4 at kallsyms_sym_address() in root/kernel/kallsyms.c.
        #    so not pattern 2, therefore, CONFIG_KALLSYMS_ABSOLUTE_PERCPU = True
        pos = self.kallsyms_relative_base_off*2 - 4 # from u64 pos to u32 pos
        while self.RO_REGION_u32[pos] == 0:
            pos -= 1
        self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU = (((self.RO_REGION_u32[pos] >> 31) & 1) == 1)
        return

    def initialize64_sparse_kallsyms_offsets(self):
        # 1. calc
        if self.kallsyms_relative_base is None:
            self.kallsyms_offsets_addr = self.kallsyms_num_syms_addr - self.kallsyms_num_syms * 8
        else:
            self.kallsyms_offsets_addr = self.kallsyms_relative_base_addr - self.kallsyms_num_syms * 4
        self.kallsyms_offsets_addr &= ~0xff # 256 bytes aligned
        return

    def initialize64_sparse_kallsyms_markers(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_names_off
        while True:
            if self.RO_REGION_u64[pos] == 0 and pos % 32 == 0:
                self.kallsyms_markers_off = pos
                self.kallsyms_markers_addr = self.krobase + pos * 8
                break
            pos += 1
        return

    def initialize64_sparse_kallsyms_token_table(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_markers_off
        while True: # use pos above
            v = self.RO_REGION_u64[pos]
            if v & 0xffffffffff000000 > 0 or (self.RO_REGION_u64[pos-1] > 0 and self.RO_REGION_u64[pos-1]*4 < v):
                self.kallsyms_token_table_addr = self.krobase + pos * 8
                break
            pos += 32
        return

    def initialize64_sparse_kallsyms_token_index(self):
        # 1. walk to next until contiguous zero value. it is end of marker of kallsyms_token_table
        # 2. align
        pos = self.kallsyms_token_table_addr - self.krobase
        while True:
            if self.RO_REGION[pos] == 0 and self.RO_REGION[pos+1] == 0:
                pos += 1
                while pos % 256: # need align
                    pos += 1
                self.kallsyms_token_index_addr = self.krobase + pos
                break
            pos += 1
        return

    def initialize64_normal_kallsyms_num_syms(self):
        # 1. next to it
        self.kallsyms_num_syms_addr = self.kallsyms_relative_base_addr + 0x8
        self.kallsyms_num_syms_off = self.kallsyms_relative_base_off + 1
        self.kallsyms_num_syms = self.RO_REGION_u64[self.kallsyms_num_syms_off]
        return

    def initialize64_normal_kallsyms_names(self):
        # 1. next to it
        self.kallsyms_names_addr = self.kallsyms_num_syms_addr + 0x8
        self.kallsyms_names_off = self.kallsyms_num_syms_off + 1
        return

    def initialize64_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU(self):
        # 1. prev to it
        # 2. if the MSB of the element is on, then it is pattern 4 at kallsyms_sym_address() in root/kernel/kallsyms.c.
        #    so not pattern 2, therefore, CONFIG_KALLSYMS_ABSOLUTE_PERCPU = True
        pos = self.kallsyms_relative_base_off*2 - 4 # from u64 pos to u32 pos
        self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU = (((self.RO_REGION_u32[pos] >> 31) & 1) == 1)
        return

    def initialize64_normal_kallsyms_offsets(self):
        # 1. calc
        # 2. align
        if self.kallsyms_relative_base is None:
            self.kallsyms_offsets_addr = self.kallsyms_num_syms_addr - self.kallsyms_num_syms * 8
        else:
            self.kallsyms_offsets_addr = self.kallsyms_relative_base_addr - self.kallsyms_num_syms * 4
        self.kallsyms_offsets_addr &= ~0x7
        return

    def initialize64_normal_kallsyms_markers(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_names_off * 2 # needs twice to use RO_REGION_u32
        while True:
            if self.RO_REGION_u32[pos] == 0: # search kallsyms_markers
                while pos % 2: # need align
                    pos += 1
                self.kallsyms_markers_off = pos
                self.kallsyms_markers_addr = self.krobase + pos * 4
                break
            pos += 1
        return

    def initialize64_normal_kallsyms_token_table(self):
        # 1. check array type is u32 or u64
        # 2. walk to next until specific value
        # 3. align
        pos = self.kallsyms_markers_off
        if self.RO_REGION_u32[pos] == 0 and self.RO_REGION_u32[pos+1] == 0: # u64 mode
            if self.meta:
                info("u64 mode at initialize64_normal_kallsyms_token_table")
            """
                0xffffffff987aaf80:     0x0000000000086329      0x000000000008724d
                0xffffffff987aaf90:     0x3131323038656565 *    0x6572007365725f00
                0xffffffff987aafa0:     0x65735f0074736967      0x6c6261005f360074
                0xffffffff987aafb0:     0x656565006c660065      0x2e00656b00647400
            """
            pos = pos//2 + 1 # skip first zero
            while True:
                if self.RO_REGION_u64[pos] == 0 or (self.RO_REGION_u64[pos] & 0xffffffffff000000) > 0:
                    self.kallsyms_token_table_addr = self.krobase + pos * 8
                    break
                pos += 1
        else: # u32 mode
            if self.meta:
                info("u32 mode at initialize64_normal_kallsyms_token_table")
            """
            [pattern 1 krce]
                0xffffffffbd101840:     0x000595e8      0x0005a026      0x0005a966      0x00000000
                0xffffffffbd101850:     0x00686361 *    0x00706572      0x63007674      0x00636568
                0xffffffffbd101860:     0x7465735f      0x34367800      0x0079735f      0x00343678
                0xffffffffbd101870:     0x00726f63      0x66006354      0x6900726f      0x74005f63
            [pattern 2 poe]
                0xffffffff9a866400:     0x0010c631      0x0010d091      0x0010db64      0x0010e677
                0xffffffff9a866410:     0x0010f0f2      0x00000000      0x00646e61 *    0x61727474
                0xffffffff9a866420:     0x005f6563      0x69676572      0x72657473      0x6f74005f
                0xffffffff9a866430:     0x332e005f      0x6e696600      0x74786500      0x78005f34
            [pattern 3 own buildroot]
                0xffffffff9d0e9dd0:     0x000506f3      0x00051205      0x00051dfc      0x000529fc
                0xffffffff9d0e9de0:     0x0005354d      0x00053fdc      0x00054a51      0x000554e1
                0xffffffff9d0e9df0:     0x6c006563 *    0x62740061      0x00767400      0x7465735f
                0xffffffff9d0e9e00:     0x666e6900      0x676e6900      0x006c6f00      0x00726f66
            [pattern 4 kone_gadget]
                0xffffffff81cfbff0:     0x00056381      0x00056f2b      0x00057a59      0x00058451
                0xffffffff81cfc000:     0x00058ebd      0x0005994f      0x00686361 *    0x7465735f
                0xffffffff81cfc010:     0x65686300      0x6f630063      0x76740072      0x70657200
                0xffffffff81cfc020:     0x726f6600      0x34367800      0x0079735f      0x00343678
            """
            pos += 1 # skip first zero
            pos += 2 # we want to use (pos, pos-1, pos-2), so avoid bug
            while True:
                if self.RO_REGION_u32[pos] == 0: # pattern 1, 2
                    self.kallsyms_token_table_addr = self.krobase + (pos+1) * 4
                    break
                diff1 = self.RO_REGION_u32[pos-1] - self.RO_REGION_u32[pos-2]
                diff2 = self.RO_REGION_u32[pos-0] - self.RO_REGION_u32[pos-1]
                if diff1 * 100 < diff2: # pattern 3, 4
                    self.kallsyms_token_table_addr = self.krobase + pos * 4
                    break
                pos += 1
        return

    def initialize64_normal_kallsyms_token_index(self):
        # 1. walk to next until contiguous zero value. it is end of marker of kallsyms_token_table
        # 2. align
        pos = self.kallsyms_token_table_addr - self.krobase
        while True:
            if self.RO_REGION[pos] == 0 and self.RO_REGION[pos+1] == 0:
                pos += 1
                while pos % 8: # need align
                    pos += 1
                self.kallsyms_token_index_addr = self.krobase + pos
                break
            pos += 1
        return

    def initialize32_kallsyms_num_syms_2(self):
        # 1. walk next
        # because used aboslute value, similar addresses are lined up
        # 0xc1940888:     0xc1000000      0xc1000000      0xc10000bc      0xc10000cc
        # 0xc1940898:     0xc10000ed      0xc1000165      0xc10001e7      0xc1000239
        # ...
        # 0xc198f0ac:     0xc1e85000      0xc1e95000      0xc1e9b000      0xc1e9b000
        # 0xc198f0bc:     0x00013a0d <- kallsyms_num_syms_addr
        pos = self.kallsyms_relative_base_off
        while True:
            val = self.RO_REGION_u32[pos]
            if val != 0 and (val >> 20) == 0:
                self.kallsyms_num_syms_addr = self.krobase + pos * 4
                self.kallsyms_num_syms_off = pos
                self.kallsyms_num_syms = val
                break
            pos += 1
        return

    def initialize64_kallsyms_num_syms_2(self):
        # 1. walk next
        # because used aboslute value, similar addresses are lined up
        pos = self.kallsyms_relative_base_off
        while True:
            val = self.RO_REGION_u64[pos]
            if val != 0 and (val >> 32) == 0:
                self.kallsyms_num_syms_addr = self.krobase + pos * 8
                self.kallsyms_num_syms_off = pos
                self.kallsyms_num_syms = val
                break
            pos += 1
        return

    def initialize32(self):
        self.RO_REGION = read_memory(self.krobase, self.krobase_size)
        self.RO_REGION_u32 = [u32(self.RO_REGION[i:i+4]) for i in range(0, len(self.RO_REGION), 4)]
        self.initialize32_kallsyms_relative_base()

        if self.kallsyms_relative_base_off is None:
            return None

        if self.RO_REGION_u32[self.kallsyms_relative_base_off + 1] == self.RO_REGION_u32[self.kallsyms_relative_base_off]: # rare case (maybe no kASLR kernel)
            self.initialize32_kallsyms_num_syms_2() # common to sparse and normal
            # do not use kallsyms_relative_base, use absolute value
            self.kallsyms_relative_base = None
            if self.RO_REGION_u32[self.kallsyms_num_syms_off + 1] == 0: # sparse mode (rare case)
                if self.meta: info("not exist relative_base. treat as sparse mode (rare case)")
                # all variables placed as 16 bytes aligned
                self.initialize32_sparse_kallsyms_names()
                self.initialize32_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
                self.initialize32_sparse_kallsyms_offsets()
                self.initialize32_sparse_kallsyms_markers()
                self.initialize32_sparse_kallsyms_token_table()
                self.initialize32_sparse_kallsyms_token_index()
            else: # normal mode (rare case)
                if self.meta: info("not exist relative_base, treat as normal mode (rare case)")
                self.initialize32_normal_kallsyms_names()
                self.initialize32_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
                self.initialize32_normal_kallsyms_offsets()
                self.initialize32_normal_kallsyms_markers()
                self.initialize32_normal_kallsyms_token_table()
                self.initialize32_normal_kallsyms_token_index()
        elif self.RO_REGION_u32[self.kallsyms_relative_base_off + 1] == 0: # sparse mode
            if self.meta: info("exist relative_base, treat as sparse mode")
            # all variables placed as 16 bytes aligned
            self.initialize32_sparse_kallsyms_num_syms()
            self.initialize32_sparse_kallsyms_names()
            self.initialize32_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
            self.initialize32_sparse_kallsyms_offsets()
            self.initialize32_sparse_kallsyms_markers()
            self.initialize32_sparse_kallsyms_token_table()
            self.initialize32_sparse_kallsyms_token_index()
        else: # normal mode
            if self.meta: info("exist relative_base, treat as normal mode")
            self.initialize32_normal_kallsyms_num_syms()
            self.initialize32_normal_kallsyms_names()
            self.initialize32_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
            self.initialize32_normal_kallsyms_offsets()
            self.initialize32_normal_kallsyms_markers()
            self.initialize32_normal_kallsyms_token_table()
            self.initialize32_normal_kallsyms_token_index()
        return True

    def initialize64(self):
        self.RO_REGION = read_memory(self.krobase, self.krobase_size)
        self.RO_REGION_u64 = [u64(self.RO_REGION[i:i+8]) for i in range(0, len(self.RO_REGION), 8)]
        self.RO_REGION_u32 = [u32(self.RO_REGION[i:i+4]) for i in range(0, len(self.RO_REGION), 4)]
        self.initialize64_kallsyms_relative_base()

        if self.RO_REGION_u64[self.kallsyms_relative_base_off + 1] == self.RO_REGION_u64[self.kallsyms_relative_base_off]: # rare case
            self.initialize64_kallsyms_num_syms_2() # common to sparse and normal
            # do not use kallsyms_relative_base, use absolute value
            self.kallsyms_relative_base = None
            if self.RO_REGION_u64[self.kallsyms_num_syms_off + 1] == 0: # sparse mode (rare case)
                if self.meta: info("not exist relative_base, treat as sparse mode (rare case)")
                # all variables placed as 256 bytes aligned
                self.initialize64_sparse_kallsyms_names()
                self.initialize64_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
                self.initialize64_sparse_kallsyms_offsets()
                self.initialize64_sparse_kallsyms_markers()
                self.initialize64_sparse_kallsyms_token_table()
                self.initialize64_sparse_kallsyms_token_index()
            else: # normal mode (rare case)
                if self.meta: info("not exist relative_base, treat as normal mode (rare case)")
                self.initialize64_normal_kallsyms_names()
                self.initialize64_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
                self.initialize64_normal_kallsyms_offsets()
                self.initialize64_normal_kallsyms_markers()
                self.initialize64_normal_kallsyms_token_table()
                self.initialize64_normal_kallsyms_token_index()
        elif self.RO_REGION_u64[self.kallsyms_relative_base_off + 1] == 0: # sparse mode
            if self.meta: info("exist relative_base, treat as sparse mode")
            # all variables placed as 256 bytes aligned
            self.initialize64_sparse_kallsyms_num_syms()
            self.initialize64_sparse_kallsyms_names()
            self.initialize64_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
            self.initialize64_sparse_kallsyms_offsets()
            self.initialize64_sparse_kallsyms_markers()
            self.initialize64_sparse_kallsyms_token_table()
            self.initialize64_sparse_kallsyms_token_index()
        else: # normal mode
            if self.meta: info("exist relative_base, treat as normal mode")
            self.initialize64_normal_kallsyms_num_syms()
            self.initialize64_normal_kallsyms_names()
            self.initialize64_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
            self.initialize64_normal_kallsyms_offsets()
            self.initialize64_normal_kallsyms_markers()
            self.initialize64_normal_kallsyms_token_table()
            self.initialize64_normal_kallsyms_token_index()
        return True

    def print_meta(self, force=False):
        if self.meta or force:
            try:
                info("kernel_base:            {:#x}".format(self.kbase)) # to saerch kallsyms_*
                info("kernel_robase:          {:#x}".format(self.krobase)) # to saerch kallsyms_*
                if self.kallsyms_relative_base:
                    info("kallsyms_relative_base: {:#x}: {:#x}".format(self.kallsyms_relative_base_addr, self.kallsyms_relative_base))
                    info("kallsyms_num_syms:      {:#x}: {:#x}".format(self.kallsyms_num_syms_addr, self.kallsyms_num_syms))
                    gdb.execute("x/4x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_relative_base_addr))
                else:
                    info("kallsyms_relative_base: None")
                    info("kallsyms_num_syms:      {:#x}: {:#x}".format(self.kallsyms_num_syms_addr, self.kallsyms_num_syms))
                    gdb.execute("x/4x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_num_syms_addr))
                info("kallsyms_names          {:#x}".format(self.kallsyms_names_addr)) # to lookup symbol
                gdb.execute("x/8x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_names_addr - 0x10))
                info("CONFIG_KALLSYMS_ABSOLUTE_PERCPU: {:d}".format(self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU)) # to calculate address
                info("kallsyms_offsets:       {:#x}".format(self.kallsyms_offsets_addr)) # to lookup symbol
                gdb.execute("x/8x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_offsets_addr - 0x10))
                info("kallsyms_markers:       {:#x}".format(self.kallsyms_markers_addr)) # to search kallsyms_*
                gdb.execute("x/8x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_markers_addr - 0x10))
                info("kallsyms_token_table:   {:#x}".format(self.kallsyms_token_table_addr)) # to calculate address
                gdb.execute("x/8x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_token_table_addr - 0x10))
                info("kallsyms_token_index:   {:#x}".format(self.kallsyms_token_index_addr)) # to calculate address
                gdb.execute("x/8x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_token_index_addr - 0x10))
            except:
                pass
        return

    def initialize(self):
        if self.initialized:
            self.print_meta()
            return True
        # get kernel memory maps
        if not self.silent:
            info("Wait for memory scan")
        self.maps = KernelbaseCommand.get_maps()
        if self.maps is None:
            return None
        # get kernel base
        self.kbase, self.kbase_size = KernelbaseCommand.get_kernel_base(self.maps)
        if self.kbase is None:
            return None
        # get kernel ro_base
        self.krobase, self.krobase_size = KernelbaseCommand.get_kernel_rodata_base(self.maps, self.kbase)
        if self.krobase is None:
            return None
        # resolve some address
        if is_32bit():
            res = self.initialize32()
        elif is_64bit():
            res = self.initialize64()
        if res:
            # prepare each byte array
            if self.kallsyms_relative_base is None:
                r = self.RO_REGION[self.kallsyms_offsets_addr - self.krobase: self.kallsyms_num_syms_addr - self.krobase]
                if is_64bit():
                    self.kallsyms_offsets = [ u64(r[i:i+8]) for i in range(0, len(r), 8)] # unsigned 64bit
                else:
                    self.kallsyms_offsets = [ u32(r[i:i+4]) for i in range(0, len(r), 4)] # unsigned 32bit
            else:
                r = self.RO_REGION[self.kallsyms_offsets_addr - self.krobase: self.kallsyms_relative_base_addr - self.krobase]
                self.kallsyms_offsets = [ u32(r[i:i+4], s=True) for i in range(0, len(r), 4)] # signed 32bit
            r = self.RO_REGION[self.kallsyms_names_addr - self.krobase: self.kallsyms_markers_addr - self.krobase]
            self.kallsyms_names = [ u8(r[i:i+1]) for i in range(0, len(r), 1)] # 8bit
            r = self.RO_REGION[self.kallsyms_token_table_addr - self.krobase: self.kallsyms_token_index_addr - self.krobase]
            self.kallsyms_token_table = [ u8(r[i:i+1]) for i in range(0, len(r), 1)] # 8bit
            r = self.RO_REGION[self.kallsyms_token_index_addr - self.krobase:][:0x100*2] # fixed table size
            self.kallsyms_token_index = [u16(r[i:i+2]) for i in range(0, len(r), 2)] # 16bit
            self.initialized = True
        # finish
        self.print_meta()
        return True if res else False

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_x86_32_64_or_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if not argv:
            self.usage()
            return

        if "-h" in argv:
            self.usage()
            return

        self.meta = False
        if "--meta" in argv:
            self.meta = True
            argv.remove("--meta")

        self.silent = False
        if "--silent" in argv:
            self.silent = True
            argv.remove("--silent")

        self.exact = False
        if "--exact" in argv:
            self.exact = True
            argv.remove("--exact")

        self.head = -1
        if "--head" in argv:
            idx = argv.index("--head")
            headN = argv[idx + 1]
            self.head = int(headN)
            argv = argv[:idx] + argv[idx+2:]

        self.print_all = False
        if "--print-all" in argv:
            self.print_all = True
            argv.remove("--print-all")
        if argv == []:
            self.print_all = True

        if not self.initialize():
            return
        self.resolve_kallsyms()
        self.print_kallsyms(argv)
        return


@register_command
class VmlinuxToElfApplyCommand(GenericCommand):
    """Apply symbol from kallsyms in memory using vmlinux-to-elf (too slow but more accurate)"""
    _cmdline_ = "vmlinux-to-elf-apply"
    _syntax_ = "{:s} [--reparse]".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @staticmethod
    def dump_kernel_elf(dumped_mem_file, symboled_vmlinux_file, force=False):
        """Dump the kernel from the memory, then apply vmlinux-to-elf to create symboled ELF"""
        # check
        try:
            vmlinux2elf = which("vmlinux-to-elf")
        except FileNotFoundError as e:
            err("{}".format(e))
            return None

        # resolve kbase, krobase
        info("Wait for memory scan")
        maps = KernelbaseCommand.get_maps() # [vaddr, size, perm]
        if maps is None:
            err("maps is None")
            return None
        kbase, kbase_size = KernelbaseCommand.get_kernel_base(maps)
        if kbase is None:
            err("kbase is None")
            return None
        krobase, krobase_size = KernelbaseCommand.get_kernel_rodata_base(maps, kbase)
        if krobase is None:
            err("krobase is None")
            return None
        krwbase, krwbase_size = KernelbaseCommand.get_kernel_rwdata_base(maps, krobase)
        if krwbase is None:
            err("krwbase is None")
            return None

        gef_print("kernel base:   {:#x} ({:#x} bytes)".format(kbase, kbase_size))
        gef_print("kernel rodata: {:#x} ({:#x} bytes)".format(krobase, krobase_size))
        gef_print("kernel data:   {:#x} ({:#x} bytes)".format(krwbase, krwbase_size))

        addrs = {}
        addrs['kbase'] = kbase
        addrs['kbase_size'] = kbase_size
        addrs['krobase'] = krobase
        addrs['krobase_size'] = krobase_size
        addrs['krwbase'] = krwbase
        addrs['krwbase_size'] = krwbase_size
        addrs['maps'] = maps

        # resolve area
        area = []
        for addr in addrs['maps']:
            if addr[0] < addrs['kbase']:
                continue
            if addr[0] >= addrs['krwbase']:
                continue
            area.append([addr[0], addr[0]+addr[1]])
        if area == []:
            err("area is blank")
            return None

        # check if it can be reused
        if not force and os.path.exists(symboled_vmlinux_file):
            data = open(symboled_vmlinux_file, "rb").read()
            data = ''.join([chr(x) for x in data])
            r1 = re.findall(r"(Linux version (?:\d+\.[\d.]*\d)[ -~]+)", data)

            data = read_memory(addrs["krobase"], addrs["krobase_size"])
            data = ''.join([chr(x) for x in data])
            r2 = re.findall(r"(Linux version (?:\d+\.[\d.]*\d)[ -~]+)", data)

            if r1 and r2 and r1[0] != r2[0]:
                info("Run vmlinux-to-elf again because the kernel version is different")
                force = True

        # dumpe memory
        if force or (not os.path.exists(dumped_mem_file) and not os.path.exists(symboled_vmlinux_file)):
            # remove old file
            if os.path.exists(dumped_mem_file):
                info("Remove old {}".format(dumped_mem_file))
                os.unlink(dumped_mem_file)

            # dump
            info("Dumping memory")
            for i, (start_addr, end_addr) in enumerate(area):
                if i == 0:
                    gef_print("Dumping area:     {:#x} - {:#x}".format(start_addr, end_addr))
                    gdb.execute("dump memory {} {:#x} {:#x}".format(dumped_mem_file, start_addr, end_addr), to_string=True)
                else:
                    size_diff = start_addr - old_end_addr
                    if size_diff:
                        gef_print("Non-mapping area: {:#x} - {:#x} (ZERO fill)".format(old_end_addr, start_addr))
                        open(dumped_mem_file, "a").write("\0" * size_diff)
                    gef_print("Dumping area:     {:#x} - {:#x}".format(start_addr, end_addr))
                    gdb.execute("append memory {} {:#x} {:#x}".format(dumped_mem_file, start_addr, end_addr), to_string=True)
                old_end_addr = end_addr
            gef_print("Dumped to {}".format(dumped_mem_file))
        else:
            # reuse by default
            pass

        # apply vmlinux-to-elf
        if force or not os.path.exists(symboled_vmlinux_file):
            info("Execute `{} '{}' '{}' --base-address={:#x}`".format(vmlinux2elf, dumped_mem_file, symboled_vmlinux_file, addrs["kbase"]))
            os.system("{} '{}' '{}' --base-address={:#x}".format(vmlinux2elf, dumped_mem_file, symboled_vmlinux_file, addrs["kbase"]))
        else:
            # reuse by default
            pass

        # Error
        if not os.path.exists(symboled_vmlinux_file):
            return None
        if os.path.getsize(symboled_vmlinux_file) == 0:
            return None

        # Success
        return addrs

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_x86_32_64_or_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        force_reparse = False
        if "--reparse" in argv:
            force_reparse = True
            argv.remove("--reparse")

        if argv:
            self.usage()
            return

        DUMPED_MEM_FILE = "/tmp/gef-dump-memory.raw"
        SYMBOLED_VMLINUX_FILE = "/tmp/gef-dump-memory.elf"
        addrs = self.dump_kernel_elf(DUMPED_MEM_FILE, SYMBOLED_VMLINUX_FILE, force=force_reparse)
        if addrs is None:
            err("Failed to create kernel ELF")
            return

        # load symbol
        info("Adding symbol")
        # Prior to gdb 8.x, add-symbol-file command requires a .text address
        #   gdb 9.x: Usage: add-symbol-file FILE [-readnow | -readnever] [-o OFF] [ADDR] [-s SECT-NAME SECT-ADDR]...
        #   gdb 8.x: Usage: add-symbol-file FILE ADDR [-readnow | -readnever | -s SECT-NAME SECT-ADDR]...
        # But the created ELF has no .text, only a .kernel
        # Applying an empty symbol has no effect, so tentatively specify the same address as the .kernel.
        cmd = "add-symbol-file {} {:#x} -s .kernel {:#x}".format(SYMBOLED_VMLINUX_FILE, addrs['kbase'], addrs['kbase'])
        info(cmd)
        gdb.execute(cmd)
        return


@register_command
class TcmallocDumpCommand(GenericCommand):
    """tcmalloc thread_heap freelist viewer (supported x86_64 only)."""
    _cmdline_ = "tcmalloc-dump"
    _syntax_ = "{:s} old|chrome [-h] [self|all|NAME[,NAME,..]|central] [--th PRINT_THRESHOLD] [--idx PRINT_TARGET_IDX] [-c ADDR_TO_COLOR]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} chrome\n".format(_cmdline_)
    _example_ += "{:s} chrome self # (default) print freelist of thread cache for current thread\n".format(_cmdline_)
    _example_ += "{:s} chrome all # print freelist of thread cache for all thread\n".format(_cmdline_)
    _example_ += "{:s} chrome \"Chrome_DevTools,Bluez D-Bus thr\" # print freelist of thread cache for specific thread\n".format(_cmdline_)
    _example_ += "{:s} chrome central # print freelist of central cache\n".format(_cmdline_)
    _example_ += "{:s} chrome --th 10 --idx 32 # Number of chunks to display per freelist = 10, target idx = 32.\n".format(_cmdline_)
    _example_ += "{:s} chrome -c 0x23a43cbef500 -c 0x23a43cbefd40 # The specified address will be displayed in different colors\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC."
    _category_ = "Heap"

    def __init__(self, *args, **kwargs):
        super().__init__(prefix=True, complete=gdb.COMPLETE_NONE)
        self.initialized = None
        return

    def get_central_cache_(self):
        try:
            return parse_address("&'tcmalloc::Static::central_cache_'")
        except:
            return None

    def get_thread_heaps_(self):
        try:
            return parse_address("&'tcmalloc::ThreadCache::thread_heaps_'")
        except:
            return None

    def get_sizemap(self):
        try:
            return parse_address("&'tcmalloc::Static::sizemap_'")
        except:
            return None

    def get_tls_addr(self, lwpid):
        PTRACE_ARCH_PRCTL = 30
        ARCH_GET_FS = 0x1003
        ppvoid = ctypes.POINTER(ctypes.c_void_p)
        fsvalue = ppvoid(ctypes.c_void_p())
        fsvalue.contents.value = 0
        libc = ctypes.CDLL('libc.so.6')
        result = libc.ptrace(PTRACE_ARCH_PRCTL, lwpid, fsvalue, ARCH_GET_FS)
        if result == 0:
            return fsvalue.contents.value
        else:
            return None

    def get_thread_list(self): # create dict: {tls_addr: lwpid}
        dic = {}
        lwpids = []
        for inf in gdb.inferiors():
            lwpids += [x.ptid[1] for x in inf.threads()]
        for lwpid in lwpids:
            tls = self.get_tls_addr(lwpid)
            if tls is not None:
                dic[tls] = lwpid
        return dic

    def get_thread_name_list(self): # create dict: {lwpid: name}
        lines = gdb.execute("info threads", to_string=True)
        dic = {}
        for line in lines.splitlines():
            r = re.findall('\(LWP (\d+)\) "(.+?)"', line)
            if not r:
                continue
            lwpid, name = int(r[0][0]), r[0][1]
            dic[lwpid] = name
        return dic

    def dump_thread_heap_freelist_single(self, freelist, idx):
        if self.FreeList_print_target_index is None:
            pass
        elif self.FreeList_print_target_index != idx:
            return

        seen = []
        chunk = read_int_from_memory(freelist + self.FreeList_offset_list)
        length = read_int_from_memory(freelist + self.FreeList_offset_length) & 0xffffffff
        real_length = 0
        error = False
        if chunk != 0: # freelist exists
            chunklist_string = ""
            while chunk != 0:
                real_length += 1
                seen.append(chunk)
                # print threshold check
                if real_length < self.FreeList_print_threshold:
                    if chunk in self.addr_to_color:
                        chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "cyan bold underline")
                    else:
                        chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "yellow bold underline")
                else:
                    if not chunklist_string.endswith(" -> ..."):
                        chunklist_string += " -> ..."
                # corrupted memory check
                try:
                    chunk = read_int_from_memory(chunk)
                except:
                    if chunklist_string.endswith(" -> ..."):
                        chunklist_string += " -> " + Color.colorify(f"{seen[-2]:#x}", "yellow bold underline")
                        chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "red bold underline")
                    chunklist_string += " (corrupted)"
                    error = True
                    break
                # heap key decode
                chunk ^= self.get_heap_key()
                # loop check
                if chunk in seen:
                    chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "red bold underline") + " (loop)"
                    error = True
                    break
            # corrupted length check
            if length != real_length and error is False:
                chunklist_string += " (length currupted)"
                error = True
            # print
            chunksize = self.index_to_size(freelist, idx)
            if chunksize is None:
                gef_print(f"freelist[idx={idx:2d}, size=unknown, len={length:d}] @ {freelist:#x}{chunklist_string}")
            else:
                chunksize = Color.colorify("{:#x}".format(chunksize), "bold pink")
                gef_print(f"freelist[idx={idx:2d}, size={chunksize}, len={length:d}] @ {freelist:#x}{chunklist_string}")
        return

    def dump_thread_heap_freelist_array(self, thread_heap):
        # lwpid check
        tls = read_int_from_memory(thread_heap + self.ThreadCache_offset_tls)
        lwpid = self.get_thread_list()[tls]
        _, current_lwpid, _ = gdb.selected_thread().ptid
        name = self.get_thread_name_list()[lwpid]

        if self.FreeList_print_target_thread == "all":
            pass
        elif self.FreeList_print_target_thread == "self" and lwpid != current_lwpid:
            return
        elif isinstance(self.FreeList_print_target_thread, list) and not name in self.FreeList_print_target_thread:
            return

        current_or_not = "(current thread)" if lwpid == current_lwpid else ""
        gef_print(titlify(f"thread cache [lwpid={lwpid}{current_or_not:s},name=\"{name}\"] @ {thread_heap:#x} freelist"))

        freelist = thread_heap + self.ThreadCache_offset_freelist_array
        for i in range(self.ThreadCache_freelist_slot_count):
            self.dump_thread_heap_freelist_single(freelist, i)
            freelist += self.sizeof_FreeList
        return

    def dump_thread_heaps(self):
        thread_heap_head = self.get_thread_heaps_()
        if thread_heap_head is None:
            err("Not found tcmalloc::ThreadCache::thread_heaps_")
            return
        gef_print(titlify(f"thread_heaps_ (head) @ {thread_heap_head:#x}"))

        heap_key = self.get_heap_key()
        if heap_key != 0:
            gef_print(f"heap_key: {heap_key:#x} (xor chunk->fd)")

        thread_heap = read_int_from_memory(thread_heap_head)
        while thread_heap:
            self.dump_thread_heap_freelist_array(thread_heap)
            thread_heap = read_int_from_memory(thread_heap + self.ThreadCache_offset_next)
        return

    def dump_central_cache_freelist_single(self, freelist, _i, _j):
        seen = []
        chunk = read_int_from_memory(freelist + self.FreeList_offset_list)
        real_length = 0
        error = False
        if chunk != 0: # freelist exists
            chunklist_string = ""
            while chunk != 0:
                real_length += 1
                seen.append(chunk)
                # print threshold check
                if real_length < self.FreeList_print_threshold:
                    if chunk in self.addr_to_color:
                        chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "cyan bold underline")
                    else:
                        chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "yellow bold underline")
                else:
                    if not chunklist_string.endswith(" -> ..."):
                        chunklist_string += " -> ..."
                # corrupted memory check
                try:
                    chunk = read_int_from_memory(chunk)
                except:
                    if chunklist_string.endswith(" -> ..."):
                        chunklist_string += " -> " + Color.colorify(f"{seen[-2]:#x}", "yellow bold underline")
                        chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "red bold underline")
                    chunklist_string += " (corrupted)"
                    error = True
                    break
                # heap key decode
                chunk ^= self.get_heap_key()
                # loop check
                if chunk in seen:
                    chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "red bold underline") + " (loop)"
                    error = True
                    break
            # print
            gef_print(f"central_cache_[{_i}].tc_slot[{_j}] @ {freelist:#x}{chunklist_string}")
        return

    def dump_central_cache(self):
        central_cache_ = self.get_central_cache_()
        if central_cache_ is None:
            err("Not found tcmalloc::Static::central_cache_")
            return
        gef_print(titlify(f"central_cache_ @ {central_cache_:#x}"))

        heap_key = self.get_heap_key()
        if heap_key != 0:
            gef_print(f"heap_key: {heap_key:#x} (xor chunk->fd)")

        for i in range(self.CentralCache_array_count):
            central_cache_i = central_cache_ + i * self.sizeof_CentralCache # &central_cache[i]

            # check slot count
            used_slots = read_int_from_memory(central_cache_i + self.CentralCache_offset_used_slots_) & 0xffffffff
            max_slots = self.CentralCache_freelist_slot_count
            if used_slots == 0:
                continue

            # calc class -> size
            size_class = read_int_from_memory(central_cache_i + self.CentralCache_offset_size_class_)
            class_to_size_array = [
                    0,    16,    32,    48,    64,    80,    96,   112,   128,   144,
                  160,   176,   192,   208,   224,   240,   256,   288,   320,   352,
                  384,   448,   512,   576,   640,   704,   768,   896,  1024,  1152,
                 1280,  1536,  1792,  2048,  2304,  2560,  2816,  3072,  3328,  4096,
                 4608,  5120,  6144,  6656,  8192, 10240, 12288, 13312, 16384, 20480,
                24576, 28672, 32768
            ]
            size_byte = class_to_size_array[size_class]

            # dump
            gef_print(titlify(f"central_cache_[{i}] @ {central_cache_i:#x} (used_slots:{used_slots}/{max_slots}, chunk_size:{size_byte:#x})"))
            tc_slots = central_cache_i + self.CentralCache_offset_tc_slots_ # &central_cache[i].tc_slots_
            for j in range(min(used_slots, self.CentralCache_freelist_slot_count)):
                addr = tc_slots + j * 0x10 # &central_cache[i].tc_slots_[j]
                self.dump_central_cache_freelist_single(addr, i, j)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if not self.initialized:
            self.usage()
            return

        if not is_x86_64():
            err("Unsupported")
            return

        if "-h" in argv:
            self.usage()
            return

        self.addr_to_color = []
        while "-c" in argv:
            idx = argv.index("-c")
            self.addr_to_color.append(int(argv[idx+1], 0))
            argv = argv[:idx] + argv[idx+2:]

        self.FreeList_print_threshold = 5
        if "--th" in argv:
            idx = argv.index("--th")
            self.FreeList_print_threshold = int(argv[idx+1], 0)
            argv = argv[:idx] + argv[idx+2:]

        self.FreeList_print_target_index = None
        if "--idx" in argv:
            idx = argv.index("--idx")
            self.FreeList_print_target_index = int(argv[idx+1], 0)
            argv = argv[:idx] + argv[idx+2:]

        if argv and argv[0] == "central":
            self.dump_central_cache()
            return

        self.FreeList_print_target_thread = "self"
        if argv:
            if argv[0] in ['all', 'self']:
                self.FreeList_print_target_thread = argv[0]
            else:
                self.FreeList_print_target_thread = argv[0].split(",")
        self.dump_thread_heaps()
        return


@register_command
class TcmallocDumpChromeCommand(TcmallocDumpCommand):
    """tcmalloc (chrome edition (improved from google-perftools-2.5)) freelist viewer (supported x86_64 only)."""
    _cmdline_ = "tcmalloc-dump chrome"
    _syntax_ = "tcmalloc-dump chrome [-h] [self|all|NAME[,NAME,..]|central] [--th PRINT_THRESHOLD] [--idx PRINT_TARGET_IDX] [-c ADDR_TO_COLOR]"
    _category_ = "Heap"

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        # chromium/third_party/tcmalloc/chromium/src/common.h
        self.kClassSizesMax = 96
        self.kMaxSize = 32 * 1024
        self.kClassArraySize = ((self.kMaxSize + 127 + (120 << 7)) >> 7) + 1
        # chromium/third_party/tcmalloc/chromium/src/thread_cache.h
        """
        00000000 ThreadCache     struc ; (sizeof=0xC48, align=0x8)
        00000000 list_           FreeList 96 dup(?) # kClassSizesMax
        00000C00 size_           dd ?
        00000C04 max_size_       dd ?
        00000C08 total_bytes_allocated_ dd ?
        00000C0C unused          dd ?
        00000C10 sampler_        Sampler ?
        00000C28 tid_            dq ?
        00000C30 in_setspecific_ db ?
        00000C31 unused2         db 7 dup(?)
        00000C38 next_           dq ?
        00000C40 prev_           dq ?
        00000C48 ThreadCache     ends
        """
        self.ThreadCache_offset_next = 0xc38
        self.ThreadCache_offset_freelist_array = 0x0
        self.ThreadCache_offset_tls = 0xc28 # actually this is not tid, but TLS base address
        self.ThreadCache_freelist_slot_count = self.kClassSizesMax
        # chromium/third_party/tcmalloc/chromium/src/thread_cache.h
        """
        00000000 FreeList        struc ; (sizeof=0x20, align=0x8)
        00000000 list_           dq ?
        00000008 length_         dd ?
        0000000C lowater_        dd ?
        00000010 max_length_     dd ?
        00000014 length_overages_ dd ?
        00000018 size_           dd ?
        0000001C unused          dd ?
        00000020 FreeList        ends
        """
        self.sizeof_FreeList = 0x20
        self.FreeList_offset_list = 0x0
        self.FreeList_offset_length = 0x8
        self.FreeList_offset_size = 0x18
        # chromium/third_party/tcmalloc/chromium/src/central_freelist.h
        self.kMaxNumTransferEntries = 64
        self.CentralCache_freelist_slot_count = self.kMaxNumTransferEntries
        # chromium/third_party/tcmalloc/chromium/src/static_vars.cc
        self.CentralCache_array_count = self.kClassSizesMax
        # chromium/third_party/tcmalloc/chromium/src/central_freelist.h
        """
        struct TCEntry {
          void *head;  // Head of chain of objects.
          void *tail;  // Tail of chain of objects.
        };
        class central_cache_[kClassSizesMax=96]
          0x0   SpinLock lock_;
          0x8   size_t   size_class_;     // My size class
          0x10  Span     empty_;          // Dummy header for list of empty spans
          0x40  Span     nonempty_;       // Dummy header for list of non-empty spans
          0x70  size_t   num_spans_;      // Number of spans in empty_ plus nonempty_
          0x78  size_t   counter_;        // Number of free objects in cache entry
          0x80  TCEntry tc_slots_[kMaxNumTransferEntries=64]
          0x480 int32_t used_slots_;
          0x484 int32_t cache_size_;
          0x488 int32_t max_cache_size_;
          0x48c char pad[0x34];
        } // size:0x4c0, total_size:0x1c800
        """
        self.sizeof_TCEntry = 0x10
        self.sizeof_CentralCache = 0x4c0
        self.CentralCache_offset_size_class_ = 0x8
        self.CentralCache_offset_tc_slots_ = 0x80
        self.CentralCache_offset_used_slots_ = 0x480
        # settings
        self.initialized = True
        return

    def get_heap_key(self):
        # chromium/third_party/tcmalloc/chromium/src/thread_cache.cc
        aslr = parse_address("TCMalloc_SystemAlloc")
        return (~(aslr >> 13)) & 0xffffffffffffffff

    def index_to_size(self, freelist, t): # freelist_index -> chunk_size
        size = read_int_from_memory(freelist + self.FreeList_offset_size)
        return size


@register_command
class TcmallocDumpOldCommand(TcmallocDumpCommand):
    """tcmalloc (google-perftools-2.5 edition) freelist viewer (supported x86_64 only)."""
    _cmdline_ = "tcmalloc-dump old"
    _syntax_ = "tcmalloc-dump old [-h] [self|all|NAME[,NAME,..]|central] [--th PRINT_THRESHOLD] [--idx PRINT_TARGET_IDX] [-c ADDR_TO_COLOR]"
    _category_ = "Heap"

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        # google-perftools-2.5/src/common.h
        self.kBaseClasses = 9 # or 16
        self.kNumClasses = self.kBaseClasses + 79 # or 73 or 69
        self.kMaxSize = 256 * 1024
        self.kClassArraySize = ((self.kMaxSize + 127 + (120 << 7)) >> 7) + 1
        self.kClassSizesMax = 128
        # google-perftools-2.5/src/thread_cache.h
        """
        00000000 ThreadCache     struc ; (sizeof=0x880)
        00000000 next_           dq ?
        00000008 prev_           dq ?
        00000010 size_           dq ?
        00000018 max_size_       dq ?
        00000020 sampler_        Sampler ?
        00000030 list_           FreeList 88 dup(?) # kNumClasses
        00000870 tid_            dq ?
        00000878 in_setspecific_ db ?
        00000879 unused          db 7 dup(?)
        00000880 ThreadCache     ends
        """
        self.ThreadCache_offset_next = 0x0
        self.ThreadCache_offset_freelist_array = 0x30
        self.ThreadCache_offset_tls = 0x870 # actually this is not tid, but TLS base address
        self.ThreadCache_freelist_slot_count = self.kNumClasses
        # google-perftools-2.5/src/thread_cache.h
        """
        00000000 FreeList        struc ; (sizeof=0x18)
        00000000 list_           dq ?
        00000008 length_         dd ?
        0000000C lowater_        dd ?
        00000010 max_length_     dd ?
        00000014 length_overages_ dd ?
        00000018 FreeList        ends
        """
        self.sizeof_FreeList = 0x18
        self.FreeList_offset_list = 0x0
        self.FreeList_offset_length = 0x8
        # google-perftools-2.5/src/common.h
        """
        00000000 SizeMap         struc ; (sizeof=0xF60)
        00000000 num_objects_to_move_ dd 88 dup(?) # kNumClasses
        00000160 class_array_    db 2169 dup(?) # kClassArraySize
        000009D9 field_9D9       db 7 dup(?)
        000009E0 class_to_size_  dq 88 dup(?) # kNumClasses
        00000CA0 class_to_pages_ dq 88 dup(?) # kNumClasses
        00000F60 SizeMap         ends
        """
        self.SizeMap_offset_class_array = self.kNumClasses * 4
        self.SizeMap_offset_class_to_size = self.SizeMap_offset_class_array + ((self.kClassArraySize + 7) // 8 * 8)
        # google-perftools-2.5/src/central_freelist.h
        self.kMaxNumTransferEntries = 64
        self.CentralCache_freelist_slot_count = self.kMaxNumTransferEntries
        # google-perftools-2.5//src/static_vars.cc
        self.CentralCache_array_count = self.kClassSizesMax
        # google-perftools-2.5/src/central_freelist.h
        """
        struct TCEntry {
          void *head;  // Head of chain of objects.
          void *tail;  // Tail of chain of objects.
        };
        class central_cache_[kClassSizesMax=128]
          0x0   SpinLock lock_;
          0x8   size_t   size_class_;     // My size class
          0x10  Span     empty_;          // Dummy header for list of empty spans
          0x40  Span     nonempty_;       // Dummy header for list of non-empty spans
          0x70  size_t   num_spans_;      // Number of spans in empty_ plus nonempty_
          0x78  size_t   counter_;        // Number of free objects in cache entry
          0x80  TCEntry tc_slots_[kMaxNumTransferEntries=64]
          0x480 int32_t used_slots_;
          0x484 int32_t cache_size_;
          0x488 int32_t max_cache_size_;
          0x48c char pad[0x34];
        } // size:0x4c0, total_size:0x26000
        """
        self.sizeof_TCEntry = 0x10
        self.sizeof_CentralCache = 0x4c0
        self.CentralCache_offset_size_class_ = 0x8
        self.CentralCache_offset_tc_slots_ = 0x80
        self.CentralCache_offset_used_slots_ = 0x480
        # settings
        self.initialized = True
        return

    def get_heap_key(self):
        return 0

    def index_to_size(self, freelist, t): # freelist_index -> chunk_size
        sizemap = self.get_sizemap()
        if sizemap is None:
            return None
        size = read_int_from_memory(sizemap + self.SizeMap_offset_class_to_size + 8 * t)
        return size


isolate_root = None
def get_isolate_root():
    def to_int32(v):
        """Cast a gdb.Value to int32"""
        return int(v.cast(gdb.Value(2**32-1).type))
    def lookup_symbol_hack(symbol):
        """Hacky way to lookup symbol's address, I've tried other options like parse_and_eval but they
           throw errors like `No symbol "v8" in current context.`. I would like to replace this function
           once I figure out the proper way.
        """
        return int(gdb.execute("info address {}".format(symbol), to_string=True).split(" is at ")[1].split(" ")[0], 16)

    global isolate_root
    if isolate_root:
        return isolate_root
    else:
        try:
            isolate_key_addr = lookup_symbol_hack("v8::internal::Isolate::isolate_key_")
            isolate_key = to_int32(gdb.parse_and_eval("*(int *){}".format(isolate_key_addr)))
        except:
            err("Failed to get value of v8::internal::Isolate::isolate_key_")
            return None

        getthreadlocal_addr = lookup_symbol_hack("v8::base::Thread::GetThreadLocal")
        res = gdb.execute("call (void*){}({})".format(getthreadlocal_addr, isolate_key), to_string=True)
        isolate_root = int(res.split("0x")[1], 16)
        return isolate_root


def del_isolate_root(event):
    global isolate_root
    isolate_root = None


@register_command
class V8DereferenceCommand(GenericCommand):
    """Dereference recursively from an address and display information. Handles v8 specific values like tagged and compressed pointers"""
    _cmdline_ = "v8deref"
    _syntax_  = "{:s} [LOCATION] [l[NB]]".format(_cmdline_)
    _example_ = "{:s} $sp l20".format(_cmdline_)
    _category_ = "Chrome"

    def __init__(self):
        super(V8DereferenceCommand, self).__init__(complete=gdb.COMPLETE_LOCATION)
        gef_on_exit_hook(del_isolate_root)
        return

    @staticmethod
    def pprint_dereferenced(addr, off):
        base_address_color = get_gef_setting("theme.dereference_base_address")
        registers_color = get_gef_setting("theme.dereference_register_value")

        regs = [(k, get_register(k)) for k in current_arch.all_registers]

        sep = " {:s} ".format(RIGHT_ARROW)
        memalign = current_arch.ptrsize

        offset = off * memalign
        current_address = align_address(addr + offset)
        addrs = V8DereferenceCommand.dereference_from(current_address)
        if not addrs:
            return ""
        if addrs[1]:
            l  = ""
            addr_l0 = format_address(int(addrs[0][0], 16))
            l += "{:s}{:s}+{:#06x}: {:{ma}s}".format(Color.colorify(addr_l0, base_address_color),
                                                     VERTICAL_LINE, offset,
                                                     sep.join(addrs[0][1:]), ma=(memalign*2 + 2))
            addr_l1 = " "*len(addr_l0)
            l += "\n"
            l += "{:s}{:s}+{:#06x}: {:{ma}s}".format(Color.colorify(addr_l1, base_address_color),
                                                     VERTICAL_LINE, offset+4,
                                                     sep.join(addrs[1][1:]), ma=(memalign*2 + 2))

            """
            TODO: Get register hints working for this as well (but not super impt imo)
            register_hints = []

            for regname, regvalue in regs:
                if current_address == regvalue:
                    register_hints.append(regname)

            if register_hints:
                m = "\t{:s}{:s}".format(LEFT_ARROW, ", ".join(list(register_hints)))
                l += Color.colorify(m, registers_color)
            """

            offset += memalign
            pass
        else:
            l  = ""
            addr_l = format_address(int(addrs[0][0], 16))
            l += "{:s}{:s}+{:#06x}: {:{ma}s}".format(Color.colorify(addr_l, base_address_color),
                                                     VERTICAL_LINE, offset,
                                                     sep.join(addrs[0][1:]), ma=(memalign*2 + 2))

            register_hints = []

            for regname, regvalue in regs:
                if current_address == regvalue:
                    register_hints.append(regname)

            if register_hints:
                m = "\t{:s}{:s}".format(LEFT_ARROW, ", ".join(list(register_hints)))
                l += Color.colorify(m, registers_color)

            offset += memalign
        return l

    @only_if_gdb_running
    def do_invoke(self, argv):
        target = "$sp"
        nb = 10

        for arg in argv:
            if arg.isdigit():
                nb = int(arg)
            elif arg[0] in ("l", "L") and arg[1:].isdigit():
                nb = int(arg[1:])
            else:
                target = arg

        addr = safe_parse_and_eval(target)
        if addr is None:
            err("Invalid address")
            return

        addr = int(addr)
        # Remove tagging (tagged pointers)
        addr = addr & (2**(8*current_arch.ptrsize)-2)
        if process_lookup_address(addr) is None:
            err("Unmapped address")
            return

        if get_gef_setting("context.grow_stack_down") is True:
            from_insnum = nb * (self.repeat_count + 1) - 1
            to_insnum = self.repeat_count * nb - 1
            insnum_step = -1
        else:
            from_insnum = 0 + self.repeat_count * nb
            to_insnum = nb * (self.repeat_count + 1)
            insnum_step = 1

        start_address = align_address(addr)

        for i in range(from_insnum, to_insnum, insnum_step):
            line = V8DereferenceCommand.pprint_dereferenced(start_address, i)
            if not line:
                break
            gef_print(line)
        return

    @staticmethod
    def dereference_from(addr):
        def format_compressed(addr):
            heap_color = get_gef_setting("theme.address_heap")
            addr_high = Color.colorify("0x{:08x}".format(addr>>32), "gray")
            addr_low  = Color.colorify(  "{:08x}".format(addr&0xffffffff), heap_color)
            return "{:s}{:s}".format(addr_high, addr_low)

        if not is_alive():
            return ([format_address(addr),], None)

        code_color = get_gef_setting("theme.dereference_code")
        string_color = get_gef_setting("theme.dereference_string")
        max_recursion = get_gef_setting("dereference.max_recursion") or 10
        addr = lookup_address(align_address(int(addr)))
        msg = ([format_address(addr.value),], [])
        seen_addrs = set()#tuple(set(), set())

        # Is this address pointing to a normal pointer?
        deref = addr.dereference()
        if deref is None:
            pass # Regular execution if so
        else:
            # Is this address pointing to compressed pointers instead?
            # Only for valid for 64-bit address space
            if current_arch.ptrsize == 8:
                isolate_root = get_isolate_root()
                if isolate_root is None:
                    err("Not found isolate_root")
                    return ""
                addr0 = lookup_address(align_address(isolate_root + (deref & 0xffffffff)))
                addr1 = lookup_address(align_address(isolate_root + (deref >> 32)))
                compressed = [False, False]
                compressed[0] = addr0.dereference() and addr0.value > isolate_root + 0x0c000 and addr0.value & 1
                compressed[1] = addr1.dereference() and addr1.value > isolate_root + 0x0c000 and addr1.value & 1
                if True in compressed:
                    msg[1].append(format_address(addr.value+4))
                    for i in range(2):
                        if compressed[i]:
                            msg[i].append(format_compressed(addr0.value if not i else addr1.value))
                        else:
                            val = int(deref & 0xffffffff) if not i else int(deref >> 32)
                            if not (val & 1): # Maybe SMI
                                msg[i].append("        {:#0{ma}x} (SMI: {:#x})".format( val, val >> 1, ma=( 10 )) )
                            else:
                                msg[i].append("        {:#0{ma}x}".format( val, ma=( 10 )) )
                    return msg


        while addr.section and max_recursion:
            if addr.value in seen_addrs:
                msg[0].append("[loop detected]")
                break
            seen_addrs.add(addr.value)

            max_recursion -= 1

            # Is this value a pointer or a value?
            # -- If it's a pointer, dereference
            deref = addr.dereference()
            if deref is None:
                # if here, dereferencing addr has triggered a MemoryError, no need to go further
                msg[0].append(str(addr))
                break

            new_addr = lookup_address(deref)
            if new_addr.valid:
                addr = new_addr
                msg[0].append(str(addr))
                continue

            # -- Otherwise try to parse the value
            if addr.section:
                if addr.section.is_executable() and addr.is_in_text_segment() and not is_ascii_string(addr.value):
                    insn = gef_current_instruction(addr.value)
                    insn_str = "{} {} {}".format(insn.location, insn.mnemonic, ", ".join(insn.operands))
                    msg[0].append(Color.colorify(insn_str, code_color))
                    break

                elif addr.section.permission.value & Permission.READ:
                    if is_ascii_string(addr.value):
                        s = read_cstring_from_memory(addr.value)
                        if len(s) < get_memory_alignment():
                            txt = '{:s} ("{:s}"?)'.format(format_address(deref), Color.colorify(s, string_color))
                        elif len(s) > 50:
                            txt = Color.colorify('"{:s}[...]"'.format(s[:50]), string_color)
                        else:
                            txt = Color.colorify('"{:s}"'.format(s), string_color)

                        msg[0].append(txt)
                        break

            # if not able to parse cleanly, simply display and break
            val = "{:#0{ma}x}".format(int(deref & 0xFFFFFFFFFFFFFFFF), ma=(current_arch.ptrsize * 2 + 2))
            msg[0].append(val)
            break

        return msg


@register_command
class PartitionAllocDumpStableCommand(GenericCommand):
    """PartitionAlloc freelist viewer for chromium stable (supported x64/x86/ARM64/ARM only)."""
    _cmdline_ = "partition-alloc-dump-stable"
    _syntax_ = "{:s} [-h] fast_malloc|array_buffer|buffer|all [-v]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} array_buffer # walk from array_buffer_root_\n".format(_cmdline_)
    _example_ += "{:s} ab # same above (fm, ab and b are valid)\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC.\n"
    _example_ += "Chromium mainline is too fast to develop. So if parse is failed, you need fix this gef.py."
    _category_ = "Chrome"

    """
    partition alloc freelist is following.

     +-root-----------------+
     | ...                  |    +---> +-extent------------+  +-> +-extent------------+  +-> ...
     | next_super_page      |    |     | next              | -+   | next              | -+
     | next_partition_page  |    |     +-------------------+      +-------------------+
     | ...                  |    |
     | first_extent         | ---+
     | direct_map_list      | -------> +-direct_map_extent-+  +-> +-direct_map_extent-+  +-> ...
     | ...                  |          | bucket            |  |   | bucket            |  |
     |                      |          | next_extent       | -+   | next_extent       | -+
     |                      |          +-------------------+      +-------------------+
     |                      |
     +-bucket[0](0x20)------+
     | head                 | -------> +-slot_span---------+  +-> +-slot_span---------+  +-> ...
     | slot_size            | <------- | bucket            |  |   | bucket            |  |
     | ...                  |    +---- | freelist_head     |  |   | freelist_head     |  |
     +-bucket[1](0x20)------+    |     | next_slot_span    | -+   | next_slot_span    | -+
     | head                 |    |     +-------------------+      +-------------------+
     | slot_size            |    |
     | ...                  |    |
     +----------------------+    |
     | ...                  |    |
     |                      |    +---> +-slot--------------+
     |                      |          | next              | --+
     +----------------------+          | (freed)           |   |
                                       +-slot--------------+   |
                                       |                   |   |
                                       | (used)            |   |
                                       +-slot--------------+ <-+
                                   +-- | next              |
                                   |   | (freed)           |
                                   |   +-slot--------------+
                                   |   |                   |
                                   |   | (used)            |
                                   +-> +-slot--------------+
                                       | next              | --> NULL
                                       | (freed)           |
                                       +-slot--------------+
                                       |                   |
                                       |                   |
                                       +-------------------+

    `extent`, `slot_span` and `slot` are in super_page.

          +-super_page-(2MB)----+
     4KB  | Guard Page          |
          +---------------------+
     4KB  | extent * 1          |
          | slot_span * 126     |
          | unused * 1          |
          +---------------------+
     8KB  | Guard Page          |
          +---------------------+
     16KB | Partition Page #1   |
          |   slot              |
          |   slot              |
          |   ...               |
          +---------------------+
          | ...                 |
          +---------------------+
     16KB | Partition Page #126 |
          |   slot              |
          |   slot              |
          |   ...               |
          +---------------------+
     12KB | Unused              |
          +---------------------+
      4KB | Guard Page          |
          +---------------------+
    """

    def slice_unpack(self, data, n):
        tmp = [data[i:i+n] for i in range(0, len(data), n)]
        if n == 8:
            return list(map(u64, tmp))
        elif n == 4:
            return list(map(u32, tmp))
        else:
            raise

    @lru_cache()
    def get_roots_heuristic(self):
        """searches for fast_malloc_root, array_buffer_root_ and buffer_root_"""
        # the pointers to each root are in the RW area.
        # first, we list up the RW area.
        filepath = get_filepath()
        if is_64bit():
            codebase = get_section_base_address(filepath)
            mask = 0x0000ffff00000000
            chromium_rw_maps = [p for p in get_process_maps() if p.permission.value == Permission.READ | Permission.WRITE]
            chromium_rw_maps = [p for p in chromium_rw_maps if (p.page_start & mask) == (codebase & mask) and p.path != filepath]
        elif is_32bit():
            mask = 0xff000000
            heapbase = HeapBaseFunction.heap_base()
            chromium_rw_maps = [p for p in get_process_maps() if p.permission.value == Permission.READ | Permission.WRITE]
            chromium_rw_maps = [p for p in chromium_rw_maps if p.page_start < heapbase and p.path != filepath]

        def n_gram(target, n):
            for idx in range(len(target) - n + 1):
                yield target[idx:idx + n]

        # Check the RW area
        roots = []
        for maps in chromium_rw_maps:
            # explode to each qword (if 64 bit arch) or dword(if 32 bit arch)
            datas = self.slice_unpack(read_memory(maps.page_start, maps.size), current_arch.ptrsize)
            addrs = [x for x in range(maps.page_start, maps.page_end, current_arch.ptrsize)]

            """
            https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/platform/wtf/allocator/partitions.cc
            base::ThreadSafePartitionRoot* Partitions::fast_malloc_root_ = nullptr;
            base::ThreadSafePartitionRoot* Partitions::array_buffer_root_ = nullptr;
            base::ThreadSafePartitionRoot* Partitions::buffer_root_ = nullptr;

            0x564883728440 <WTF::Partitions::fast_malloc_root_>:    0x0000000000000000
            0x564883728448 <WTF::Partitions::array_buffer_root_>:   0x000056488372a380
            0x564883728450 <WTF::Partitions::buffer_root_>: 0x0000564883729400
            0x564883728458 <guard variable for WTF::Partitions::Initialize()::initialized>: 0x0000000100000101
            ...
            0x55c7e358d480 <WTF::Partitions::InitializeOnce()::fast_malloc_allocator>:      0x0000000000000000
            ...
            0x55c7e358e400 <WTF::Partitions::InitializeOnce()::buffer_allocator>:   0x0000000100000001
            ...
            0x55c7e358f380 <WTF::Partitions::InitializeArrayBufferPartition()::array_buffer_allocator>:     0x0000000100000001
            """
            # check consecutive quadruples
            for addr, data in zip(n_gram(addrs, 4), n_gram(datas, 4)):
                # root pointer address and root address are close (at least, these addresses are similar. see above example)
                if data[0] != 0 and (addr[0] & mask) != (data[0] & mask): # fast_malloc_root may be zero
                    continue
                if (addr[1] & mask) != (data[1] & mask): # array_buffer_root_ is must be non-zero
                    continue
                if (addr[2] & mask) != (data[2] & mask): # buffer_root_ is must be non-zero
                    continue
                # they should be aligned
                if data[0] & 0x7:
                    continue
                if data[1] & 0x7:
                    continue
                if data[2] & 0x7:
                    continue
                # initialized must be bool 0x01
                if (data[3] & 0xff) != 0x01:
                    continue
                # check root size
                buffer_root_size = data[1] - data[2]
                if buffer_root_size < 0x300:
                    continue
                if buffer_root_size > 0x2000:
                    continue
                # check root struct.
                """
                The first 64 bytes of root are mostly 0 due to padding considering the cache line.
                This is same both 64-bit and 32bit.
                0x55719118e380: 0x0000000100000001      0x0000000000000000     <--- here may be used
                0x55719118e390: 0x0000000000000000      0x0000000000000000     <--- here may be used
                0x55719118e3a0: 0x0000000000000000      0x0000000000000000     <--- hare may be not used
                0x55719118e3b0: 0x0000000000000000      0x0000000000000000     <--- here may be not used
                """
                array_buffer_root_first64 = read_memory(data[1], 64)
                if array_buffer_root_first64[32:] != b"\0"*32:
                    continue
                buffer_root_first64 = read_memory(data[2], 64)
                if buffer_root_first64[32:] != b"\0"*32:
                    continue
                # add candidate
                root_candidate = [
                    ["fast_malloc_root_",  addr[0]],
                    ["array_buffer_root_", addr[1]],
                    ["buffer_root_",       addr[2]],
                ]
                roots.append(root_candidate)

        # debug print
        if len(roots) == 0:
            err("roots were not found. try check code")
            return []

        elif len(roots) == 1:
            root = roots[0]
            for r in root:
                info("found: {:s}: {:#x}".format(r[0], r[1]))
            return roots[0] # [["fast_...", addr], ["array...", addr], ["buffer...", addr]]

        else:
            err("candidates for root are found in multiple places. try check code")
            for root in roots:
                for r in root:
                    gef_print("  candidate: {:20s} {:#x}".format(r[0], r[1]))
                gef_print()
            return []

    @lru_cache()
    def get_roots(self):
        def get_root(root_string):
            try:
                root_addr = parse_address("&'WTF::Partitions::{:s}'".format(root_string))
                return [[root_string, root_addr]]
            except:
                return []

        roots = []
        # try from symbols
        for root_string in ["fast_malloc_root_", "array_buffer_root_", "buffer_root_"]:
            roots += get_root(root_string)
        # maybe no symbols, try heuristic
        if len(roots) == 0:
            info("Symbol is not found. It will use heuristic search")
            roots = self.get_roots_heuristic()
        # retry checking
        if len(roots) == 0:
            info("Symbol is not found.")
        return roots

    @lru_cache()
    def get_sentinel_slot_spans(self):
        """sentinel_slot_span is default slot_span, so search it"""
        sentinel = []
        try:
            t = parse_address("&'base::internal::SlotSpanMetadata<true>::sentinel_slot_span_'")
            sentinel.append(t)
        except:
            pass
        try:
            f = parse_address("&'base::internal::SlotSpanMetadata<false>::sentinel_slot_span_'")
            sentinel.append(f)
        except:
            pass
        return sentinel

    def byteswap(self, x):
        def p(a):
            return struct.pack("<I",a&0xffffffff)
        def ube(a):
            return struct.unpack(">I",a)[0]
        def pQ(a):
            return struct.pack("<Q",a&0xffffffffffffffff)
        def uQbe(a):
            return struct.unpack(">Q",a)[0]
        if is_64bit():
            converted = uQbe(pQ(x))
        elif is_32bit():
            converted = ube(p(x))
        return converted

    def read_root(self, addr, name):
        ptrsize = current_arch.ptrsize
        root = {}
        root["name"] = name
        root["addr"] = current = read_int_from_memory(addr)
        """
        https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_root.h
        struct base::PartitionRoot {
            union {
                struct {
                    QuarantineMode quarantine_mode; // uint8_t
                    ScanMode scan_mode;             // uint8_t
                    bool with_thread_cache = false;
                    bool with_denser_bucket_distribution = false;
                    bool allow_aligned_alloc;
                    bool allow_cookie;
                    bool brp_enabled_;
                    bool use_configurable_pool;
                    //uint32_t extras_size;
                    //uint32_t extras_offset;
                }
                uint8_t one_cacheline[internal::kPartitionCachelineSize]; // 64 bytes
            }
            ::partition_alloc::Lock lock_;  // 8 bytes
            Bucket buckets[internal::kNumBuckets] = {};
            Bucket sentinel_bucket{};
            bool initialized = false;
            std::atomic<size_t> total_size_of_committed_pages{0};
            std::atomic<size_t> max_size_of_committed_pages{0};
            std::atomic<size_t> total_size_of_super_pages{0};
            std::atomic<size_t> total_size_of_direct_mapped_pages{0};
            size_t total_size_of_allocated_bytes PA_GUARDED_BY(lock_) = 0;
            size_t max_size_of_allocated_bytes PA_GUARDED_BY(lock_) = 0;
            std::atomic<uint64_t> syscall_count{};
            std::atomic<uint64_t> syscall_total_time_ns{};
            //std::atomic<size_t> total_size_of_brp_quarantined_bytes{0};
            //std::atomic<size_t> total_count_of_brp_quarantined_slots{0};
            //std::atomic<size_t> cumulative_size_of_brp_quarantined_bytes{0};
            //std::atomic<size_t> cumulative_count_of_brp_quarantined_slots{0};
            size_t empty_slot_spans_dirty_bytes PA_GUARDED_BY(lock_) = 0;
            int max_empty_slot_spans_dirty_bytes_shift = 3;
            uintptr_t next_super_page = 0;
            uintptr_t next_partition_page = 0;
            uintptr_t next_partition_page_end = 0;
            SuperPageExtentEntry* current_extent = nullptr;
            SuperPageExtentEntry* first_extent = nullptr;
            DirectMapExtent* direct_map_list PA_GUARDED_BY(lock_) = nullptr;
            SlotSpan* global_empty_slot_span_ring[internal::kMaxFreeableSpans] PA_GUARDED_BY(lock_) = {};
            int16_t global_empty_slot_span_ring_index PA_GUARDED_BY(lock_) = 0;
            int16_t global_empty_slot_span_ring_size PA_GUARDED_BY(lock_) = internal::kDefaultEmptySlotSpanRingSize;
            uintptr_t inverted_self = 0;
            std::atomic<int> thread_caches_being_constructed_{0};
            bool quarantine_always_for_testing = false;
            #partition_alloc::PartitionTag current_partition_tag = 0; // if ARM MTE is enable
            #uintptr_t next_tag_bitmap_page = 0; // if ARM MTE is enable
        }
        """
        x = u64(read_memory(current, 8))
        current += 64 # sizeof(union {...})

        root["lock_"] = u64(read_memory(current, 8))
        current += 8

        # for 32bit, there is 2 patterns because aligned or packed
        if is_32bit():
            if self.align_pad is None:
                x = read_int_from_memory(current)
                if x == 0:
                    self.align_pad = True
                else:
                    self.align_pad = False
            if self.align_pad:
                current += ptrsize

        root["buckets"] = []
        while True:
            if read_int_from_memory(current) == 1: # search `bool initialized`
                break
            bucket, current = self.read_bucket(current)
            root["buckets"].append(bucket)
        root["sentinel_bucket"] = root["buckets"].pop()

        root["initialized"] = read_int_from_memory(current) & 0xff
        current += ptrsize # with pad
        root["total_size_of_committed_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["max_size_of_committed_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["total_size_of_super_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["total_size_of_direct_mapped_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["total_size_of_allocated_bytes"] = read_int_from_memory(current)
        current += ptrsize
        root["max_size_of_allocated_bytes"] = read_int_from_memory(current)
        current += ptrsize
        root["syscall_count"] = read_int_from_memory(current)
        current += ptrsize
        root["syscall_total_time_ns"] = read_int_from_memory(current)
        current += ptrsize
        root["empty_slot_spans_dirty_bytes"] = u32(read_memory(current, 4))
        current += ptrsize # with pad
        root["max_empty_slot_spans_dirty_bytes_shift"] = u32(read_memory(current, 4))
        current += ptrsize # with pad
        root["next_super_page"] = read_int_from_memory(current)
        current += ptrsize
        root["next_partition_page"] = read_int_from_memory(current)
        current += ptrsize
        root["next_partition_page_end"] = read_int_from_memory(current)
        current += ptrsize
        root["current_extent"] = read_int_from_memory(current)
        current += ptrsize
        root["first_extent"] = read_int_from_memory(current)
        current += ptrsize
        root["direct_map_list"] = read_int_from_memory(current)
        current += ptrsize

        root["global_empty_slot_span_ring"] = []
        inv = root["addr"] ^ ((1 << (current_arch.ptrsize * 8)) - 1)
        while True:
            if read_int_from_memory(current + ptrsize) == inv: # search `inverted_self`
                break
            x = read_int_from_memory(current)
            current += ptrsize
            root["global_empty_slot_span_ring"].append(x)

        root["global_empty_slot_span_ring_index"] = u16(read_memory(current, 2))
        current += 2
        root["global_empty_slot_span_ring_size"] = u16(read_memory(current, 2))
        current += ptrsize - 2 # with pad
        root["inverted_self"] = read_int_from_memory(current)
        current += ptrsize
        root["thread_caches_being_constructed_"] = u32(read_memory(current, 4))
        current += 4
        root["quarantine_always_for_testing"] = u32(read_memory(current, 4)) & 0xff
        current += 4
        return root, current

    def read_bucket(self, addr):
        ptrsize = current_arch.ptrsize
        bucket = {}
        bucket["addr"] = current = addr
        """
        https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_bucket.h
        struct base::internal::PartitionBucket {
            SlotSpanMetadata<thread_safe>* active_slot_spans_head;
            SlotSpanMetadata<thread_safe>* empty_slot_spans_head;
            SlotSpanMetadata<thread_safe>* decommitted_slot_spans_head;
            uint32_t slot_size;
            uint32_t num_system_pages_per_slot_span : 8;
            uint32_t num_full_slot_spans : 24;
            uint64_t slot_size_reciprocal;
        };
        """
        bucket["active_slot_spans_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["empty_slot_spans_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["decommitted_slot_spans_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["slot_size"] = u32(read_memory(current, 4))
        current += 4
        x = u32(read_memory(current, 4))
        bucket["num_system_pages_per_slot_span"] = x & 0xff
        bucket["num_full_slot_spans"] = (x >> 8) & 0xffffff
        current += 4

        # for 32bit, there is 2 patterns because aligned or packed
        if is_32bit() and self.align_pad:
            current += 4
        bucket["slot_size_reciprocal"] = u64(read_memory(current, 8))
        current += 8
        return bucket, current

    def read_extent(self, addr):
        ptrsize = current_arch.ptrsize
        extent = {}
        extent["addr"] = current = addr
        extent["super_page_base"] = current - 0x1000
        """
        https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_page.h
        struct PartitionSuperPageExtentEntry {
          PartitionRootBase* root;
          PartitionSuperPageExtentEntry* next;
          uint16_t number_of_consecutive_super_pages;
          uint16_t number_of_nonempty_slot_spans;
        };
        """
        extent["root"] = read_int_from_memory(current)
        current += ptrsize
        extent["next"] = read_int_from_memory(current)
        current += ptrsize
        extent["number_of_consecutive_super_pages"] = u16(read_memory(current, 2))
        current += 2
        extent["number_of_nonempty_slot_spans"] = u16(read_memory(current, 2))
        current += 2
        extent["super_page_end"] = extent["super_page_base"] + extent["number_of_consecutive_super_pages"] * 0x200000
        return extent, current

    def read_direct_map(self, addr):
        ptrsize = current_arch.ptrsize
        direct_map = {}
        direct_map["addr"] = current = addr
        """
        https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_direct_map_extent.h
        struct PartitionDirectMapExtent {
          PartitionDirectMapExtent<thread_safe>* next_extent;
          PartitionDirectMapExtent<thread_safe>* prev_extent;
          PartitionBucket<thread_safe>* bucket;
          size_t reservation_size;
          size_t padding_for_alignment;
        };
        """
        direct_map["next_extent"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["prev_extent"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["bucket"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["reservation_size"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["padding_for_alignment"] = read_int_from_memory(current)
        current += ptrsize
        return direct_map, current

    def read_slot_span(self, addr):
        ptrsize = current_arch.ptrsize
        slot_span = {}
        slot_span["addr"] = current = addr
        slot_span["super_page_addr"] = (slot_span["addr"] & ~(DEFAULT_PAGE_SIZE-1)) - DEFAULT_PAGE_SIZE
        slot_span["partition_page_index"] = (slot_span["addr"] & (DEFAULT_PAGE_SIZE-1)) // 0x20
        slot_span["partition_page_start"] = slot_span["super_page_addr"] + slot_span["partition_page_index"] * DEFAULT_PAGE_SIZE * 4
        """
        https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_page.h
        struct SlotSpanMetadata {
          PartitionFreelistEntry* freelist_head = nullptr;
          SlotSpanMetadata<thread_safe>* next_slot_span = nullptr;
          PartitionBucket<thread_safe>* const bucket = nullptr;
          uint32_t marked_full : 1
          uint32_t num_allocated_slots : kMaxSlotsPerSlotSpanBits; // 13 bits
          uint32_t num_unprovisioned_slots : kMaxSlotsPerSlotSpanBits; // 13 bits
          const uint32_t can_store_raw_size_ : 1;
          uint32_t freelist_is_sorted_ : 1;
          uint32_t unused1_ : (32 - 1 - 2 * kMaxSlotsPerSlotSpanBits - 1 - 1); // 3 bits
          uint16_t in_empty_cache_ : 1;
          uint16_t empty_cache_index_ : kEmptyCacheIndexBits; // 7 bits
          uint16_t unused2_ : (16 - 1 - kEmptyCacheIndexBits); // 8 bits
        }
        """
        slot_span["freelist_head"] = read_int_from_memory(current)
        current += ptrsize
        slot_span["next_slot_span"] = read_int_from_memory(current)
        current += ptrsize
        slot_span["bucket"] = read_int_from_memory(current)
        current += ptrsize
        x = u32(read_memory(current, 4))
        current += 4
        slot_span["marked_full"] = (x >> 0) & 1
        slot_span["num_allocated_slots"] = (x >> 1) & 0x1fff
        slot_span["num_unprovisioned_slots"] = (x >> 14) & 0x1fff
        slot_span["can_store_raw_size_"] = (x >> 27) & 1
        slot_span["freelist_is_sorted_"] = (x >> 28) & 1
        slot_span["unused1_"] = (x >> 29) & 0x7
        x = u16(read_memory(current, 2))
        current += 2
        slot_span["in_empty_cache_"] = (x >> 0) & 1
        slot_span["empty_cache_index_"] = (x >> 1) & 0x7f
        slot_span["unused2_"] = (x >> 8) & 0xff
        return slot_span, current

    def print_root(self, root):
        gef_print(titlify("*{} @ {:#x}".format(root["name"], root["addr"])))
        gef_print("uint8_t one_cacheline[64]:                             ...")
        gef_print("::partition_alloc::Lock lock_;                         {:#x}".format(root["lock_"]))
        gef_print("Bucket buckets[{:3d}]:".format(len(root["buckets"])))
        for idx, bucket in enumerate(root["buckets"]):
            self.print_bucket(bucket, root, idx)
        if self.verbose:
            gef_print("Bucket sentinel_bucket:")
            self.print_bucket(root["sentinel_bucket"], root)
        else:
            gef_print("Bucket sentinel_bucket:                                ...")
        gef_print("bool initialized:                                      {:#x}".format(root["initialized"]))
        gef_print("std::atomic<size_t> total_size_of_committed_pages:     {:#x}".format(root["total_size_of_committed_pages"]))
        gef_print("std::atomic<size_t> max_size_of_committed_pages:       {:#x}".format(root["max_size_of_committed_pages"]))
        gef_print("std::atomic<size_t> total_size_of_super_pages:         {:#x}".format(root["total_size_of_super_pages"]))
        gef_print("std::atomic<size_t> total_size_of_direct_mapped_pages: {:#x}".format(root["total_size_of_direct_mapped_pages"]))
        gef_print("size_t total_size_of_allocated_bytes:                  {:#x}".format(root["total_size_of_allocated_bytes"]))
        gef_print("size_t max_size_of_allocated_bytes:                    {:#x}".format(root["max_size_of_allocated_bytes"]))
        gef_print("std::atomic<uint64_t> syscall_count:                   {:#x}".format(root["syscall_count"]))
        gef_print("std::atomic<uint64_t> syscall_total_time_ns:           {:#x}".format(root["syscall_total_time_ns"]))
        gef_print("size_t empty_slot_spans_dirty_bytes:                   {:#x}".format(root["empty_slot_spans_dirty_bytes"]))
        gef_print("int max_empty_slot_spans_dirty_bytes_shift:            {:#x}".format(root["max_empty_slot_spans_dirty_bytes_shift"]))
        gef_print("uintptr_t next_super_page:                             {:#x}".format(root["next_super_page"]))
        gef_print("uintptr_t next_partition_page:                         {:#x}".format(root["next_partition_page"]))
        gef_print("uintptr_t next_partition_page_end:                     {:#x}".format(root["next_partition_page_end"]))
        gef_print("SuperPageExtentEntry* current_extent:                  {:#x}".format(root["current_extent"]))
        self.print_extent_list(root["current_extent"])
        gef_print("SuperPageExtentEntry* first_extent:                    {:#x}".format(root["first_extent"]))
        self.print_extent_list(root["first_extent"])
        gef_print("DirectMapExtent* direct_map_list:                      {:#x}".format(root["direct_map_list"]))
        self.print_direct_map_list(root["direct_map_list"], root)
        ring_len = len(root["global_empty_slot_span_ring"])
        if self.verbose:
            gef_print("SlotSpan* global_empty_slot_span_ring[{:2d}]:".format(ring_len))
            for i in range(len(root["global_empty_slot_span_ring"])):
                x = root["global_empty_slot_span_ring"][i]
                gef_print("    global_empty_slot_span_ring[{:2d}]:                       {:#x}".format(i, x))
        else:
            gef_print("SlotSpan* global_empty_slot_span_ring[{:2d}]:             ...".format(ring_len))
        gef_print("int16_t global_empty_slot_span_ring_index:             {:#x}".format(root["global_empty_slot_span_ring_index"]))
        gef_print("int16_t global_empty_slot_span_ring_size:              {:#x}".format(root["global_empty_slot_span_ring_size"]))
        inv = root["inverted_self"]
        inv_inv = inv ^ ((1 << (current_arch.ptrsize * 8)) - 1)
        gef_print("uintptr_t inverted_self:                               {:#x} (=~{:#x})".format(inv, inv_inv))
        gef_print("std::atomic<int> thread_caches_being_constructed_:     {:#x}".format(root["thread_caches_being_constructed_"]))
        gef_print("bool quarantine_always_for_testing:                    {:#x}".format(root["quarantine_always_for_testing"]))
        return

    def print_extent_list(self, head):
        try:
            current = head
            while current:
                extent, _ = self.read_extent(current)
                gef_print("    -> extent @{:<#14x}".format(extent["addr"]))
                gef_print("           root:{:<#14x} ".format(extent["root"]))
                super_page_info = "{:<#14x} - {:<#14x}".format(extent["super_page_base"], extent["super_page_end"])
                page_info = "(total 0x200000(2MB) * {:d} pages)".format(extent["number_of_consecutive_super_pages"])
                gef_print("           super_page:{:s} {:s}".format(Color.colorify(super_page_info, "yellow bold"), page_info))
                gef_print("           non_empty_slot_spans:{:d} ".format(extent["number_of_nonempty_slot_spans"]))
                gef_print("           next:{:<#14x}".format(extent["next"]))
                current = extent["next"]
        except:
            err("Corrupted?")
        return

    def print_direct_map_list(self, head, root):
        try:
            current = head
            while current:
                direct_map, _ = self.read_direct_map(current)
                gef_print("    -> direct_map @{:<#14x}: ".format(direct_map["addr"]))
                gef_print("           next_extent:{:<#14x} ".format(direct_map["next_extent"]))
                gef_print("           prev_extent:{:<#14x} ".format(direct_map["prev_extent"]))
                gef_print("           bucket:{:<#14x} ".format(direct_map["bucket"]))
                gef_print("           reservation_size:{:#x}".format(direct_map["reservation_size"]))
                gef_print("           padding_for_alignment:{:#x}".format(direct_map["padding_for_alignment"]))
                bucket, _ = self.read_bucket(direct_map["bucket"])
                self.print_bucket(bucket, root)
                current = direct_map["next_extent"]
        except:
            err("Corrupted?")
        return

    def print_bucket(self, bucket, root, idx = None):
        sentinel1 = self.get_sentinel_slot_spans() # from symbol
        sentinel2 = [root["sentinel_bucket"]["active_slot_spans_head"]] # from heuristic search
        sentinel = list(set(sentinel1 + sentinel2)) # uniq

        if not self.verbose:
            if bucket["active_slot_spans_head"] in sentinel + [0x0]:
                return # skip printing

        slot_size = Color.colorify("{:#7x}".format(bucket["slot_size"]), "bold pink")
        if idx is not None:
            gef_print("    buckets[{:3d}](slot_size:{:s}) @{:<#14x}".format(idx, slot_size, bucket["addr"]))
        else:
            gef_print("    bucket(slot_size:{:s}) @{:<#14x}".format(slot_size, bucket["addr"]))
        gef_print("        num_system_pages_per_slot_span:{:<#4x} ".format(bucket["num_system_pages_per_slot_span"]))
        gef_print("        num_full_slot_spans:{:<#4x} ".format(bucket["num_full_slot_spans"]))
        gef_print("        slot_size_reciprocal:{:#x}".format(bucket["slot_size_reciprocal"]))

        if self.verbose:
            target_list = ["active_slot_spans_head", "empty_slot_spans_head", "decommitted_slot_spans_head"]
        else:
            target_list = ["active_slot_spans_head"]

        for key in target_list:
            head = bucket[key]
            # sentinel can be ignored, so skip
            if not self.verbose and (head in sentinel + [0x0]):
                continue
            if head in sentinel:
                # print sentinel (verbose)
                gef_print("        {:s}:sentinel_pages".format(Color.colorify(key, "bold cyan underline")))
            else:
                # default
                gef_print("        {:s}:{:<#14x}".format(Color.colorify(key, "bold cyan underline"), head))
            self.print_slot_span(head, bucket)
        return

    def print_slot_span(self, head, bucket):
        current = head
        while current:
            try:
                slot_span, _ = self.read_slot_span(current)
            except:
                err("Corrupted?")
                break
            text_fmt = "            -> slot_span @{:<#14x} (#{:3d} of super_page @{:<#14x})"
            gef_print(text_fmt.format(slot_span["addr"], slot_span["partition_page_index"], slot_span["super_page_addr"]))
            gef_print("                   next_slot_span:{:<#14x} ".format(slot_span["next_slot_span"]))
            page_start = slot_span["partition_page_start"]
            page_end = slot_span["partition_page_start"] + bucket["num_system_pages_per_slot_span"] * DEFAULT_PAGE_SIZE
            gef_print("                   slot_span_area:{:#x}-{:#x} ".format(page_start, page_end))
            gef_print("                   num_allocated_slots:{:#x}".format(slot_span["num_allocated_slots"]))
            self.print_freelist(slot_span["freelist_head"], bucket, slot_span)
            current = slot_span["next_slot_span"]
        return

    def print_freelist(self, head, bucket, slot_span):
        gef_print("                   freelist_head:{:<#14x} ".format(head))

        slot_size = bucket["slot_size"]
        page_start = slot_span["partition_page_start"]
        page_end = slot_span["partition_page_start"] + bucket["num_system_pages_per_slot_span"] * DEFAULT_PAGE_SIZE

        text = ""
        cnt = 0
        chunk = head
        seen = []
        while chunk:
            if cnt % 7 == 0:
                if cnt > 0:
                    text += "\n"
                text += " "*23

            if chunk in seen:
                text += Color.colorify("-> {:<#14x} (loop) ".format(chunk), "red bold")
                break

            if not ((page_start <= chunk < page_end) and ((chunk - page_start) % slot_size == 0)):
                text += Color.colorify("-> {:<#14x} (corrupted) ".format(chunk), "red bold")
                break

            try:
                next_chunk = self.byteswap(read_int_from_memory(chunk))
            except:
                text += Color.colorify("-> {:<#14x} (corrupted) ".format(chunk), "red bold")
                break

            text += "-> " + Color.colorify("{:<#14x} ".format(chunk), "yellow bold")
            cnt += 1
            seen.append(chunk)
            chunk = next_chunk

        if cnt > 0:
            text += "(num: {:#x})".format(cnt)

        if text:
            gef_print(text)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    @only_if_x86_32_64_or_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if is_32bit():
            self.align_pad = None

        if "-h" in argv:
            self.usage()
            return

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        if len(argv) != 1:
            self.usage()
            return

        if not argv[0] in ["fast_malloc", "fm", "array_buffer", "ab", "buffer", "b", "all"]:
            self.usage()
            return
        target = argv[0]

        for name, addr in self.get_roots():
            ok = False
            if target == "all":
                ok = True
            elif target in ["fast_malloc", "fm"] and name == "fast_malloc_root_":
                ok = True
            elif target in ["array_buffer", "ab"] and name == "array_buffer_root_":
                ok = True
            elif target in ["buffer", "b"] and name == "buffer_root_":
                ok = True

            if ok:
                try:
                    root, _ = self.read_root(addr, name)
                except:
                    mem_value = read_int_from_memory(addr)
                    err("Parse error {:s}: @ {:#x} -> {:#x}".format(name, addr, mem_value))
                    continue
                self.print_root(root)
        return


@register_command
class PartitionAllocDumpBetaCommand(PartitionAllocDumpStableCommand):
    """PartitionAlloc freelist viewer for chromium beta (supported x64/x86/ARM64/ARM only)."""
    _cmdline_ = "partition-alloc-dump-beta"
    _syntax_ = "{:s} [-h] fast_malloc|array_buffer|buffer|all [-v]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} array_buffer # walk from array_buffer_root_\n".format(_cmdline_)
    _example_ += "{:s} ab # same above (fm, ab and b are valid)\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC.\n"
    _example_ += "Chromium mainline is too fast to develop. So if parse is failed, you need fix this gef.py."
    _category_ = "Chrome"

    # No diffs affecting this command


@register_command
class PartitionAllocDumpDevCommand(PartitionAllocDumpBetaCommand):
    """PartitionAlloc freelist viewer for chromium dev (supported x64/x86/ARM64/ARM only)."""
    _cmdline_ = "partition-alloc-dump-dev"
    _syntax_ = "{:s} [-h] fast_malloc|array_buffer|buffer|all [-v]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} array_buffer # walk from array_buffer_root_\n".format(_cmdline_)
    _example_ += "{:s} ab # same above (fm, ab and b are valid)\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC.\n"
    _example_ += "Chromium mainline is too fast to develop. So if parse is failed, you need fix this gef.py."
    _category_ = "Chrome"

    # No diffs affecting this command


@register_command
class PartitionAllocDumpOld1Command(GenericCommand):
    """PartitionAlloc freelist viewer (supported x64/x86/ARM64/ARM only). This is old command, based on Google CTF 2021 - fullchain."""
    _cmdline_ = "partition-alloc-dump-old1"
    _syntax_ = "{:s} [-h] fast_malloc|array_buffer|buffer|layout|all [-v]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} array_buffer # walk from array_buffer_root_\n".format(_cmdline_)
    _example_ += "{:s} ab # same above (fm, ab, b and l are valid)\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "For the implementation in 2021 Jul (tested on Google CTF 2021 - fullchain).\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC.\n"
    _category_ = "Chrome"

    """
    partition alloc freelist is following.

     +-root-----------------+
     | ...                  |    +---> +-extent------------+  +-> +-extent------------+  +-> ...
     | next_super_page      |    |     | super_page_base   |  |   | super_page_base   |  |
     | next_partition_page  |    |     | next              | -+   | next              | -+
     | ...                  |    |     +-------------------+      +-------------------+
     | first_extent         | ---+
     | direct_map_list      | -------> +-direct_map_extent-+  +-> +-direct_map_extent-+  +-> ...
     | ...                  |          | bucket            |  |   | bucket            |  |
     |                      |          | next_extent       | -+   | next_extent       | -+
     |                      |          +-------------------+      +-------------------+
     |                      |
     +-bucket[0](0x20)------+
     | head                 | -------> +-slot_span---------+  +-> +-slot_span---------+  +-> ...
     | slot_size            | <------- | bucket            |  |   | bucket            |  |
     | ...                  |    +---- | freelist_head     |  |   | freelist_head     |  |
     +-bucket[1](0x20)------+    |     | next_slot_span    | -+   | next_slot_span    | -+
     | head                 |    |     +-------------------+      +-------------------+
     | slot_size            |    |
     | ...                  |    |
     +----------------------+    |
     | ...                  |    |
     |                      |    +---> +-slot--------------+
     |                      |          | next              | --+
     +----------------------+          | (freed)           |   |
                                       +-slot--------------+   |
                                       |                   |   |
                                       | (used)            |   |
                                       +-slot--------------+ <-+
                                   +-- | next              |
                                   |   | (freed)           |
                                   |   +-slot--------------+
                                   |   |                   |
                                   |   | (used)            |
                                   +-> +-slot--------------+
                                       | next              | --> NULL
                                       | (freed)           |
                                       +-slot--------------+
                                       |                   |
                                       |                   |
                                       +-------------------+

    `slot_span` and `slot` are in super_page.

          +-super_page-(2MB)----+
     4KB  | Guard Page          |
          +---------------------+
     4KB  | slot_span * 128     |
          +---------------------+
     8KB  | Guard Page          |
          +---------------------+
     16KB | Partition Page #1   |
          |   slot              |
          |   slot              |
          |   ...               |
          +---------------------+
          | ...                 |
          +---------------------+
     16KB | Partition Page #126 |
          +---------------------+
     12KB | Unused              |
          +---------------------+
      4KB | Guard Page          |
          +---------------------+
    """

    def slice_unpack(self, data, n):
        tmp = [data[i:i+n] for i in range(0, len(data), n)]
        if n == 8:
            return list(map(u64, tmp))
        elif n == 4:
            return list(map(u32, tmp))
        else:
            raise

    @lru_cache()
    def get_roots_heuristic(self):
        """searches for array_buffer_root_, buffer_root_, layout_root_ and fast_malloc_root_"""
        filepath = get_filepath()
        if is_64bit():
            codebase = get_section_base_address(filepath)
            mask = 0x0000ffff00000000
            chromium_rw_maps = [p for p in get_process_maps() if p.permission.value == Permission.READ | Permission.WRITE]
            chromium_rw_maps = [p for p in chromium_rw_maps if (p.page_start & mask) == (codebase & mask) and p.path != filepath]
        elif is_32bit():
            mask = 0xff000000
            heapbase = HeapBaseFunction.heap_base()
            chromium_rw_maps = [p for p in get_process_maps() if p.permission.value == Permission.READ | Permission.WRITE]
            chromium_rw_maps = [p for p in chromium_rw_maps if p.page_start < heapbase and p.path != filepath]

        roots = []
        for maps in chromium_rw_maps:
            datas = self.slice_unpack(read_memory(maps.page_start, maps.size), current_arch.ptrsize)
            addrs = [x for x in range(maps.page_start, maps.page_end, current_arch.ptrsize)]

            """
            #if !BUILDFLAG(USE_PARTITION_ALLOC_AS_MALLOC)
            base::ThreadSafePartitionRoot* Partitions::fast_malloc_root_ = nullptr;
            #endif
            base::ThreadSafePartitionRoot* Partitions::array_buffer_root_ = nullptr;
            base::ThreadSafePartitionRoot* Partitions::buffer_root_ = nullptr;
            base::ThreadUnsafePartitionRoot* Partitions::layout_root_ = nullptr;
            """
            for i in range(len(addrs)-3):
                if (datas[i] & mask) != (addrs[i] & mask): # maybe it points near
                    continue
                if (datas[i] & 0x7) != 0: # maybe it is aligned
                    continue

                # roots are next to each other
                # calc diff                          # [fast_malloc_root_ exists]            # [fast_malloc_root_ does not exist] #
                root_size1 = datas[i+1] - datas[i]   # array_buffer_root - fast_malloc_root_ # buffer_root_ - array_buffer_root_  # valid
                root_size2 = datas[i+2] - datas[i+1] # buffer_root_ - array_buffer_root_     # layout_root_ - buffer_root_        # valid
                root_size3 = datas[i+3] - datas[i+2] # layout_root_ - buffer_root_           # xxx - xxx                          # maybe invalid

                # sizeof(root) is all same
                if root_size1 != root_size2:
                    continue

                if is_64bit() and ((root_size1 < 0x1000) or (0x1800 < root_size1)): # sizeof(*root) is valid
                    continue
                elif is_32bit() and ((root_size1 < 0x800) or (0x1800 < root_size1)): # sizeof(*root) is valid
                    continue

                # here, maybe found
                if addrs[i] in [root[1] for root in roots]: # but it has already checked
                    continue

                if root_size2 == root_size3: # fast_malloc_root_ exists
                    roots.append(["fast_malloc_root_", addrs[i]])
                    roots.append(["array_buffer_root_", addrs[i+1]])
                    roots.append(["buffer_root_", addrs[i+2]])
                    roots.append(["layout_root_", addrs[i+3]])
                else: # fast_malloc_root_ does not exist
                    roots.append(["array_buffer_root_", addrs[i]])
                    roots.append(["buffer_root_", addrs[i+1]])
                    roots.append(["layout_root_", addrs[i+2]])

        if len(roots) in [3, 4]:
            for root in roots:
                info("found: {:s}: {:#x}".format(root[0], root[1]))
        elif len(roots) == 0:
            err("root were not found. try check code")
        else:
            err("candidates for root are found in multiple places. try check code")
            for root in roots:
                gef_print("  candidate: {:s} {:#x}".format(root[0], root[1]))
                if root[0] == "layout_root_":
                    gef_print("")
            roots = []
        return roots

    @lru_cache()
    def get_roots(self):
        def get_root(root_string):
            try:
                root_addr = parse_address("&'WTF::Partitions::{:s}'".format(root_string))
                return [[root_string, root_addr]]
            except:
                return []

        roots = []
        # try from symbols
        for root_string in ["fast_malloc_root_", "array_buffer_root_", "buffer_root_", "layout_root_"]:
            roots += get_root(root_string)
        # maybe no symbols, try heuristic
        if len(roots) == 0:
            info("Symbol is not found. It will use heuristic search")
            roots += self.get_roots_heuristic()
        # retry checking
        if len(roots) == 0:
            info("Symbol is not found.")
        return roots

    @lru_cache()
    def get_sentinel_slot_spans(self):
        """sentinel_slot_span is default slot_span, so search it"""
        sentinel = []
        try:
            t = parse_address("&'base::internal::SlotSpanMetadata<true>::sentinel_slot_span_'")
            sentinel.append(t)
        except:
            pass
        try:
            f = parse_address("&'base::internal::SlotSpanMetadata<false>::sentinel_slot_span_'")
            sentinel.append(f)
        except:
            pass
        return sentinel

    def byteswap(self, x):
        def p(a):
            return struct.pack("<I",a&0xffffffff)
        def ube(a):
            return struct.unpack(">I",a)[0]
        def pQ(a):
            return struct.pack("<Q",a&0xffffffffffffffff)
        def uQbe(a):
            return struct.unpack(">Q",a)[0]
        if is_64bit():
            converted = uQbe(pQ(x))
        elif is_32bit():
            converted = ube(p(x))
        return converted

    def read_root(self, addr, name):
        ptrsize = current_arch.ptrsize
        root = {}
        root["name"] = name
        root["addr"] = current = read_int_from_memory(addr)
        """
        struct base::PartitionRoot {
            bool with_thread_cache = false;
            const bool is_thread_safe = thread_safe;
            bool allow_aligned_alloc;
            bool allow_cookies;
            bool allow_ref_count;
            //static constexpr bool use_lazy_commit = false;
            //static constexpr bool never_used_lazy_commit = true;
            //uint32_t extras_size;
            //uint32_t extras_offset;
            internal::MaybeSpinLock<thread_safe> lock_;
            Bucket buckets[kNumBuckets] = {};
            Bucket sentinel_bucket;
            bool initialized = false;
            std::atomic<size_t> total_size_of_committed_pages{0};
            std::atomic<size_t> total_size_of_super_pages{0};
            std::atomic<size_t> total_size_of_direct_mapped_pages{0};
            char* next_super_page = nullptr;
            char* next_partition_page = nullptr;
            char* next_partition_page_end = nullptr;
            SuperPageExtentEntry* current_extent = nullptr;
            SuperPageExtentEntry* first_extent = nullptr;
            DirectMapExtent* direct_map_list GUARDED_BY(lock_) = nullptr;
            SlotSpan* global_empty_slot_span_ring[kMaxFreeableSpans] = {};
            int16_t global_empty_slot_span_ring_index = 0;
            uintptr_t inverted_self = 0;
            std::atomic<int> thread_caches_being_constructed_{0};
        }
        """
        x = u64(read_memory(current, 8))
        current += 8
        root["with_thread_cache"] = (x >> 0) & 0xff
        root["is_thread_safe"] = (x >> 8) & 0xff
        root["allow_aligned_alloc"] = (x >> 16) & 0xff
        root["allow_cookies"] = (x >> 24) & 0xff
        root["allow_ref_count"] = (x >> 32) & 0xff

        root["lock_"] = read_int_from_memory(current)
        current += ptrsize

        # for 32bit, there is 2 patterns because aligned or packed
        if is_32bit():
            if self.align_pad is None:
                x = read_int_from_memory(current)
                if x == 0:
                    self.align_pad = True
                else:
                    self.align_pad = False
            if self.align_pad:
                current += ptrsize

        root["buckets"] = []
        while True:
            if read_int_from_memory(current) == 1: # search initialized
                break
            bucket, current = self.read_bucket(current)
            root["buckets"].append(bucket)
        root["sentinel_bucket"] = root["buckets"].pop()

        root["initialized"] = read_int_from_memory(current) & 0xff
        current += ptrsize # with pad
        root["total_size_of_committed_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["total_size_of_super_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["total_size_of_direct_mapped_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["next_super_page"] = read_int_from_memory(current)
        current += ptrsize
        root["next_partition_page"] = read_int_from_memory(current)
        current += ptrsize
        root["next_partition_page_end"] = read_int_from_memory(current)
        current += ptrsize
        root["current_extent"] = read_int_from_memory(current)
        current += ptrsize
        root["first_extent"] = read_int_from_memory(current)
        current += ptrsize
        root["direct_map_list"] = read_int_from_memory(current)
        current += ptrsize

        root["global_empty_slot_span_ring"] = []
        inv = root["addr"] ^ ((1 << (current_arch.ptrsize * 8)) - 1)
        while True:
            if read_int_from_memory(current + ptrsize) == inv: # search inverted_self
                break
            x = read_int_from_memory(current)
            current += ptrsize
            root["global_empty_slot_span_ring"].append(x)

        root["global_empty_slot_span_ring_index"] = u16(read_memory(current, 2))
        current += ptrsize # with pad
        root["inverted_self"] = read_int_from_memory(current)
        current += ptrsize
        root["thread_caches_being_constructed_"] = u32(read_memory(current, 4))
        current += 4
        return root, current

    def read_bucket(self, addr):
        ptrsize = current_arch.ptrsize
        bucket = {}
        bucket["addr"] = current = addr
        """
        struct base::internal::PartitionBucket {
            SlotSpanMetadata<thread_safe>* active_slot_spans_head;
            SlotSpanMetadata<thread_safe>* empty_slot_spans_head;
            SlotSpanMetadata<thread_safe>* decommitted_slot_spans_head;
            uint32_t slot_size;
            uint32_t num_system_pages_per_slot_span : 8;
            uint32_t num_full_slot_spans : 24;
            uint64_t slot_size_reciprocal;
        };
        """
        bucket["active_slot_spans_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["empty_slot_spans_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["decommitted_slot_spans_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["slot_size"] = u32(read_memory(current, 4))
        current += 4
        x = u32(read_memory(current, 4))
        bucket["num_system_pages_per_slot_span"] = x & 0xff
        bucket["num_full_slot_spans"] = (x >> 8) & 0xffffff
        current += 4

        # for 32bit, there is 2 patterns because aligned or packed
        if is_32bit() and self.align_pad:
            current += 4
        bucket["slot_size_reciprocal"] = u64(read_memory(current, 8))
        current += 8
        return bucket, current

    def read_extent(self, addr):
        ptrsize = current_arch.ptrsize
        extent = {}
        extent["addr"] = current = addr
        """
        struct PartitionSuperPageExtentEntry {
          PartitionRootBase* root;
          char* super_page_base;
          char* super_pages_end;
          PartitionSuperPageExtentEntry* next;
        };
        """
        kSuperPageShift = 21
        extent["root"] = read_int_from_memory(current)
        current += ptrsize
        extent["super_page_base"] = read_int_from_memory(current)
        current += ptrsize
        extent["super_pages_end"] = read_int_from_memory(current)
        current += ptrsize
        extent["next"] = read_int_from_memory(current)
        current += ptrsize
        extent["num_pages"] = (extent["super_pages_end"] - extent["super_page_base"]) >> kSuperPageShift
        return extent, current

    def read_direct_map(self, addr):
        ptrsize = current_arch.ptrsize
        direct_map = {}
        direct_map["addr"] = current = addr
        """
        struct PartitionDirectMapExtent {
          PartitionDirectMapExtent<thread_safe>* next_extent;
          PartitionDirectMapExtent<thread_safe>* prev_extent;
          PartitionBucket<thread_safe>* bucket;
          size_t map_size;
        };
        """
        direct_map["next_extent"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["prev_extent"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["bucket"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["map_size"] = read_int_from_memory(current)
        current += ptrsize
        return direct_map, current

    def read_slot_span(self, addr):
        ptrsize = current_arch.ptrsize
        slot_span = {}
        slot_span["addr"] = current = addr
        slot_span["super_page_addr"] = (slot_span["addr"] & ~(DEFAULT_PAGE_SIZE-1)) - DEFAULT_PAGE_SIZE
        slot_span["partition_page_index"] = (slot_span["addr"] & (DEFAULT_PAGE_SIZE-1)) // 0x20
        slot_span["partition_page_start"] = slot_span["super_page_addr"] + slot_span["partition_page_index"] * DEFAULT_PAGE_SIZE * 4
        """
        struct SlotSpanMetadata {
          PartitionFreelistEntry* freelist_head = nullptr;
          SlotSpanMetadata<thread_safe>* next_slot_span = nullptr;
          PartitionBucket<thread_safe>* const bucket;
          int16_t num_allocated_slots = 0;
          uint16_t num_unprovisioned_slots = 0;
          int8_t empty_cache_index = 0;
          const bool can_store_raw_size;
        }
        """
        slot_span["freelist_head"] = read_int_from_memory(current)
        current += ptrsize
        slot_span["next_slot_span"] = read_int_from_memory(current)
        current += ptrsize
        slot_span["bucket"] = read_int_from_memory(current)
        current += ptrsize
        slot_span["num_allocated_slots"] = u16(read_memory(current, 2))
        current += 2
        slot_span["num_unprovisioned_slots"] = u16(read_memory(current, 2))
        current += 2
        slot_span["empty_cache_index"] = u8(read_memory(current, 1))
        current += 1
        slot_span["can_store_raw_size"] = u8(read_memory(current, 1))
        current += 1
        return slot_span, current

    def print_root(self, root):
        gef_print(titlify("*{} @ {:#x}".format(root["name"], root["addr"])))
        gef_print("bool with_thread_cache:                                {:#x}".format(root["with_thread_cache"]))
        gef_print("const bool is_thread_safe:                             {:#x}".format(root["is_thread_safe"]))
        gef_print("bool allow_aligned_alloc:                              {:#x}".format(root["allow_aligned_alloc"]))
        gef_print("bool allow_cookies:                                    {:#x}".format(root["allow_cookies"]))
        gef_print("bool allow_ref_count:                                  {:#x}".format(root["allow_ref_count"]))
        gef_print("internal::MaybeSpinLock:                               {:#x}".format(root["lock_"]))
        gef_print("Bucket buckets[{:3d}]:".format(len(root["buckets"])))
        for idx, bucket in enumerate(root["buckets"]):
            self.print_bucket(bucket, root, idx)
        if self.verbose:
            gef_print("Bucket sentinel_bucket:")
            self.print_bucket(root["sentinel_bucket"], root)
        else:
            gef_print("Bucket sentinel_bucket:                                ...")
        gef_print("bool initialized:                                      {:#x}".format(root["initialized"]))
        gef_print("std::atomic<size_t> total_size_of_commited_pages:      {:#x}".format(root["total_size_of_committed_pages"]))
        gef_print("std::atomic<size_t> total_size_of_super_pages:         {:#x}".format(root["total_size_of_super_pages"]))
        gef_print("std::atomic<size_t> total_size_of_direct_mapped_pages: {:#x}".format(root["total_size_of_direct_mapped_pages"]))
        gef_print("char* next_super_page:                                 {:#x}".format(root["next_super_page"]))
        gef_print("char* next_partition_page:                             {:#x}".format(root["next_partition_page"]))
        gef_print("char* next_partition_page_end:                         {:#x}".format(root["next_partition_page_end"]))
        gef_print("SuperPageExtentEntry* current_extent:                  {:#x}".format(root["current_extent"]))
        gef_print("SuperPageExtentEntry* first_extent:                    {:#x}".format(root["first_extent"]))
        self.print_extent_list(root["first_extent"])
        gef_print("DirectMapExtent* direct_map_list:                      {:#x}".format(root["direct_map_list"]))
        self.print_direct_map_list(root["direct_map_list"], root)
        ring_len = len(root["global_empty_slot_span_ring"])
        if self.verbose:
            gef_print("SlotSpan* global_empty_slot_span_ring[{:2d}]:".format(ring_len))
            for i in range(len(root["global_empty_slot_span_ring"])):
                x = root["global_empty_slot_span_ring"][i]
                gef_print("    global_empty_slot_span_ring[{:2d}]:                       {:#x}".format(i, x))
        else:
            gef_print("SlotSpan* global_empty_slot_span_ring[{:2d}]:             ...".format(ring_len))
        gef_print("int16_t global_empty_slot_span_ring_index:             {:#x}".format(root["global_empty_slot_span_ring_index"]))
        inv = root["inverted_self"]
        inv_inv = inv ^ ((1 << (current_arch.ptrsize * 8)) - 1)
        gef_print("uintptr_t inverted_self:                               {:#x} (=~{:#x})".format(inv, inv_inv))
        gef_print("std::atomic<int> thread_caches_being_constructed_:     {:#x}".format(root["thread_caches_being_constructed_"]))
        return

    def print_extent_list(self, head):
        try:
            current = head
            while current:
                extent, _ = self.read_extent(current)
                text = "    -> extent @{:<#14x}: ".format(extent["addr"])
                text += "root:{:<#14x} ".format(extent["root"])
                super_page_info = "{:<#14x} - {:<#14x}".format(extent["super_page_base"], extent["super_pages_end"])
                text += "super_page:" + Color.colorify(super_page_info, "yellow bold")
                text += " (total 0x200000(2MB) * {:d} pages) ".format(extent["num_pages"])
                text += "next:{:<#14x}".format(extent["next"])
                gef_print(text)
                current = extent["next"]
        except:
            err("Corrupted?")
        return

    def print_direct_map_list(self, head, root):
        bugged = False
        def bugcheck(bucket):
            # maybe chromium's bug: bucket used by direct_map is strange
            """
            I confirmed under v89.0.4389.114, v92.0.4515.107. but it is fixed under v93.0.4540.0
            gef> x/16xg 0x2000201040 <--- direct_map_list->bucket
            0x2000201040:   0x00000000001e0000 *    0x0000000000000000 <-- * is strange, it should be valid pointer or null
            0x2000201050:   0x0000000000000000      0x00000000001e0000     because it is `active_slot_spans_head`
            0x2000201060:   0x0000000000000000      0x0000002000001068
            0x2000201070:   0x0000000000000000      0x0000002000201040
            0x2000201080:   0x00000000001fc000      0x0000000000000000
            """
            nonlocal bugged
            if bugged: # already printed
                return
            x = bucket["active_slot_spans_head"]
            if x == 0: # nullptr is valid
                return
            try:
                read_memory(x)
            except:
                info("maybe chrome bug; direct_map_list->bucket->active_slot_spans_head is broken? it was fixed at least v93.0.4540.0")
                bugged = True
            return

        try:
            current = head
            while current:
                direct_map, _ = self.read_direct_map(current)
                text = "    -> direct_map @{:<#14x}: ".format(direct_map["addr"])
                text += "next_extent:{:<#14x} ".format(direct_map["next_extent"])
                text += "prev_extent:{:<#14x} ".format(direct_map["prev_extent"])
                text += "bucket:{:<#14x} ".format(direct_map["bucket"])
                text += "map_size:{:#x}".format(direct_map["map_size"])
                gef_print(text)
                bucket, _ = self.read_bucket(direct_map["bucket"])
                bugcheck(bucket)
                self.print_bucket(bucket, root)
                current = direct_map["next_extent"]
        except:
            err("Corrupted?")
        return

    def print_bucket(self, bucket, root, idx = None):
        sentinel1 = self.get_sentinel_slot_spans() # from symbol
        sentinel2 = [root["sentinel_bucket"]["active_slot_spans_head"]] # from heuristic search
        sentinel = list(set(sentinel1 + sentinel2)) # uniq

        if not self.verbose:
            if bucket["active_slot_spans_head"] in sentinel + [0x0]:
                return # skip printing

        slot_size = Color.colorify("{:#7x}".format(bucket["slot_size"]), "bold pink")
        if idx is not None:
            text = "    buckets[{:3d}](slot_size:{:s}) @{:<#14x}".format(idx, slot_size, bucket["addr"])
        else:
            text = "    bucket(slot_size:{:s}) @{:<#14x}".format(slot_size, bucket["addr"])
        gef_print(text)
        text = "        "
        text += "num_system_pages_per_slot_span:{:<#4x} ".format(bucket["num_system_pages_per_slot_span"])
        text += "num_full_slot_spans:{:<#4x} ".format(bucket["num_full_slot_spans"])
        text += "slot_size_reciprocal:{:#x}".format(bucket["slot_size_reciprocal"])
        gef_print(text)

        if self.verbose:
            target_list = ["active_slot_spans_head", "empty_slot_spans_head", "decommitted_slot_spans_head"]
        else:
            target_list = ["active_slot_spans_head"]

        for key in target_list:
            head = bucket[key]
            if not self.verbose and (head in sentinel + [0x0]):
                continue
            if head in sentinel:
                gef_print("        {:s}:sentinel_pages".format(Color.colorify(key, "bold cyan underline")))
            else:
                gef_print("        {:s}:{:<#14x}".format(Color.colorify(key, "bold cyan underline"), head))
            self.print_slot_span(head, bucket)
        return

    def print_slot_span(self, head, bucket):
        current = head
        while current:
            try:
                slot_span, _ = self.read_slot_span(current)
            except:
                err("Corrupted?")
                break
            text_fmt = "            -> slot_span @{:<#14x} (#{:3d} of super_page @{:<#14x})"
            text = text_fmt.format(slot_span["addr"], slot_span["partition_page_index"], slot_span["super_page_addr"])
            gef_print(text)
            text = "                "
            text += "next_slot_span:{:<#14x} ".format(slot_span["next_slot_span"])
            page_start = slot_span["partition_page_start"]
            page_end = slot_span["partition_page_start"] + bucket["num_system_pages_per_slot_span"] * DEFAULT_PAGE_SIZE
            text += "slot_span_area:{:#x}-{:#x} ".format(page_start, page_end)
            text += "num_allocated_slots:{:#x}".format(slot_span["num_allocated_slots"])
            gef_print(text)
            self.print_freelist(slot_span["freelist_head"], bucket, slot_span)
            current = slot_span["next_slot_span"]
        return

    def print_freelist(self, head, bucket, slot_span):
        gef_print("                freelist_head:{:<#14x} ".format(head))

        slot_size = bucket["slot_size"]
        page_start = slot_span["partition_page_start"]
        page_end = slot_span["partition_page_start"] + bucket["num_system_pages_per_slot_span"] * DEFAULT_PAGE_SIZE

        text = ""
        cnt = 0
        chunk = head
        seen = []
        while chunk:
            if cnt % 7 == 0:
                if cnt > 0:
                    text += "\n"
                text += " "*20

            if chunk in seen:
                text += Color.colorify("-> {:<#14x} (loop) ".format(chunk), "red bold")
                break

            if not ((page_start <= chunk < page_end) and ((chunk - page_start) % slot_size == 0)):
                text += Color.colorify("-> {:<#14x} (corrupted) ".format(chunk), "red bold")
                break

            try:
                next_chunk = self.byteswap(read_int_from_memory(chunk))
            except:
                text += Color.colorify("-> {:<#14x} (corrupted) ".format(chunk), "red bold")
                break

            text += "-> " + Color.colorify("{:<#14x} ".format(chunk), "yellow bold")
            cnt += 1
            seen.append(chunk)
            chunk = next_chunk

        if cnt > 0:
            text += "(num: {:#x})".format(cnt)

        if text:
            gef_print(text)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    @only_if_x86_32_64_or_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if is_32bit():
            self.align_pad = None

        if "-h" in argv:
            self.usage()
            return

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        if len(argv) != 1:
            self.usage()
            return

        if not argv[0] in ["fast_malloc", "fm", "array_buffer", "ab", "buffer", "b", "layout", "l", "all"]:
            self.usage()
            return
        target = argv[0]

        for name, addr in self.get_roots():
            ok = False
            if target == "all":
                ok = True
            elif target in ["fast_malloc", "fm"] and name == "fast_malloc_root_":
                ok = True
            elif target in ["array_buffer", "ab"] and name == "array_buffer_root_":
                ok = True
            elif target in ["buffer", "b"] and name == "buffer_root_":
                ok = True
            elif target in ["layout", "l"] and name == "layout_root_":
                ok = True

            if ok:
                try:
                    root, _ = self.read_root(addr, name)
                except:
                    err("Parse error {:s}: @ {:#x}".format(name, addr))
                    continue
                self.print_root(root)
        return


@register_command
class PartitionAllocDumpOld2Command(GenericCommand):
    """PartitionAlloc freelist viewer (supported x64 only). This is old command, based on 0ctf 2020 chromium fullchain."""
    _cmdline_ = "partition-alloc-dump-old2"
    _syntax_ = "{:s} [-h] fast_malloc|array_buffer|buffer|layout|all [-v]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} array_buffer # walk from array_buffer_root_\n".format(_cmdline_)
    _example_ += "{:s} ab # same above (fm, ab, b and l are valid)\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "For the implementation in 2020 Jun (tested on 0CTF 2020 - chromium fullchain).\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC.\n"
    _category_ = "Chrome"

    """
    See https://qiita.com/msmania/items/1a10d5b7d20f6455b9b1

    partition alloc freelist is following.

     +-root-----------------+
     | ...                  |    +---> +-extent------------+  +-> +-extent------------+  +-> ...
     | next_super_page      |    |     | super_page_base   |  |   | super_page_base   |  |
     | next_partition_page  |    |     | next              | -+   | next              | -+
     | ...                  |    |     +-------------------+      +-------------------+
     | first_extent         | ---+
     | direct_map_list      | -------> +-direct_map_extent-+  +-> +-direct_map_extent-+  +-> ...
     | ...                  |          | bucket            |  |   | bucket            |  |
     |                      |          | next_extent       | -+   | next_extent       | -+
     |                      |          +-------------------+      +-------------------+
     |                      |
     +-bucket[0](0x20)------+
     | head                 | -------> +-page--------------+  +-> +-page--------------+  +-> ...
     | slot_size            | <------- | bucket            |  |   | bucket            |  |
     | ...                  |    +---- | freelist_head     |  |   | freelist_head     |  |
     +-bucket[1](0x20)------+    |     | next_page         | -+   | next_page         | -+
     | head                 |    |     +-------------------+      +-------------------+
     | slot_size            |    |
     | ...                  |    |
     +----------------------+    |
     | ...                  |    |
     |                      |    +---> +-slot--------------+
     |                      |          | next              | --+
     +----------------------+          | (freed)           |   |
                                       +-slot--------------+   |
                                       |                   |   |
                                       | (used)            |   |
                                       +-slot--------------+ <-+
                                   +-- | next              |
                                   |   | (freed)           |
                                   |   +-slot--------------+
                                   |   |                   |
                                   |   | (used)            |
                                   +-> +-slot--------------+
                                       | next              | --> NULL
                                       | (freed)           |
                                       +-slot--------------+
                                       |                   |
                                       |                   |
                                       +-------------------+

    `page` and `slot` are in super_page.

          +-super_page-(2MB)----+
     4KB  | Guard Page          |
          +---------------------+
     4KB  | page * 128          |
          +---------------------+
     8KB  | Guard Page          |
          +---------------------+
     16KB | Partition Page #1   |
          |   slot              |
          |   slot              |
          |   ...               |
          +---------------------+
          | ...                 |
          +---------------------+
     16KB | Partition Page #126 |
          +---------------------+
     12KB | Unused              |
          +---------------------+
      4KB | Guard Page          |
          +---------------------+
    """

    def get_roots(self):
        roots = []
        try:
            fast_malloc_root = parse_address("&'WTF::Partitions::fast_malloc_root_'")
            roots.append(("fast_malloc_root_", fast_malloc_root))
        except:
            err("'WTF::Partitions::fast_malloc_root_' is not found")
        try:
            array_buffer_root = parse_address("&'WTF::Partitions::array_buffer_root_'")
            roots.append(("array_buffer_root_", array_buffer_root))
        except:
            err("'WTF::Partitions::array_buffer_root_' is not found")
        try:
            buffer_root = parse_address("&'WTF::Partitions::buffer_root_'")
            roots.append(("buffer_root_", buffer_root))
        except:
            err("'WTF::Partitions::buffer_root_' is not found")
        try:
            layout_root = parse_address("&'WTF::Partitions::layout_root_'")
            roots.append(("layout_root_", layout_root))
        except:
            err("'WTF::Partitions::layout_root_' is not found")
        return roots

    def get_sentinel_buckets(self):
        sentinel = []
        try:
            t = parse_address("&'base::internal::PartitionBucket<true>::sentinel_bucket_'")
            sentinel.append(t)
        except:
            err("'base::internal::PartitionBucket<true>::sentinel_bucket_' is not found")
        try:
            f = parse_address("&'base::internal::PartitionBucket<false>::sentinel_bucket_'")
            sentinel.append(f)
        except:
            err("'base::internal::PartitionBucket<false>::sentinel_bucket_' is not found")
        return sentinel

    def get_sentinel_pages(self):
        sentinel = []
        try:
            t = parse_address("&'base::internal::PartitionPage<true>::sentinel_page_'")
            sentinel.append(t)
        except:
            err("'base::internal::PartitionPage<true>::sentinel_page_' is not found")
        try:
            f = parse_address("&'base::internal::PartitionPage<false>::sentinel_page_'")
            sentinel.append(f)
        except:
            err("'base::internal::PartitionPage<false>::sentinel_page_' is not found")
        return sentinel

    def byteswap(self, x):
        def pQ(a):
            return struct.pack("<Q",a&0xffffffffffffffff)
        def uQbe(a):
            return struct.unpack(">Q",a)[0]
        return uQbe(pQ(x))

    def read_root(self, addr, name):
        ptrsize = current_arch.ptrsize
        root = {}
        root["name"] = name
        root["addr"] = current = read_int_from_memory(addr)
        """
        struct PartitionRootGeneric {
            struct PartitionRootBase {
              size_t total_size_of_committed_pages = 0;
              size_t total_size_of_super_pages = 0;
              size_t total_size_of_direct_mapped_pages = 0;
              unsigned num_buckets = 0;
              unsigned max_allocation = 0;
              bool initialized = false;
              char* next_super_page = nullptr;
              char* next_partition_page = nullptr;
              char* next_partition_page_end = nullptr;
              PartitionSuperPageExtentEntry* current_extent = nullptr;
              PartitionSuperPageExtentEntry* first_extent = nullptr;
              PartitionDirectMapExtent* direct_map_list = nullptr;
              PartitionPage* global_empty_page_ring[kMaxFreeableSpans] = {};
              int16_t global_empty_page_ring_index = 0;
              uintptr_t inverted_self = 0;
            }
            size_t order_index_shifts[kBitsPerSizeT + 1] = {};
            size_t order_sub_index_masks[kBitsPerSizeT + 1] = {};
            internal::PartitionBucket* bucket_lookups[((kBitsPerSizeT + 1) * kGenericNumBucketsPerOrder) + 1] = {};
            struct PartitionBucket buckets[kGenericNumBuckets] = {};
        }
        """
        kBitsPerSizeT = 64
        kMaxFreeableSpans = 16
        kGenericMinBucketedOrder = 4
        kGenericMaxBucketedOrder = 20
        kGenericNumBucketedOrders = (kGenericMaxBucketedOrder - kGenericMinBucketedOrder) + 1
        kGenericNumBucketsPerOrder = 8
        kGenericNumBuckets = kGenericNumBucketedOrders * kGenericNumBucketsPerOrder
        kGenericSmallestBucket = 1 << (kGenericMinBucketedOrder - 1)
        kSystemPageSize = 4096
        kPartitionPageShift = 14
        kPageMetadataShift = 5
        kSuperPageShift = 21
        kSuperPageSize = 1 << kSuperPageShift
        kSuperPageOffsetMask = kSuperPageSize - 1
        kSuperPageBaseMask = ~kSuperPageOffsetMask

        current += ptrsize # needed, but why?
        root["total_size_of_committed_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["total_size_of_super_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["total_size_of_direct_mapped_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["num_buckets"] = u32(read_memory(current, 4))
        current += 4
        root["max_allocation"] = u32(read_memory(current, 4))
        current += 4
        root["initialized"] = u8(read_memory(current, 1))
        current += ptrsize # with pad
        root["next_super_page"] = read_int_from_memory(current)
        current += ptrsize
        root["next_partition_page"] = read_int_from_memory(current)
        current += ptrsize
        root["next_partition_page_end"] = read_int_from_memory(current)
        current += ptrsize
        root["current_extent"] = read_int_from_memory(current)
        current += ptrsize
        root["first_extent"] = read_int_from_memory(current)
        current += ptrsize
        root["direct_map_list"] = read_int_from_memory(current)
        current += ptrsize
        root["global_empty_page_ring"] = []
        for i in range(kMaxFreeableSpans):
            x = read_int_from_memory(current)
            current += ptrsize
            root["global_empty_page_ring"].append(x)
        root["global_empty_page_ring_index"] = u16(read_memory(current, 2))
        current += ptrsize # with pad
        root["inverted_self"] = read_int_from_memory(current)
        current += ptrsize
        root["order_index_shifts"] = []
        for i in range(kBitsPerSizeT + 1):
            x = read_int_from_memory(current)
            current += ptrsize
            root["order_index_shifts"].append(x)
        root["order_sub_index_masks"] = []
        for i in range(kBitsPerSizeT + 1):
            x = read_int_from_memory(current)
            current += ptrsize
            root["order_sub_index_masks"].append(x)
        root["bucket_lookups"] = []
        for i in range(((kBitsPerSizeT + 1) * kGenericNumBucketsPerOrder) + 1):
            x = read_int_from_memory(current)
            current += ptrsize
            root["bucket_lookups"].append(x)
        root["buckets"] = []
        for i in range(kGenericNumBuckets):
            bucket, current = self.read_bucket(current)
            root["buckets"].append(bucket)
            if bucket["slot_size"] == 0xf0000: # some system use different size
                break
        return root, current

    def read_bucket(self, addr):
        ptrsize = current_arch.ptrsize
        bucket = {}
        bucket["addr"] = current = addr
        """
        struct PartitionBucket {
          PartitionPage* active_pages_head;
          PartitionPage* empty_pages_head;
          PartitionPage* decommitted_pages_head;
          uint32_t slot_size;
          uint32_t num_system_pages_per_slot_span : 8;
          uint32_t num_full_pages : 24;
        };
        """
        bucket["active_pages_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["empty_pages_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["decommitted_pages_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["slot_size"] = u32(read_memory(current, 4))
        current += 4
        x = u32(read_memory(current, 4))
        bucket["num_system_pages_per_slot_span"] = x & 0xff
        bucket["num_full_pages"] = (x >> 8) & 0xffffff
        current += 4
        return bucket, current

    def read_extent(self, addr):
        ptrsize = current_arch.ptrsize
        extent = {}
        extent["addr"] = current = addr
        """
        struct PartitionSuperPageExtentEntry {
          PartitionRootBase* root;
          char* super_page_base;
          char* super_pages_end;
          PartitionSuperPageExtentEntry* next;
        };
        """
        kSuperPageShift = 21

        extent["root"] = read_int_from_memory(current)
        current += ptrsize
        extent["super_page_base"] = read_int_from_memory(current)
        current += ptrsize
        extent["super_pages_end"] = read_int_from_memory(current)
        current += ptrsize
        extent["next"] = read_int_from_memory(current)
        current += ptrsize
        extent["num_pages"] = (extent["super_pages_end"] - extent["super_page_base"]) >> kSuperPageShift
        return extent, current

    def read_direct_map(self, addr):
        ptrsize = current_arch.ptrsize
        direct_map = {}
        direct_map["addr"] = current = addr
        """
        struct PartitionDirectMapExtent {
          PartitionDirectMapExtent<thread_safe>* next_extent;
          PartitionDirectMapExtent<thread_safe>* prev_extent;
          PartitionBucket<thread_safe>* bucket;
          size_t map_size;  // Mapped size, not including guard pages and meta-data.
        };
        """
        direct_map["next_extent"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["prev_extent"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["bucket"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["map_size"] = read_int_from_memory(current)
        current += ptrsize
        return direct_map, current

    def read_page(self, addr):
        ptrsize = current_arch.ptrsize
        page = {}
        page["addr"] = current = addr
        page["super_page_addr"] = (page["addr"] & ~(DEFAULT_PAGE_SIZE-1)) - DEFAULT_PAGE_SIZE
        page["partition_page_index"] = (page["addr"] & (DEFAULT_PAGE_SIZE-1)) // 0x20
        page["partition_page_start"] = page["super_page_addr"] + page["partition_page_index"] * DEFAULT_PAGE_SIZE * 4
        """
        struct PartitionPage {
          PartitionFreelistEntry* freelist_head;
          PartitionPage* next_page;
          PartitionBucket* bucket; // Deliberately signed, 0 for empty or decommitted page, -n for full pages:
          int16_t num_allocated_slots;
          uint16_t num_unprovisioned_slots;
          uint16_t page_offset;
          int16_t empty_cache_index; // -1 if not in the empty cache.
        }
        """
        page["freelist_head"] = read_int_from_memory(current)
        current += ptrsize
        page["next_page"] = read_int_from_memory(current)
        current += ptrsize
        page["bucket"] = read_int_from_memory(current)
        current += ptrsize
        page["num_allocated_slots"] = u16(read_memory(current, 2))
        current += 2
        page["num_unprovisioned_slots"] = u16(read_memory(current, 2))
        current += 2
        page["page_offset"] = u16(read_memory(current, 2))
        current += 2
        page["empty_cache_index"] = u16(read_memory(current, 2))
        current += 2
        return page, current

    def print_root(self, root):
        sentinel_buckets = self.get_sentinel_buckets()
        gef_print(titlify("*{} @ {:#x}".format(root["name"], root["addr"])))
        gef_print("size_t total_size_of_committed_pages:          {:#x}".format(root["total_size_of_committed_pages"]))
        gef_print("size_t total_size_of_super_pages:              {:#x}".format(root["total_size_of_super_pages"]))
        gef_print("size_t total_size_of_direct_mapped_pages:      {:#x}".format(root["total_size_of_direct_mapped_pages"]))
        gef_print("unsigned int num_buckets:                      {:#x}".format(root["num_buckets"]))
        gef_print("unsigned int max_allocation:                   {:#x}".format(root["max_allocation"]))
        gef_print("bool initialized:                              {:#x}".format(root["initialized"]))
        gef_print("char* next_super_page:                         {:#x}".format(root["next_super_page"]))
        gef_print("char* next_partition_page:                     {:#x}".format(root["next_partition_page"]))
        gef_print("char* next_partition_page_end:                 {:#x}".format(root["next_partition_page_end"]))
        gef_print("PartitionSuperPageExtentEntry* current_extent: {:#x}".format(root["current_extent"]))
        gef_print("PartitionSuperPageExtentEntry* first_extent:   {:#x}".format(root["first_extent"]))
        self.print_extent_list(root["first_extent"])

        gef_print("PartitionDirectMapExtent* direct_map_list:     {:#x}".format(root["direct_map_list"]))
        self.print_direct_map_list(root["direct_map_list"])

        if self.verbose:
            gef_print("PartitionPage* global_empty_page_ring[16]:")
            for i in range(len(root["global_empty_page_ring"])):
                gef_print("    global_empty_page_ring[{:2d}]:                    {:#x}".format(i, root["global_empty_page_ring"][i]))
        else:
            gef_print("PartitionPage* global_empty_page_ring[16]:     ...")

        gef_print("int16_t global_empty_page_ring_index:          {:#x}".format(root["global_empty_page_ring_index"]))
        inv = root["inverted_self"]
        gef_print("uintptr_t inverted_self:                       {:#x} (=~{:#x})".format(inv, inv^0xffffffffffffffff))

        if self.verbose:
            gef_print("size_t order_index_shifts[{:2d}]".format(len(root["order_index_shifts"])))
            for i in range(len(root["order_index_shifts"])):
                gef_print("    order_index_shifts[{:2d}]:                        {:#x}".format(i, root["order_index_shifts"][i]))
        else:
            gef_print("size_t order_index_shifts[{:2d}]                  ...".format(len(root["order_index_shifts"])))

        if self.verbose:
            gef_print("size_t order_sub_index_masks[{:2d}]:".format(len(root["order_sub_index_masks"])))
            for i in range(len(root["order_sub_index_masks"])):
                gef_print("    order_sub_index_masks[{:2d}]:                     {:#x}".format(i, root["order_sub_index_masks"][i]))
        else:
            gef_print("size_t order_sub_index_masks[{:2d}]:              ...".format(len(root["order_sub_index_masks"])))

        if self.verbose:
            gef_print("internal::PartitionBucket* bucket_lookups[{:d}]:".format(len(root["bucket_lookups"])))
            for i in range(len(root["bucket_lookups"])):
                if root["bucket_lookups"][i] in sentinel_buckets:
                    gef_print("    bucket_lookups[{:3d}]:                           sentinel_bucket".format(i))
                else:
                    gef_print("    bucket_lookups[{:3d}]:                           {:#x}".format(i, root["bucket_lookups"][i]))
        else:
            gef_print("internal::PartitionBucket* bucket_lookups[{:3d}]:...".format(len(root["bucket_lookups"])))

        gef_print("internal::PartitionBucket buckets[{:3d}]:".format(len(root["buckets"])))
        for idx, bucket in enumerate(root["buckets"]):
            self.print_bucket(bucket, idx)
        return

    def print_extent_list(self, head):
        try:
            current = head
            while current:
                extent, _ = self.read_extent(current)
                text = "    -> extent @{:<#14x}: ".format(extent["addr"])
                text += "root:{:<#14x} ".format(extent["root"])
                super_page_info = "{:<#14x} - {:<#14x}".format(extent["super_page_base"], extent["super_pages_end"])
                text += "super_page:" + Color.colorify(super_page_info, "yellow bold")
                text += " (total 0x200000(2MB) * {:d} pages) ".format(extent["num_pages"])
                text += "next:{:<#14x}".format(extent["next"])
                gef_print(text)
                current = extent["next"]
        except:
            err("Corrupted?")
        return

    def print_direct_map_list(self, head):
        try:
            current = head
            while current:
                direct_map, _ = self.read_direct_map(current)
                text = "    -> direct_map @{:<#14x}: ".format(direct_map["addr"])
                text += "next_extent:{:<#14x} ".format(direct_map["next_extent"])
                text += "prev_extent:{:<#14x} ".format(direct_map["prev_extent"])
                text += "bucket:{:<#14x} ".format(direct_map["bucket"])
                text += "map_size:{:#x}".format(direct_map["map_size"])
                gef_print(text)
                bucket, _ = self.read_bucket(direct_map["bucket"])
                self.print_bucket(bucket)
                current = direct_map["next_extent"]
        except:
            err("Corrupted?")
        return

    def print_bucket(self, bucket, idx = None):
        skip_pages = self.get_sentinel_pages()

        slot_size = Color.colorify("{:#7x}".format(bucket["slot_size"]), "bold pink")
        if idx is not None:
            text = "    buckets[{:3d}](slot_size:{:s}) @{:<#14x}: ".format(idx, slot_size, bucket["addr"])
        else:
            text = "    bucket(slot_size:{:s}) @{:<#14x}: ".format(slot_size, bucket["addr"])
        text += "num_system_pages_per_slot_span:{:<#4x} ".format(bucket["num_system_pages_per_slot_span"])
        text += "num_full_pages:{:#x}".format(bucket["num_full_pages"])
        gef_print(text)

        if self.verbose:
            target_list = ["active_pages_head", "empty_pages_head", "decommitted_pages_head"]
        else:
            target_list = ["active_pages_head"]

        for key in target_list:
            head = bucket[key]
            if not self.verbose and (head in skip_pages + [0x0]):
                continue
            if head in skip_pages:
                gef_print("        {:s}:sentinel_pages".format(Color.colorify(key, "bold cyan underline")))
            else:
                gef_print("        {:s}:{:<#14x}".format(Color.colorify(key, "bold cyan underline"), head))
            self.print_pages(head, bucket)
        return

    def print_pages(self, head, bucket):
        current = head
        while current:
            try:
                page, _ = self.read_page(current)
            except:
                err("Corrupted?")
                break
            text_fmt = "            -> page @{:<#14x} (#{:3d} of super_page @{:<#14x}): "
            text = text_fmt.format(page["addr"], page["partition_page_index"], page["super_page_addr"])
            text += "next_page:{:<#14x} ".format(page["next_page"])
            page_start = page["partition_page_start"]
            page_end = page["partition_page_start"] + bucket["num_system_pages_per_slot_span"] * DEFAULT_PAGE_SIZE
            text += "page_area:{:#x}-{:#x} ".format(page_start, page_end)
            text += "num_allocated_slots:{:#x}".format(page["num_allocated_slots"])
            gef_print(text)
            self.print_freelist(page["freelist_head"], bucket, page)
            current = page["next_page"]
        return

    def print_freelist(self, head, bucket, page):
        gef_print("                freelist_head:{:<#14x} ".format(head))

        slot_size = bucket["slot_size"]
        page_start = page["partition_page_start"]
        page_end = page["partition_page_start"] + bucket["num_system_pages_per_slot_span"] * DEFAULT_PAGE_SIZE

        text = ""
        cnt = 0
        chunk = head
        seen = []
        while chunk:
            if cnt % 7 == 0:
                if cnt > 0:
                    text += "\n"
                text += " "*20

            if chunk in seen:
                text += Color.colorify("-> {:<#14x} (loop) ".format(chunk), "red bold")
                break

            if not ((page_start <= chunk < page_end) and ((chunk - page_start) % slot_size == 0)):
                text += Color.colorify("-> {:<#14x} (corrupted) ".format(chunk), "red bold")
                break

            try:
                next_chunk = self.byteswap(read_int_from_memory(chunk))
            except:
                text += Color.colorify("-> {:<#14x} (corrupted) ".format(chunk), "red bold")
                break

            text += "-> " + Color.colorify("{:<#14x} ".format(chunk), "yellow bold")
            cnt += 1
            seen.append(chunk)
            chunk = next_chunk

        if cnt > 0:
            text += "(num: {:#x})".format(cnt)

        if text:
            gef_print(text)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if not is_x86_64():
            err("Unsupported")
            return

        if "-h" in argv:
            self.usage()
            return

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        if len(argv) != 1:
            self.usage()
            return

        if not argv[0] in ["fast_malloc", "fm", "array_buffer", "ab", "buffer", "b", "layout", "l", "all"]:
            self.usage()
            return
        target = argv[0]

        for name, addr in self.get_roots():
            if target == "all":
                root, _ = self.read_root(addr, name)
                self.print_root(root)
            elif target in ["fast_malloc", "fm"] and name == "fast_malloc_root_":
                root, _ = self.read_root(addr, name)
                self.print_root(root)
            elif target in ["array_buffer", "ab"] and name == "array_buffer_root_":
                root, _ = self.read_root(addr, name)
                self.print_root(root)
            elif target in ["buffer", "b"] and name == "buffer_root_":
                root, _ = self.read_root(addr, name)
                self.print_root(root)
            elif target in ["layout", "l"] and name == "layout_root_":
                root, _ = self.read_root(addr, name)
                self.print_root(root)
        return


@register_command
class MuslDumpCommand(GenericCommand):
    """musl heap reusable chunks viewer (supported on x64/x86, based on musl libc v1.2.2; src/malloc/mallocng).
    See https://h-noson.hatenablog.jp/entry/2021/05/03/161933#-177pts-mooosl"""
    _cmdline_ = "musl-dump"
    _syntax_ = "{:s} ctx|unused [-v] [-a ACTIVE_IDX]".format(_cmdline_)
    _category_ = "Heap"

    def get_malloc_context_heuristic(self):
        try:
            # search malloc
            malloc = parse_address("malloc")
            info("malloc: {:#x}".format(malloc))

            # search __libc_malloc_impl
            """
            [pattern 1]
               0x7ffff7d7dde0 <malloc>:     jmp    0x7ffff7d8ece2 <__libc_malloc_impl>

            [pattern 2]
               0x7ffff7f71650 <malloc>:     endbr64
               0x7ffff7f71654 <malloc+4>:   jmp    0x7ffff7f72ff0

            [pattern 3]
               0xf7f78bf0 <malloc>: jmp    0xf7f8bc3c
            """
            res = gdb.execute("x/10i {:#x}".format(malloc), to_string=True)
            for line in res.splitlines():
                m = re.search(r"jmp\s*(0x\w+)", line)
                if not m:
                    continue
                __libc_malloc_impl = int(m.group(1), 16)
                break
            info("__libc_malloc_impl: {:#x}".format(__libc_malloc_impl))

            # search __malloc_alloc_meta
            """
            [pattern 1]
               0x7ffff7d8ed0a <__libc_malloc_impl+40>:      call   0x7ffff7d88dc1 <__errno_location>
               0x7ffff7d8ed34 <__libc_malloc_impl+82>:      call   0x7ffff7da0c3b <mmap64>
               0x7ffff7d8ed48 <__libc_malloc_impl+102>:     call   0x7ffff7d8e36b <wrlock>
               0x7ffff7d8ed4d <__libc_malloc_impl+107>:     call   0x7ffff7d8e382 <step_seq>
               0x7ffff7d8ed52 <__libc_malloc_impl+112>:     call   0x7ffff7d8e45a <__malloc_alloc_meta>

            [pattern 2]
               0x7ffff7f7303b:      call   0x7ffff7f8a640 <mmap64>
               0x7ffff7f73074:      call   0x7ffff7f72290

            [pattern 3]
               0xf7f8bc40:  call   0xf7f7cf84
               0xf7f8bc67:  call   0xf7f84e85 <__errno_location>
               0xf7f8bc88:  call   0xf7f9cd53 <mmap64>
               0xf7f8bc9b:  call   0xf7f8b3aa
               0xf7f8bca0:  call   0xf7f8b3d2
               0xf7f8bca5:  call   0xf7f8b439
            """
            __malloc_alloc_meta_candidate = []
            res = gdb.execute("x/100i {:#x}".format(__libc_malloc_impl), to_string=True)
            for line in res.splitlines():
                m = re.search(r"call\s*(0x\w+)", line)
                if not m:
                    continue
                addr = int(m.group(1), 16)
                __malloc_alloc_meta_candidate.append(addr)

            # search __malloc_context
            """
            [patttern 1]
               0x7ffff7d8e45a <__malloc_alloc_meta>:        push   r12
               0x7ffff7d8e45c <__malloc_alloc_meta+2>:      push   rbp
               0x7ffff7d8e45d <__malloc_alloc_meta+3>:      push   rbx
               0x7ffff7d8e45e <__malloc_alloc_meta+4>:      sub    rsp,0x10
               0x7ffff7d8e462 <__malloc_alloc_meta+8>:      cmp    DWORD PTR [rip+0x26d67f],0x0        # 0x7ffff7ffbae8 <__malloc_context+8>

            [patttern 2]
               0x7ffff7f72290:      endbr64
               0x7ffff7f72294:      push   r12
               0x7ffff7f72296:      push   rbp
               0x7ffff7f72297:      push   rbx
               0x7ffff7f72298:      sub    rsp,0x10
               0x7ffff7f7229c:      mov    rax,QWORD PTR fs:0x28
               0x7ffff7f722a5:      mov    QWORD PTR [rsp+0x8],rax
               0x7ffff7f722aa:      xor    eax,eax
               0x7ffff7f722ac:      mov    eax,DWORD PTR [rip+0x89816]        # 0x7ffff7ffbac8
               0x7ffff7f722b2:      test   eax,eax

            [pattern 3]
               0xf7f8b439:  push   ebp
               0xf7f8b43a:  push   edi
               0xf7f8b43b:  push   esi
               0xf7f8b43c:  push   ebx
               0xf7f8b43d:  call   0xf7f7cf84
               0xf7f8b442:  add    ebx,0x6fbbe       # libc_bss_base
               0xf7f8b448:  sub    esp,0x1c
               0xf7f8b44b:  cmp    DWORD PTR [ebx+0x708],0x0
            """
            for cand in __malloc_alloc_meta_candidate:
                info("alloc_meta (candidate): {:#x}".format(cand))
                res = gdb.execute("x/10i {:#x}".format(cand), to_string=True)
                for line in res.splitlines():
                    if is_x86_64():
                        m = re.search(r"DWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                        if not m:
                            continue
                        __malloc_context_init_done = int(m.group(1), 16)
                    else:
                        m = re.search(r"DWORD PTR \[e[abcd]x\+(0x\w+)\]", line)
                        if not m:
                            continue
                        __malloc_context_init_done_offset = int(m.group(1), 16)
                        rw_maps = [p for p in get_process_maps() if p.permission.value == Permission.READ | Permission.WRITE]
                        rw_maps = [p for p in rw_maps if "libc.so" in p.path]
                        libc_bss_base = rw_maps[0].page_start
                        __malloc_context_init_done = libc_bss_base + __malloc_context_init_done_offset
                    # check
                    value = u32(read_memory(__malloc_context_init_done, 4))
                    if value not in [0, 1]: # init_done is 1 or 0
                        continue
                    # found
                    info("__malloc_context.init_done: {:#x}".format(__malloc_context_init_done))
                    __malloc_context = __malloc_context_init_done - current_arch.ptrsize
                    x = read_int_from_memory(__malloc_context)
                    if x == gef_getpagesize():
                        __malloc_context -= current_arch.ptrsize
                    info("__malloc_context: {:#x}".format(__malloc_context))
                    return __malloc_context
            return None
        except:
            err("Not found &__malloc_context")
            return None

    def get_malloc_context(self):
        try:
            return parse_address("&__malloc_context")
        except:
            info("Symbol is not found. It will use heuristic search")
            return self.get_malloc_context_heuristic()

    @lru_cache()
    def class_to_size(self, cl):
        class_to_size_list = [
            1, 2, 3, 4, 5, 6, 7, 8,
            9, 10, 12, 15,
            18, 20, 25, 31,
            36, 42, 50, 63,
            72, 84, 102, 127,
            146, 170, 204, 255,
            292, 340, 409, 511,
            584, 682, 818, 1023,
            1169, 1364, 1637, 2047,
            2340, 2730, 3276, 4095,
            4680, 5460, 6552, 8191,
        ]
        assert cl < len(class_to_size_list)
        return class_to_size_list[cl] * 0x10

    def read_ctx(self):
        ptrsize = current_arch.ptrsize
        ctx = {}
        ctx["addr"] = current = self.get_malloc_context()
        if current is None:
            return None
        """
        struct malloc_context {
            uint64_t secret;
        #ifndef PAGESIZE
            size_t pagesize;
        #endif
            int init_done;
            unsigned mmap_counter;
            struct meta *free_meta_head;
            struct meta *avail_meta;
            size_t avail_meta_count;
            size_t avail_meta_area_count;
            size_t meta_alloc_shift;
            struct meta_area *meta_area_head;
            struct meta_area *meta_area_tail;
            unsigned char *avail_meta_areas;
            struct meta *active[48];
            size_t usage_by_class[48];
            uint8_t unmap_seq[32];
            uint8_t bounces[32];
            uint8_t seq;
            uintptr_t brk;
        };
        """
        ctx["secret"] = u64(read_memory(current, 8))
        current += 8
        x = read_int_from_memory(current)
        if x == gef_getpagesize():
            ctx["pagesize"] = x
            current += ptrsize
        else:
            ctx["pagesize"] = None

        ctx["init_done"] = u32(read_memory(current, 4))
        current += 4
        ctx["mmap_counter"] = u32(read_memory(current, 4))
        current += 4
        ctx["free_meta_head"] = read_int_from_memory(current)
        current += ptrsize
        ctx["avail_meta"] = read_int_from_memory(current)
        current += ptrsize
        ctx["avail_meta_count"] = read_int_from_memory(current)
        current += ptrsize
        ctx["avail_meta_area_count"] = read_int_from_memory(current)
        current += ptrsize
        ctx["alloc_shift"] = read_int_from_memory(current)
        current += ptrsize
        ctx["meta_area_head"] = read_int_from_memory(current)
        current += ptrsize
        ctx["meta_area_tail"] = read_int_from_memory(current)
        current += ptrsize
        ctx["avail_meta_areas"] = read_int_from_memory(current)
        current += ptrsize
        ctx["active"] = []
        for i in range(48):
            ctx["active"].append(read_int_from_memory(current))
            current += ptrsize
        ctx["usage_by_class"] = []
        for i in range(48):
            ctx["usage_by_class"].append(read_int_from_memory(current))
            current += ptrsize
        ctx["unmap_seq"] = read_memory(current, 32)
        current += 32
        ctx["bounces"] = read_memory(current, 32)
        current += 32
        ctx["seq"] = ord(read_memory(current, 1))
        current += ptrsize # with padding
        ctx["brk"] = read_int_from_memory(current)
        current += ptrsize
        return ctx

    def print_ctx(self, ctx):
        gef_print(titlify("__malloc_context: {:#x}".format(ctx["addr"])))
        gef_print("  uint64_t secret:                    {:#x}".format(ctx["secret"]))
        if ctx["pagesize"]:
            gef_print("  size_t pagesize:                    {:#x}".format(ctx["pagesize"]))
        gef_print("  int init_done:                      {:#x}".format(ctx["init_done"]))
        gef_print("  unsigned int mmap_counter:          {:#x}".format(ctx["mmap_counter"]))
        gef_print("  struct meta* free_meta_head:        {:#x}".format(ctx["free_meta_head"]))
        gef_print("  struct meta* avail_meta:            {:#x}".format(ctx["avail_meta"]))
        gef_print("  size_t avail_meta_count:            {:#x}".format(ctx["avail_meta_count"]))
        gef_print("  size_t avail_meta_area_count:       {:#x}".format(ctx["avail_meta_area_count"]))
        gef_print("  size_t alloc_shift:                 {:#x}".format(ctx["alloc_shift"]))
        gef_print("  struct meta_area* meta_area_head:   {:#x}".format(ctx["meta_area_head"]))
        gef_print("  struct meta_area* meta_area_tail:   {:#x}".format(ctx["meta_area_tail"]))
        gef_print("  unsigned char* avail_meta_areas:    {:#x}".format(ctx["avail_meta_areas"]))
        gef_print("  struct meta* active[48]:")
        for i in range(48):
            gef_print("     active[{:2d}] (for chunk_size={:#7x}):     {:#x}".format(i, self.class_to_size(i), ctx["active"][i]))
        gef_print("  size_t usage_by_class[48]:")
        for i in range(48):
            gef_print("     usage_by_class[{:2d}]:                     {:#x}".format(i, ctx["usage_by_class"][i]))
        gef_print("  uint8_t unmap_seq[32]:              {}".format(' '.join(["%02x" % x for x in ctx["unmap_seq"]])))
        gef_print("  uint8_t bounces[32]:                {}".format(' '.join(["%02x" % x for x in ctx["bounces"]])))
        gef_print("  uint8_t seq:                        {:#x}".format(ctx["seq"]))
        gef_print("  uintptr_t brk:                      {:#x}".format(ctx["brk"]))
        return

    def read_meta(self, addr):
        ptrsize = current_arch.ptrsize
        meta = {}
        meta["addr"] = current = addr
        """
        struct meta {
            struct meta *prev;
            struct meta *next;
            struct group *mem;
            volatile int avail_mask;
            volatile int freed_mask;
            uintptr_t last_idx:5;
            uintptr_t freeable:1;
            uintptr_t sizeclass:6;
            uintptr_t maplen:8*sizeof(uintptr_t)-12;
        };
        """
        meta["prev"] = read_int_from_memory(current)
        current += ptrsize
        meta["next"] = read_int_from_memory(current)
        current += ptrsize
        meta["mem"] = read_int_from_memory(current)
        current += ptrsize
        meta["avail_mask"] = u32(read_memory(current, 4))
        current += 4
        meta["freed_mask"] = u32(read_memory(current, 4))
        current += 4
        x = read_int_from_memory(current)
        meta["last_idx"] = x & 0b11111
        meta["freeable"] = (x >> 5) & 0b1
        meta["sizeclass"] = (x >> 6) & 0b111111
        meta["maplen"] = (x >> 12)
        current += ptrsize
        return meta

    def make_state(self, meta):
        avail_mask = meta["avail_mask"]
        freed_mask = meta["freed_mask"]
        last_idx = meta["last_idx"]

        mask = avail_mask | freed_mask
        text = ""
        for i in range(last_idx+1):
            if avail_mask & 1:
                text = "A" + text
            elif freed_mask & 1:
                text = "F" + text
            else:
                text = "U" + text
            avail_mask >>= 1
            freed_mask >>= 1
            mask = avail_mask | freed_mask
        return text

    def read_group(self, meta, offset):
        ptrsize = current_arch.ptrsize
        group = {}
        group["addr"] = current = meta["mem"] + offset
        group["data"] = read_memory(group["addr"], self.class_to_size(meta["sizeclass"]))
        """
        from source code:
        struct group {
            struct meta *meta;
            unsigned char active_idx:5;
            char pad[UNIT - sizeof(struct meta *) - 1]; // UNIT = 16
            unsigned char storage[];
        };

        however, the actual usage is as follows. (x64)
        struct group {
            struct meta *meta;
            unsigned int slot_offset32;
            unsigned char is_slot_offset32;
            unsigned char slot_index:5;
            unsigned char reserved:3;
            unsigned short slot_offset16;
        }
        """
        group["meta"] = read_int_from_memory(current)
        current += ptrsize
        x = u32(read_memory(current, 4))
        current += 4 if is_x86_64() else 8
        y = u32(read_memory(current, 4))
        group["reserved"] = (x >> 13) & 0b111
        group["slot_idx"] = (y >> 8) & 0b11111
        if y & 0xff:
            group["slot_offset"] = x
        else:
            group["slot_offset"] = (y >> 16) & 0xffff
        current += ptrsize
        return group

    def dump_chunk(self, group, state):
        ptrsize = current_arch.ptrsize

        subinfo = "state:{:5s} meta:{:<#14x} reserved:{:#x}".format(state, group["meta"], group["reserved"])
        if state == "Used":
            subinfo += " slot_idx:{:<#3x} slot_offset:{:#x}".format(group["slot_idx"], group["slot_offset"])

        slicer = lambda data, n: [data[i:i+n] for i in range(0, len(data), n)]
        data = slicer(group["data"], ptrsize*2)
        addr = group["addr"]
        group_line_threshold = 8

        # create dump text
        unpack = u32 if ptrsize == 4 else u64
        width = ptrsize*2 + 2
        dump = ""
        done = False
        for blk, blks in itertools.groupby(data):
            repeat_count = len(list(blks))
            d1, d2 = unpack(blk[:ptrsize]), unpack(blk[ptrsize:])
            dascii = ''.join(list(map(lambda x: chr(x) if 0x20<=x<0x7f else '.', list(blk))))
            if repeat_count < group_line_threshold:
                for i in range(repeat_count):
                    dump += f"{addr:#x}: {d1:#0{width:d}x} {d2:#0{width:d}x} | {dascii:s} | " + subinfo + "\n"
                    addr += ptrsize*2
                    if subinfo:
                        subinfo = ""
            else:
                dump += f"{addr:#x}: {d1:#0{width:d}x} {d2:#0{width:d}x} | {dascii:s} | " + subinfo + "\n"
                dump += "* {:#d} lines, {:#x} bytes \n".format(repeat_count-1, (repeat_count-1)*ptrsize*2)
                addr += ptrsize*2*repeat_count
                if subinfo:
                    subinfo = ""
            if done:
                break

        # print
        dump = dump.rstrip()
        if state == "Used":
            gef_print(dump)
        else:
            gef_print(Color.grayify(dump))
        return

    def print_meta(self, ctx):
        gef_print(Color.colorify("Legend for `Unused chunks list`: A:Avail F:Freed U:Used", "yellow"))
        gef_print(Color.colorify("  1. Search most right 'A' and return it", "yellow"))
        gef_print(Color.colorify("  2. Search most right 'F' and return it", "yellow"))
        gef_print(Color.colorify("  3. If nothing is found, create new meta", "yellow"))

        # iterate __malloc_context.active
        for idx in range(48):
            if self.active_idx and idx != self.active_idx:
                continue
            current = ctx["active"][idx]
            if current == 0:
                continue

            gef_print(titlify("active[{:2d}] (chunk_size={:#x})".format(idx, self.class_to_size(idx))))

            # iterate list of meta
            seen = []
            while current not in seen:
                meta = self.read_meta(current)
                gef_print("meta @ {:#x}".format(meta["addr"]))
                text = "  "
                text += "prev:{:#x} next:{:#x} ".format(meta["prev"], meta["next"])
                text += Color.colorify("mem:{:#x} ".format(meta["mem"]), "bold cyan")
                text += "avail_mask:{:#x} freed_mask:{:#x} ".format(meta["avail_mask"], meta["freed_mask"])
                text += "last_idx:{:#x} freeable:{:#x} ".format(meta["last_idx"], meta["freeable"])
                text += "sizeclass:{:#x} maplen:{:#x}".format(meta["sizeclass"], meta["maplen"])
                gef_print(text)

                state = self.make_state(meta)
                gef_print("  Unused chunks list: {}".format(repr(state)))

                # dump chunks
                if self.verbose:
                    dic = {"A": "Avail", "F": "Freed", "U": "Used"}
                    for i in range(meta["last_idx"] + 1):
                        offset = self.class_to_size(idx) * i
                        group = self.read_group(meta, offset)
                        self.dump_chunk(group, dic[state[-i-1]])
                    gef_print("")

                seen.append(current)
                current = meta["next"]
        return

    @only_if_gdb_running
    @only_if_x86_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        self.active_idx = False
        while "-a" in argv:
            idx = argv.index("-a")
            self.active_idx = int(argv[idx + 1])
            argv = argv[:idx] + argv[idx+2:]

        if not argv:
            self.usage()
            return

        ctx = self.read_ctx()
        if ctx is None:
            return
        if argv[0] == "ctx":
            self.print_ctx(ctx)
        elif argv[0] == "unused":
            self.print_meta(ctx)
        return


@register_command
class XphysAddrCommand(GenericCommand):
    """Dump physical memory via qemu-monitor."""
    _cmdline_ = "xp"
    _syntax_ = "{:s} [-h] [OPTION] ADDRESS".format(_cmdline_)
    _example_ = "{:s} /16xg 0x11223344".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def dump_physmem(self, argv):
        result = gdb.execute("monitor xp {:s}".format(' '.join(argv)), to_string=True)
        gef_print(result.strip())
        return

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        if "-h" in argv:
            self.usage()
            return
        self.dump_physmem(argv)
        return


@register_command
class XSecureMemAddrCommand(GenericCommand):
    """Dump secure memory via qemu-system memory map."""
    _cmdline_ = "xsm"
    _syntax_ = "{:s} [-h] [-v] /FMT --phys|--off|--virt ADDRESS".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} /16xw --phys 0xe11e3d0 # absolute (physical/non-ASLR) address of secure memory\n".format(_cmdline_)
    _example_ += "{:s} /16xw --off 0x11e3d0 # the offset from secure memory area\n".format(_cmdline_)
    _example_ += "{:s} /16xw --virt 0x783ae3d0 # secure memory ASLR is supported".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @staticmethod
    def get_secure_memory_base_and_size(verbose=False):
        result = gdb.execute("monitor info mtree -f", to_string=True)
        for line in result.splitlines():
            m = re.search(r"([0-9a-f]{16})-([0-9a-f]{16}).*virt.secure-ram", line)
            if m:
                secure_memory_base = int(m.group(1), 16)
                secure_memory_size = int(m.group(2), 16) + 1 - secure_memory_base
                break
        else:
            return None, None
        if verbose:
            start = secure_memory_base
            end = secure_memory_base + secure_memory_size
            info("secure memory base: {:#x}-{:#x} ({:#x} bytes)".format(start, end, secure_memory_size))
        return secure_memory_base, secure_memory_size

    @staticmethod
    def get_secure_memory_qemu_map(secure_memory_base, secure_memory_size, verbose=False):
        qemu_system_pid = get_pid()
        if qemu_system_pid is None:
            err("Not found qemu-system pid")
            return None
        # fast path
        ret = gdb.execute("monitor gpa2hva {:#x}".format(secure_memory_base), to_string=True)
        r = re.search("is (0x[0-9a-f]+)", ret)
        if r:
            secure_memory_page_addr = int(r.group(1), 16)
            sm = process_lookup_address(secure_memory_page_addr)
            if sm:
                if verbose:
                    info("secure memory page of pid {:d}: {:#x}".format(qemu_system_pid, secure_memory_page_addr))
                return sm

        # slow path
        maps = list(get_process_maps_linux("/proc/{:d}/maps".format(qemu_system_pid)))
        secure_memory_maps = [m for m in maps if m.size == secure_memory_size]
        if len(secure_memory_maps) == 1:
            if verbose:
                secure_memory_page_addr = secure_memory_maps[0].page_start
                info("secure memory page of pid {:d}: {:#x}".format(qemu_system_pid, secure_memory_page_addr))
            return secure_memory_maps[0]
        return None

    @staticmethod
    def virt2phys(vaddr, verbose=False): # vaddr -> addr1 or None
        maps = V2PCommand.get_maps(FORCE_PREFIX_S=True, verbose=verbose)
        if maps is None:
            return None
        for vstart, vend, pstart, pend in maps:
            if vstart <= vaddr < vend:
                offset = vaddr - vstart
                paddr = pstart + offset
                if verbose:
                    info("virt2phys: {:#x} -> {:#x}".format(vaddr, paddr))
                return paddr
        return None

    @staticmethod
    def phys2virt(paddr, verbose=False): # paddr -> [addr1, addr2, ...] or []
        maps = V2PCommand.get_maps(FORCE_PREFIX_S=True, verbose=verbose)
        if maps is None:
            return []
        result = []
        for vstart, vend, pstart, pend in maps:
            if pstart <= paddr < pend:
                offset = paddr - pstart
                vaddr = vstart + offset
                if verbose:
                    info("phys2virt: {:#x} -> {:#x}".format(paddr, vaddr))
                result.append(vaddr)
        return result

    @staticmethod
    def read_secure_memory(sm, offset, dump_size, verbose=False):
        qemu_system_pid = get_pid()
        if qemu_system_pid is None:
            err("Not found qemu-system pid")
            return None

        if dump_size > sm.size:
            dump_size = sm.size

        if verbose:
            info("target offset: {:#x}".format(offset))
            info("read address: {:#x}, size:{:#x}".format(sm.page_start + offset, dump_size))

        with open("/proc/{:d}/mem".format(qemu_system_pid), "rb") as fd:
            try:
                fd.seek(sm.page_start + offset, 0)
                data = fd.read(dump_size)
            except:
                return None
        if verbose:
            info("read size result: {:#x}".format(len(data)))
        return data

    def print_secure_memory_x(self, target, data):
        slicer = lambda data, n: [data[i:i+n] for i in range(0, len(data), n)]
        for i, data16 in enumerate(slicer(data, 16)):
            addr = int(target) + i * 0x10
            data_units = slicer(data16, self.dump_unit)
            if self.dump_unit == 1:
                data_units_hex = ["{:#04x}".format(ord(x)) for x in data_units]
            elif self.dump_unit == 2:
                data_units_hex = ["{:#06x}".format(u16(x)) for x in data_units]
            elif self.dump_unit == 4:
                data_units_hex = ["{:#010x}".format(u32(x)) for x in data_units]
            elif self.dump_unit == 8:
                data_units_hex = ["{:#018x}".format(u64(x)) for x in data_units]
            gef_print("{:#018x}: {:s}".format(addr, ' '.join(data_units_hex)))
        return

    def print_secure_memory_i(self, target, data):
        kwargs = {}
        kwargs["code"] = data.hex()
        if is_arm32():
            kwargs["arch"] = "ARM"
            if target & 1:
                kwargs["mode"] = "THUMB"
            else:
                kwargs["mode"] = "ARM"
        elif is_arm64():
            kwargs["arch"] = "ARM64"
            kwargs["mode"] = "ARM"

        try:
            for insn in capstone_disassemble(target, self.dump_count, **kwargs):
                insn_fmt = "{:12o}"
                text_insn = insn_fmt.format(insn)
                msg = "{} {}".format(" "*5, text_insn)
                gef_print(msg)
        except gdb.error:
            pass
        return

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        # arg parse
        if "-h" in argv:
            self.usage()
            return

        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        self.dump_type = "x"
        self.dump_unit = current_arch.ptrsize
        self.dump_count = 1
        if argv and argv[0].startswith("/"):
            m = re.search(r"/(\d*)(\S*)", argv[0])
            if m:
                if m.group(1):
                    self.dump_count = int(m.group(1))
                for c in m.group(2):
                    if c in ["x", "i"]:
                        self.dump_type = c
                    elif c in ["b", "h", "w", "g"]:
                        self.dump_unit = {"b":1, "h":2, "w":4, "g":8}[c]
                    else:
                        err("Unsupported format: {}".format(c))
                        return
            argv = argv[1:]

        if argv and argv[0] in ["--phys", "--off", "--virt"]:
            addr_type = argv[0]
            argv = argv[1:]
        else:
            self.usage()
            return

        try:
            target = int(gdb.parse_and_eval(''.join(argv)))
        except:
            self.usage()
            return

        # initialize
        sm_base, sm_size = self.get_secure_memory_base_and_size(verbose)
        if sm_base is None or sm_size is None:
            err("Not found memory tree of secure memory (see monitor info mtree -f)")
            return
        sm = self.get_secure_memory_qemu_map(sm_base, sm_size, verbose)
        if sm is None:
            err("Not found secure memory maps")
            return

        # dump
        if addr_type == "--phys":
            if sm_base <= target < sm_base + sm_size:
                target_offset = target - sm_base
            else:
                err("Phys {:#x} is not default secure memory (unsupported)".format(target))
                return
        elif addr_type == "--off":
            if 0 <= target < sm_size:
                target_offset = target
            else:
                err("Offset {:#x} is not default secure memory (unsupported)".format(target))
                return
        elif addr_type == "--virt":
            target_phys = self.virt2phys(target, verbose)
            if target_phys is None:
                err("Not found physical address")
                return
            if sm_base <= target_phys < sm_base + sm_size:
                target_offset = target_phys - sm_base
            else:
                err("Virt {:#x} is not default secure memory (unsupported)".format(target))
                return

        if self.dump_type == "x":
            dump_size = self.dump_count * self.dump_unit
        elif self.dump_type == "i":
            dump_size = self.dump_count * 4 # ARM opcode is at most 4byte
            if target_offset & 1:
                target_offset -= 1
        data = self.read_secure_memory(sm, target_offset, dump_size, verbose)
        if data is None:
            err("Read error")
            return

        # print
        if self.dump_type == "x":
            self.print_secure_memory_x(target, data)
        elif self.dump_type == "i":
            self.print_secure_memory_i(target, data)
        return


# The wsm command directly modifies /proc/<PID>/mem of qemu-system.
# However, even though the memory change was successful, it may not be reflected in the behavior of the code.
# I don't know the cause, but I'm guessing it's because qemu has an internal cache.
# Apparently setting a breakpoint ignores this cache, so setting a temporary breakpoint avoids this problem.
class TemporaryDummyBreakpoint(gdb.Breakpoint):
    """Create a breakpoint to avoid gdb cache problem"""
    def __init__(self):
        super().__init__("*{:#x}".format(0x0), type=gdb.BP_BREAKPOINT, internal=True, temporary=True)
        return

    def stop(self):
        return False


@register_command
class WSecureMemAddrCommand(GenericCommand):
    """Write secure memory via qemu-system memory map."""
    _cmdline_ = "wsm"
    _syntax_ = "{:s} [-h] [-v] -b byte|short|dword|qword|string|hex VALUE --phys|--off|--virt ADDRESS".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} -b dword 0x41414141 --phys 0xe11e3d0 # absolute (physical/non-ASLR) address of secure memory\n".format(_cmdline_)
    _example_ += "{:s} -b string \"\\\\x41\\\\x41\\\\x41\\\\x41\" --off 0x11e3d0 # the offset of secure memory\n".format(_cmdline_)
    _example_ += "{:s} -b hex \"4141 4141\" --off 0x11e3d0 # hex string is supported (invalid character is ignored)\n".format(_cmdline_)
    _example_ += "{:s} -b byte 0x41 --virt 0x783ae3d0 # secure memory ASLR is supported".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @staticmethod
    def write_secure_memory(sm, offset, data, verbose=False):
        qemu_system_pid = get_pid()
        if qemu_system_pid is None:
            return None

        write_size = len(data)
        if write_size > sm.size:
            write_size = sm.size
            data = data[:write_size]

        if verbose:
            info("target offset: {:#x}".format(offset))
            info("write address: {:#x}, size:{:#x}".format(sm.page_start + offset, write_size))

        with open("/proc/{:d}/mem".format(qemu_system_pid), "r+b") as fd:
            try:
                fd.seek(sm.page_start + offset, 0)
                ret = fd.write(data)
            except:
                return None
        if verbose:
            info("written size result: {:#x}".format(ret))

        # avoid qemu-system caches
        TemporaryDummyBreakpoint()

        # By default, "context code" uses gdb_disassemble.
        # However, due to gdb's internal cache, changes to secure memory may not be reflected in the disassembled results.
        # Therefore, if capstone is available, change it to disassemble by capstone.
        if get_gef_setting("context.use_capstone") is False:
            set_gef_setting("context.use_capstone", True)
        return ret

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        # arg parse
        if "-h" in argv:
            self.usage()
            return

        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        if len(argv) >= 3 and argv[0] == "-b":
            try:
                if argv[1] == "byte":
                    data = p8(int(argv[2], 0))
                elif argv[1] == "short":
                    data = p16(int(argv[2], 0))
                elif argv[1] == "dword":
                    data = p32(int(argv[2], 0))
                elif argv[1] == "qword":
                    data = p64(int(argv[2], 0))
                elif argv[1] == "string":
                    try:
                        data = codecs.escape_decode(argv[2])[0]
                    except binascii.Error:
                        gef_print("Could not decode '\\xXX' encoded string \"{}\"".format(data))
                        return
                elif argv[1] == "hex":
                    _data = ""
                    for c in argv[2].lower():
                        if c in '0123456789abcdef':
                            _data += c
                    data = bytes.fromhex(_data)
                else:
                    self.usage()
                    return
                argv = argv[3:]
            except:
                self.usage()
                return

        if argv and argv[0] in ["--phys", "--off", "--virt"]:
            addr_type = argv[0]
            argv = argv[1:]
        else:
            self.usage()
            return

        try:
            target = int(gdb.parse_and_eval(''.join(argv)))
        except:
            self.usage()
            return

        # initialize
        sm_base, sm_size = XSecureMemAddrCommand.get_secure_memory_base_and_size(verbose)
        if sm_base is None or sm_size is None:
            err("Not found memory tree of secure memory (see monitor info mtree -f)")
            return
        sm = XSecureMemAddrCommand.get_secure_memory_qemu_map(sm_base, sm_size, verbose)
        if sm is None:
            err("Not found secure memory maps")
            return

        # write
        if addr_type == "--phys":
            if sm_base <= target < sm_base + sm_size:
                target_offset = target - sm_base
            else:
                err("Phys {:#x} is not default secure memory (unsupported)".format(target))
                return
        elif addr_type == "--off":
            if 0 <= target < sm_size:
                target_offset = target
            else:
                err("Offset {:#x} is not default secure memory (unsupported)".format(target))
                return
        elif addr_type == "--virt":
            target_phys = XSecureMemAddrCommand.virt2phys(target, verbose)
            if target_phys is None:
                err("Not found physical address")
                return
            if sm_base <= target_phys < sm_base + sm_size:
                target_offset = target_phys - sm_base
            else:
                err("Virt {:#x} is not default secure memory (unsupported)".format(target))
                return
        ret = self.write_secure_memory(sm, target_offset, data, verbose)
        if ret is None:
            err("Write error")
            return
        return


@register_command
class BreakSecureMemAddrCommand(GenericCommand):
    """Set a breakpoint in virtual memory by specifying the physical memory of the secure world."""
    _cmdline_ = "bsm"
    _syntax_ = "{:s} [-h] [-v] PHYS_ADDRESS".format(_cmdline_)
    _example_ = "{:s} 0xe1008d8".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        # arg parse
        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        try:
            phys_addr = parse_address(' '.join(argv))
            if verbose:
                info("phys address: {:#x}".format(phys_addr))
        except:
            self.usage()
            return

        virt_addrs = XSecureMemAddrCommand.phys2virt(phys_addr, verbose)

        for virt_addr in virt_addrs:
            gdb.execute("break *{:#x}".format(virt_addr))
        return


class OpteeThreadEnterUserModeBreakpoint(gdb.Breakpoint):
    """Create a breakpoint to thread_enter_user_mode"""
    def __init__(self, vaddr, ta_offset):
        super().__init__("*{:#x}".format(vaddr), type=gdb.BP_BREAKPOINT, internal=True)
        self.count = 0
        self.ta_offset = ta_offset
        return

    @staticmethod
    def get_ta_loaded_address():
        if is_arm32():
            res = get_maps_by_pagewalk("pagewalk -q -S")
            res = sorted(set(res.splitlines()))
            res = list(filter(lambda line: "PL0/R-X" in line, res))
        elif is_arm64():
            res = get_maps_by_pagewalk("pagewalk 1 -q")
            res = sorted(set(res.splitlines()))
            res = list(filter(lambda line: "EL0/R-X" in line, res))
        maps = []
        for line in res:
            vrange, prange, *_ = line.split()
            vstart, vend = [int(x, 16) for x in vrange.split("-")]
            pstart, pend = [int(x, 16) for x in prange.split("-")]
            maps.append((vstart, vend, pstart, pend))
        if len(maps) == 2:
            return maps[1]
        else:
            return None

    def stop(self):
        if self.count != 1:
            self.count += 1
            return False

        ta_address = self.get_ta_loaded_address()
        if ta_address is None:
            err("TA address is not found")
            self.enabled = False
            return False

        ta_vstart, ta_vend, _, _ = ta_address
        info("TA address: {:#x}".format(ta_vstart))

        ta_vsize = ta_vend - ta_vstart
        if self.ta_offset >= ta_vsize:
            err("TA offset {:#x} is greater than the size of TA R-X area ({:#x})".format(self.ta_offset, ta_vsize))
            self.enabled = False
            return False

        gdb.execute("break *{:#x}".format(ta_vstart + self.ta_offset))
        self.enabled = False
        return False


@register_command
class OpteeBreakTaAddrCommand(GenericCommand):
    """Set a breakpoint to OPTEE-TA."""
    _cmdline_ = "optee-break-ta"
    _syntax_ = "{:s} [-h] [-v] ADDR_thread_enter_user_mode TA_OFFSET\n".format(_cmdline_)
    _syntax_ += "  ADDR_thread_enter_user_mode: The physical address of `thread_enter_user_mode` at OPTEE-OS\n".format(_cmdline_)
    _syntax_ += "  TA_OFFSET:                   The breakpoint target offset of OPTEE-TA".format(_cmdline_)
    _example_ = "{:s} 0xe137c78 0x2784".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        # arg parse
        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        try:
            thread_enter_user_mode = phys_addr = parse_address(argv[0])
            if verbose:
                info("thread_enter_user_mode @ OPTEE-OS: {:#x}".format(thread_enter_user_mode))
            argv = argv[1:]
        except:
            self.usage()
            return

        try:
            ta_offset = parse_address(' '.join(argv))
            if verbose:
                info("breakpoint target offset of TA: {:#x}".format(ta_offset))
        except:
            self.usage()
            return

        thread_enter_user_mode_virt = XSecureMemAddrCommand.phys2virt(thread_enter_user_mode, verbose)

        for vaddr in thread_enter_user_mode_virt:
            OpteeThreadEnterUserModeBreakpoint(vaddr, ta_offset)
            info("Temporarily breakpoint at {:#x}".format(vaddr))
        return


@register_command
class OpteeBgetDumpCommand(GenericCommand):
    """Dump bget allocator of OPTEE-Trusted-App."""
    _cmdline_ = "optee-bget-dump"
    _syntax_ = "{:s} [-h] [-v] OFFSET_malloc_ctx\n".format(_cmdline_)
    _syntax_ += "  OFFSET_malloc_ctx:   The offset of `malloc_ctx` at OPTEE-TA".format(_cmdline_)
    _example_ = "{:s} 0x2a408\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "Simplified heap structure\n"
    _example_ += "+-malloc_ctx-------------------+         +-free-ed chunk----------+\n"
    _example_ += "| bufsize prevfree             |<--+ +-->| bufsize prevfree       |= 0 (if upper chunk is used)  +--> ...\n"
    _example_ += "| bufsize bsize                |   | |   | bufsize bsize          |= the size of this chunk      |\n"
    _example_ += "| struct bfhead *flink         |-----+   | struct bfhead *flink   |------------------------------+\n"
    _example_ += "| struct bfhead *blink         |   +-----| struct bfhead *blink   |\n"
    _example_ += "| (bufsize totalloc)           |         |                        |\n"
    _example_ += "| (long numget)                |         |                        |\n"
    _example_ += "| (long numrel)                |         |                        |\n"
    _example_ += "| (long numpblk)               |         +-used chunk-------------+\n"
    _example_ += "| (long numpget)               |         | bufsize prevfree       |= the size of upper chunk (if upper chunk is free-ed)"
    _example_ += "| (long numprel)               |         | bufsize bsize          |= the size of this chunk (negative number)\n"
    _example_ += "| (long numdget)               |         | uchar user_data[bsize] |\n"
    _example_ += "| (long numdrel)               |         |                        |\n"
    _example_ += "| (func_ptr compfcn)           |         |                        |\n"
    _example_ += "| (func_ptr acqfcn)            |         +------------------------+\n"
    _example_ += "| (func_ptr relfcn)            |\n"
    _example_ += "| (bufsize exp_incr)           |\n"
    _example_ += "| (bufsize pool_len)           |\n"
    _example_ += "| struct malloc_pool* pool     |\n"
    _example_ += "| size_t pool_len              |\n"
    _example_ += "| (struct malloc_stats mstats) |\n"
    _example_ += "+------------------------------+"
    _category_ = "Qemu-system Cooperation"

    def is_readable_virt_memory(self, addr):
        if is_arm32():
            res = get_maps_by_pagewalk("pagewalk -q -S")
            res = sorted(set(res.splitlines()))
            res = list(filter(lambda line: "PL0/RW-" in line, res))
        elif is_arm64():
            res = get_maps_by_pagewalk("pagewalk 1 -q")
            res = sorted(set(res.splitlines()))
            res = list(filter(lambda line: "EL0/RW-" in line, res))
        for line in res:
            vrange, prange, *_ = line.split()
            vstart, vend = [int(x, 16) for x in vrange.split("-")]
            pstart, pend = [int(x, 16) for x in prange.split("-")]
            if vstart <= addr < vend:
                return True
        return False

    def parse_flink(self, head):
        current = head
        flinks = []
        seen = [current]
        while True:
            try:
                prevfree = read_int_from_memory(current + current_arch.ptrsize*0)
                bsize = read_int_from_memory(current + current_arch.ptrsize*1)
                flink = read_int_from_memory(current + current_arch.ptrsize*2)
                blink = read_int_from_memory(current + current_arch.ptrsize*3)
                next_prevfree = read_int_from_memory(current + bsize)
                next_bsize = read_int_from_memory(current + bsize + current_arch.ptrsize)
            except:
                flinks.append("memory corrupted")
                break
            if flink % 8 or blink % 8 or bsize % 8 or next_prevfree % 8 or next_bsize % 8:
                flinks.append("unaligned corrupted")
                break
            flinks.append({"_addr": current, "prevfree":prevfree, "bsize":bsize, "flink":flink, "blink":blink,
                           "next_prevfree":next_prevfree, "next_bsize":next_bsize})
            if flink == head:
                break
            if flink in seen[1:]:
                flinks.append("loop detected")
                break
            seen.append(current)
            current = flink
        return flinks

    def parse_blink(self, head):
        current = head
        blinks = []
        seen = [current]
        while True:
            try:
                prevfree = read_int_from_memory(current + current_arch.ptrsize*0)
                bsize = read_int_from_memory(current + current_arch.ptrsize*1)
                flink = read_int_from_memory(current + current_arch.ptrsize*2)
                blink = read_int_from_memory(current + current_arch.ptrsize*3)
                next_prevfree = read_int_from_memory(current + bsize)
                next_bsize = read_int_from_memory(current + bsize + current_arch.ptrsize)
            except:
                blinks.append("memory corrupted")
                break
            if flink % 8 or blink % 8 or bsize % 8 or next_prevfree % 8 or next_bsize % 8:
                blinks.append("unaligned corrupted")
                break
            blinks.append({"_addr": current, "prevfree":prevfree, "bsize":bsize, "flink":flink, "blink":blink,
                           "next_prevfree":next_prevfree, "next_bsize":next_bsize})
            if blink == head:
                break
            if blink in seen[1:]:
                blinks.append("loop detected")
                break
            seen.append(current)
            current = blink
        return blinks

    def parse_malloc_ctx(self, malloc_ctx_addr):
        malloc_ctx = {}
        malloc_ctx["_addr"] = current = malloc_ctx_addr

        malloc_ctx["prevfree"] = read_int_from_memory(current)
        current += current_arch.ptrsize
        malloc_ctx["bsize"] = read_int_from_memory(current)
        current += current_arch.ptrsize
        malloc_ctx["flink"] = read_int_from_memory(current)
        malloc_ctx["flink_list"] = self.parse_flink(malloc_ctx["flink"])
        current += current_arch.ptrsize
        malloc_ctx["blink"] = read_int_from_memory(current)
        malloc_ctx["blink_list"] = self.parse_blink(malloc_ctx["blink"])
        current += current_arch.ptrsize

        # search pool
        for i in range(14):
            pool_candidate = read_int_from_memory(current)
            current += current_arch.ptrsize
            if self.is_readable_virt_memory(pool_candidate):
                malloc_ctx["pool"] = pool_candidate
                break
        else:
            err("Not found malloc_ctx->pool")
            return None

        malloc_ctx["pool_len"] = read_int_from_memory(current)
        current += current_arch.ptrsize

        malloc_ctx["pool_list"] = []
        for i in range(malloc_ctx["pool_len"]):
            buf = read_int_from_memory(malloc_ctx["pool"] + (i*2)*current_arch.ptrsize)
            size = read_int_from_memory(malloc_ctx["pool"] + (i*2+1)*current_arch.ptrsize)
            malloc_ctx["pool_list"].append({"buf": buf, "len":size})

        return malloc_ctx

    def print_malloc_ctx(self, malloc_ctx):
        gef_print(titlify("malloc_ctx @ {:#x}".format(malloc_ctx["_addr"])))
        gef_print("prevfree: {:#x}".format(malloc_ctx["prevfree"]))
        gef_print("bsize:    {:#x}".format(malloc_ctx["bsize"]))
        gef_print("flink:    {:#x}".format(malloc_ctx["flink"]))
        for chunk in malloc_ctx["flink_list"]:
            if isinstance(chunk, str):
                gef_print("  -> {:s}".format(Color.colorify(chunk, "red bold")))
            else:
                chunk_addr = Color.colorify("{:#010x}".format(chunk["_addr"]), "yellow bold")
                fmt = "  -> {:s}: (prevfree:{:#x}  bsize:{:#010x}  flink:{:#010x}  blink:{:#010x}  next_prevfree:{:#010x}  next_bsize:{:#010x}({:#010x}))"
                gef_print(fmt.format(chunk_addr, chunk["prevfree"], chunk["bsize"], chunk["flink"], chunk["blink"],
                                     chunk["next_prevfree"], chunk["next_bsize"], (-chunk["next_bsize"]) & 0xffffffff))
        gef_print("blink:    {:#x}".format(malloc_ctx["blink"]))
        for chunk in malloc_ctx["blink_list"]:
            if isinstance(chunk, str):
                gef_print("  -> {:s}".format(Color.colorify(chunk, "red bold")))
            else:
                chunk_addr = Color.colorify("{:#010x}".format(chunk["_addr"]), "yellow bold")
                fmt = "  -> {:s}: (prevfree:{:#x}  bsize:{:#010x}  flink:{:#010x}  blink:{:#010x}  next_prevfree:{:#010x}  next_bsize:{:#010x}({:#010x}))"
                gef_print(fmt.format(chunk_addr, chunk["prevfree"], chunk["bsize"], chunk["flink"], chunk["blink"],
                                     chunk["next_prevfree"], chunk["next_bsize"], (-chunk["next_bsize"]) & 0xffffffff))
        gef_print("pool:     {:#x}".format(malloc_ctx["pool"]))
        gef_print("pool_len: {:#x}".format(malloc_ctx["pool_len"]))

        for i in range(malloc_ctx["pool_len"]):
            pool = malloc_ctx["pool_list"][i]
            gef_print("  pool[{:d}]  buf:{:#x}  size:{:#x}".format(i, pool["buf"], pool["len"]))
        return

    def print_chunk_list(self, malloc_ctx):
        for i in range(malloc_ctx["pool_len"]):
            pool = malloc_ctx["pool_list"][i]
            pool_start = pool["buf"]
            pool_end = pool["buf"] + pool["len"]
            gef_print(titlify("pool[{:d}] @ {:#x} - {:#x}".format(i, pool_start, pool_end)))

            chunk = pool_start
            used = Color.colorify("used", "green underline")
            freed = Color.colorify("free", "grey bold")
            seen = []
            while chunk < pool_end:
                if chunk in seen:
                    gef_print(Color.colorify("loop detected", "red bold"))
                    break
                seen.append(chunk)
                try:
                    prevfree = read_int_from_memory(chunk + current_arch.ptrsize*0)
                    bsize = read_int_from_memory(chunk + current_arch.ptrsize*1)
                    flink = read_int_from_memory(chunk + current_arch.ptrsize*2)
                    blink = read_int_from_memory(chunk + current_arch.ptrsize*3)
                except:
                    gef_print(Color.colorify("unaligned orrupted", "red bold"))
                    break
                chunk_addr = Color.colorify("{:#010x}".format(chunk), "yellow bold")
                bsize_inv = (-bsize) & 0xffffffff
                if bsize_inv < 0x80000000: # used
                    fmt = "{:s} {:s}: prevfree:{:#010x}  bsize:{:#010x}({:#010x})"
                    gef_print(fmt.format(used, chunk_addr, prevfree, bsize, bsize_inv))
                    chunk += bsize_inv
                else: # freed
                    fmt = "{:s} {:s}: prevfree:{:#010x}  bsize:{:#010x}              flink:{:#010x}  blink:{:#010x}"
                    gef_print(fmt.format(freed, chunk_addr, prevfree, bsize, flink, blink))
                    chunk += bsize
                if chunk % 8:
                    gef_print(Color.colorify("unaligned orrupted", "red bold"))
                    break
            return

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        # arg parse
        if "-h" in argv:
            self.usage()
            return

        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        try:
            malloc_ctx_offset = parse_address(argv[0])
            if verbose:
                info("offset of malloc_ctx: {:#x}".format(malloc_ctx_offset))
        except:
            self.usage()
            return

        ta_address_map = OpteeThreadEnterUserModeBreakpoint.get_ta_loaded_address()
        if ta_address_map is None:
            err("TA address is not found")
            return
        ta_address = ta_address_map[0]
        if verbose:
            info("TA loaded address: {:#x}".format(ta_address))

        malloc_ctx_addr = ta_address + malloc_ctx_offset
        if verbose:
            info("malloc_ctx: {:#x}".format(malloc_ctx_addr))

        malloc_ctx = self.parse_malloc_ctx(malloc_ctx_addr)
        if malloc_ctx is None:
            err("parse failed")
            return
        self.print_malloc_ctx(malloc_ctx)
        self.print_chunk_list(malloc_ctx)
        return


@register_command
class CpuidCommand(GenericCommand):
    """Get cpuid result."""
    _cmdline_ = "cpuid"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "DISABLE `-enbale-kvm` option for qemu-system; This command will be aborted if the option is set"
    _category_ = "Show/Modify Register"

    def get_state(self, code_len):
        d = {}
        d["pc"] = get_register("$pc")
        d["code"] = read_memory(d["pc"], code_len)
        if is_x86_64():
            d["rax"] = get_register("$rax")
            d["rbx"] = get_register("$rbx")
            d["rdx"] = get_register("$rdx")
            d["rcx"] = get_register("$rcx")
        else:
            d["eax"] = get_register("$eax")
            d["ebx"] = get_register("$ebx")
            d["edx"] = get_register("$edx")
            d["ecx"] = get_register("$ecx")
        return d

    def revert_state(self, d):
        write_memory(d["pc"], d["code"], len(d["code"]))
        gdb.execute("set $pc = {:#x}".format(d["pc"]), to_string=True)
        if is_x86_64():
            gdb.execute("set $rax = {:#x}".format(d["rax"]), to_string=True)
            gdb.execute("set $rbx = {:#x}".format(d["rbx"]), to_string=True)
            gdb.execute("set $rdx = {:#x}".format(d["rdx"]), to_string=True)
            gdb.execute("set $rcx = {:#x}".format(d["rcx"]), to_string=True)
        else:
            gdb.execute("set $eax = {:#x}".format(d["eax"]), to_string=True)
            gdb.execute("set $ebx = {:#x}".format(d["ebx"]), to_string=True)
            gdb.execute("set $edx = {:#x}".format(d["edx"]), to_string=True)
            gdb.execute("set $ecx = {:#x}".format(d["ecx"]), to_string=True)
        return

    def close_stdout(self):
        self.stdout = 1
        self.stdout_bak = os.dup(self.stdout)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stdout)
        f.close()
        return

    def revert_stdout(self):
        os.dup2(self.stdout_bak, self.stdout)
        os.close(self.stdout_bak)
        return

    def execute_cpuid(self, num, subnum=0):
        code = b"\xeb\xfe\x0f\xa2" # inf-loop (to stop another thread); cpuid
        gef_on_stop_unhook(hook_stop_handler)
        d = self.get_state(len(code))
        write_memory(d["pc"], code, len(code))
        if is_x86_64():
            gdb.execute("set $rax = {:#x}".format(num), to_string=True)
            gdb.execute("set $rcx = {:#x}".format(subnum), to_string=True)
        else:
            gdb.execute("set $eax = {:#x}".format(num), to_string=True)
            gdb.execute("set $ecx = {:#x}".format(subnum), to_string=True)
        gdb.execute("set $pc = {:#x}".format(d["pc"]+2), to_string=True) # skip "\xeb\xfe"
        self.close_stdout()
        gdb.execute("stepi", to_string=True)
        self.revert_stdout()
        eax = get_register("$eax") & 0xffffffff
        ebx = get_register("$ebx") & 0xffffffff
        ecx = get_register("$ecx") & 0xffffffff
        edx = get_register("$edx") & 0xffffffff
        self.revert_state(d)
        gef_on_stop_hook(hook_stop_handler)
        return eax, ebx, ecx, edx

    def show_result(self, id, subid, eax, ebx, ecx, edx):
        if eax == ebx == ecx == edx == 0:
            return

        if subid is None:
            info("cpuid (eax={:#x})".format(id))
        else:
            info("cpuid (eax={:#x}, ecx={:#x})".format(id, subid))
        gef_print(Color.colorify("    eax={:#x}, ebx={:#x}, ecx={:#x}, edx={:#x}".format(eax, ebx, ecx, edx), "bold yellow"))

        def c(reg, shift, mask, msg):
            val = (reg >> shift) & mask
            msg = msg + " (={:#x})".format(val)
            if val:
                return Color.colorify(msg, "white bold")
            else:
                return msg

        if id == 0:
            vid = (p32(ebx) + p32(edx) + p32(ecx)).decode("utf-8")
            gef_print("    eax: Maximum Input Value for Basic CPUID Information")
            gef_print("    ebx+edx+ecx: Vendor ID (={:s})".format(repr(vid)))
        elif id == 1:
            gef_print("    eax: Version Information")
            gef_print(c(eax,  0, 0xf,       "        EAX  3- 0: Stepping ID"))
            gef_print(c(eax,  4, 0xf,       "        EAX  7- 4: Model Number"))
            gef_print(c(eax,  8, 0xf,       "        EAX 11- 8: Family Code"))
            gef_print(c(eax, 12, 0b11,      "        EAX 13-12: Processor Type"))
            gef_print(c(eax, 14, 0b11,      "        EAX 15-14: Reserved"))
            gef_print(c(eax, 16, 0xf,       "        EAX 19-16: Extended Model"))
            gef_print(c(eax, 20, 0xff,      "        EAX 27-20: Extended Family"))
            gef_print(c(eax, 28, 0xf,       "        EAX 31-28: Reserved"))
            gef_print("    ebx: Additional Information")
            gef_print(c(ebx,  0, 0xff,      "        EBX  7- 0: Brand Index"))
            gef_print(c(ebx,  8, 0xff,      "        EBX 15- 8: CLFLUSH line size"))
            gef_print(c(ebx, 16, 0xff,      "        EBX 23-16: The number of logical processors"))
            gef_print(c(ebx, 24, 0xff,      "        EBX 31-24: Initial APIC ID"))
            gef_print("    edx,ecx: Feature Information")
            gef_print(c(edx,  0, 1,         "        EDX     0: FPU (Floating Point Unit on-chip)"))
            gef_print(c(edx,  1, 1,         "        EDX     1: VME (Virtual 8086 Mode Enhancements)"))
            gef_print(c(edx,  2, 1,         "        EDX     2: DE (Debugging Extensions)"))
            gef_print(c(edx,  3, 1,         "        EDX     3: PSE (Page Size Extension)"))
            gef_print(c(edx,  4, 1,         "        EDX     4: TSC (Time Stamp Counter)"))
            gef_print(c(edx,  5, 1,         "        EDX     5: MSR (Model Specific Registers RDMSR and WRMSR instructions)"))
            gef_print(c(edx,  6, 1,         "        EDX     6: PAE (Physical Address Extension)"))
            gef_print(c(edx,  7, 1,         "        EDX     7: MCE (Machine Check Exception)"))
            gef_print(c(edx,  8, 1,         "        EDX     8: CX8 (CMPXCHG8B instruction)"))
            gef_print(c(edx,  9, 1,         "        EDX     9: APIC (APIC on-chip)"))
            gef_print(c(edx, 10, 1,         "        EDX    10: Reserved"))
            gef_print(c(edx, 11, 1,         "        EDX    11: SEP (SYSENTER and SYSEXIT instructions)"))
            gef_print(c(edx, 12, 1,         "        EDX    12: MTRR (Memory Type Range Registers)"))
            gef_print(c(edx, 13, 1,         "        EDX    13: PGE (Page Global Bit)"))
            gef_print(c(edx, 14, 1,         "        EDX    14: MCA (Machine Check Architecture)"))
            gef_print(c(edx, 15, 1,         "        EDX    15: CMOV (Conditional Move instructions)"))
            gef_print(c(edx, 16, 1,         "        EDX    16: PAT (Page Attribute Table)"))
            gef_print(c(edx, 17, 1,         "        EDX    17: PSE-36 (36-Bit Page Size Extension)"))
            gef_print(c(edx, 18, 1,         "        EDX    18: PSN (Processor Serial Number)"))
            gef_print(c(edx, 19, 1,         "        EDX    19: CLFSH (CLFLUSH instruction)"))
            gef_print(c(edx, 20, 1,         "        EDX    20: Reserved"))
            gef_print(c(edx, 21, 1,         "        EDX    21: DS (Debug Store)"))
            gef_print(c(edx, 22, 1,         "        EDX    22: ACPI (Thermal Monitor and Software Controlled Clock Facilities)"))
            gef_print(c(edx, 23, 1,         "        EDX    23: MMX (Intel MMX technology)"))
            gef_print(c(edx, 24, 1,         "        EDX    24: FXSR (FXSAVE and FXRSTOR instructions)"))
            gef_print(c(edx, 25, 1,         "        EDX    25: SSE (Streaming SIMD Extension)"))
            gef_print(c(edx, 26, 1,         "        EDX    26: SSE2 (STreaming SIMD Extension 2)"))
            gef_print(c(edx, 27, 1,         "        EDX    27: SS (Self Snoop)"))
            gef_print(c(edx, 28, 1,         "        EDX    28: HTT (Max APIC IDs reserved field is Valid)"))
            gef_print(c(edx, 29, 1,         "        EDX    29: TM (Thermal Monitor)"))
            gef_print(c(edx, 30, 1,         "        EDX    30: Reserved"))
            gef_print(c(edx, 31, 1,         "        EDX    31: PBE (Pending Break Enable)"))
            gef_print(c(ecx,  0, 1,         "        ECX     0: SSE3 (Streaming SIMD Extensions 3)"))
            gef_print(c(ecx,  1, 1,         "        ECX     1: PCLMULQDQ (PCLMULQDQ instruction)"))
            gef_print(c(ecx,  2, 1,         "        ECX     2: DTES64 (64-bit DS Area)"))
            gef_print(c(ecx,  3, 1,         "        ECX     3: MONITOR (MONITOR/MWAIT instruction)"))
            gef_print(c(ecx,  4, 1,         "        ECX     4: DS-CPL (CPL Qualified Debug Store)"))
            gef_print(c(ecx,  5, 1,         "        ECX     5: VMX (Intel VT (Virtual Machine eXtensions))"))
            gef_print(c(ecx,  6, 1,         "        ECX     6: SMX (Safer Mode eXtensions)"))
            gef_print(c(ecx,  7, 1,         "        ECX     7: EIST (Enhanced Intel SpeedStep Technology)"))
            gef_print(c(ecx,  8, 1,         "        ECX     8: TM2 (Thermal Monitor 2)"))
            gef_print(c(ecx,  9, 1,         "        ECX     9: SSSE3 (Supplemental Streaming SIMD Extensions 3)"))
            gef_print(c(ecx, 10, 1,         "        ECX    10: CNXT-ID (L1 Context ID)"))
            gef_print(c(ecx, 11, 1,         "        ECX    11: SDBG (IA32_DEBUG_INTERFACE MSR for silicon debug)"))
            gef_print(c(ecx, 12, 1,         "        ECX    12: FMA (FMA extensions using YMM state)"))
            gef_print(c(ecx, 13, 1,         "        ECX    13: CMPXCHG16B (CMPXCHG16B instruction)"))
            gef_print(c(ecx, 14, 1,         "        ECX    14: xTPR (xTPR update control)"))
            gef_print(c(ecx, 15, 1,         "        ECX    15: PDCM (Perfmon and Debug Capability MSR)"))
            gef_print(c(ecx, 16, 1,         "        ECX    16: Reserved"))
            gef_print(c(ecx, 17, 1,         "        ECX    17: PCID (Process-Context IDentifiers)"))
            gef_print(c(ecx, 18, 1,         "        ECX    18: DCA (Direct Cache Access)"))
            gef_print(c(ecx, 19, 1,         "        ECX    19: SSE4_1 (Streaming SIMD Extensions 4.1)"))
            gef_print(c(ecx, 20, 1,         "        ECX    20: SSE4_2 (Streaming SIMD Extensions 4.2)"))
            gef_print(c(ecx, 21, 1,         "        ECX    21: x2APIC"))
            gef_print(c(ecx, 22, 1,         "        ECX    22: MOVBE (MOVBE instruction)"))
            gef_print(c(ecx, 23, 1,         "        ECX    23: POPCNT (POPulation CouNt instruction)"))
            gef_print(c(ecx, 24, 1,         "        ECX    24: TSC-Deadline"))
            gef_print(c(ecx, 25, 1,         "        ECX    25: AESNI (AESNI Instruction)"))
            gef_print(c(ecx, 26, 1,         "        ECX    26: XSAVE (XSAVE instruction)"))
            gef_print(c(ecx, 27, 1,         "        ECX    27: OSXSAVE (OSXSAVE instruction)"))
            gef_print(c(ecx, 28, 1,         "        ECX    28: AVX (Intel Advanced Vector eXtensions)"))
            gef_print(c(ecx, 29, 1,         "        ECX    29: F16C (16-bit Floating-point Conversion instructions)"))
            gef_print(c(ecx, 30, 1,         "        ECX    30: RDRAND (RDRAND instruction)"))
            gef_print(c(ecx, 31, 1,         "        ECX    31: RAZ (Reserved for use by hypervisor to indicate guest status)"))
        elif id == 2:
            gef_print("    Cache and TLB Information")
        elif id == 3:
            gef_print("    eax,ebx: Reserved")
            gef_print("    edx+ecx: Processor Serial Number")
        elif id == 4:
            gef_print("    Information of cache configuration descriptor")
        elif id == 5:
            gef_print("    Information of MONITOR/MWAIT")
        elif id == 6:
            gef_print("    Information of power management")
            gef_print(c(eax,  0, 1,         "        EAX     0: Digital temperature sensor"))
            gef_print(c(eax,  1, 1,         "        EAX     1: Intel Turbo Boost Technology"))
            gef_print(c(eax,  2, 1,         "        EAX     2: ARAT (Always Running APIC Timer)"))
            gef_print(c(eax,  3, 1,         "        EAX     3: Reserved"))
            gef_print(c(eax,  4, 1,         "        EAX     4: Power limit notification controls"))
            gef_print(c(eax,  5, 1,         "        EAX     5: Clock modulation duty cycle extensions"))
            gef_print(c(eax,  6, 1,         "        EAX     6: Package thermal management"))
            gef_print(c(eax,  7, 1,         "        EAX     7: Hardware-managed P-state base support (HWP)"))
            gef_print(c(eax,  8, 1,         "        EAX     8: HWP notification interrupt enable MSR"))
            gef_print(c(eax,  9, 1,         "        EAX     9: HWP activity window MSR"))
            gef_print(c(eax, 10, 1,         "        EAX    10: HWP energy/performance preference MSR"))
            gef_print(c(eax, 11, 1,         "        EAX    11: HWP package level request MSR"))
            gef_print(c(eax, 12, 1,         "        EAX    12: Reserved"))
            gef_print(c(eax, 13, 1,         "        EAX    13: HDC (Hardware Duty Cycle programming)"))
            gef_print(c(eax, 14, 1,         "        EAX    14: Intel Turbo Boost Max Technology 3.0"))
            gef_print(c(eax, 15, 1,         "        EAX    15: HWP Capabilities, Highest Performance change"))
            gef_print(c(eax, 16, 1,         "        EAX    16: HWP PECI override"))
            gef_print(c(eax, 17, 1,         "        EAX    17: Flexible HWP"))
            gef_print(c(eax, 18, 1,         "        EAX    18: Fast access mode for IA32_HWP_REQUEST MSR"))
            gef_print(c(eax, 19, 1,         "        EAX    19: Hardware feedback MSRs"))
            gef_print(c(eax, 20, 1,         "        EAX    20: Ignoring Idle Logical Processor HWP request"))
            gef_print(c(eax, 21, 1,         "        EAX    21: Reserved"))
            gef_print(c(eax, 22, 1,         "        EAX    22: Reserved"))
            gef_print(c(eax, 23, 1,         "        EAX    23: Enhanced hardware feedback MSRs"))
            gef_print(c(eax, 24, 0x7f,      "        EAX 30-24: Reserved"))
            gef_print(c(eax, 31, 1,         "        EAX    31: IP payloads are LIP"))
            gef_print(c(ebx,  0, 0xf,       "        EBX  3- 0: Number of interrupted thresholds of digital temperature sensor"))
            gef_print(c(ebx,  4, 0xfffffff, "        EBX 31- 4: Reserved"))
            gef_print(c(ecx,  0, 1,         "        ECX     0: Hardware Coordination Feedback Capability (APERF and MPERF)"))
            gef_print(c(ecx,  1, 1,         "        ECX     1: Reserved"))
            gef_print(c(ecx,  2, 1,         "        ECX     2: Reserved"))
            gef_print(c(ecx,  3, 1,         "        ECX     3: Performance-energy bias preference"))
            gef_print(c(ecx,  4, 0xfffffff, "        ECX 31- 4: Reserved"))
            gef_print(c(edx,  0, 1,         "        EDX     0: Performance feature report"))
            gef_print(c(edx,  1, 1,         "        EDX     1: Energy efficiency capacity report"))
            gef_print(c(edx,  2, 0x3f,      "        EDX  7- 2: Reserved"))
            gef_print(c(edx,  8, 0xf,       "        EDX 11- 8: The size of the hardware feedback interface structure"))
            gef_print(c(edx, 12, 0xf,       "        EDX 15-12: Reserved"))
            gef_print(c(edx, 16, 0xffff,    "        EDX 31-16: Index of rows for the hardware feedback interface structure"))
        elif id == 7 and subid == 0:
            gef_print("    eax: Maximum Input Value for Extended CPUID Information")
            gef_print("    ebx,edx,edx: Extended Feature Information")
            gef_print(c(ebx,  0, 1,         "        EBX     0: FSGSBASE (FSGSBASE instructions)"))
            gef_print(c(ebx,  1, 1,         "        EBX     1: TSC_ADJUST (IA32_TSC_ADJUST MSR supported)"))
            gef_print(c(ebx,  2, 1,         "        EBX     2: SGX (Software Guard Extensions)"))
            gef_print(c(ebx,  3, 1,         "        EBX     3: BMI1 (Bit Manipulation Instructions)"))
            gef_print(c(ebx,  4, 1,         "        EBX     4: HLE (Hardware Lock Elision)"))
            gef_print(c(ebx,  5, 1,         "        EBX     5: AVX2 (Advanced Vector Extensions 2.0)"))
            gef_print(c(ebx,  6, 1,         "        EBX     6: FDP_EXCPTN_ONLY (x87 FPU Data Pointer updated only on x87 Exceptions)"))
            gef_print(c(ebx,  7, 1,         "        EBX     7: SMEP (Supervisor Mode Execution Protection)"))
            gef_print(c(ebx,  8, 1,         "        EBX     8: BMI2 (Bit Manipulation Instructions 2)"))
            gef_print(c(ebx,  9, 1,         "        EBX     9: ERMS (Enhanced REP MOVSB/STOSB)"))
            gef_print(c(ebx, 10, 1,         "        EBX    10: INVPCID (INVPCID instruction)"))
            gef_print(c(ebx, 11, 1,         "        EBX    11: RTM (Restricted Transactional Memor)"))
            gef_print(c(ebx, 12, 1,         "        EBX    12: PQM (Platform QoS Monitoring)"))
            gef_print(c(ebx, 13, 1,         "        EBX    13: x87 FPU CS and DS deprecated"))
            gef_print(c(ebx, 14, 1,         "        EBX    14: MPX (Memory Protection eXtensions)"))
            gef_print(c(ebx, 15, 1,         "        EBX    15: PQE (Platform QoS Enforcement)"))
            gef_print(c(ebx, 16, 1,         "        EBX    16: AVX512F (AVX512 Foundation)"))
            gef_print(c(ebx, 17, 1,         "        EBX    17: AVX512DQ (AVX512 Double/Quadword instructions)"))
            gef_print(c(ebx, 18, 1,         "        EBX    18: RDSEED (RDSEED instruction)"))
            gef_print(c(ebx, 19, 1,         "        EBX    19: ADX (Multi-Precision Add-Carry instruction eXtensions)"))
            gef_print(c(ebx, 20, 1,         "        EBX    20: SMAP (Supervisor Mode Access Prevention)"))
            gef_print(c(ebx, 21, 1,         "        EBX    21: AVX512IFMA (AVX512 Integer FMA instructions)"))
            gef_print(c(ebx, 22, 1,         "        EBX    22: (Intel) PCOMMIT (Persistent Commit instruction)"))
            gef_print(c(ebx, 22, 1,         "        EBX    22: (AMD) RDPID (RDPID instruction and TSC_AUX MSR iupport)"))
            gef_print(c(ebx, 23, 1,         "        EBX    23: CLFLUSHOPT (CLFLUSHOPT instruction)"))
            gef_print(c(ebx, 24, 1,         "        EBX    24: CLWB (Cache Line Write-Back instruction)"))
            gef_print(c(ebx, 25, 1,         "        EBX    25: PT (Intel Processor Trace)"))
            gef_print(c(ebx, 26, 1,         "        EBX    26: AVX512PF (AVX512 Prefetch instructions)"))
            gef_print(c(ebx, 27, 1,         "        EBX    27: AVX512ER (AVX512 Exponent/Reciprocal instructions)"))
            gef_print(c(ebx, 28, 1,         "        EBX    28: AVX512CD (AVX512 Conflict Detection instructions)"))
            gef_print(c(ebx, 29, 1,         "        EBX    29: SHA (SHA-1/SHA-256 instructions)"))
            gef_print(c(ebx, 30, 1,         "        EBX    30: AVX512BW (AVX512 Byte/Word instructions)"))
            gef_print(c(ebx, 31, 1,         "        EBX    31: AVX512VL (AVX512 Vector Length Extensions)"))
            gef_print(c(ecx,  0, 1,         "        ECX     0: PREFETCHWT1 (PREFETCHWT1 instruction)"))
            gef_print(c(ecx,  1, 1,         "        ECX     1: AVX512VBMI (AVX512 Vector Byte Manipulation Instructions)"))
            gef_print(c(ecx,  2, 1,         "        ECX     2: UMIP (User Mode Instruction Prevention)"))
            gef_print(c(ecx,  3, 1,         "        ECX     3: PKU (Protection Keys for User-mode pages)"))
            gef_print(c(ecx,  4, 1,         "        ECX     4: OSPKE (OS has Enabled Protection Keys)"))
            gef_print(c(ecx,  5, 1,         "        ECX     5: WAITPKG (Wait and Pause Enhancements)"))
            gef_print(c(ecx,  6, 1,         "        ECX     6: AVX512VBMI2 (AVX512 Vector Byte Manipulation Instructions 2)"))
            gef_print(c(ecx,  7, 1,         "        ECX     7: CET_SS (CET shadow stack)"))
            gef_print(c(ecx,  8, 1,         "        ECX     8: GFNI (Galois Field NI / Galois Field Affine Transformation)"))
            gef_print(c(ecx,  9, 1,         "        ECX     9: VAES (VEX-encoded AES-NI)"))
            gef_print(c(ecx, 10, 1,         "        ECX    10: VPCL (VEX-encoded PCLMUL)"))
            gef_print(c(ecx, 11, 1,         "        ECX    11: AVX512VNNI (AVX512 Vector Neural Network Instructions)"))
            gef_print(c(ecx, 12, 1,         "        ECX    12: AVX512BITALG (AVX512 Bitwise Algorithms)"))
            gef_print(c(ecx, 13, 1,         "        ECX    13: TME_EN (Total Memory Encryption)"))
            gef_print(c(ecx, 14, 1,         "        ECX    14: AVX512 VPOPCNTDQ"))
            gef_print(c(ecx, 15, 1,         "        ECX    15: Reserved"))
            gef_print(c(ecx, 16, 1,         "        ECX    16: LA57 (5-Level paging)"))
            gef_print(c(ecx, 17, 0x1f,      "        ECX 21-17: MAWAU (MPX Address-Width Adjust for CPL=3)"))
            gef_print(c(ecx, 22, 1,         "        ECX    22: RDPID (Read Processor ID)"))
            gef_print(c(ecx, 23, 1,         "        ECX    23: KL (Key Locker)"))
            gef_print(c(ecx, 24, 1,         "        ECX    24: Reserved"))
            gef_print(c(ecx, 25, 1,         "        ECX    25: CLDEMOTE (Cache Line Demote)"))
            gef_print(c(ecx, 26, 1,         "        ECX    26: Reserved"))
            gef_print(c(ecx, 27, 1,         "        ECX    27: MOVDIRI (32-bit Direct Stores)"))
            gef_print(c(ecx, 28, 1,         "        ECX    28: MOVDIRI64B (64-bit Direct Stores)"))
            gef_print(c(ecx, 29, 1,         "        ECX    29: ENQCMD (ENQueue Stores)"))
            gef_print(c(ecx, 30, 1,         "        ECX    30: SGX_LC (SGX Launch Configuration)"))
            gef_print(c(ecx, 31, 1,         "        ECX    31: PKS (Protection Keys for Supervisor-mode pages)"))
            gef_print(c(edx,  0, 1,         "        EDX     0: Reserved"))
            gef_print(c(edx,  1, 1,         "        EDX     1: Reserved"))
            gef_print(c(edx,  2, 1,         "        EDX     2: AVX512_4VNNIW"))
            gef_print(c(edx,  3, 1,         "        EDX     3: AVX512_4FMAPS"))
            gef_print(c(edx,  4, 1,         "        EDX     4: Fast Short REP MOV"))
            gef_print(c(edx,  5, 1,         "        EDX     5: UINTR (User Interrupts)"))
            gef_print(c(edx,  6, 1,         "        EDX     6: Reserved"))
            gef_print(c(edx,  7, 1,         "        EDX     7: Reserved"))
            gef_print(c(edx,  8, 1,         "        EDX     8: AVX512_VP2INTERSECT"))
            gef_print(c(edx,  9, 1,         "        EDX     9: Reserved"))
            gef_print(c(edx, 10, 1,         "        EDX    10: MD_CLEAR"))
            gef_print(c(edx, 11, 1,         "        EDX    11: Reserved"))
            gef_print(c(edx, 12, 1,         "        EDX    12: Reserved"))
            gef_print(c(edx, 13, 1,         "        EDX    13: TSX force abort MSR"))
            gef_print(c(edx, 14, 1,         "        EDX    14: SERIALIZE"))
            gef_print(c(edx, 15, 1,         "        EDX    15: Hybrid"))
            gef_print(c(edx, 16, 1,         "        EDX    16: TSX suspend load address tracking"))
            gef_print(c(edx, 17, 1,         "        EDX    17: Reserved"))
            gef_print(c(edx, 18, 1,         "        EDX    18: PCONFIG"))
            gef_print(c(edx, 19, 1,         "        EDX    19: Reserved"))
            gef_print(c(edx, 20, 1,         "        EDX    20: CET_IBT (CET Indirect Branch Tracking)"))
            gef_print(c(edx, 21, 1,         "        EDX    21: Reserved"))
            gef_print(c(edx, 22, 1,         "        EDX    22: AMX-BF16 (Tile computation on bfloat16)"))
            gef_print(c(edx, 23, 1,         "        EDX    23: AVX512FP16"))
            gef_print(c(edx, 24, 1,         "        EDX    24: AMX-TILE (Tile architecture)"))
            gef_print(c(edx, 25, 1,         "        EDX    25: AMX-INT8 (Tile computation on 8-bit integers)"))
            gef_print(c(edx, 26, 1,         "        EDX    26: IBRS/IBPB (Indirect Branch Restricted Speculation/Indirect Branch Predictor Barrier)"))
            gef_print(c(edx, 27, 1,         "        EDX    27: STIBP (Single Thread Indirect Branch Predictors)"))
            gef_print(c(edx, 28, 1,         "        EDX    28: L1D_FLUSH (L1 Data Cache Flush)"))
            gef_print(c(edx, 29, 1,         "        EDX    29: IA32_ARCH_CAPABILITIES MSR"))
            gef_print(c(edx, 30, 1,         "        EDX    30: IA32_CORE_CAPABILITIES MSR"))
            gef_print(c(edx, 31, 1,         "        EDX    31: SSBD (Speculative Store Bypass Disable)"))
        elif id == 7 and subid != 0:
            gef_print("    ebx,edx,edx: Extended Feature Information")
        elif id == 8:
            gef_print("    Reserved")
        elif id == 9:
            gef_print("    eax: PLATFORM_DCA_CAP MSR")
            gef_print("    ebx,ecx,edx: Reserved")
        elif id == 10:
            gef_print("    DCA parameters")
            gef_print(c(eax,  0, 0xff,      "        EAX  7- 0: Revision"))
            gef_print(c(eax,  8, 0xff,      "        EAX 15- 8: Number of PeMo counters per logical processor"))
            gef_print(c(eax, 16, 0xff,      "        EAX 23-16: Bit width of PeMo counter"))
            gef_print(c(eax, 24, 0xff,      "        EAX 31-24: EBX bit vector length"))
            gef_print(c(ebx,  0, 1,         "        EBX     0: Core cycles event unavailable"))
            gef_print(c(ebx,  1, 1,         "        EBX     1: Instructions retired event unavailable"))
            gef_print(c(ebx,  2, 1,         "        EBX     2: Reference cycles event unavailable"))
            gef_print(c(ebx,  3, 1,         "        EBX     3: Last level cache references event unavailable"))
            gef_print(c(ebx,  4, 1,         "        EBX     4: Last level cache misses event unavailable"))
            gef_print(c(ebx,  5, 1,         "        EBX     5: Branch instructions retired event unavailable"))
            gef_print(c(ebx,  6, 1,         "        EBX     6: Branch mispredicts retired event unavailable"))
            gef_print(c(ebx,  7, 0x1ffffff, "        EBX 31- 7: Reserved"))
            gef_print(c(ecx,  0, 0xffffffff,"        ECX 31- 0: Reserved"))
            gef_print(c(edx,  0, 0x1f,      "        EDX  4- 0: Number of fixed function PeMo counters"))
            gef_print(c(edx,  5, 0xff,      "        EDX 12- 5: Bit width of fixed function PeMo counter"))
            gef_print(c(edx, 13, 1,         "        EDX    13: Reserved"))
            gef_print(c(edx, 14, 1,         "        EDX    14: Reserved"))
            gef_print(c(edx, 15, 1,         "        EDX    15: AnyThread deprecation"))
            gef_print(c(edx, 16, 0xffff,    "        EDX 31-16: Reserved"))
        elif id == 11:
            gef_print("    Information of topology enumeration")
        elif id == 12:
            gef_print("    Reserved")
        elif id == 13:
            if subid == 0:
                m = "main"
            elif subid == 1:
                m = "sub"
            else:
                m = "XCR0.{:d}".format(subid)
            gef_print("    Information of extended state enumeration ({:s})".format(m))
        elif id in [15, 16]:
            gef_print("    Intel Resource Director Technology (Intel RDT), Cache, Memory Bandwidth Allocation Enumeration")
        elif id == 18:
            gef_print("    Information of Intel SGX")
        elif id == 20:
            gef_print("    Information of Intel Processor Trace Enumeration")
            gef_print(c(ebx,  0, 1,         "        EBX     0: CR3 filtering"))
            gef_print(c(ebx,  1, 1,         "        EBX     1: Configurable PSB, Cycle-Accurate Mode"))
            gef_print(c(ebx,  2, 1,         "        EBX     2: Filtering preserved across warm reset"))
            gef_print(c(ebx,  3, 1,         "        EBX     3: MTC timing packet, suppression of COFI-based packets"))
            gef_print(c(ebx,  4, 1,         "        EBX     4: PTWRITE"))
            gef_print(c(ebx,  5, 1,         "        EBX     5: Power Event Trace"))
            gef_print(c(ebx,  6, 1,         "        EBX     6: PSB and PMI preservation MSRs"))
            gef_print(c(ebx,  7, 0x1ffffff, "        EBX 31- 7: Reserved"))
            gef_print(c(ecx,  0, 1,         "        ECX     0: ToPA output scheme"))
            gef_print(c(ecx,  1, 1,         "        ECX     1: ToPA tables hold multiple output entries"))
            gef_print(c(ecx,  2, 1,         "        ECX     2: Single-range output scheme"))
            gef_print(c(ecx,  3, 1,         "        ECX     3: Trace Transport output support"))
            gef_print(c(ecx,  4, 0x7ffffff, "        ECX 30- 4: Reserved"))
            gef_print(c(ecx, 31, 1,         "        ECX    31: IP payloads are LIP"))
        elif id == 21:
            gef_print("    TSC and Nominal Core Crystal Clock")
        elif id == 22:
            gef_print("    Information of CPU frequency")
            gef_print(c(eax,  0, 0xffff,    "        EAX 15- 0: Processor Base Frequency (MHz)"))
            gef_print(c(eax, 16, 0xffff,    "        EAX 31-16: Reserved"))
            gef_print(c(ebx,  0, 0xffff,    "        EBX 15- 0: Maximum Frequency (MHz)"))
            gef_print(c(ebx, 16, 0xffff,    "        EBX 31-16: Reserved"))
            gef_print(c(ecx,  0, 0xffff,    "        ECX 15- 0: Bus (Reference) Frequency (MHz)"))
            gef_print(c(ecx, 16, 0xffff,    "        ECX 31-16: Reserved"))
            gef_print(c(edx,  0, 0xffffffff,"        EDX 31- 0: Reserved"))
        elif id == 23:
            gef_print("    Information of System-On-Chip Vendor Attribute Enumeration")
        elif id == 24:
            gef_print("    Information of Deterministic Address Translation Parameters")
        elif id == 26:
            gef_print("    Information of Hybrid Information Enumeration")
        elif id == 31:
            gef_print("    Information of V2 Extended Topology Enumeration")
        elif id == 0x40000000:
            vid = (p32(ebx) + p32(ecx) + p32(edx)).decode("utf-8")
            gef_print("    eax: Maximum Input Value for Hypervisor Function CPUID Information")
            gef_print("    ebx+ecx+edx: Hypervisor Brand String (={:s})".format(repr(vid)))
        elif id == 0x40000001:
            gef_print("    Hypervisor")
            gef_print(c(eax,  0, 1,         "        EAX     0: Clocksource"))
            gef_print(c(eax,  1, 1,         "        EAX     1: NOP IO Delay"))
            gef_print(c(eax,  2, 1,         "        EAX     2: MMU Op"))
            gef_print(c(eax,  3, 1,         "        EAX     3: Clocksource 2"))
            gef_print(c(eax,  4, 1,         "        EAX     4: Async PF"))
            gef_print(c(eax,  5, 1,         "        EAX     5: Steal Time"))
            gef_print(c(eax,  6, 1,         "        EAX     6: PV EOI"))
            gef_print(c(eax,  7, 1,         "        EAX     7: PV UNHALT"))
            gef_print(c(eax,  8, 1,         "        EAX     8: Reserved"))
            gef_print(c(eax,  9, 1,         "        EAX     9: PV TLB flush"))
            gef_print(c(eax, 10, 1,         "        EAX    10: PV async PF VMEXIT"))
            gef_print(c(eax, 11, 1,         "        EAX    11: PV send IPI"))
            gef_print(c(eax, 12, 1,         "        EAX    12: PV poll control"))
            gef_print(c(eax, 13, 1,         "        EAX    13: PV sched yield"))
            gef_print(c(eax, 14, 1,         "        EAX    14: Async PF INT"))
            gef_print(c(eax, 15, 1,         "        EAX    15: MSI extended destination ID"))
            gef_print(c(eax, 16, 1,         "        EAX    16: Hypercall map GPA range"))
            gef_print(c(eax, 17, 1,         "        EAX    17: Hypercall map GPA range"))
            gef_print(c(eax, 18, 1,         "        EAX    18: Migration control"))
            gef_print(c(eax, 19, 0x3f,      "        EAX 24-19: Reserved"))
            gef_print(c(eax, 25, 1,         "        EAX    25: Clocksource Stable"))
            gef_print(c(eax, 26, 0x3f,      "        EAX 31-26: Reserved"))
            gef_print(c(edx,  0, 1,         "        EDX     0: vCPUs realtime, never preempted"))
            gef_print(c(edx,  1, 0x7fffffff,"        EDX 31- 1: Reserved"))
        elif id == 0x40000003:
            gef_print("    Hypervisor")
            gef_print(c(eax,  0, 1,         "        EAX     0: VP_RUNTIME"))
            gef_print(c(eax,  1, 1,         "        EAX     1: TIME_REF_COUNT"))
            gef_print(c(eax,  2, 1,         "        EAX     2: Basic SynIC MSRs"))
            gef_print(c(eax,  3, 1,         "        EAX     3: Synthetic Timer"))
            gef_print(c(eax,  4, 1,         "        EAX     4: APIC access"))
            gef_print(c(eax,  5, 1,         "        EAX     5: Hypercall MSRs"))
            gef_print(c(eax,  6, 1,         "        EAX     6: VP Index MSR"))
            gef_print(c(eax,  7, 1,         "        EAX     7: System Reset MSR"))
            gef_print(c(eax,  8, 1,         "        EAX     8: Access stats MSRs"))
            gef_print(c(eax,  9, 1,         "        EAX     9: Reference TSC"))
            gef_print(c(eax, 10, 1,         "        EAX    10: Guest Idle MSR"))
            gef_print(c(eax, 11, 1,         "        EAX    11: Timer Frequency MSRs"))
            gef_print(c(eax, 12, 1,         "        EAX    12: Debug MSRs"))
            gef_print(c(eax, 13, 1,         "        EAX    13: Reenlightenment controls"))
            gef_print(c(eax, 14, 0x3ffff,   "        EAX 31-14: Reserved"))
            gef_print(c(ebx,  0, 1,         "        EBX     0: CreatePartitions"))
            gef_print(c(ebx,  1, 1,         "        EBX     1: AccessPartitionId"))
            gef_print(c(ebx,  2, 1,         "        EBX     2: AccessMemoryPool"))
            gef_print(c(ebx,  3, 1,         "        EBX     3: AdjustMemoryBuffers"))
            gef_print(c(ebx,  4, 1,         "        EBX     4: PostMessages"))
            gef_print(c(ebx,  5, 1,         "        EBX     5: SignalEvents"))
            gef_print(c(ebx,  6, 1,         "        EBX     6: CreatePort"))
            gef_print(c(ebx,  7, 1,         "        EBX     7: ConnectPort"))
            gef_print(c(ebx,  8, 1,         "        EBX     8: AccessStats"))
            gef_print(c(ebx,  9, 1,         "        EBX     9: Reserved"))
            gef_print(c(ebx, 10, 1,         "        EBX    10: Reserved"))
            gef_print(c(ebx, 11, 1,         "        EBX    11: Debugging"))
            gef_print(c(ebx, 12, 1,         "        EBX    12: CpuManagement"))
            gef_print(c(ebx, 13, 1,         "        EBX    13: ConfigureProfiler"))
            gef_print(c(ebx, 14, 1,         "        EBX    14: EnableExpandedStackwalking"))
            gef_print(c(ebx, 15, 1,         "        EBX    15: Reserved"))
            gef_print(c(ebx, 16, 1,         "        EBX    16: AccessVSM"))
            gef_print(c(ebx, 17, 1,         "        EBX    17: AccessVpRegisters"))
            gef_print(c(ebx, 18, 1,         "        EBX    18: Reserved"))
            gef_print(c(ebx, 19, 1,         "        EBX    19: Reserved"))
            gef_print(c(ebx, 20, 1,         "        EBX    20: EnableExtendedHypercalls"))
            gef_print(c(ebx, 21, 1,         "        EBX    21: StartVirtualProcessor"))
            gef_print(c(ebx, 22, 0x3ff,     "        EBX 31-22: Reserved"))
            gef_print(c(edx,  0, 1,         "        EDX     0: MWAIT instruction support (deprecated)"))
            gef_print(c(edx,  1, 1,         "        EDX     1: Guest debugging support"))
            gef_print(c(edx,  2, 1,         "        EDX     2: Performance Monitor support"))
            gef_print(c(edx,  3, 1,         "        EDX     3: Physical CPU dynamic partitioning event support"))
            gef_print(c(edx,  4, 1,         "        EDX     4: Hypercall input params via XMM registers"))
            gef_print(c(edx,  5, 1,         "        EDX     5: Virtual guest idle state support"))
            gef_print(c(edx,  6, 1,         "        EDX     6: Hypervisor sleep state support"))
            gef_print(c(edx,  7, 1,         "        EDX     7: NUMA distance query support"))
            gef_print(c(edx,  8, 1,         "        EDX     8: Timer frequency details available"))
            gef_print(c(edx,  9, 1,         "        EDX     9: Synthetic machine check injection support"))
            gef_print(c(edx, 10, 1,         "        EDX    10: Guest crash MSR support"))
            gef_print(c(edx, 11, 1,         "        EDX    11: Debug MSR support"))
            gef_print(c(edx, 12, 1,         "        EDX    12: NPIEP support"))
            gef_print(c(edx, 13, 1,         "        EDX    13: Hypervisor disable support"))
            gef_print(c(edx, 14, 1,         "        EDX    14: Extended GVA ranges for flush virtual address list available"))
            gef_print(c(edx, 15, 1,         "        EDX    15: Hypercall output via XMM registers"))
            gef_print(c(edx, 16, 1,         "        EDX    16: Virtual guest idle state"))
            gef_print(c(edx, 17, 1,         "        EDX    17: Soft interrupt polling mode available"))
            gef_print(c(edx, 18, 1,         "        EDX    18: Hypercall MSR lock available"))
            gef_print(c(edx, 19, 1,         "        EDX    19: Direct synthetic timers support"))
            gef_print(c(edx, 20, 1,         "        EDX    20: PAT register available for VSM"))
            gef_print(c(edx, 21, 1,         "        EDX    21: BNDCFGS register available for VSM"))
            gef_print(c(edx, 22, 1,         "        EDX    22: Reserved"))
            gef_print(c(edx, 23, 1,         "        EDX    23: Synthetic time unhalted timer"))
            gef_print(c(edx, 24, 1,         "        EDX    24: Reserved"))
            gef_print(c(edx, 25, 1,         "        EDX    25: Reserved"))
            gef_print(c(edx, 26, 1,         "        EDX    26: Intel Last Branch Record (LBR) feature"))
            gef_print(c(edx, 27, 1,         "        EDX 31-27: Reserved"))
        elif id == 0x40000004:
            gef_print("    Hypervisor implementation recommendations")
            gef_print(c(eax,  0, 1,         "        EAX     0: Hypercall for address space switches"))
            gef_print(c(eax,  1, 1,         "        EAX     1: Hypercall for local TLB flushes"))
            gef_print(c(eax,  2, 1,         "        EAX     2: Hypercall for remote TLB flushes"))
            gef_print(c(eax,  3, 1,         "        EAX     3: MSRs for accessing APIC registers"))
            gef_print(c(eax,  4, 1,         "        EAX     4: Hypervisor MSR for system RESET"))
            gef_print(c(eax,  5, 1,         "        EAX     5: Relaxed timing"))
            gef_print(c(eax,  6, 1,         "        EAX     6: DMA remapping"))
            gef_print(c(eax,  7, 1,         "        EAX     7: Interrupt remapping"))
            gef_print(c(eax,  8, 1,         "        EAX     8: x2APIC MSRs"))
            gef_print(c(eax,  9, 1,         "        EAX     9: Deprecating AutoEOI"))
            gef_print(c(eax, 10, 1,         "        EAX    10: Hypercall for SyntheticClusterIpi"))
            gef_print(c(eax, 11, 1,         "        EAX    11: Interface ExProcessorMasks"))
            gef_print(c(eax, 12, 1,         "        EAX    12: Nested Hyper-V partition"))
            gef_print(c(eax, 13, 1,         "        EAX    13: INT for MBEC system calls"))
            gef_print(c(eax, 14, 1,         "        EAX    14: Enlightenment VMCS interface"))
            gef_print(c(eax, 15, 1,         "        EAX    15: Synced timeline"))
            gef_print(c(eax, 16, 1,         "        EAX    16: Reserved"))
            gef_print(c(eax, 17, 1,         "        EAX    17: Direct local flush entire"))
            gef_print(c(eax, 18, 1,         "        EAX    18: No architectural core sharing"))
            gef_print(c(eax, 19, 0x1fff,    "        EAX 31-19: Reserved"))
        elif id == 0x40000006:
            gef_print("    Hypervisor hardware features enable")
            gef_print(c(eax,  0, 1,         "        EAX     0: APIC overlay assist"))
            gef_print(c(eax,  1, 1,         "        EAX     1: MSR bitmaps"))
            gef_print(c(eax,  2, 1,         "        EAX     2: Architectural performance counters"))
            gef_print(c(eax,  3, 1,         "        EAX     3: Second-level address translation"))
            gef_print(c(eax,  4, 1,         "        EAX     4: DMA remapping"))
            gef_print(c(eax,  5, 1,         "        EAX     5: Interrupt remapping"))
            gef_print(c(eax,  6, 1,         "        EAX     6: Memory patrol scrubber"))
            gef_print(c(eax,  7, 1,         "        EAX     7: DMA protection"))
            gef_print(c(eax,  8, 1,         "        EAX     8: HPET"))
            gef_print(c(eax,  9, 1,         "        EAX     9: Volatile synthetic timers"))
            gef_print(c(eax, 10, 0x3fffff,  "        EAX 31-10: Reserved"))
        elif id == 0x40000007:
            gef_print("    Hypervisor CPU management features")
            gef_print(c(eax,  0, 1,         "        EAX     0: Start logical processor"))
            gef_print(c(eax,  1, 1,         "        EAX     1: Create root virtual processor"))
            gef_print(c(eax,  2, 1,         "        EAX     2: Performance counter sync"))
            gef_print(c(eax,  3, 0x1fffffff,"        EAX 31- 3: Reserved"))
            gef_print(c(ebx,  0, 1,         "        EBX     0: Processor power management"))
            gef_print(c(ebx,  1, 1,         "        EBX     1: MWAIT idle states"))
            gef_print(c(ebx,  2, 1,         "        EBX     2: Logical processor idling"))
            gef_print(c(ebx,  3, 0x1fffffff,"        EBX 31- 3: Reserved"))
            gef_print(c(ecx,  0, 1,         "        ECX     0: Remap guest uncached"))
            gef_print(c(ecx,  1, 0x7fffffff,"        ECX 31- 1: Reserved"))
        elif id == 0x40000008:
            gef_print("    Hypervisor shared virtual memory (SVM) features")
            gef_print(c(eax,  0, 1,         "        EAX     0: SVM (Shared Virtual Memory)"))
            gef_print(c(eax,  1, 0x7fffffff,"        EAX 31- 1: Reserved"))
        elif id == 0x40000009:
            gef_print("    Nested hypervisor feature indentification")
            gef_print(c(eax,  0, 1,         "        EAX     0: Reserved"))
            gef_print(c(eax,  1, 1,         "        EAX     1: Reserved"))
            gef_print(c(eax,  2, 1,         "        EAX     2: Synthetic Timer"))
            gef_print(c(eax,  3, 1,         "        EAX     3: Reserved"))
            gef_print(c(eax,  4, 1,         "        EAX     4: Interrupt control registers"))
            gef_print(c(eax,  5, 1,         "        EAX     5: Hypercall MSRs"))
            gef_print(c(eax,  6, 1,         "        EAX     6: VP index MSR"))
            gef_print(c(eax,  7, 0x1f,      "        EAX 11- 7: Reserved"))
            gef_print(c(eax, 12, 1,         "        EAX    12: Reenlightenment controls"))
            gef_print(c(eax, 13, 0x7ffff,   "        EAX 31-13: Reserved"))
            gef_print(c(edx,  0, 0xf,       "        EDX  3- 0: Reserved"))
            gef_print(c(eax,  4, 1,         "        EDX     4: Hypercall input params via XMM registers"))
            gef_print(c(edx,  5, 0x3ff,     "        EDX 14- 5: Reserved"))
            gef_print(c(edx, 15, 1,         "        EDX    15: Hypercall output via XMM registers"))
            gef_print(c(edx, 16, 1,         "        EDX    16: Reserved"))
            gef_print(c(edx, 17, 1,         "        EDX    17: Soft interrupt polling mode available"))
            gef_print(c(edx, 18, 0x3fff,    "        EDX 31-18: Reserved"))
        elif id == 0x4000000a:
            gef_print("    Nested hypervisor feature indentification")
            gef_print(c(eax,  0, 0x1ffff,   "        EAX 16- 0: Reserved"))
            gef_print(c(eax, 17, 1,         "        EAX    17: Direct virtual flush hypercalls"))
            gef_print(c(eax, 18, 1,         "        EAX    18: Flush GPA space and list hypercalls"))
            gef_print(c(eax, 19, 1,         "        EAX    19: Enlightened MSR bitmaps"))
            gef_print(c(eax, 20, 1,         "        EAX    20: Combining virtualization exceptions in page fault exception class"))
            gef_print(c(eax, 21, 0x7ff,     "        EAX 31-21: Reserved"))
        elif id == 0x40000010:
            gef_print("    Hypervisor timing information")
            gef_print("    eax: (Virtual) TSC frequency in kHz")
            gef_print("    ebx: (Virtual) Bus (local apic timer) frequency in kHz")
            gef_print("    ecx,edx: Reserved")
        elif id == 0x80000000:
            gef_print("    eax: Maximum Input Value for Extended Function CPUID Information")
            gef_print("    ebx,ecx,edx: Reserved")
        elif id == 0x80000001:
            gef_print("    eax,ebx: Extended Processor Signature")
            gef_print("    edx,ecx: Extended Processor Feature")
            gef_print(c(edx,  0, 1,         "        EDX     0: FPU (Floating Point Unit on-chip)"))
            gef_print(c(edx,  1, 1,         "        EDX     1: VME (Virtual 8086 Mode Enhancements)"))
            gef_print(c(edx,  2, 1,         "        EDX     2: DE (Debugging Extensions)"))
            gef_print(c(edx,  3, 1,         "        EDX     3: PSE (Page Size Extension)"))
            gef_print(c(edx,  4, 1,         "        EDX     4: TSC (Time Stamp Counter)"))
            gef_print(c(edx,  5, 1,         "        EDX     5: MSR (Model Specific Registers RDMSR and WRMSR instructions)"))
            gef_print(c(edx,  6, 1,         "        EDX     6: PAE (Physical Address Extension)"))
            gef_print(c(edx,  7, 1,         "        EDX     7: MCE (Machine Check Exception)"))
            gef_print(c(edx,  8, 1,         "        EDX     8: CX8 (CMPXCHG8B instruction)"))
            gef_print(c(edx,  9, 1,         "        EDX     9: APIC (APIC on-chip)"))
            gef_print(c(edx, 10, 1,         "        EDX    10: Reserved"))
            gef_print(c(edx, 11, 1,         "        EDX    11: (Intel) SEP (SYSENTER and SYSEXIT instructions)"))
            gef_print(c(edx, 11, 1,         "        EDX    11: (AMD) SYSCALL (SYSCALL and SYSRET instructions)"))
            gef_print(c(edx, 12, 1,         "        EDX    12: MTRR (Memory Type Range Registers)"))
            gef_print(c(edx, 13, 1,         "        EDX    13: PGE (Page Global Bit)"))
            gef_print(c(edx, 14, 1,         "        EDX    14: MCA (Machine Check Architecture)"))
            gef_print(c(edx, 15, 1,         "        EDX    15: CMOV (Conditional MOVe instructions)"))
            gef_print(c(edx, 16, 1,         "        EDX    16: PAT (Page Attribute Table)"))
            gef_print(c(edx, 17, 1,         "        EDX    17: PSE-36 (36-Bit Page Size Extension)"))
            gef_print(c(edx, 18, 1,         "        EDX    18: Reserved"))
            gef_print(c(edx, 19, 1,         "        EDX    19: MP (MultiProcessing capable)"))
            gef_print(c(edx, 20, 1,         "        EDX    20: (Intel) XD (No-execute page protection)"))
            gef_print(c(edx, 20, 1,         "        EDX    20: (AMD) NX (No-execute page protection)"))
            gef_print(c(edx, 21, 1,         "        EDX    21: Reserved"))
            gef_print(c(edx, 22, 1,         "        EDX    22: MMX+ (MMX instruction extensions)"))
            gef_print(c(edx, 23, 1,         "        EDX    23: MMX (Intel MMX technology)"))
            gef_print(c(edx, 24, 1,         "        EDX    24: FXSR (FXSAVE and FXRSTOR instructions)"))
            gef_print(c(edx, 25, 1,         "        EDX    25: FFXSR (Fast FXSAVE/FXRSTOR)"))
            gef_print(c(edx, 26, 1,         "        EDX    26: P1GB (1GB Page support)"))
            gef_print(c(edx, 27, 1,         "        EDX    27: RDTSCP (RDTSCP instruction)"))
            gef_print(c(edx, 28, 1,         "        EDX    28: Reserved"))
            gef_print(c(edx, 29, 1,         "        EDX    29: LM (Long Mode (EM64T))"))
            gef_print(c(edx, 30, 1,         "        EDX    30: 3DNow!+ (3DNow! extended)"))
            gef_print(c(edx, 31, 1,         "        EDX    31: 3DNow! (3DNow! instructions)"))
            gef_print(c(ecx,  0, 1,         "        ECX     0: LAHF (LAHF/SAHF supported in 64-bit mode)"))
            gef_print(c(ecx,  1, 1,         "        ECX     1: CMPL (Core Multi-Processing Legacy mode)"))
            gef_print(c(ecx,  2, 1,         "        ECX     2: SVM (Secure Virtual Machine)"))
            gef_print(c(ecx,  3, 1,         "        ECX     3: EAS (Extended APIC Space)"))
            gef_print(c(ecx,  4, 1,         "        ECX     4: AMC8 (AltMovCr8; LOCK MOV CR0 means MOV CR8)"))
            gef_print(c(ecx,  5, 1,         "        ECX     5: ABM (Advanced Bit Manipulation; LZCNT instruction)"))
            gef_print(c(ecx,  6, 1,         "        ECX     6: SSE4A (SSE4A instructions)"))
            gef_print(c(ecx,  7, 1,         "        ECX     7: MASSE (Mis-Aligned SSE Support)"))
            gef_print(c(ecx,  8, 1,         "        ECX     8: PREFETCH (3DNow! PREFETCH/PREFETCHHW instructions)"))
            gef_print(c(ecx,  9, 1,         "        ECX     9: OSVW (OS-Visible Workaround)"))
            gef_print(c(ecx, 10, 1,         "        ECX    10: IBS (Instruction-Based Sampling)"))
            gef_print(c(ecx, 11, 1,         "        ECX    11: XOP (eXtended OPeration)"))
            gef_print(c(ecx, 12, 1,         "        ECX    12: SKINIT (SKINIT/STGI instructions)"))
            gef_print(c(ecx, 13, 1,         "        ECX    13: WDT (WatchDog Timer)"))
            gef_print(c(ecx, 14, 1,         "        ECX    14: Reserved"))
            gef_print(c(ecx, 15, 1,         "        ECX    15: LWP (Light Weight Profiling)"))
            gef_print(c(ecx, 16, 1,         "        ECX    16: FMA4 (4-operands FMA instructions)"))
            gef_print(c(ecx, 17, 1,         "        ECX    17: TCE (Translation Cache Extension)"))
            gef_print(c(ecx, 18, 1,         "        ECX    18: Reserved"))
            gef_print(c(ecx, 19, 1,         "        ECX    19: MSR (Node ID MSR"))
            gef_print(c(ecx, 20, 1,         "        ECX    20: Reserved"))
            gef_print(c(ecx, 21, 1,         "        ECX    21: TBM (Trailing Bit Manipulation instructions)"))
            gef_print(c(ecx, 22, 1,         "        ECX    22: TOPOEXT (TOPology EXTensions)"))
            gef_print(c(ecx, 23, 1,         "        ECX    23: PERFCTR_CORE (CORE PERFormance CounTeR extensions)"))
            gef_print(c(ecx, 24, 1,         "        ECX    24: PERFCTR_NB (NB PERFormance CounTeR extensions"))
            gef_print(c(ecx, 25, 1,         "        ECX    25: Streaming performance monitor architecture"))
            gef_print(c(ecx, 26, 1,         "        ECX    26: DBX (Data breakpoint eXtensions)"))
            gef_print(c(ecx, 27, 1,         "        ECX    27: PERFTSC (PERFormance Time Stamp Counter)"))
            gef_print(c(ecx, 28, 1,         "        ECX    28: PERFCTR_L2 (L2 PERFormance CounTeR extensions)"))
            gef_print(c(ecx, 29, 1,         "        ECX    29: MONITORX/MWAITX instructions"))
            gef_print(c(ecx, 30, 1,         "        ECX    30: Address mask extension for instruction breakpoint"))
            gef_print(c(ecx, 31, 1,         "        ECX    31: Reserved"))
        elif id in [0x80000002, 0x80000003, 0x80000004]:
            vid = (p32(eax) + p32(ebx) + p32(ecx) + p32(edx)).decode("utf-8")
            gef_print("    eax+ebx+ecx+edx: Processor Brand String (={:s})".format(repr(vid)))
        elif id == 0x80000005:
            gef_print("    L1 Cache Information")
            gef_print("    eax: 4/2 MB L1 TLB configuration descriptor")
            gef_print("    ebx: 4 KB L1 TLB configuration descriptor")
            gef_print("    ecx: data L1 cache configuration descriptor")
            gef_print("    edx: code L1 cache configuration descriptor")
        elif id == 0x80000006:
            gef_print("    L2/L3 Cache Information")
            gef_print("    eax: 4/2 MB L2 TLB configuration descriptor")
            gef_print("    ebx: 4 KB L2 TLB configuration descriptor")
            gef_print("    ecx: unified L2 cache configuration descriptor")
            gef_print("    edx: unified L3 cache configuration descriptor")
        elif id == 0x80000007:
            gef_print("    ebx: RAS Capabilities")
            gef_print(c(ebx,  0, 1,         "        EBX     0: MCA overflow recovery"))
            gef_print(c(ebx,  1, 1,         "        EBX     1: Software uncorrectable error containment and recovery"))
            gef_print(c(ebx,  2, 1,         "        EBX     2: HWA (HardWare Assert)"))
            gef_print(c(ebx,  3, 1,         "        EBX     3: Scalable MCA"))
            gef_print(c(ebx,  4, 1,         "        EBX     4: PFEH (Platform First Error Handling)"))
            gef_print(c(ebx,  5, 0x7ffffff, "        EBX 31- 5: Reserved"))
            gef_print("    edx: Advanced Power Management information")
            gef_print(c(edx,  0, 1,         "        EDX     0: TS (Temperature Sensor)"))
            gef_print(c(edx,  1, 1,         "        EDX     1: FID (Frequency ID control)"))
            gef_print(c(edx,  2, 1,         "        EDX     2: VID (Voltage ID control)"))
            gef_print(c(edx,  3, 1,         "        EDX     3: TTP (Thermal Trip)"))
            gef_print(c(edx,  4, 1,         "        EDX     4: TM (Thermal Monitoring)"))
            gef_print(c(edx,  5, 1,         "        EDX     5: STC (Software Thermal Control)"))
            gef_print(c(edx,  6, 1,         "        EDX     6: MUL (100MHz Multiplier steps)"))
            gef_print(c(edx,  7, 1,         "        EDX     7: HWPS (HardWare P-State control)"))
            gef_print(c(edx,  8, 1,         "        EDX     8: ITSC (Invariant TSC)"))
            gef_print(c(edx,  9, 1,         "        EDX     9: Core performance boost"))
            gef_print(c(edx, 10, 1,         "        EDX    10: Read-only effective frequency interface"))
            gef_print(c(edx, 11, 1,         "        EDX    11: Processor feedback interface"))
            gef_print(c(edx, 12, 1,         "        EDX    12: Core power reporting"))
            gef_print(c(edx, 13, 1,         "        EDX    13: Connected standby"))
            gef_print(c(edx, 14, 1,         "        EDX    14: RAPL (Running Average Power Limit)"))
            gef_print(c(edx, 15, 0x1ffff,   "        EAX 31-15: Reserved"))
        elif id == 0x80000008:
            gef_print("    eax: Extended Address Length Information")
            gef_print(c(eax,  0, 0xff,      "        EAX  7- 0: Physical address length"))
            gef_print(c(eax,  8, 0xff,      "        EAX 15- 8: Linear address length"))
            gef_print(c(eax, 16, 0xff,      "        EAX 23-16: Guest physical address length"))
            gef_print(c(eax, 24, 0xff,      "        EAX 31-24: Reserved"))
            gef_print("    ebx: Extended Feature Extensions ID")
            gef_print(c(ebx,  0, 1,         "        EBX     0: CLZERO (CLZERO instruction)"))
            gef_print(c(ebx,  1, 1,         "        EBX     1: IRPerf (Instructions Retired count support)"))
            gef_print(c(ebx,  2, 1,         "        EBX     2: XSAVE always saves/restores error pointers"))
            gef_print(c(ebx,  3, 1,         "        EBX     3: INVLPGB and TLBSYNC instruction"))
            gef_print(c(ebx,  4, 1,         "        EBX     4: RDPRU (RDPRU instruction)"))
            gef_print(c(ebx,  5, 1,         "        EBX     5: Reserved"))
            gef_print(c(ebx,  6, 1,         "        EBX     6: MBE (Memory Bandwidth Enforcement)"))
            gef_print(c(ebx,  7, 1,         "        EBX     7: Reserved"))
            gef_print(c(ebx,  8, 1,         "        EBX     8: MCOMMIT (MCOMMIT instruction)"))
            gef_print(c(ebx,  9, 1,         "        EBX     9: WBNOINVD (Write Back and do NOt INValiDate cache)"))
            gef_print(c(ebx, 10, 1,         "        EBX    10: LBR extensions"))
            gef_print(c(ebx, 11, 1,         "        EBX    11: Reserved"))
            gef_print(c(ebx, 12, 1,         "        EBX    12: IBPB (Indirect Branch Prediction Barrier)"))
            gef_print(c(ebx, 13, 1,         "        EBX    13: WBINVD (Write Back and INValiDate cache)"))
            gef_print(c(ebx, 14, 1,         "        EBX    14: IBRS (Indirect Branch Restricted Speculation)"))
            gef_print(c(ebx, 15, 1,         "        EBX    15: STIBP (Single Thread Indirect Branch Predictor)"))
            gef_print(c(ebx, 16, 1,         "        EBX    16: Reserved"))
            gef_print(c(ebx, 17, 1,         "        EBX    17: STIBP always on"))
            gef_print(c(ebx, 18, 1,         "        EBX    18: IBRS preferred over software solution"))
            gef_print(c(ebx, 19, 1,         "        EBX    19: IBRS provides Same Mode Protection"))
            gef_print(c(ebx, 20, 1,         "        EBX    20: EFER.LMLSE is unsupported"))
            gef_print(c(ebx, 21, 1,         "        EBX    21: INVLPGB for guest nested translations"))
            gef_print(c(ebx, 22, 1,         "        EBX    22: Reserved"))
            gef_print(c(ebx, 23, 1,         "        EBX    23: PPIN (Protected Processor Inventory Number)"))
            gef_print(c(ebx, 24, 1,         "        EBX    24: SSBD (Speculative Store Bypass Disable)"))
            gef_print(c(ebx, 25, 1,         "        EBX    25: VIRT_SPEC_CTL"))
            gef_print(c(ebx, 26, 1,         "        EBX    26: SSBD no longer needed"))
            gef_print(c(ebx, 27, 1,         "        EBX    27: CPPC (Collaborative Processor Performance Control)"))
            gef_print(c(ebx, 28, 1,         "        EBX    28: PSFD (Predictive Store Forward Disable)"))
            gef_print(c(ebx, 29, 1,         "        EBX    29: Reserved"))
            gef_print(c(ebx, 30, 1,         "        EBX    30: Reserved"))
            gef_print(c(ebx, 31, 1,         "        EBX    31: Reserved"))
            gef_print("    ecx: Extended Core Information")
            gef_print(c(ecx,  0, 0xff,      "        ECX  7- 0: Number of cores per (number of dies-1)"))
            gef_print(c(ecx,  8, 0xf,       "        ECX 11- 8: Reserved"))
            gef_print(c(ecx, 12, 0xf,       "        ECX 15-12: Number of LSBs in APIC ID that indicate core ID"))
            gef_print(c(ecx, 16, 0xffff,    "        ECX 31-16: Reserved"))
        elif id == 0x8000000a:
            gef_print("    SVM Revision and Feature Identification")
            gef_print(c(edx,  0, 1,         "        EDX     0: Nested paging"))
            gef_print(c(edx,  1, 1,         "        EDX     1: LBR virtualization"))
            gef_print(c(edx,  2, 1,         "        EDX     2: SVM lock"))
            gef_print(c(edx,  3, 1,         "        EDX     3: NRIP save"))
            gef_print(c(edx,  4, 1,         "        EDX     4: MSR-based TSC rate control"))
            gef_print(c(edx,  5, 1,         "        EDX     5: VMCB clean bits"))
            gef_print(c(edx,  6, 1,         "        EDX     6: Flush by ASID"))
            gef_print(c(edx,  7, 1,         "        EDX     7: Decode assists"))
            gef_print(c(edx,  8, 1,         "        EDX     8: Reserved"))
            gef_print(c(edx,  9, 1,         "        EDX     9: Reserved"))
            gef_print(c(edx, 10, 1,         "        EDX    10: Pause intercept filter"))
            gef_print(c(edx, 11, 1,         "        EDX    11: Encrypted micro-code patch"))
            gef_print(c(edx, 12, 1,         "        EDX    12: PAUSE filter threshold"))
            gef_print(c(edx, 13, 1,         "        EDX    13: AMD virtual interrupt controller"))
            gef_print(c(edx, 14, 1,         "        EDX    14: Reserved"))
            gef_print(c(edx, 15, 1,         "        EDX    15: Virtualized VMLOAD/VMSAVE"))
            gef_print(c(edx, 16, 1,         "        EDX    16: Virtualized GIF"))
            gef_print(c(edx, 17, 1,         "        EDX    17: GMET (Guest Mode Execution Trap"))
            gef_print(c(edx, 18, 1,         "        EDX    18: Reserved"))
            gef_print(c(edx, 19, 1,         "        EDX    19: SVM supervisor shadow stack restrictions"))
            gef_print(c(edx, 20, 1,         "        EDX    20: SPEC_CTRL virtualization"))
            gef_print(c(edx, 21, 1,         "        EDX    21: Reserved"))
            gef_print(c(edx, 22, 1,         "        EDX    22: Reserved"))
            gef_print(c(edx, 23, 1,         "        EDX    23: Host MCE override"))
            gef_print(c(edx, 24, 1,         "        EDX    24: INVLPGB/TLBSYNC hypervisor enable"))
            gef_print(c(edx, 25, 0x7f,      "        EDX 31-25: Reserved"))
        elif id == 0x80000019:
            gef_print("    TLB Configuration Descriptors")
        elif id == 0x8000001a:
            gef_print("    Performance Optimization Identifiers")
            gef_print(c(eax,  0, 1,         "        EAX     0: FP128 (128-bit SSE full-width pipelines)"))
            gef_print(c(eax,  1, 1,         "        EAX     1: MOVU (Efficient MOVU SSE instructions)"))
            gef_print(c(eax,  2, 1,         "        EAX     2: FP256 (256-bit AVX full-width pipelines)"))
            gef_print(c(eax,  3, 0x1fffffff,"        EAX 31- 3: Reserved"))
        elif id == 0x8000001b:
            gef_print("    Instruction Based Sampling Identifiers")
            gef_print(c(eax,  0, 1,         "        EAX     0: IBSFFV (IBS Feature Flags Valid)"))
            gef_print(c(eax,  1, 1,         "        EAX     1: FetchSam (IBS Fetch Sampling)"))
            gef_print(c(eax,  2, 1,         "        EAX     2: OpSam (IBS Execution Sampling)"))
            gef_print(c(eax,  3, 1,         "        EAX     3: RdWrOpCnt (Read/write of Op Counter)"))
            gef_print(c(eax,  4, 1,         "        EAX     4: OpCnt (Op Counting mode)"))
            gef_print(c(eax,  5, 1,         "        EAX     5: BrnTrgt (Branch Target address reporting)"))
            gef_print(c(eax,  6, 1,         "        EAX     6: OpCntExt (IBS op cur/max count extended by 7 bits)"))
            gef_print(c(eax,  7, 1,         "        EAX     7: RipInvalidChk (IBS RIP invalid indication)"))
            gef_print(c(eax,  8, 1,         "        EAX     8: OpBrnFuse (IBS fused Branch micro-op indication)"))
            gef_print(c(eax,  9, 1,         "        EAX     9: IbsFetchCtlExtd (IBS Fetch Control Extended MSR)"))
            gef_print(c(eax, 10, 1,         "        EAX    10: IbsOpData4 (IBS Op Data 4 MSR)"))
            gef_print(c(eax, 11, 0x1fffff,  "        EAX 31-11: Reserved"))
        elif id == 0x8fffffff:
            vid = (p32(eax) + p32(ebx) + p32(ecx) + p32(edx)).decode("utf-8")
            gef_print("    eax+ebx+ecx+edx: Easter egg (={:s})".format(repr(vid)))
        elif id == 0xc0000000:
            gef_print("    eax: Maximum Input Value for Extended Function CPUID Information")
            gef_print("    ebx,ecx,edx: Reserved")
        elif id == 0xc0000001:
            gef_print("    Centaur features")
            gef_print(c(edx,  0, 1,         "        EDX     0: AIS (Alternate Instruction Set available)"))
            gef_print(c(edx,  1, 1,         "        EDX     1: AIS_EN (Alternate Instruction Set ENabled)"))
            gef_print(c(edx,  2, 1,         "        EDX     2: RNG (Random Number Generator available)"))
            gef_print(c(edx,  3, 1,         "        EDX     3: RNG_EN (Random Number Generator ENabled)"))
            gef_print(c(edx,  4, 1,         "        EDX     4: LH (LongHaul MSR 0000_110Ah)"))
            gef_print(c(edx,  5, 1,         "        EDX     5: FEMMS"))
            gef_print(c(edx,  6, 1,         "        EDX     6: ACE (Advanced Cryptography Engine available)"))
            gef_print(c(edx,  7, 1,         "        EDX     7: ACE_EN (Advanced Cryptography Engine Enabled)"))
            gef_print(c(edx,  8, 1,         "        EDX     8: ACE2 (Montgomery Multiplier and Hash Engine available)"))
            gef_print(c(edx,  9, 1,         "        EDX     9: ACE2_EN (Montgomery Multiplier and Hash Engine Enabled)"))
            gef_print(c(edx, 10, 1,         "        EDX    10: PHE (Padlock Hash Engine available)"))
            gef_print(c(edx, 11, 1,         "        EDX    11: PHE_EN (Padlock Hash Engine ENabled)"))
            gef_print(c(edx, 12, 1,         "        EDX    12: PMM (Padlock Montgomery Multiplier available)"))
            gef_print(c(edx, 13, 1,         "        EDX    13: PMM_EN (Padlock Montgomery Multiplier ENabled)"))
            gef_print(c(edx, 14, 0x3ffff,   "        EAX 31-14: Reserved"))
        return

    @only_if_gdb_running
    @only_if_x86_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            argv.remove("-h")
            self.usage()
            return

        # Basic Information
        eax, _, _, _ = self.execute_cpuid(0)
        valid_max_cpuid = min(eax, 0x20)

        for id in range(valid_max_cpuid + 1):
            if id == 4:
                for subid in range(3):
                    eax, ebx, ecx, edx = self.execute_cpuid(id, subid)
                    self.show_result(id, subid, eax, ebx, ecx, edx)
            elif id == 7:
                eax, _, _, _ = self.execute_cpuid(id, 0)
                for subid in range(eax + 1):
                    eax, ebx, ecx, edx = self.execute_cpuid(id, subid)
                    self.show_result(id, subid, eax, ebx, ecx, edx)
            elif id == 13:
                for subid in range(63):
                    eax, ebx, ecx, edx = self.execute_cpuid(id, subid)
                    self.show_result(id, subid, eax, ebx, ecx, edx)
            elif id in [16, 18, 19, 20, 23, 24, 26, 31]:
                eax, ebx, ecx, edx = self.execute_cpuid(id, 0)
                self.show_result(id, 0, eax, ebx, ecx, edx)
            else:
                eax, ebx, ecx, edx = self.execute_cpuid(id)
                self.show_result(id, None, eax, ebx, ecx, edx)

        # Hypervisor Information
        valid_max_cpuid, _, _, _ = self.execute_cpuid(0x40000000)
        for id in range(0x40000000, valid_max_cpuid + 1):
            eax, ebx, ecx, edx = self.execute_cpuid(id)
            self.show_result(id, None, eax, ebx, ecx, edx)

        # Extended Information
        valid_max_cpuid, _, _, _ = self.execute_cpuid(0x80000000)
        for id in range(0x80000000, valid_max_cpuid + 1):
            eax, ebx, ecx, edx = self.execute_cpuid(id)
            self.show_result(id, None, eax, ebx, ecx, edx)
        for id in [0x8fffffff,]:
            eax, ebx, ecx, edx = self.execute_cpuid(id)
            self.show_result(id, None, eax, ebx, ecx, edx)

        # Transmeta Specific Information
        valid_max_cpuid, _, _, _ = self.execute_cpuid(0x80860000)
        for id in range(0x80860000, valid_max_cpuid + 1):
            eax, ebx, ecx, edx = self.execute_cpuid(id)
            self.show_result(id, None, eax, ebx, ecx, edx)

        # Centaur(VIA) Specific Information
        valid_max_cpuid, _, _, _ = self.execute_cpuid(0xc0000000)
        for id in range(0xc0000000, valid_max_cpuid + 1):
            eax, ebx, ecx, edx = self.execute_cpuid(id)
            self.show_result(id, None, eax, ebx, ecx, edx)
        return


@register_command
class MsrCommand(GenericCommand):
    """Get MSR via kernel."""
    _cmdline_ = "msr"
    _syntax_ = "{:s} [-h] [-l] MSR_VALUE|MSR_NAME".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} 0xc0000080 # rcx value\n".format(_cmdline_)
    _example_ += "{:s} MSR_EFER # another valid format\n".format(_cmdline_)
    _example_ += "{:s} -l # list known MSR const values\n".format(_cmdline_)
    _example_ += "{:s} -l MSR_EFER MSR_GS_BASE MSR_FS_BASE # show specific MSR const value\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "DISABLE `-enbale-kvm` option for qemu-system; This command will be aborted if the option is set"
    _category_ = "Show/Modify Register"

    msr_table = [
        ["MSR_EFER",                         0xc0000080, "Extended feature register"],
        ["MSR_STAR",                         0xc0000081, "Legacy mode SYSCALL target"],
        ["MSR_LSTAR",                        0xc0000082, "Long mode SYSCALL target"],
        ["MSR_CSTAR",                        0xc0000083, "Compat mode SYSCALL target"],
        ["MSR_SYSCALL_MASK",                 0xc0000084, "EFLAGS mask for syscall"],
        ["MSR_FS_BASE",                      0xc0000100, "64bit FS base"],
        ["MSR_GS_BASE",                      0xc0000101, "64bit GS base"],
        ["MSR_KERNEL_GS_BASE",               0xc0000102, "SwapGS GS shadow"],
        ["MSR_TSC_AUX",                      0xc0000103, "Auxiliary TSC"],
        ["MSR_TEST_CTRL",                    0x00000033, ""],
        ["MSR_IA32_SPEC_CTRL",               0x00000048, "Speculation Control"],
        ["MSR_IA32_PRED_CMD",                0x00000049, "Prediction Command"],
        ["MSR_PPIN_CTL",                     0x0000004e, ""],
        ["MSR_PPIN",                         0x0000004f, ""],
        ["MSR_IA32_PERFCTR",                 0x000000c1, ""],
        ["MSR_IA32_PERFCTR",                 0x000000c2, ""],
        ["MSR_FSB_FREQ",                     0x000000cd, ""],
        ["MSR_PLATFORM_INFO",                0x000000ce, ""],
        ["MSR_IA32_CORE_CAPS",               0x000000cf, ""],
        ["MSR_IA32_UMWAIT_CONTROL",          0x000000e1, ""],
        ["MSR_PKG_CST_CONFIG_CONTROL",       0x000000e2, ""],
        ["MSR_MTRRcap",                      0x000000fe, ""],
        ["MSR_IA32_ARCH_CAPABILITIES",       0x0000010a, ""],
        ["MSR_IA32_FLUSH_CMD",               0x0000010b, ""],
        ["MSR_IA32_BBL_CR_CTL",              0x00000119, ""],
        ["MSR_IA32_BBL_CR_CTL3",             0x0000011e, ""],
        ["MSR_IA32_TSX_CTRL",                0x00000122, ""],
        ["MSR_IA32_MCU_OPT_CTRL",            0x00000123, ""],
        ["MSR_IA32_SYSENTER_CS",             0x00000174, ""],
        ["MSR_IA32_SYSENTER_ESP",            0x00000175, ""],
        ["MSR_IA32_SYSENTER_EIP",            0x00000176, ""],
        ["MSR_IA32_MCG_CAP",                 0x00000179, ""],
        ["MSR_IA32_MCG_STATUS",              0x0000017a, ""],
        ["MSR_IA32_MCG_CTL",                 0x0000017b, ""],
        ["MSR_IA32_MCG_EXT_CTL",             0x000004d0, ""],
        ["MSR_OFFCORE_RSP_0",                0x000001a6, ""],
        ["MSR_OFFCORE_RSP_1",                0x000001a7, ""],
        ["MSR_TURBO_RATIO_LIMIT",            0x000001ad, ""],
        ["MSR_TURBO_RATIO_LIMIT1",           0x000001ae, ""],
        ["MSR_TURBO_RATIO_LIMIT2",           0x000001af, ""],
        ["MSR_LBR_SELECT",                   0x000001c8, ""],
        ["MSR_LBR_TOS",                      0x000001c9, ""],
        ["MSR_IA32_POWER_CTL",               0x000001fc, ""],
        ["MSR_LBR_NHM_FROM",                 0x00000680, ""],
        ["MSR_LBR_NHM_TO",                   0x000006c0, ""],
        ["MSR_LBR_CORE_FROM",                0x00000040, ""],
        ["MSR_LBR_CORE_TO",                  0x00000060, ""],
        ["MSR_LBR_INFO_0",                   0x00000dc0, ""],
        ["MSR_LBR_INFO_1",                   0x00000dc1, ""],
        ["MSR_LBR_INFO_2",                   0x00000dc2, ""],
        ["MSR_LBR_INFO_3",                   0x00000dc3, ""],
        ["MSR_LBR_INFO_4",                   0x00000dc4, ""],
        ["MSR_LBR_INFO_5",                   0x00000dc5, ""],
        ["MSR_LBR_INFO_6",                   0x00000dc6, ""],
        ["MSR_LBR_INFO_7",                   0x00000dc7, ""],
        ["MSR_LBR_INFO_8",                   0x00000dc8, ""],
        ["MSR_LBR_INFO_9",                   0x00000dc9, ""],
        ["MSR_LBR_INFO_10",                  0x00000dca, ""],
        ["MSR_LBR_INFO_11",                  0x00000dcb, ""],
        ["MSR_LBR_INFO_12",                  0x00000dcc, ""],
        ["MSR_LBR_INFO_13",                  0x00000dcd, ""],
        ["MSR_LBR_INFO_14",                  0x00000dce, ""],
        ["MSR_LBR_INFO_15",                  0x00000dcf, ""],
        ["MSR_LBR_INFO_16",                  0x00000dd0, ""],
        ["MSR_LBR_INFO_17",                  0x00000dd1, ""],
        ["MSR_LBR_INFO_18",                  0x00000dd2, ""],
        ["MSR_LBR_INFO_19",                  0x00000dd3, ""],
        ["MSR_LBR_INFO_20",                  0x00000dd4, ""],
        ["MSR_LBR_INFO_21",                  0x00000dd5, ""],
        ["MSR_LBR_INFO_22",                  0x00000dd6, ""],
        ["MSR_LBR_INFO_23",                  0x00000dd7, ""],
        ["MSR_LBR_INFO_24",                  0x00000dd8, ""],
        ["MSR_LBR_INFO_25",                  0x00000dd9, ""],
        ["MSR_LBR_INFO_26",                  0x00000dda, ""],
        ["MSR_LBR_INFO_27",                  0x00000ddb, ""],
        ["MSR_LBR_INFO_28",                  0x00000ddc, ""],
        ["MSR_LBR_INFO_29",                  0x00000ddd, ""],
        ["MSR_LBR_INFO_30",                  0x00000dde, ""],
        ["MSR_LBR_INFO_31",                  0x00000ddf, ""],
        ["MSR_ARCH_LBR_CTL",                 0x000014ce, ""],
        ["MSR_ARCH_LBR_DEPTH",               0x000014cf, ""],
        ["MSR_ARCH_LBR_FROM_0",              0x00001500, ""],
        ["MSR_ARCH_LBR_TO_0",                0x00001600, ""],
        ["MSR_ARCH_LBR_INFO_0",              0x00001200, ""],
        ["MSR_IA32_PEBS_ENABLE",             0x000003f1, ""],
        ["MSR_PEBS_DATA_CFG",                0x000003f2, ""],
        ["MSR_IA32_DS_AREA",                 0x00000600, ""],
        ["MSR_IA32_PERF_CAPABILITIES",       0x00000345, ""],
        ["MSR_PEBS_LD_LAT_THRESHOLD",        0x000003f6, ""],
        ["MSR_IA32_RTIT_CTL",                0x00000570, ""],
        ["MSR_IA32_RTIT_STATUS",             0x00000571, ""],
        ["MSR_IA32_RTIT_ADDR0_A",            0x00000580, ""],
        ["MSR_IA32_RTIT_ADDR0_B",            0x00000581, ""],
        ["MSR_IA32_RTIT_ADDR1_A",            0x00000582, ""],
        ["MSR_IA32_RTIT_ADDR1_B",            0x00000583, ""],
        ["MSR_IA32_RTIT_ADDR2_A",            0x00000584, ""],
        ["MSR_IA32_RTIT_ADDR2_B",            0x00000585, ""],
        ["MSR_IA32_RTIT_ADDR3_A",            0x00000586, ""],
        ["MSR_IA32_RTIT_ADDR3_B",            0x00000587, ""],
        ["MSR_IA32_RTIT_CR3_MATCH",          0x00000572, ""],
        ["MSR_IA32_RTIT_OUTPUT_BASE",        0x00000560, ""],
        ["MSR_IA32_RTIT_OUTPUT_MASK",        0x00000561, ""],
        ["MSR_MTRRfix64K_00000",             0x00000250, ""],
        ["MSR_MTRRfix16K_80000",             0x00000258, ""],
        ["MSR_MTRRfix16K_A0000",             0x00000259, ""],
        ["MSR_MTRRfix4K_C0000",              0x00000268, ""],
        ["MSR_MTRRfix4K_C8000",              0x00000269, ""],
        ["MSR_MTRRfix4K_D0000",              0x0000026a, ""],
        ["MSR_MTRRfix4K_D8000",              0x0000026b, ""],
        ["MSR_MTRRfix4K_E0000",              0x0000026c, ""],
        ["MSR_MTRRfix4K_E8000",              0x0000026d, ""],
        ["MSR_MTRRfix4K_F0000",              0x0000026e, ""],
        ["MSR_MTRRfix4K_F8000",              0x0000026f, ""],
        ["MSR_MTRRdefType",                  0x000002ff, ""],
        ["MSR_IA32_CR_PAT",                  0x00000277, ""],
        ["MSR_IA32_DEBUGCTLMSR",             0x000001d9, ""],
        ["MSR_IA32_LASTBRANCHFROMIP",        0x000001db, ""],
        ["MSR_IA32_LASTBRANCHTOIP",          0x000001dc, ""],
        ["MSR_IA32_LASTINTFROMIP",           0x000001dd, ""],
        ["MSR_IA32_LASTINTTOIP",             0x000001de, ""],
        ["MSR_PEBS_FRONTEND",                0x000003f7, ""],
        ["MSR_IA32_MC0_CTL",                 0x00000400, ""],
        ["MSR_IA32_MC0_STATUS",              0x00000401, ""],
        ["MSR_IA32_MC0_ADDR",                0x00000402, ""],
        ["MSR_IA32_MC0_MISC",                0x00000403, ""],
        ["MSR_PKG_C3_RESIDENCY",             0x000003f8, ""],
        ["MSR_PKG_C6_RESIDENCY",             0x000003f9, ""],
        ["MSR_ATOM_PKG_C6_RESIDENCY",        0x000003fa, ""],
        ["MSR_PKG_C7_RESIDENCY",             0x000003fa, ""],
        ["MSR_CORE_C3_RESIDENCY",            0x000003fc, ""],
        ["MSR_CORE_C6_RESIDENCY",            0x000003fd, ""],
        ["MSR_CORE_C7_RESIDENCY",            0x000003fe, ""],
        ["MSR_KNL_CORE_C6_RESIDENCY",        0x000003ff, ""],
        ["MSR_PKG_C2_RESIDENCY",             0x0000060d, ""],
        ["MSR_PKG_C8_RESIDENCY",             0x00000630, ""],
        ["MSR_PKG_C9_RESIDENCY",             0x00000631, ""],
        ["MSR_PKG_C10_RESIDENCY",            0x00000632, ""],
        ["MSR_PKGC3_IRTL",                   0x0000060a, ""],
        ["MSR_PKGC6_IRTL",                   0x0000060b, ""],
        ["MSR_PKGC7_IRTL",                   0x0000060c, ""],
        ["MSR_PKGC8_IRTL",                   0x00000633, ""],
        ["MSR_PKGC9_IRTL",                   0x00000634, ""],
        ["MSR_PKGC10_IRTL",                  0x00000635, ""],
        ["MSR_RAPL_POWER_UNIT",              0x00000606, ""],
        ["MSR_PKG_POWER_LIMIT",              0x00000610, ""],
        ["MSR_PKG_ENERGY_STATUS",            0x00000611, ""],
        ["MSR_PKG_PERF_STATUS",              0x00000613, ""],
        ["MSR_PKG_POWER_INFO",               0x00000614, ""],
        ["MSR_DRAM_POWER_LIMIT",             0x00000618, ""],
        ["MSR_DRAM_ENERGY_STATUS",           0x00000619, ""],
        ["MSR_DRAM_PERF_STATUS",             0x0000061b, ""],
        ["MSR_DRAM_POWER_INFO",              0x0000061c, ""],
        ["MSR_PP0_POWER_LIMIT",              0x00000638, ""],
        ["MSR_PP0_ENERGY_STATUS",            0x00000639, ""],
        ["MSR_PP0_POLICY",                   0x0000063a, ""],
        ["MSR_PP0_PERF_STATUS",              0x0000063b, ""],
        ["MSR_PP1_POWER_LIMIT",              0x00000640, ""],
        ["MSR_PP1_ENERGY_STATUS",            0x00000641, ""],
        ["MSR_PP1_POLICY",                   0x00000642, ""],
        ["MSR_AMD_PKG_ENERGY_STATUS",        0xc001029b, ""],
        ["MSR_AMD_RAPL_POWER_UNIT",          0xc0010299, ""],
        ["MSR_CONFIG_TDP_NOMINAL",           0x00000648, ""],
        ["MSR_CONFIG_TDP_LEVEL_1",           0x00000649, ""],
        ["MSR_CONFIG_TDP_LEVEL_2",           0x0000064a, ""],
        ["MSR_CONFIG_TDP_CONTROL",           0x0000064b, ""],
        ["MSR_TURBO_ACTIVATION_RATIO",       0x0000064c, ""],
        ["MSR_PLATFORM_ENERGY_STATUS",       0x0000064d, ""],
        ["MSR_PKG_WEIGHTED_CORE_C0_RES",     0x00000658, ""],
        ["MSR_PKG_ANY_CORE_C0_RES",          0x00000659, ""],
        ["MSR_PKG_ANY_GFXE_C0_RES",          0x0000065a, ""],
        ["MSR_PKG_BOTH_CORE_GFXE_C0_RES",    0x0000065b, ""],
        ["MSR_CORE_C1_RES",                  0x00000660, ""],
        ["MSR_MODULE_C6_RES_MS",             0x00000664, ""],
        ["MSR_CC6_DEMOTION_POLICY_CONFIG",   0x00000668, ""],
        ["MSR_MC6_DEMOTION_POLICY_CONFIG",   0x00000669, ""],
        ["MSR_ATOM_CORE_RATIOS",             0x0000066a, ""],
        ["MSR_ATOM_CORE_VIDS",               0x0000066b, ""],
        ["MSR_ATOM_CORE_TURBO_RATIOS",       0x0000066c, ""],
        ["MSR_ATOM_CORE_TURBO_VIDS",         0x0000066d, ""],
        ["MSR_CORE_PERF_LIMIT_REASONS",      0x00000690, ""],
        ["MSR_GFX_PERF_LIMIT_REASONS",       0x000006b0, ""],
        ["MSR_RING_PERF_LIMIT_REASONS",      0x000006b1, ""],
        ["MSR_PPERF",                        0x0000064e, ""],
        ["MSR_PERF_LIMIT_REASONS",           0x0000064f, ""],
        ["MSR_PM_ENABLE",                    0x00000770, ""],
        ["MSR_HWP_CAPABILITIES",             0x00000771, ""],
        ["MSR_HWP_REQUEST_PKG",              0x00000772, ""],
        ["MSR_HWP_INTERRUPT",                0x00000773, ""],
        ["MSR_HWP_REQUEST",                  0x00000774, ""],
        ["MSR_HWP_STATUS",                   0x00000777, ""],
        ["MSR_AMD64_MC0_MASK",               0xc0010044, ""],
        ["MSR_IA32_MC0_CTL2",                0x00000280, ""],
        ["MSR_P6_PERFCTR0",                  0x000000c1, ""],
        ["MSR_P6_PERFCTR1",                  0x000000c2, ""],
        ["MSR_P6_EVNTSEL0",                  0x00000186, ""],
        ["MSR_P6_EVNTSEL1",                  0x00000187, ""],
        ["MSR_KNC_PERFCTR0",                 0x00000020, ""],
        ["MSR_KNC_PERFCTR1",                 0x00000021, ""],
        ["MSR_KNC_EVNTSEL0",                 0x00000028, ""],
        ["MSR_KNC_EVNTSEL1",                 0x00000029, ""],
        ["MSR_IA32_PMC0",                    0x000004c1, ""],
        ["MSR_RELOAD_PMC0",                  0x000014c1, ""],
        ["MSR_RELOAD_FIXED_CTR0",            0x00001309, ""],
        ["MSR_AMD64_PATCH_LEVEL",            0x0000008b, ""],
        ["MSR_AMD64_TSC_RATIO",              0xc0000104, ""],
        ["MSR_AMD64_NB_CFG",                 0xc001001f, ""],
        ["MSR_AMD64_PATCH_LOADER",           0xc0010020, ""],
        ["MSR_AMD_PERF_CTL",                 0xc0010062, ""],
        ["MSR_AMD_PERF_STATUS",              0xc0010063, ""],
        ["MSR_AMD_PSTATE_DEF_BASE",          0xc0010064, ""],
        ["MSR_AMD64_OSVW_ID_LENGTH",         0xc0010140, ""],
        ["MSR_AMD64_OSVW_STATUS",            0xc0010141, ""],
        ["MSR_AMD_PPIN_CTL",                 0xc00102f0, ""],
        ["MSR_AMD_PPIN",                     0xc00102f1, ""],
        ["MSR_AMD64_CPUID_FN_1",             0xc0011004, ""],
        ["MSR_AMD64_LS_CFG",                 0xc0011020, ""],
        ["MSR_AMD64_DC_CFG",                 0xc0011022, ""],
        ["MSR_AMD64_BU_CFG2",                0xc001102a, ""],
        ["MSR_AMD64_IBSFETCHCTL",            0xc0011030, ""],
        ["MSR_AMD64_IBSFETCHLINAD",          0xc0011031, ""],
        ["MSR_AMD64_IBSFETCHPHYSAD",         0xc0011032, ""],
        ["MSR_AMD64_IBSOPCTL",               0xc0011033, ""],
        ["MSR_AMD64_IBSOPRIP",               0xc0011034, ""],
        ["MSR_AMD64_IBSOPDATA",              0xc0011035, ""],
        ["MSR_AMD64_IBSOPDATA2",             0xc0011036, ""],
        ["MSR_AMD64_IBSOPDATA3",             0xc0011037, ""],
        ["MSR_AMD64_IBSDCLINAD",             0xc0011038, ""],
        ["MSR_AMD64_IBSDCPHYSAD",            0xc0011039, ""],
        ["MSR_AMD64_IBSCTL",                 0xc001103a, ""],
        ["MSR_AMD64_IBSBRTARGET",            0xc001103b, ""],
        ["MSR_AMD64_IBSOPDATA4",             0xc001103d, ""],
        ["MSR_AMD64_SEV",                    0xc0010131, ""],
        ["MSR_AMD64_VIRT_SPEC_CTRL",         0xc001011f, ""],
        ["MSR_F17H_IRPERF",                  0xc00000e9, ""],
        ["MSR_F16H_L2I_PERF_CTL",            0xc0010230, ""],
        ["MSR_F16H_L2I_PERF_CTR",            0xc0010231, ""],
        ["MSR_F16H_DR1_ADDR_MASK",           0xc0011019, ""],
        ["MSR_F16H_DR2_ADDR_MASK",           0xc001101a, ""],
        ["MSR_F16H_DR3_ADDR_MASK",           0xc001101b, ""],
        ["MSR_F16H_DR0_ADDR_MASK",           0xc0011027, ""],
        ["MSR_F15H_CU_PWR_ACCUMULATOR",      0xc001007a, ""],
        ["MSR_F15H_CU_MAX_PWR_ACCUMULATOR",  0xc001007b, ""],
        ["MSR_F15H_PERF_CTL0",               0xc0010200, ""],
        ["MSR_F15H_PERF_CTL1",               0xc0010202, ""],
        ["MSR_F15H_PERF_CTL2",               0xc0010204, ""],
        ["MSR_F15H_PERF_CTL3",               0xc0010206, ""],
        ["MSR_F15H_PERF_CTL4",               0xc0010208, ""],
        ["MSR_F15H_PERF_CTL5",               0xc001020a, ""],
        ["MSR_F15H_PERF_CTR0",               0xc0010201, ""],
        ["MSR_F15H_PERF_CTR1",               0xc0010203, ""],
        ["MSR_F15H_PERF_CTR2",               0xc0010205, ""],
        ["MSR_F15H_PERF_CTR3",               0xc0010207, ""],
        ["MSR_F15H_PERF_CTR4",               0xc0010209, ""],
        ["MSR_F15H_PERF_CTR5",               0xc001020b, ""],
        ["MSR_F15H_NB_PERF_CTL",             0xc0010240, ""],
        ["MSR_F15H_NB_PERF_CTR",             0xc0010241, ""],
        ["MSR_F15H_PTSC",                    0xc0010280, ""],
        ["MSR_F15H_IC_CFG",                  0xc0011021, ""],
        ["MSR_F15H_EX_CFG",                  0xc001102c, ""],
        ["MSR_FAM10H_MMIO_CONF_BASE",        0xc0010058, ""],
        ["MSR_FAM10H_NODE_ID",               0xc001100c, ""],
        ["MSR_F10H_DECFG",                   0xc0011029, ""],
        ["MSR_K8_TOP_MEM1",                  0xc001001a, ""],
        ["MSR_K8_TOP_MEM2",                  0xc001001d, ""],
        ["MSR_K8_SYSCFG",                    0xc0010010, ""],
        ["MSR_K8_INT_PENDING_MSG",           0xc0010055, ""],
        ["MSR_K8_TSEG_ADDR",                 0xc0010112, ""],
        ["MSR_K8_TSEG_MASK",                 0xc0010113, ""],
        ["MSR_K7_EVNTSEL0",                  0xc0010000, ""],
        ["MSR_K7_PERFCTR0",                  0xc0010004, ""],
        ["MSR_K7_EVNTSEL1",                  0xc0010001, ""],
        ["MSR_K7_PERFCTR1",                  0xc0010005, ""],
        ["MSR_K7_EVNTSEL2",                  0xc0010002, ""],
        ["MSR_K7_PERFCTR2",                  0xc0010006, ""],
        ["MSR_K7_EVNTSEL3",                  0xc0010003, ""],
        ["MSR_K7_PERFCTR3",                  0xc0010007, ""],
        ["MSR_K7_CLK_CTL",                   0xc001001b, ""],
        ["MSR_K7_HWCR",                      0xc0010015, ""],
        ["MSR_K7_FID_VID_CTL",               0xc0010041, ""],
        ["MSR_K7_FID_VID_STATUS",            0xc0010042, ""],
        ["MSR_K6_WHCR",                      0xc0000082, ""],
        ["MSR_K6_UWCCR",                     0xc0000085, ""],
        ["MSR_K6_EPMR",                      0xc0000086, ""],
        ["MSR_K6_PSOR",                      0xc0000087, ""],
        ["MSR_K6_PFIR",                      0xc0000088, ""],
        ["MSR_IDT_FCR1",                     0x00000107, ""],
        ["MSR_IDT_FCR2",                     0x00000108, ""],
        ["MSR_IDT_FCR3",                     0x00000109, ""],
        ["MSR_IDT_FCR4",                     0x0000010a, ""],
        ["MSR_IDT_MCR0",                     0x00000110, ""],
        ["MSR_IDT_MCR1",                     0x00000111, ""],
        ["MSR_IDT_MCR2",                     0x00000112, ""],
        ["MSR_IDT_MCR3",                     0x00000113, ""],
        ["MSR_IDT_MCR4",                     0x00000114, ""],
        ["MSR_IDT_MCR5",                     0x00000115, ""],
        ["MSR_IDT_MCR6",                     0x00000116, ""],
        ["MSR_IDT_MCR7",                     0x00000117, ""],
        ["MSR_IDT_MCR_CTRL",                 0x00000120, ""],
        ["MSR_VIA_FCR",                      0x00001107, ""],
        ["MSR_VIA_LONGHAUL",                 0x0000110a, ""],
        ["MSR_VIA_RNG",                      0x0000110b, ""],
        ["MSR_VIA_BCR2",                     0x00001147, ""],
        ["MSR_TMTA_LONGRUN_CTRL",            0x80868010, ""],
        ["MSR_TMTA_LONGRUN_FLAGS",           0x80868011, ""],
        ["MSR_TMTA_LRTI_READOUT",            0x80868018, ""],
        ["MSR_TMTA_LRTI_VOLT_MHZ",           0x8086801a, ""],
        ["MSR_IA32_P5_MC_ADDR",              0x00000000, ""],
        ["MSR_IA32_P5_MC_TYPE",              0x00000001, ""],
        ["MSR_IA32_TSC",                     0x00000010, ""],
        ["MSR_IA32_PLATFORM_ID",             0x00000017, ""],
        ["MSR_IA32_EBL_CR_POWERON",          0x0000002a, ""],
        ["MSR_EBC_FREQUENCY_ID",             0x0000002c, ""],
        ["MSR_SMI_COUNT",                    0x00000034, ""],
        ["MSR_IA32_FEAT_CTL",                0x0000003a, ""],
        ["MSR_IA32_TSC_ADJUST",              0x0000003b, ""],
        ["MSR_IA32_BNDCFGS",                 0x00000d90, ""],
        ["MSR_IA32_BNDCFGS_RSVD",            0x00000ffc, ""],
        ["MSR_IA32_XSS",                     0x00000da0, ""],
        ["MSR_IA32_APICBASE",                0x0000001b, ""],
        ["MSR_IA32_TSCDEADLINE",             0x000006e0, ""],
        ["MSR_IA32_UCODE_WRITE",             0x00000079, ""],
        ["MSR_IA32_UCODE_REV",               0x0000008b, ""],
        ["MSR_IA32_SMM_MONITOR_CTL",         0x0000009b, ""],
        ["MSR_IA32_SMBASE",                  0x0000009e, ""],
        ["MSR_IA32_PERF_STATUS",             0x00000198, ""],
        ["MSR_IA32_PERF_CTL",                0x00000199, ""],
        ["MSR_IA32_MPERF",                   0x000000e7, ""],
        ["MSR_IA32_APERF",                   0x000000e8, ""],
        ["MSR_IA32_THERM_CONTROL",           0x0000019a, ""],
        ["MSR_IA32_THERM_INTERRUPT",         0x0000019b, ""],
        ["MSR_IA32_THERM_STATUS",            0x0000019c, ""],
        ["MSR_THERM2_CTL",                   0x0000019d, ""],
        ["MSR_IA32_MISC_ENABLE",             0x000001a0, ""],
        ["MSR_IA32_TEMPERATURE_TARGET",      0x000001a2, ""],
        ["MSR_MISC_FEATURE_CONTROL",         0x000001a4, ""],
        ["MSR_MISC_PWR_MGMT",                0x000001aa, ""],
        ["MSR_IA32_ENERGY_PERF_BIAS",        0x000001b0, ""],
        ["MSR_IA32_PACKAGE_THERM_STATUS",    0x000001b1, ""],
        ["MSR_IA32_PACKAGE_THERM_INTERRUPT", 0x000001b2, ""],
        ["MSR_MISC_FEATURES_ENABLES",        0x00000140, ""],
        ["MSR_IA32_TSC_DEADLINE",            0x000006e0, ""],
        ["MSR_TSX_FORCE_ABORT",              0x0000010f, ""],
        ["MSR_IA32_MCG_EAX",                 0x00000180, ""],
        ["MSR_IA32_MCG_EBX",                 0x00000181, ""],
        ["MSR_IA32_MCG_ECX",                 0x00000182, ""],
        ["MSR_IA32_MCG_EDX",                 0x00000183, ""],
        ["MSR_IA32_MCG_ESI",                 0x00000184, ""],
        ["MSR_IA32_MCG_EDI",                 0x00000185, ""],
        ["MSR_IA32_MCG_EBP",                 0x00000186, ""],
        ["MSR_IA32_MCG_ESP",                 0x00000187, ""],
        ["MSR_IA32_MCG_EFLAGS",              0x00000188, ""],
        ["MSR_IA32_MCG_EIP",                 0x00000189, ""],
        ["MSR_IA32_MCG_RESERVED",            0x0000018a, ""],
        ["MSR_P4_BPU_PERFCTR0",              0x00000300, ""],
        ["MSR_P4_BPU_PERFCTR1",              0x00000301, ""],
        ["MSR_P4_BPU_PERFCTR2",              0x00000302, ""],
        ["MSR_P4_BPU_PERFCTR3",              0x00000303, ""],
        ["MSR_P4_MS_PERFCTR0",               0x00000304, ""],
        ["MSR_P4_MS_PERFCTR1",               0x00000305, ""],
        ["MSR_P4_MS_PERFCTR2",               0x00000306, ""],
        ["MSR_P4_MS_PERFCTR3",               0x00000307, ""],
        ["MSR_P4_FLAME_PERFCTR0",            0x00000308, ""],
        ["MSR_P4_FLAME_PERFCTR1",            0x00000309, ""],
        ["MSR_P4_FLAME_PERFCTR2",            0x0000030a, ""],
        ["MSR_P4_FLAME_PERFCTR3",            0x0000030b, ""],
        ["MSR_P4_IQ_PERFCTR0",               0x0000030c, ""],
        ["MSR_P4_IQ_PERFCTR1",               0x0000030d, ""],
        ["MSR_P4_IQ_PERFCTR2",               0x0000030e, ""],
        ["MSR_P4_IQ_PERFCTR3",               0x0000030f, ""],
        ["MSR_P4_IQ_PERFCTR4",               0x00000310, ""],
        ["MSR_P4_IQ_PERFCTR5",               0x00000311, ""],
        ["MSR_P4_BPU_CCCR0",                 0x00000360, ""],
        ["MSR_P4_BPU_CCCR1",                 0x00000361, ""],
        ["MSR_P4_BPU_CCCR2",                 0x00000362, ""],
        ["MSR_P4_BPU_CCCR3",                 0x00000363, ""],
        ["MSR_P4_MS_CCCR0",                  0x00000364, ""],
        ["MSR_P4_MS_CCCR1",                  0x00000365, ""],
        ["MSR_P4_MS_CCCR2",                  0x00000366, ""],
        ["MSR_P4_MS_CCCR3",                  0x00000367, ""],
        ["MSR_P4_FLAME_CCCR0",               0x00000368, ""],
        ["MSR_P4_FLAME_CCCR1",               0x00000369, ""],
        ["MSR_P4_FLAME_CCCR2",               0x0000036a, ""],
        ["MSR_P4_FLAME_CCCR3",               0x0000036b, ""],
        ["MSR_P4_IQ_CCCR0",                  0x0000036c, ""],
        ["MSR_P4_IQ_CCCR1",                  0x0000036d, ""],
        ["MSR_P4_IQ_CCCR2",                  0x0000036e, ""],
        ["MSR_P4_IQ_CCCR3",                  0x0000036f, ""],
        ["MSR_P4_IQ_CCCR4",                  0x00000370, ""],
        ["MSR_P4_IQ_CCCR5",                  0x00000371, ""],
        ["MSR_P4_ALF_ESCR0",                 0x000003ca, ""],
        ["MSR_P4_ALF_ESCR1",                 0x000003cb, ""],
        ["MSR_P4_BPU_ESCR0",                 0x000003b2, ""],
        ["MSR_P4_BPU_ESCR1",                 0x000003b3, ""],
        ["MSR_P4_BSU_ESCR0",                 0x000003a0, ""],
        ["MSR_P4_BSU_ESCR1",                 0x000003a1, ""],
        ["MSR_P4_CRU_ESCR0",                 0x000003b8, ""],
        ["MSR_P4_CRU_ESCR1",                 0x000003b9, ""],
        ["MSR_P4_CRU_ESCR2",                 0x000003cc, ""],
        ["MSR_P4_CRU_ESCR3",                 0x000003cd, ""],
        ["MSR_P4_CRU_ESCR4",                 0x000003e0, ""],
        ["MSR_P4_CRU_ESCR5",                 0x000003e1, ""],
        ["MSR_P4_DAC_ESCR0",                 0x000003a8, ""],
        ["MSR_P4_DAC_ESCR1",                 0x000003a9, ""],
        ["MSR_P4_FIRM_ESCR0",                0x000003a4, ""],
        ["MSR_P4_FIRM_ESCR1",                0x000003a5, ""],
        ["MSR_P4_FLAME_ESCR0",               0x000003a6, ""],
        ["MSR_P4_FLAME_ESCR1",               0x000003a7, ""],
        ["MSR_P4_FSB_ESCR0",                 0x000003a2, ""],
        ["MSR_P4_FSB_ESCR1",                 0x000003a3, ""],
        ["MSR_P4_IQ_ESCR0",                  0x000003ba, ""],
        ["MSR_P4_IQ_ESCR1",                  0x000003bb, ""],
        ["MSR_P4_IS_ESCR0",                  0x000003b4, ""],
        ["MSR_P4_IS_ESCR1",                  0x000003b5, ""],
        ["MSR_P4_ITLB_ESCR0",                0x000003b6, ""],
        ["MSR_P4_ITLB_ESCR1",                0x000003b7, ""],
        ["MSR_P4_IX_ESCR0",                  0x000003c8, ""],
        ["MSR_P4_IX_ESCR1",                  0x000003c9, ""],
        ["MSR_P4_MOB_ESCR0",                 0x000003aa, ""],
        ["MSR_P4_MOB_ESCR1",                 0x000003ab, ""],
        ["MSR_P4_MS_ESCR0",                  0x000003c0, ""],
        ["MSR_P4_MS_ESCR1",                  0x000003c1, ""],
        ["MSR_P4_PMH_ESCR0",                 0x000003ac, ""],
        ["MSR_P4_PMH_ESCR1",                 0x000003ad, ""],
        ["MSR_P4_RAT_ESCR0",                 0x000003bc, ""],
        ["MSR_P4_RAT_ESCR1",                 0x000003bd, ""],
        ["MSR_P4_SAAT_ESCR0",                0x000003ae, ""],
        ["MSR_P4_SAAT_ESCR1",                0x000003af, ""],
        ["MSR_P4_SSU_ESCR0",                 0x000003be, ""],
        ["MSR_P4_SSU_ESCR1",                 0x000003bf, ""],
        ["MSR_P4_TBPU_ESCR0",                0x000003c2, ""],
        ["MSR_P4_TBPU_ESCR1",                0x000003c3, ""],
        ["MSR_P4_TC_ESCR0",                  0x000003c4, ""],
        ["MSR_P4_TC_ESCR1",                  0x000003c5, ""],
        ["MSR_P4_U2L_ESCR0",                 0x000003b0, ""],
        ["MSR_P4_U2L_ESCR1",                 0x000003b1, ""],
        ["MSR_P4_PEBS_MATRIX_VERT",          0x000003f2, ""],
        ["MSR_CORE_PERF_FIXED_CTR0",         0x00000309, ""],
        ["MSR_CORE_PERF_FIXED_CTR1",         0x0000030a, ""],
        ["MSR_CORE_PERF_FIXED_CTR2",         0x0000030b, ""],
        ["MSR_CORE_PERF_FIXED_CTR_CTRL",     0x0000038d, ""],
        ["MSR_CORE_PERF_GLOBAL_STATUS",      0x0000038e, ""],
        ["MSR_CORE_PERF_GLOBAL_CTRL",        0x0000038f, ""],
        ["MSR_CORE_PERF_GLOBAL_OVF_CTRL",    0x00000390, ""],
        ["MSR_GEODE_BUSCONT_CONF0",          0x00001900, ""],
        ["MSR_IA32_VMX_BASIC",               0x00000480, ""],
        ["MSR_IA32_VMX_PINBASED_CTLS",       0x00000481, ""],
        ["MSR_IA32_VMX_PROCBASED_CTLS",      0x00000482, ""],
        ["MSR_IA32_VMX_EXIT_CTLS",           0x00000483, ""],
        ["MSR_IA32_VMX_ENTRY_CTLS",          0x00000484, ""],
        ["MSR_IA32_VMX_MISC",                0x00000485, ""],
        ["MSR_IA32_VMX_CR0_FIXED0",          0x00000486, ""],
        ["MSR_IA32_VMX_CR0_FIXED1",          0x00000487, ""],
        ["MSR_IA32_VMX_CR4_FIXED0",          0x00000488, ""],
        ["MSR_IA32_VMX_CR4_FIXED1",          0x00000489, ""],
        ["MSR_IA32_VMX_VMCS_ENUM",           0x0000048a, ""],
        ["MSR_IA32_VMX_PROCBASED_CTLS2",     0x0000048b, ""],
        ["MSR_IA32_VMX_EPT_VPID_CAP",        0x0000048c, ""],
        ["MSR_IA32_VMX_TRUE_PINBASED_CTLS",  0x0000048d, ""],
        ["MSR_IA32_VMX_TRUE_PROCBASED_CTLS", 0x0000048e, ""],
        ["MSR_IA32_VMX_TRUE_EXIT_CTLS",      0x0000048f, ""],
        ["MSR_IA32_VMX_TRUE_ENTRY_CTLS",     0x00000490, ""],
        ["MSR_IA32_VMX_VMFUNC",              0x00000491, ""],
        ["MSR_VM_CR",                        0xc0010114, ""],
        ["MSR_VM_IGNNE",                     0xc0010115, ""],
        ["MSR_VM_HSAVE_PA",                  0xc0010117, ""],
    ]

    def lookup_name2val(self, target_name):
        for name, val, desc in self.msr_table:
            if name == target_name:
                return val
        return None

    def lookup_val2name(self, target_val):
        for name, val, desc in self.msr_table:
            if val == target_val:
                return name
        return "Unknown"

    def print_const_table(self, filt):
        gef_print(titlify("MSR const table"))
        fmt = "{:34s}: {:10s} : {:s}"
        legend = ["Name", "Value", "Description"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for name, val, desc in self.msr_table:
            if filt == []:
                gef_print("{:34s}: {:#010x} : {:s}".format(name, val, desc))
                continue
            for f in filt:
                if f in name:
                    gef_print("{:34s}: {:#010x} : {:s}".format(name, val, desc))
        return

    def bits_split(self, x, bits=64):
        # 0xaaaabbbb -> 0xaaaa_bbbb
        out = ""
        for i in range(bits):
            if x & (1 << i):
                out = "1" + out
            else:
                out = "0" + out
            if i % 4 == 3:
                out = "_" + out
        while out.startswith("_0000"):
            out = out[5:]
        return "0b" + out[1:]

    def get_state(self, code_len):
        d = {}
        d["pc"] = get_register("$pc")
        d["code"] = read_memory(d["pc"], code_len)
        if is_x86_64():
            d["rax"] = get_register("$rax")
            d["rdx"] = get_register("$rdx")
            d["rcx"] = get_register("$rcx")
        else:
            d["eax"] = get_register("$eax")
            d["edx"] = get_register("$edx")
            d["ecx"] = get_register("$ecx")
        return d

    def revert_state(self, d):
        write_memory(d["pc"], d["code"], len(d["code"]))
        gdb.execute("set $pc = {:#x}".format(d["pc"]), to_string=True)
        if is_x86_64():
            gdb.execute("set $rax = {:#x}".format(d["rax"]), to_string=True)
            gdb.execute("set $rdx = {:#x}".format(d["rdx"]), to_string=True)
            gdb.execute("set $rcx = {:#x}".format(d["rcx"]), to_string=True)
        else:
            gdb.execute("set $eax = {:#x}".format(d["eax"]), to_string=True)
            gdb.execute("set $edx = {:#x}".format(d["edx"]), to_string=True)
            gdb.execute("set $ecx = {:#x}".format(d["ecx"]), to_string=True)
        return

    def close_stdout(self):
        self.stdout = 1
        self.stdout_bak = os.dup(self.stdout)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stdout)
        f.close()
        return

    def revert_stdout(self):
        os.dup2(self.stdout_bak, self.stdout)
        os.close(self.stdout_bak)
        return

    def read_msr_core(self, num):
        code = b"\xeb\xfe\x0f\x32" # inf-loop (to stop another thread); rdmsr
        gef_on_stop_unhook(hook_stop_handler)
        d = self.get_state(len(code))
        write_memory(d["pc"], code, len(code))
        if is_x86_64():
            gdb.execute("set $rcx = {:#x}".format(num), to_string=True)
        else:
            gdb.execute("set $ecx = {:#x}".format(num), to_string=True)
        gdb.execute("set $pc = {:#x}".format(d["pc"]+2), to_string=True) # skip "\xeb\xfe"
        self.close_stdout()
        gdb.execute("stepi", to_string=True)
        self.revert_stdout()
        eax = get_register("$eax")
        edx = get_register("$edx")
        self.revert_state(d)
        gef_on_stop_hook(hook_stop_handler)
        return ((edx << 32) | eax) & 0xffffffffffffffff

    def read_msr(self, num):
        val = self.read_msr_core(num)
        name = self.lookup_val2name(num)
        gef_print("{:s} ({:#x}): {:#x} (={:s})".format(name, num, val, self.bits_split(val)))
        return

    @only_if_gdb_running
    @only_if_x86_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv or not argv:
            self.usage()
            return

        if "-l" in argv:
            argv.remove("-l")
            self.print_const_table(argv)
            return

        ring = get_register("$cs") & 0b11
        if ring != 0:
            err("Ring 0 is needed")
            return

        # search const table
        num = self.lookup_name2val(argv[0])
        if num is None:
            try:
                num = int(argv[0], 16)
            except:
                self.usage()
                return
        self.read_msr(num)
        return

class PrintBitInfo:
    """Printing various bit informations of the register"""

    def __init__(self, name, register_bit, description, bit_info):
        self.name = name
        self.register_bit = register_bit
        self.description = description
        self.bit_info = bit_info
        return

    def bits_split(self, x):
        # 0xaaaabbbb -> 0xaaaa_bbbb
        out = ""
        for i in range(self.register_bit):
            if x & (1 << i):
                out = "1" + out
            else:
                out = "0" + out
            if i % 4 == 3:
                out = "_" + out
        return "0b" + out[1:]

    def print_value(self, regval, split=True):
        regname = Color.colorify(self.name, "red bold")
        if split:
            value_str = Color.colorify("{:#x} (={:s})".format(regval, self.bits_split(regval)), "yellow bold")
            gef_print("{:s} = {:s}".format(regname, value_str))
        else:
            value_str = Color.colorify("{:#x}".format(regval), "yellow bold")
            gef_print("{:s} = {:s}".format(regname, value_str))
        return

    def print_description(self):
        if self.description:
            gef_print(self.description)
        return

    def print_bitinfo(self, regval):
        # search max width for bit range string
        bit_range_strs = []
        for info in self.bit_info:
            bits, sym, sdesc, ldesc = info
            if isinstance(bits, int):
                bit_range_strs.append("") # length = 0
            elif isinstance(bits, list):
                bit_range_str = []
                tmp = []
                for b in sorted(bits, reverse=True):
                    if tmp == [] or tmp[-1] - 1 == b:
                        tmp.append(b) # bits are contiguous
                        continue
                    else:
                        # bits are not contiguous (scattered), create format string
                        if len(tmp) == 1:
                            bit_range_str.append("{:d}".format(tmp[0]))
                        else:
                            bit_range_str.append("{:d}-{:d}".format(tmp[0], tmp[-1]))
                        # then restart
                        tmp = [b]
                # add remain
                if tmp:
                    if len(tmp) == 1:
                        bit_range_str.append("{:d}".format(tmp[0]))
                    else:
                        bit_range_str.append("{:d}-{:d}".format(tmp[0], tmp[-1]))
                # join
                bit_range_strs.append(','.join(bit_range_str))
            else:
                raise
        max_width_bits = max(list(map(len, bit_range_strs)) + [2]) # 2 is default

        # search max width for sym
        max_width_sym = 0
        for info in self.bit_info:
            bits, sym, sdesc, ldesc = info
            if sym:
                max_width_sym = max(max_width_sym, len(sym))

        # search max width for val
        max_width_val = 0
        for info in self.bit_info:
            bits, sym, sdesc, ldesc = info
            if isinstance(bits, int):
                val = (regval & (1 << bits)) >> bits
            elif isinstance(bits, list):
                val = 0
                for j, x in enumerate(bits):
                    val |= (regval & (1 << x)) >> (x-j)
            else:
                raise
            max_width_val = max(max_width_val, len("{:#x}".format(val)))

        # search max width for sdesc
        max_width_sdesc = 0
        for info in self.bit_info:
            bits, sym, sdesc, ldesc = info
            if sdesc:
                max_width_sdesc = max(max_width_sdesc, len(sdesc))

        # print using each width
        for i, info in enumerate(self.bit_info):
            bits, sym, sdesc, ldesc = info
            if isinstance(bits, int):
                b = "{:d}".format(bits)
                val = (regval & (1 << bits)) >> bits
            elif isinstance(bits, list):
                b = bit_range_strs[i]
                val = 0
                for j, x in enumerate(bits):
                    val |= (regval & (1 << x)) >> (x-j)
            else:
                raise

            if val:
                colored_val = Color.colorify(f"{val:>#{max_width_val}x}", "bold")
            else:
                colored_val = f"{val:>#{max_width_val}x}"
            if sym is not None and sdesc is not None:
                gef_print(f"bit{b:>{max_width_bits}s}: {colored_val:s} [{sym:{max_width_sym}s}: {sdesc:{max_width_sdesc}s}]: {ldesc}")
            else:
                gef_print(f"bit{b:>{max_width_bits}s}: {colored_val:s}: {ldesc}")
        return

    def print(self, regval, split=True):
        self.print_value(regval, split)
        self.print_description()
        self.print_bitinfo(regval)
        return


@register_command
class QemuRegistersCommand(GenericCommand):
    """Get regisers via qemu-monitor."""
    _cmdline_ = "qreg"
    _syntax_ = "{:s} [-h] [-v]".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def qregisters_x86_x64(self):
        res = gdb.execute("monitor info registers", to_string=True)
        red = lambda x: Color.colorify(x, "red bold")
        yellow = lambda x: Color.colorify(x, "yellow bold")

        # CR0
        gef_print(titlify("CR0 (Control Register 0)"))
        desc = "It contains system control flags that control operating mode and states of the processor"
        bit_info = [
            [31, "PG", "Paging", "If 1, enable paging and use CR3 register, else disable paging"],
            [30, "CD", "Cache disable", "If 1, disable the memory cache globally"],
            [29, "NW", "Not-write through", "If 1, disable write-through caching globally"],
            [18, "AM", "Alignment mask", "If 1, alignment check enabled when EFLAGS.AC==1 and Ring-3"],
            [16, "WP", "Write protect", "If 1, the CPU can't write to read-only pages when Ring-0"],
            [5, "NE", "Numeric error", "If 1, enable internal x87 FPU error reporting, else enables PC style x87 error detection"],
            [4, "ET", "Extension type", "x64: always 1. i386: if 1, x87 DX math coprosessor instructions is supported"],
            [3, "TS", "Task switched", "If 1, allow the saving x87 task context upon a task switch only after x87 instruction used"],
            [2, "EM", "Emulation", "If 1, no x87 FPU present, else x87 FPU present"],
            [1, "MP", "Monitor co-processor", "If 1, WAIT/FWAIT instructions generate #NM exception when CR0.TS"],
            [0, "PE", "Protected mode enable", "If 1, system is in protected mode, else system is in real mode"],
        ]
        cr0 = int(re.search(r"CR0=(\S+)", res).group(1), 16)
        PrintBitInfo("CR0", 32, desc, bit_info).print(cr0)

        # CR1
        gef_print(titlify("CR1 (Control Register 1)"))
        gef_print("Reserved")

        # CR2
        gef_print(titlify("CR2 (Control Register 2)"))
        desc = "When page fault, the address attempted to access is stored (PFLA: Page Fault Linear Address)"
        cr2 = int(re.search(r"CR2=(\S+)", res).group(1), 16)
        PrintBitInfo("CR2", 64 if is_x86_64() else 32, desc, bit_info=[]).print(cr2, split=False)

        # CR3
        gef_print(titlify("CR3 (Control Register 3)"))
        desc = "It contains the physical address of the base of the paging-structure hierarchy and two flags"
        bit_info = [
            [list(range(12,32)), None, None, "Base of page directory base, typically it points to PML4T if 4-level paging"],
            [list(range(0, 12)), None, None, "Process context identifier when CR4.PCIDE=1"],
            [4, "PCD", "Page-level Cache Disable", "If 1, disable Page-Directory itself caching when CR4.PCIDE=0"],
            [3, "PWT", "Page-level Write-Through", "If 1, enable write through Page-Directory itself caching when CR4.PCIDE=0"],
        ]
        cr3 = int(re.search(r"CR3=(\S+)", res).group(1), 16)
        PrintBitInfo("CR3", 64 if is_x86_64() else 32, desc, bit_info).print(cr3)

        # CR4
        gef_print(titlify("CR4 (Control Register 4)"))
        desc = "It contains flags that enable some architectural extensions, and indicate OS or executive support for specific processor capabilities"
        bit_info = [
            [24, "PKS", "Enable protection keys for supervisor-mode pages", "If 1, enables PKS"],
            [23, "CET", "Control-flow Enforcement Technology", "If 1, enables CET"],
            [22, "PKE", "Protection Key Enable", "If 1, enables PKE"],
            [21, "SMAP", "Supervisor Mode Access Protection Enable", "If 1, access of data in a higher ring generates a fault"],
            [20, "SMEP", "Supervisor Mode Execution Protection Enable", "If 1, execution of code in a higher ring generates a fault"],
            [18, "OSXSAVE", "Enable XSAVE and Processor Extended States", "If 1, enable XSAVE/XSAVEC/XSAVEOPT/XSAVES/XRSTOR/XRSTORS/XSETBV/XGETBV"],
            [17, "PCIDE", "PCID Enable", "If 1, enables process-context identifiers (PCIDs)"],
            [15, "FSGSBASE", "FSGSBASE Enable", "If 1, enable RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE"],
            [14, "SMXE", "Safer Mode Extensions Enable", "If 1, enable Trusted Execution Technology (TXT)"],
            [13, "VMXE", "Virtual Machine Extensions Enable", "If 1, enable Intel VT-x x86 virtualization"],
            [12, "LA57", "57bit linear addresses", "If 1, enables 5-Level Paging"],
            [11, "UMIP", "User-Mode Instruction Prevention", "If 1, SGDT/SIDT/SLDT/SMSW/STR instructions can only be executed in ring0"],
            [10, "OSXMMEXCPT", "OS support for Unmasked SIMD FP Exceptions", "If 1, enables unmasked SSE exceptions"],
            [9, "OSFXSR", "OS support for FXSAVE/FXRSTOR", "If 1, enables SSE instructions and fast FPU save & restore"],
            [8, "PCE", "Performance-Monitoring Counter enable", "If 1, RDPMC instruction can be executed at any privilege level"],
            [7, "PGE", "Page Global Enabled", "If 1, address translations (PDE or PTE records) may be shared between address spaces"],
            [6, "MCE", "Machine Check Exception", "If 1, enables machine check interrupts to occur"],
            [5, "PAE", "Physical Address Extension", "If 1, changes page table layout to translate 32bit virtaddr into 36bit physaddr"],
            [4, "PSE", "Page Size Extension", "If 1, page size is 4MB, else 4KB, this bit is ignored when PAE or x86-64 long mode"],
            [3, "DE", "Debugging Extensions", "If 1, enables debug register based breaks on I/O space access"],
            [2, "TSD", "Time Stamp Disable", "If 1, RDTSC instruction can only be executed in ring0"],
            [1, "PVI", "Protected-mode Virtual Interrupts", "If 1, enables support for the virtual interrupt flag (VIF) in protected mode"],
            [0, "VME", "Virtual 8086 Mode Extensions", "If 1, enables support for the virtual interrupt flag (VIF) in virtual-8086 mode"],
        ]
        cr4 = int(re.search(r"CR4=(\S+)", res).group(1), 16)
        PrintBitInfo("CR4", 64 if is_x86_64() else 32, desc, bit_info).print(cr4)

        # DR0-DR3
        gef_print(titlify("DR0-DR3 (Debug Address Register 0-3)"))
        desc = "Contain linear addresses of up to 4 hardware breakpoints. If paging is enabled, they are translated to physical addresses"
        dr0 = int(re.search(r"DR0=(\S+)", res).group(1), 16)
        dr1 = int(re.search(r"DR1=(\S+)", res).group(1), 16)
        dr2 = int(re.search(r"DR2=(\S+)", res).group(1), 16)
        dr3 = int(re.search(r"DR3=(\S+)", res).group(1), 16)
        PrintBitInfo("DR0", 64 if is_x86_64() else 32, None, bit_info=[]).print(dr0, split=False)
        PrintBitInfo("DR1", 64 if is_x86_64() else 32, None, bit_info=[]).print(dr1, split=False)
        PrintBitInfo("DR2", 64 if is_x86_64() else 32, None, bit_info=[]).print(dr2, split=False)
        PrintBitInfo("DR3", 64 if is_x86_64() else 32, desc, bit_info=[]).print(dr3, split=False)

        # DR4-DR5
        gef_print(titlify("DR4-DR5 (Debug Register 4-5)"))
        gef_print("Reserved")

        # DR6
        gef_print(titlify("DR6 (Debug Status Register 6)"))
        desc = "It permits the debugger to determine which debug conditions have occurred"
        bit_info = [
            [16, "RTM","restricted transactional memory", "If 0, the debug exception or breakpoint exception occured inside an RTM region"],
            [15, "BT", "task switch", "If 1, the debug instruction resulted from a task switch where TSS.T of target task was set"],
            [14, "BS", "single step", "If 1, the debug exception was triggered by the single-step execution mode (enabled with EFLAGS.TF)"],
            [13, "BD", "debug register access detected", "If 1, the next instruction accesses one of the debug registers"],
            [3, "B3", "breakpoint condition detected", "If 1, breakpoint condition was met when a debug exception for DR3"],
            [2, "B2", "breakpoint condition detected", "If 1, breakpoint condition was met when a debug exception for DR2"],
            [1, "B1", "breakpoint condition detected", "If 1, breakpoint condition was met when a debug exception for DR1"],
            [0, "B0", "breakpoint condition detected", "If 1, breakpoint condition was met when a debug exception for DR0"],
        ]
        dr6 = int(re.search(r"DR6=(\S+)", res).group(1), 16)
        PrintBitInfo("DR6", 32, desc, bit_info).print(dr6)

        # DR7
        gef_print(titlify("DR7 (Debug Control Register 7)"))
        desc = "A local breakpoint bit deactivates on hardware task switches, while a global does not"
        bit_info = [
            [[30,31], "LEN3", "Size of DR3 breakpoint", ""],
            [[28,29], "R/W3", "Breakpoint conditions for DR3", ""],
            [[26,27], "LEN2", "Size of DR2 breakpoint", ""],
            [[24,25], "R/W2", "Breakpoint conditions for DR2", ""],
            [[22,23], "LEN1", "Size of DR1 breakpoint", ""],
            [[20,21], "R/W1", "Breakpoint conditions for DR1", ""],
            [[18,19], "LEN0", "Size of DR0 breakpoint", ""],
            [[16,17], "R/W0", "Breakpoint conditions for DR0", ""],
            [13, "GD", "General Detect enable", ""],
            [11, "RTM", "Restricted Transactional Memory", ""],
            [9, "GE", "Global Exact breakpoint", ""],
            [8, "LE", "Local Exact breakpoint", ""],
            [7, "G3", "Global DR3 breakpoint", ""],
            [6, "L3", "Local DR3 breakpoint", ""],
            [5, "G2", "Global DR2 breakpoint", ""],
            [4, "L2", "Local DR2 breakpoint", ""],
            [3, "G1", "Global DR1 breakpoint", ""],
            [2, "L1", "Local DR1 breakpoint", ""],
            [1, "G0", "Global DR0 breakpoint", ""],
            [0, "L0", "Local DR0 breakpoint", ""],
        ]
        dr7 = int(re.search(r"DR7=(\S+)", res).group(1), 16)
        PrintBitInfo("DR7", 64 if is_x86_64() else 32, desc, bit_info).print(dr7)

        # EFER
        gef_print(titlify("EFER (Extended Feature Enable Register; MSR_EFER:0xc0000080)"))
        efer = int(re.search(r"EFER=(\S+)", res).group(1), 16)
        bit_info = [
            [15,"TCE",   "Translation Cache Extension", ""],
            [14,"FFXSR", "Fast FXSAVE/FXRSTOR", ""],
            [13,"LMSLE", "Long Mode Segment Limit Enable", ""],
            [12,"SVME",  "Secure Virtual Machine Enable", ""],
            [11,"NXE",   "No-Execute Enable", ""],
            [10,"LMA",   "Long Mode Active", ""],
            [8, "LME",   "Long Mode Enable", ""],
            [4, "L2D",   "L2 Cache Disable", "AMD K6 only"],
            [3, "GEWBED","Global EWBE# Disable", "AMD K6 only"],
            [2, "SEWBED","Speculative EWBE# Disable", "AMD K6 only"],
            [1, "DPE",   "Data Prefetch Enable", "AMD K6 only"],
            [0, "SCE",   "System Call Extensions", ""],
        ]
        PrintBitInfo("EFER", 64 if is_x86_64() else 32, None, bit_info).print(efer)

        # TR
        gef_print(titlify("TR (Task Register)"))
        tr = re.search(r"TR\s*=\s*(\S+) (\S+) (\S+) (\S+)", res)
        trseg, base, limit, attr = [int(tr.group(i), 16) for i in range(1,5)]
        gef_print("{:s} = {:s}".format(red("TR"), yellow("{:#x}".format(trseg))))
        regv = Color.boldify("{:#x} (rpl:{:d},ti:{:d},index:{:d})".format(trseg, trseg&0b11, (trseg>>2)&1, trseg>>3))
        gef_print("seg: {:s}: segment selector for TSS (Task State Segment)".format(regv))
        gef_print("  base : {:s}: starting address of TSS".format(Color.boldify("{:#x}".format(base))))
        gef_print("  limit: {:s}: segment limit or fixed value(=__KERNEL_TSS_LIMIT x64:0x206f/x86:0x206b)".format(Color.boldify("{:#x}".format(limit))))
        gef_print("  attr : {:s}: attribute".format(Color.boldify("{:#x}".format(attr))))

        # GDTR
        gef_print(titlify("GDTR (Global Descriptor Table Register)"))
        gdtr = re.search(r"GDT\s*=\s*(\S+) (\S+)", res)
        base, limit = [int(gdtr.group(i), 16) for i in range(1,3)]
        gef_print("{:s} = {:s}:{:s}".format(red("GDTR"), yellow("{:#x}".format(base)), yellow("{:#x}".format(limit))))
        gef_print("base : {:s}: starting address of GDT (Global Descriptor Table)".format(Color.boldify("{:#x}".format(base))))
        gef_print("limit: {:s}: (size of GDT) - 1".format(Color.boldify("{:#x}".format(limit))))
        info("GDT entry")
        regs = GdtInfoCommand.get_segreg_list()
        gef_print(Color.colorify("[ #] {:20s}: ".format("segname") + GdtInfoCommand.segval2str_legend(), get_gef_setting("theme.table_heading")))
        gdtinfo = read_memory(base, limit+1)
        # https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/segment.h
        if is_x86_64():
            segname_info = [
                "NULL",
                "KERNEL_32_CS",
                "KERNEL_CS",
                "KERNEL_DS",
                "DEFAULT_USER32_CS",
                "DEFAULT_USER_DS",
                "DEFAULT_USER_CS",
                "",
                "TSS-part1",
                "TSS-part2",
                "LDT-part1",
                "LDT-part2",
                "TLS_#1",
                "TLS_#2",
                "TLS_#3",
                "CPUNODE",
            ]
        else:
            segname_info = [
                "NULL",
                "RESERVED",
                "RESERVED",
                "RESERVED",
                "UNUSED",
                "UNUSED",
                "TLS_#1",
                "TLS_#2",
                "TLS_#3",
                "RESERVED",
                "RESERVED",
                "RESERVED",
                "KERNEL_CS",
                "KERNEL_DS",
                "DEFAULT_USER_CS",
                "DEFAULT_USER_DS",
                "TSS",
                "LDT",
                "PNPBIOS_CS32",
                "PNPBIOS_CS16",
                "PNPBIOS_DS",
                "PNPBIOS_TS1",
                "PNPBIOS_TS2",
                "APMBIOS_BASE",
                "APMBIOS",
                "APMBIOS",
                "ESPFIX_SS",
                "PERCPU",
                "STACK_CANARY",
                "UNUSED",
                "UNUSED",
                "DOUBLEFAULT_TSS",
            ]
        sliced = list(map(u64, [gdtinfo[i:i+8] for i in range(0, len(gdtinfo), 8)]))
        registers_color = get_gef_setting("theme.dereference_register_value")
        for i, b in enumerate(sliced):
            reglist = ', '.join(regs.get(i,[]))
            if reglist:
                reglist = LEFT_ARROW + reglist
            if is_x86_64() and i == (trseg>>3): # for TSS
                s = GdtInfoCommand.segval2str(b, value_only=True)
                prev = b
                reglist = reglist + ", tr" if reglist else LEFT_ARROW + "TR"
            elif is_x86_64() and i == (trseg>>3) + 1: # for TSS
                s = GdtInfoCommand.segval2str([prev, b])
            elif is_x86_32() and i == (trseg>>3): # for TSS
                s = GdtInfoCommand.segval2str(b)
                reglist = reglist + ", tr" if reglist else LEFT_ARROW + "TR"
            else:
                s = GdtInfoCommand.segval2str(b)
            gef_print("[{:02d}] {:20s}: {:s} {:s}".format(i, segname_info[i], s, Color.colorify(reglist, registers_color)))
        info("more info, use `gdtinfo -v` command, it prints legend of GDT entry")

        # IDTR
        gef_print(titlify("IDTR (Interrupt Descriptor Table Register)"))
        idtr = re.search(r"IDT\s*=\s*(\S+) (\S+)", res)
        base, limit = [int(idtr.group(i), 16) for i in range(1,3)]
        gef_print("{:s} = {:s}:{:s}".format(red("IDTR"), yellow("{:#x}".format(base)), yellow("{:#x}".format(limit))))
        gef_print("base : {:s}: starting address of IDT (Interrupt Descriptor Table)".format(Color.boldify("{:#x}".format(base))))
        gef_print("limit: {:s}: (size of IDT) - 1".format(Color.boldify("{:#x}".format(limit))))

        # LDTR
        gef_print(titlify("LDTR (Local Descriptor Table Register)"))
        ldtr = re.search(r"LDT\s*=\s*(\S+) (\S+) (\S+) (\S+)", res)
        seg, base, limit, attr = [int(ldtr.group(i), 16) for i in range(1,5)]
        gef_print("{:s} = {:s}".format(red("LDTR"), yellow("{:#x}".format(seg))))
        regv = Color.boldify("{:#x} (rpl:{:d},ti:{:d},index:{:d})".format(seg, seg&0b11, (seg>>2)&1, seg>>3))
        gef_print("seg: {:s}: segment selector for LDT (Local Descriptor Table)".format(regv))
        gef_print("  base : {:s}: starting address of LDT".format(Color.boldify("{:#x}".format(base))))
        gef_print("  limit: {:s}: segment limit".format(Color.boldify("{:#x}".format(limit))))
        gef_print("  attr : {:s}: attribute".format(Color.boldify("{:#x}".format(attr))))
        return

    def qregisters(self):
        res = gdb.execute("monitor info registers", to_string=True)
        gef_print(titlify("info register"))
        for line in res.splitlines():
            gef_print(line)

        if is_x86():
            if not self.add_info:
                info("use `-v` for print Additional info")
            else:
                info("Additional info")
                self.qregisters_x86_x64()
        return

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.add_info = False
        if "-v" in argv:
            self.add_info = True
            argv.remove("-v")

        self.qregisters()
        return


@lru_cache()
def get_maps_arm64_optee_secure_memory(verbose=False):
    # heuristic search of qemu-system memory
    sm_base, sm_size = XSecureMemAddrCommand.get_secure_memory_base_and_size(verbose)
    if sm_base is None or sm_size is None:
        err("Not found memory tree of secure memory (see monitor info mtree -f)") 
        return None
    sm = XSecureMemAddrCommand.get_secure_memory_qemu_map(sm_base, sm_size, verbose)
    if sm is None:
        err("Not found secure memory maps")
        return None
    data = XSecureMemAddrCommand.read_secure_memory(sm, 0x0, sm.size, verbose)

    def slice_unpack(data, n):
        tmp = [data[i:i+n] for i in range(0, len(data), n)]
        return list(map(u64 if n == 8 else u32, tmp))
    data_list = slice_unpack(data, 8)

    """
    enum teecore_memtypes {
        MEM_AREA_END = 0,
        MEM_AREA_TEE_RAM,
        MEM_AREA_TEE_RAM_RX,
        MEM_AREA_TEE_RAM_RO,
        MEM_AREA_TEE_RAM_RW,
        MEM_AREA_INIT_RAM_RO,
        MEM_AREA_INIT_RAM_RX,
        MEM_AREA_NEX_RAM_RO,
        MEM_AREA_NEX_RAM_RW,
        MEM_AREA_TEE_COHERENT,
        MEM_AREA_TEE_ASAN,
        MEM_AREA_IDENTITY_MAP_RX,
        MEM_AREA_TA_RAM,
        MEM_AREA_NSEC_SHM,
        MEM_AREA_RAM_NSEC,
        MEM_AREA_RAM_SEC,
        MEM_AREA_IO_NSEC,
        MEM_AREA_IO_SEC,
        MEM_AREA_EXT_DT,
        MEM_AREA_RES_VASPACE,
        MEM_AREA_SHM_VASPACE,
        MEM_AREA_TS_VASPACE,
        MEM_AREA_PAGER_VASPACE,
        MEM_AREA_SDP_MEM,
        MEM_AREA_DDR_OVERALL,
        MEM_AREA_SEC_RAM_OVERALL,
        MEM_AREA_MAXTYPE
    };
    struct tee_mmap_region {
        unsigned int type; /* enum teecore_memtypes */
        unsigned int region_size;
        paddr_t pa;
        vaddr_t va;
        size_t size;
        uint32_t attr; /* TEE_MATTR_* above */
    };
    """
    maps = []
    old_i = -1
    for i in range(len(data_list)-4):
        type = data_list[i] & 0xffffffff
        if 26 < type: # enum teecore_memtypes
            continue
        region_size = (data_list[i] >> 32) & 0xffffffff
        if region_size & 0xfff or region_size < 0x1000 or 0xfffff000 < region_size:
            continue
        pa, va, size, attr = data_list[i+1:i+5]
        if pa & 0xfff or 0xfffff000 < pa:
            continue
        if va & 0xfff or 0xfffff000 < va:
            continue
        if size & 0xfff or size < 0x1000 or 0xfffff000 < size:
            continue
        if len(maps) > 0 and old_i + 5 != i: # Judging continuity
            continue
        maps.append([va, va+size, pa, pa+size])
        old_i = i
    if verbose:
        fmt = "{:33s}  {:33s}  {:12s}"
        legend = ["Virtual address start-end", "Physical address start-end", "Total size"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for va_start, va_end, pa_start, pa_end in maps:
            gef_print("{:016x}-{:016x}  {:016x}-{:016x}  {:<#12x}".format(va_start, va_end, pa_start, pa_end, va_end - va_start))
    return maps


@lru_cache()
def get_maps_by_pagewalk(command):
    # for lru cache
    return gdb.execute(command, to_string=True)


@register_command
class V2PCommand(GenericCommand):
    """Transfer from virtual address to physical address."""
    _cmdline_ = "v2p"
    _syntax_ = "{:s} [-h] [-s|-S] ADDRESS".format(_cmdline_)
    _example_ = ""
    _example_ += "{:s} 0xa31dd000\n".format(_cmdline_)
    _example_ += "{:s} 0xa31dd000 -S # use TTBRn_ELm_S for parsing start register (ARMv7) / heuristic search the memory of qemu-system (ARMv8)\n".format(_cmdline_)
    _example_ += "{:s} 0xa31dd000 -s # use TTBRn_ELm for parsing start register (ARMv7/v8)".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @staticmethod
    def get_maps(FORCE_PREFIX_S, verbose=False):
        if is_arm64():
            if FORCE_PREFIX_S is True:
                return get_maps_arm64_optee_secure_memory(verbose) # already parsed
            else:
                res = get_maps_by_pagewalk("pagewalk 1 -q --no-merge")
        else:
            if FORCE_PREFIX_S is None:
                res = get_maps_by_pagewalk("pagewalk -q --no-merge")
            elif FORCE_PREFIX_S is True:
                res = get_maps_by_pagewalk("pagewalk -q --no-merge -S")
            elif FORCE_PREFIX_S is False:
                res = get_maps_by_pagewalk("pagewalk -q --no-merge -s")
        res = sorted(set(res.splitlines()))
        res = list(filter(lambda line: line.endswith("]"), res))
        res = list(filter(lambda line: not "[+]" in line, res))
        maps = []
        for line in res:
            vrange, prange, *_ = line.split()
            vstart, vend = [int(x, 16) for x in vrange.split("-")]
            pstart, pend = [int(x, 16) for x in prange.split("-")]
            maps.append((vstart, vend, pstart, pend))
        if maps == []:
            if is_x86():
                warn("Make sure you are in ring0 (=kernel mode)")
            elif is_arm32():
                warn("Make sure you are in supervisor mode (=kernel mode)")
                warn("Make sure qemu 3.x or higher")
            elif is_arm64():
                warn("Make sure you are in EL1 (=kernel mode)")
                warn("Make sure qemu 3.x or higher")
            return None
        return maps

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_x86_32_64_or_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if not argv:
            self.usage()
            return

        FORCE_PREFIX_S = None
        if is_arm32() or is_arm64():
            if "-s" in argv:
                FORCE_PREFIX_S = False
                argv.remove("-s")
            elif "-S" in argv:
                FORCE_PREFIX_S = True
                argv.remove("-S")

        try:
            addr = int(gdb.parse_and_eval(' '.join(argv)))
        except:
            self.usage()
            return

        maps = self.get_maps(FORCE_PREFIX_S)
        if maps is None:
            return
        for vstart, vend, pstart, pend in maps:
            if vstart <= addr < vend:
                offset = addr - vstart
                paddr = pstart + offset
                gef_print("Virt: {:#x} -> Phys: {:#x}".format(addr, paddr))
        return


@register_command
class P2VCommand(GenericCommand):
    """Transfer from physical address to virtual address."""
    _cmdline_ = "p2v"
    _syntax_ = "{:s} [-h] [-s|-S] ADDRESS".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_x86_32_64_or_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if not argv:
            self.usage()
            return

        FORCE_PREFIX_S = None
        if is_arm32() or is_arm64():
            if "-s" in argv:
                FORCE_PREFIX_S = False
                argv.remove("-s")
            elif "-S" in argv:
                FORCE_PREFIX_S = True
                argv.remove("-S")

        try:
            addr = int(gdb.parse_and_eval(' '.join(argv)))
        except:
            self.usage()
            return

        maps = V2PCommand.get_maps(FORCE_PREFIX_S)
        if maps is None:
            return
        count = 0
        for vstart, vend, pstart, pend in maps:
            if pstart <= addr < pend:
                offset = addr - pstart
                vaddr = vstart + offset
                if count < 10:
                    gef_print("Phys: {:#x} -> Virt: {:#x}".format(addr, vaddr))
                count += 1
        if count:
            gef_print("Total {:d} results are found".format(count))
        else:
            gef_print("Not mapped as virt")
        return


@register_command
class PagewalkCommand(GenericCommand):
    """Get physical memory info via qemu-monitor. Currently, x64, x86, arm and arm64 are supported."""
    _cmdline_ = "pagewalk"
    _syntax_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def __init__(self, *args, **kwargs):
        super().__init__(prefix=True, complete=gdb.COMPLETE_NONE)
        return

    def read_physmem_cache(self, paddr, size=8):
        if "{:#x}_{:d}".format(paddr, size) in self.cache:
            return self.cache["{:#x}_{:d}".format(paddr, size)]
        out = read_physmem(paddr, size)
        self.cache["{:#x}_{:d}".format(paddr, size)] = out
        return out

    def slice_unpack(self, data, n):
        tmp = [data[i:i+n] for i in range(0, len(data), n)]
        if n == 8:
            return list(map(u64, tmp))
        elif n == 4:
            return list(map(u32, tmp))
        else:
            raise

    # merge pages that points same phys page
    # for example, there are 16 pages,
    #    virt: 0xffffffff11107000  -> phys:0xabcd000
    #    virt: 0xffffffff11117000  -> phys;0xabcd000
    #    virt: 0xffffffff11127000  -> phys;0xabcd000
    #    ...
    #    virt: 0xffffffff111d7000  -> phys;0xabcd000
    #    virt: 0xffffffff111e7000  -> phys;0xabcd000
    #    virt: 0xffffffff111f7000  -> phys;0xabcd000
    # they will be merged by "*". type is changed from int to string.
    #    virt:"0xffffffff111*7000" -> phys:0xabcd000
    def merge1(self):
        # group entries that refer to the same phys page
        tmp = {}
        for entry in self.mappings: # [virt_addr, phys_addr, page_size, page_count, flags]
            va, other = entry[0], tuple(entry[1:])
            if not other in tmp:
                tmp[other] = []
            tmp[other].append("{:016x}".format(va))

        # merge if possible
        merged_mappings = []
        for other, va_array in tmp.items():
            if len(va_array) < 16:
                for va in va_array:
                    merged_mappings.append([va] + list(other))
                continue
            queue = va_array
            queue_done = []
            for shift in range(4, 16):
                while len(queue) >= 16:
                    q = queue[0]
                    tmp16 = []
                    for c in "0123456789abcdef":
                        cand = q[:16-shift-1] + c + q[16-shift:]
                        if cand in queue:
                            queue.remove(cand)
                            tmp16.append(cand)
                    if len(tmp16) == 16:
                        queue_done.append( q[:16-shift-1] + "*" + q[16-shift:] )
                    else:
                        queue_done += tmp16

                queue = queue + queue_done
                queue_done = []

            for q in queue:
                merged_mappings.append([q] + list(other))

        # done
        self.mappings = sorted(merged_mappings)
        return

    # merge consecutive pages
    def merge2(self):
        merged_mappings = []
        prev = None
        for now in self.mappings: # [virt_addr_string, phys_addr, page_size, page_count, flags]

            # specific case
            if "*" in now[0]:
                if prev:
                    merged_mappings += [prev]
                merged_mappings += [now]
                prev = None
                continue

            # first loop case
            if prev is None:
                prev = now
                continue

            now_va = int(now[0], 16) if isinstance(now[0], str) else now[0]
            prev_va = int(prev[0], 16) if isinstance(prev[0], str) else prev[0]
            now_pa = int(now[1], 16) if isinstance(now[1], str) else now[1]
            prev_pa = int(prev[1], 16) if isinstance(prev[1], str) else prev[1]
            now_size = now[2]
            prev_size = prev[2]
            now_cnt = now[3]
            prev_cnt = prev[3]
            now_flags = now[4]
            prev_flags = prev[4]

            # check consecutiveness
            if self.simple:
                if prev_va + prev_size == now_va: # va consecutiveness
                    if prev_flags == now_flags: # flags equivalence
                        # ok, they are consecutive (at least virt_addr)
                        prev[2] += now[2]
                        # For simple mode, page_size is ignored.
                        # so we use entry[2] as total_size instead of page_size.
                        continue
            else:
                if prev_va + prev_size * prev_cnt == now_va: # va consecutiveness
                    if prev_pa + prev_size * prev_cnt == now_pa: # pa consecutiveness
                        if prev_size == now_size: # page_size equivalence
                            if prev_flags == now_flags: # flags equivalence
                                # ok, they are consecutive
                                prev[3] += 1 # prev_page_cnt update
                                continue

            merged_mappings += [prev]
            prev = now

        if prev:
            merged_mappings += [prev]

        self.mappings = merged_mappings
        return

    def vrange_filter(self):
        filterd_mappings = []
        for addr in self.vrange:
            for mapping in self.mappings:
                va, _, size, cnt = mapping[:4]
                if isinstance(va, str) and "*" in va:
                    start = int(va.replace("*", "0"), 16)
                    end = int(va.replace("*", "f"), 16)
                    if start <= addr and addr < end + size * cnt:
                        filterd_mappings.append(mapping)
                else:
                    if isinstance(va, str):
                        va = int(va, 16)
                    if va <= addr and addr < va + size * cnt:
                        filterd_mappings.append(mapping)
        self.mappings = sorted(filterd_mappings)
        return

    def prange_filter(self):
        filterd_mappings = []
        for addr in self.prange:
            for mapping in self.mappings:
                _, pa, size, cnt = mapping[:4]
                if isinstance(pa, str):
                    pa = int(pa, 16)
                if pa <= addr and addr < pa + size * cnt:
                    filterd_mappings.append(mapping)
        self.mappings = sorted(filterd_mappings)
        return

    def format_legend(self):
        fmt = "{:33s}  {:33s}  {:12s} {:11s} {:6s} {:s}"
        legend = ["Virtual address start-end", "Physical address start-end", "Total size", "Page size", "Count", "Flags"]
        return fmt.format(*legend)

    def format_entry(self, entry):
        va, pa, size, cnt, flags = entry
        if isinstance(va, str) and "*" in va:
            vend = "{:016x}".format(int(va.replace("*", "0"), 16) + size * cnt)
            for pos in [x.span() for x in re.finditer(r'\*', va)]:
                vend = vend[:pos[0]] + "*" + vend[pos[1]:]
            pend = pa + size * cnt
            if self.simple:
                text = "{:16s}-{:16s}  {:33s}  {:<#12x} {:<11s} {:<6s} [{:s}]".format(va, vend, "-", size, "-", "-", flags)
            else:
                text = "{:16s}-{:16s}  {:016x}-{:016x}  {:<#12x} {:<#11x} {:<6d} [{:s}]".format(va, vend, pa, pend, size*cnt, size, cnt, flags)
        else:
            if isinstance(va, str):
                va = int(va, 16)
            vend = va + size * cnt
            pend = pa + size * cnt
            if self.simple:
                text = "{:016x}-{:016x}  {:33s}  {:<#12x} {:<11s} {:<6s} [{:s}]".format(va, vend, "-", size, "-", "-", flags)
            else:
                text = "{:016x}-{:016x}  {:016x}-{:016x}  {:<#12x} {:<#11x} {:<6d} [{:s}]".format(va, vend, pa, pend, size*cnt, size, cnt, flags)
        return text

    def print_page(self):
        if len(self.mappings) == 0:
            warn("No virtual mappings found")
            return

        self.mappings = sorted(self.mappings)

        # merging
        if self.no_merge:
            pass
        else:
            self.merge1()
            if not self.quiet:
                info("PT Entry (merged similar pages that refer the same physpage): {:d}".format(len(self.mappings)))
            self.merge2()
            if not self.quiet:
                info("PT Entry (merged consecutive pages): {:d}".format(len(self.mappings)))

        # filter by virtual address range
        if self.vrange != []:
            self.vrange_filter()
            if not self.quiet:
                info("PT Entry (filterd by virtual address range): {:d}".format(len(self.mappings)))

        # filter by physical address range
        if self.prange != []:
            self.prange_filter()
            if not self.quiet:
                info("PT Entry (filterd by physical address range): {:d}".format(len(self.mappings)))

        # create output
        lines = []
        for entry_info in self.mappings:
            line = self.format_entry(entry_info)
            lines.append(line)

        # filter by keyword
        if self.filter != []:
            filtered_lines = []
            for line in lines:
                for filt in self.filter:
                    if re.search(filt, line):
                        filtered_lines.append(line)
            lines = filtered_lines
            if not self.quiet:
                info("PT Entry (filterd by keyword): {:d}".format(len(lines)))

        # sort by phys
        if self.sort_by_phys:
            lines = sorted(lines, key=lambda x: x.split()[1])

        # check how many result
        if lines == []:
            warn("Nothing to display")
            return

        # print
        gef_print(titlify("Memory map"))
        gef_print(Color.colorify(self.format_legend(), get_gef_setting("theme.table_heading")))
        for line in lines:
            gef_print(line)
        return

    def is_not_trace_target(self, va_start, va_end):
        if self.trace == []:
            return False
        for tr in self.trace:
            if va_start <= tr and tr < va_end:
                return False
        return True

    def is_not_filter_target(self, line):
        if self.filter == []:
            return False
        for filt in self.filter:
            if re.search(filt, line):
                return False
        return True

    def parse_common_args(self, argv):
        self.quiet = False
        if "-q" in argv:
            self.quiet = True
            argv.remove("-q")

        self.print_each_level = False
        if "--print-each-level" in argv:
            self.print_each_level = True
            argv.remove("--print-each-level")

        self.no_merge = False
        if "--no-merge" in argv:
            self.no_merge = True
            argv.remove("--no-merge")

        self.sort_by_phys = False
        if "--sort-by-phys" in argv:
            self.sort_by_phys = True
            argv.remove("--sort-by-phys")

        self.simple = False
        if "--simple" in argv:
            self.simple = True
            argv.remove("--simple")

        self.filter = []
        while "--filter" in argv:
            idx = argv.index("--filter")
            pattern = argv[idx + 1]
            self.filter.append(pattern)
            argv = argv[:idx] + argv[idx+2:]

        self.vrange = []
        while "--vrange" in argv:
            idx = argv.index("--vrange")
            vrange_addr = int(argv[idx + 1], 16)
            self.vrange.append(vrange_addr)
            argv = argv[:idx] + argv[idx+2:]

        self.prange = []
        while "--prange" in argv:
            idx = argv.index("--prange")
            prange_addr = int(argv[idx + 1], 16)
            self.prange.append(prange_addr)
            argv = argv[:idx] + argv[idx+2:]

        self.trace = []
        while "--trace" in argv:
            idx = argv.index("--trace")
            trace_addr = int(argv[idx + 1], 16)
            self.trace.append(trace_addr)
            self.vrange.append(trace_addr) # also set --vrange
            argv = argv[:idx] + argv[idx+2:]
            self.print_each_level = True # overwrite

        self.cache = {}
        return argv

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_x86_32_64_or_arm_32_64
    def do_invoke(self, argv):
        self.dont_repeat()
        if is_x86_32():
            gdb.execute("pagewalk x86 {}".format(' '.join(argv)))
        elif is_x86_64():
            gdb.execute("pagewalk x64 {}".format(' '.join(argv)))
        elif is_arm32():
            gdb.execute("pagewalk arm {}".format(' '.join(argv)))
        elif is_arm64():
            gdb.execute("pagewalk arm64 {}".format(' '.join(argv)))
        return


@register_command
class PagewalkX64Command(PagewalkCommand):
    """Dump pagetable for x64/x86 using qemu-monitor."""
    _cmdline_ = "pagewalk x64"
    _syntax_ = "{:s} [-h] [-q] [--print-each-level] [--no-merge] [--filter REGEX] [--vrange ADDR] [--prange ADDR] [--sort-by-phys] [--simple] [--trace ADDR]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} --print-each-level # show all level pagetables\n".format(_cmdline_)
    _example_ += "{:s} --no-merge         # do not merge similar/consecutive address\n".format(_cmdline_)
    _example_ += "{:s} --filter 0xabc     # grep by REGEX pattern\n".format(_cmdline_)
    _example_ += "{:s} --vrange 0x7fff00  # filter by map included specific virtual address\n".format(_cmdline_)
    _example_ += "{:s} --prange 0x7fff00  # filter by map included specific physical address\n".format(_cmdline_)
    _example_ += "{:s} --sort-by-phys     # sort by physical address\n".format(_cmdline_)
    _example_ += "{:s} --simple           # merge with ignoring physical address consecutivness\n".format(_cmdline_)
    _example_ += "{:s} --trace 0x7fff00   # show all level pagetables only associated specific address\n".format(_cmdline_)
    _example_ += "{:s} -q                 # show result only (quiet)".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"
    _aliases_ = ["pagewalk x86",]

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        return

    def format_flags(self, flag_info):
        flags = []
        if "NO_RW" in flag_info and "XD" in flag_info:
            flags += ["R--"]
        elif "NO_RW" in flag_info and not "XD" in flag_info:
            flags += ["R-X"]
        elif not "NO_RW" in flag_info and "XD" in flag_info:
            flags += ["RW-"]
        elif not "NO_RW" in flag_info and not "XD" in flag_info:
            flags += ["RWX"]
        if "NO_US" in flag_info:
            flags += ["KERN"]
        else:
            flags += ["USER"]
        if "A" in flag_info:
            flags += ["ACCESSED"]
        if "D" in flag_info:
            flags += ["DIRTY"]
        if "G" in flag_info:
            flags += ["GLOBAL"]
        return ' '.join(flags)

    def pagewalk_PML5T(self):
        if not self.quiet:
            gef_print(titlify("PML5E: Page Map Level 5 Entry"))
        PML5E = []
        COUNT = 0; INVALID = 0
        for va_base, table_base, parent_flags in self.TABLES:
            entries = self.read_physmem_cache(table_base, 2**self.bits["PML5T_BITS"] * self.bits["ENTRY_SIZE"])
            entries = self.slice_unpack(entries, self.bits["ENTRY_SIZE"])
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    INVALID += 1
                    continue

                # calc virtual address
                b = self.bits["PML4T_BITS"] + self.bits["PDPT_BITS"] + self.bits["PDT_BITS"] + self.bits["PT_BITS"] + self.bits["OFFSET"]
                sign_ext = 0xfe00000000000000 if ((i >> (self.bits["PML5T_BITS"]-1)) & 1) else 0
                new_va = va_base + (sign_ext | (i << b))
                new_va_end = new_va + (1 << b)

                # calc flags
                flags = parent_flags.copy()
                if ((entry >> 1) & 1) == 0: flags.append("NO_RW")
                if ((entry >> 2) & 1) == 0: flags.append("NO_US")
                if ((entry >> 5) & 1) == 1: flags.append("A")
                if ((entry >> 63) & 1) == 1: flags.append("XD")

                # calc next table (drop the flag bits)
                next_level_table = entry & 0x000ffffffffff000

                # make entry
                PML5E.append([new_va, next_level_table, flags])
                entry_type = "TABLE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * self.bits["ENTRY_SIZE"]
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("PML5 Entry: {:d}".format(len(PML5E)))
            info("Invalid entries: {:d}".format(INVALID))
        self.TABLES = PML5E
        return

    def pagewalk_PML4T(self):
        if not self.quiet:
            gef_print(titlify("PML4E: Page Map Level 4 Entry"))
        PML4E = []
        COUNT = 0; INVALID = 0
        for va_base, table_base, parent_flags in self.TABLES:
            entries = self.read_physmem_cache(table_base, 2**self.bits["PML4T_BITS"] * self.bits["ENTRY_SIZE"])
            entries = self.slice_unpack(entries, self.bits["ENTRY_SIZE"])
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    INVALID += 1
                    continue

                # calc virtual address
                b = self.bits["PDPT_BITS"] + self.bits["PDT_BITS"] + self.bits["PT_BITS"] + self.bits["OFFSET"]
                if "PML5T_BITS" in self.bits:
                    new_va = va_base + (i << b)
                    new_va_end = new_va + (1 << b)
                else:
                    sign_ext = 0xffff000000000000 if ((i >> (self.bits["PML4T_BITS"]-1)) & 1) else 0
                    new_va = va_base + (sign_ext | (i << b))
                    new_va_end = new_va + (1 << b)

                # calc flags
                flags = parent_flags.copy()
                if ((entry >> 1) & 1) == 0: flags.append("NO_RW")
                if ((entry >> 2) & 1) == 0: flags.append("NO_US")
                if ((entry >> 5) & 1) == 1: flags.append("A")
                if ((entry >> 63) & 1) == 1: flags.append("XD")

                # calc next table (drop the flag bits)
                next_level_table = entry & 0x000ffffffffff000

                # make entry
                PML4E.append([new_va, next_level_table, flags])
                entry_type = "TABLE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * self.bits["ENTRY_SIZE"]
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("PML4 Entry: {:d}".format(len(PML4E)))
            info("Invalid entries: {:d}".format(INVALID))
        self.TABLES = PML4E
        return

    def pagewalk_PDPT(self):
        if not self.quiet:
            gef_print(titlify("PDPE: Page Directory Pointer Entry"))

        def is_set_PS(entry):
            return ((entry >> 7) & 1) == 1

        PDPTE = []; PTE = []
        COUNT = 0; INVALID = 0
        for va_base, table_base, parent_flags in self.TABLES:
            entries = self.read_physmem_cache(table_base, 2**self.bits["PDPT_BITS"] * self.bits["ENTRY_SIZE"])
            entries = self.slice_unpack(entries, self.bits["ENTRY_SIZE"])
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    INVALID += 1
                    continue

                # calc virtual address
                new_va = va_base + (i << (self.bits["PDT_BITS"] + self.bits["PT_BITS"] + self.bits["OFFSET"]))
                new_va_end = new_va + (1 << (self.bits["PDT_BITS"] + self.bits["PT_BITS"] + self.bits["OFFSET"]))

                # calc flags
                flags = parent_flags.copy()
                if is_x86_64():
                    if ((entry >> 1) & 1) == 0: flags.append("NO_RW")
                    if ((entry >> 2) & 1) == 0: flags.append("NO_US")
                    if ((entry >> 5) & 1) == 1: flags.append("A")
                    if is_set_PS(entry) and ((entry >> 6) & 1) == 1: flags.append("D")
                    if is_set_PS(entry) and ((entry >> 8) & 1) == 1: flags.append("G")
                    if ((entry >> 63) & 1) == 1: flags.append("XD")
                else: # x86_32 and PAE
                    pass

                # calc next table (drop the flag bits)
                if is_x86_64() and is_set_PS(entry):
                    next_level_table = entry & 0x000fffffffffe000
                else:
                    next_level_table = entry & 0x000ffffffffff000

                # make entry
                if is_set_PS(entry):
                    virt_addr = new_va
                    phys_addr = next_level_table
                    page_size = 1 * 1024 * 1024 * 1024
                    page_count = 1
                    PTE.append([virt_addr, phys_addr, page_size, page_count, self.format_flags(flags)])
                    entry_type = "1GB-PAGE"
                else:
                    PDPTE.append([new_va, next_level_table, flags])
                    entry_type = "TABLE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * self.bits["ENTRY_SIZE"]
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("PDPT Entry: {:d}".format(len(PDPTE)))
            info("PT Entry (1GB): {:d}".format(len(PTE)))
            info("Invalid entries: {:d}".format(INVALID))
        self.TABLES = PDPTE
        self.PTE += PTE
        return

    def pagewalk_PDT(self):
        if not self.quiet:
            gef_print(titlify("PDE: Page Directory Entry"))

        def is_set_PS(entry):
            return ((entry >> 7) & 1) == 1

        PDE = []; PTE = []
        COUNT = 0; INVALID = 0
        for va_base, table_base, parent_flags in self.TABLES:
            entries = self.read_physmem_cache(table_base, 2**self.bits["PDT_BITS"] * self.bits["ENTRY_SIZE"])
            entries = self.slice_unpack(entries, self.bits["ENTRY_SIZE"])
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    INVALID += 1
                    continue

                # calc virtual address
                new_va = va_base + (i << (self.bits["PT_BITS"] + self.bits["OFFSET"]))
                new_va_end = new_va + (1 << (self.bits["PT_BITS"] + self.bits["OFFSET"]))

                # calc flags
                flags = parent_flags.copy()
                if ((entry >> 1) & 1) == 0: flags.append("NO_RW")
                if ((entry >> 2) & 1) == 0: flags.append("NO_US")
                if ((entry >> 5) & 1) == 1: flags.append("A")
                if is_set_PS(entry) and ((entry >> 6) & 1) == 1: flags.append("D")
                if is_set_PS(entry) and ((entry >> 8) & 1) == 1: flags.append("G")
                if self.PAE and ((entry >> 63) & 1) == 1: flags.append("XD")

                # calc next table (drop the flag bits)
                if is_x86_64() and is_set_PS(entry):
                    next_level_table = entry & 0x000fffffffffe000
                elif is_x86_32() and is_set_PS(entry):
                    high = (entry >> 13) & 0xf
                    low = (entry >> 22) & 0x3ff
                    next_level_table = (high << 10) | low
                else:
                    next_level_table = entry & 0x000ffffffffff000

                # make entry
                if is_set_PS(entry):
                    virt_addr = new_va
                    phys_addr = next_level_table
                    if self.PAE:
                        page_size = 2 * 1024 * 1024
                        entry_type = "2MB-PAGE"
                    else:
                        page_size = 4 * 1024 * 1024
                        entry_type = "4MB-PAGE"
                    page_count = 1
                    PTE.append([virt_addr, phys_addr, page_size, page_count, self.format_flags(flags)])
                else:
                    PDE.append([new_va, next_level_table, flags])
                    entry_type = "TABLE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * self.bits["ENTRY_SIZE"]
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("PD Entry: {:d}".format(len(PDE)))
            info("PT Entry ({:d}MB): {:d}".format(2 if self.PAE else 4, len(PTE)))
            info("Invalid entries: {:d}".format(INVALID))
        self.TABLES = PDE
        self.PTE += PTE
        return

    def pagewalk_PT(self):
        if not self.quiet:
            gef_print(titlify("PTE: Page Table Entry"))
        PTE = []
        COUNT = 0; INVALID = 0
        for va_base, table_base, parent_flags in self.TABLES:
            entries = self.read_physmem_cache(table_base, 2**self.bits["PT_BITS"] * self.bits["ENTRY_SIZE"])
            entries = self.slice_unpack(entries, self.bits["ENTRY_SIZE"])
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    INVALID += 1
                    continue

                # calc virtual address
                virt_addr = va_base + (i << self.bits["OFFSET"])
                virt_addr_end = virt_addr + (1 << self.bits["OFFSET"])

                # calc flags
                flags = parent_flags.copy()
                if ((entry >> 1) & 1) == 0: flags.append("NO_RW")
                if ((entry >> 2) & 1) == 0: flags.append("NO_US")
                if ((entry >> 5) & 1) == 1: flags.append("A")
                if ((entry >> 6) & 1) == 1: flags.append("D")
                if ((entry >> 8) & 1) == 1: flags.append("G")
                if self.PAE and ((entry >> 63) & 1) == 1: flags.append("XD")

                # calc physical addr (drop the flag bits)
                phys_addr = entry & 0x000ffffffffff000

                # make entry
                page_size = 4 * 1024
                page_count = 1
                PTE.append([virt_addr, phys_addr, page_size, page_count, self.format_flags(flags)])
                entry_type = "4KB-PAGE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(virt_addr, virt_addr_end):
                        continue
                    addr = table_base + i * self.bits["ENTRY_SIZE"]
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, virt_addr, virt_addr_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("PT Entry (4KB): {:d}".format(len(PTE)))
            info("Invalid entries: {:d}".format(INVALID))
        self.PTE += PTE
        return

    def pagewalk(self):
        # `info tlb` on qemu-monitor returns pagetable without intermediate pagetable information.
        # for printing it, we will pagewalk manually.
        res = gdb.execute("monitor info registers", to_string=True)
        cr3 = int(re.search(r"CR3=(\S+)", res).group(1), 16)
        cr4 = int(re.search(r"CR4=(\S+)", res).group(1), 16)
        if not self.quiet:
            info("cr3: {:#018x}".format(cr3))
            info("cr4: {:#018x}".format(cr4))

        # virtual address base
        va_base = 0

        # pagewalk base is from CR3 register
        if is_x86_64(): # 64bit
            pagewalk_base = (cr3 >> 12) << 12
        elif ((cr4 >> 5) & 1) == 1: # 32bit PAE
            pagewalk_base = (cr3 >> 5) << 5
        else: # 32bit non-PAE
            pagewalk_base = (cr3 >> 12) << 12

        # we ignore PWT and PCD flags.
        flags = []

        # do pagewalk
        self.PTE = []
        self.TABLES = [(va_base, pagewalk_base, flags)]
        if is_x86_64():
            if (cr4 >> 12) & 1: # PML5T check
                # 64bit 5-level(4KB): 9,9,9,9,9,12
                # 64bit 5-level(2MB): 9,9,9,9,0,21
                # 64bit 5-level(1GB): 9,9,9,0,0,30
                if not self.quiet:
                    info("64-bit 5 level page table")
                self.bits = { "ENTRY_SIZE":64//8, "PML5T_BITS":9, "PML4T_BITS":9, "PDPT_BITS":9, "PDT_BITS":9, "PT_BITS":9, "OFFSET":12 }
                self.PAE = True
                self.pagewalk_PML5T()
                self.pagewalk_PML4T()
                self.pagewalk_PDPT()
                self.pagewalk_PDT()
                self.pagewalk_PT()
            else:
                # 64bit 4-level(4KB): 9,9,9,9,12
                # 64bit 4-level(2MB): 9,9,9,0,21
                # 64bit 4-level(1GB): 9,9,0,0,30
                if not self.quiet:
                    info("64-bit 4 level page table")
                self.bits = { "ENTRY_SIZE":64//8, "PML4T_BITS":9, "PDPT_BITS":9, "PDT_BITS":9, "PT_BITS":9, "OFFSET":12 }
                self.PAE = True
                self.pagewalk_PML4T()
                self.pagewalk_PDPT()
                self.pagewalk_PDT()
                self.pagewalk_PT()
        elif is_x86_32():
            if (cr4 >> 5) & 1: # PAE check
                # 32bit PAE(4KB): 2,9,9,12 (PTE Size: 64bit)
                # 32bit PAE(2MB): 2,9,0,21 (PTE Size: 64bit)
                if not self.quiet:
                    info("32-bit {:s} page table".format(Color.boldify("PAE")))
                self.bits = { "ENTRY_SIZE":64//8, "PDPT_BITS":2, "PDT_BITS":9, "PT_BITS":9, "OFFSET":12 }
                self.PAE = True
                self.pagewalk_PDPT()
                self.pagewalk_PDT()
                self.pagewalk_PT()
            else:
                # 32bit(4KB): 10,10,12
                # 32bit(4MB): 10,0,22
                if not self.quiet:
                    info("32-bit Non-PAE page table")
                self.bits = { "ENTRY_SIZE":32//8, "PDT_BITS":10, "PT_BITS":10, "OFFSET":12 }
                self.PAE = False
                self.pagewalk_PDT()
                self.pagewalk_PT()
        else:
            err("Unsupported")
            return

        if not self.quiet:
            gef_print(titlify("Total"))
            info("PT Entry (Total): {:d}".format(len(self.PTE)))
        self.mappings = self.PTE
        self.print_page()
        return

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_x86_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        try:
            argv = self.parse_common_args(argv)
            if argv:
                raise
        except:
            self.usage()
            return
        self.mappings = None
        self.pagewalk()
        self.cache = {}
        return


@register_command
class PagewalkArmCommand(PagewalkCommand):
    """Dump pagetable for ARM (Cortex-A only) using qemu-monitor."""
    _cmdline_ = "pagewalk arm"
    _syntax_ = "{:s} [-h] [-q] [-S|-s] [--print-each-level] [--no-merge] [--filter REGEX] [--vrange ADDR] [--prange ADDR] [--sort-by-phys] [--simple] [--trace ADDR]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} --print-each-level # show all level pagetables\n".format(_cmdline_)
    _example_ += "{:s} --no-merge         # do not merge similar/consecutive address\n".format(_cmdline_)
    _example_ += "{:s} --filter 0xabc     # grep by REGEX pattern\n".format(_cmdline_)
    _example_ += "{:s} --vrange 0x7fff00  # filter by map included specific virtual address\n".format(_cmdline_)
    _example_ += "{:s} --prange 0x7fff00  # filter by map included specific physical address\n".format(_cmdline_)
    _example_ += "{:s} --sort-by-phys     # sort by physical address\n".format(_cmdline_)
    _example_ += "{:s} --simple           # merge with ignoring physical address consecutivness\n".format(_cmdline_)
    _example_ += "{:s} --trace 0x7fff00   # show all level pagetables only associated specific address\n".format(_cmdline_)
    _example_ += "{:s} -q                 # show result only (quiet)\n".format(_cmdline_)
    _example_ += "{:s} -S                 # use TTBRn_ELm_S for parsing start register\n".format(_cmdline_)
    _example_ += "{:s} -s                 # use TTBRn_ELm for parsing start register\n".format(_cmdline_)
    _example_ += "PL2 pagewalk is unsupported"
    _category_ = "Qemu-system Cooperation"

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        return

    def format_flags_short(self, flag_info):
        flags = []

        XN = "XN" in flag_info
        PXN = "PXN" in flag_info
        PXN &= self.PXN

        # AP[2:0] access permissions model
        if "AP=000" in flag_info:
            if XN == False and PXN == False:
                flags += ['PL0/---', "PL1/---"] #
            elif XN == False and PXN == True:
                flags += ['PL0/---', "PL1/---"] # PXN
            elif XN == True and PXN == False:
                flags += ['PL0/---', "PL1/---"] # XN
            elif XN == True and PXN == True:
                flags += ['PL0/---', "PL1/---"] # XN, PXN
        elif "AP=001" in flag_info:
            if XN == False and PXN == False:
                flags += ['PL0/---', "PL1/RWX"] #
            elif XN == False and PXN == True:
                flags += ['PL0/---', "PL1/RW-"] # PXN
            elif XN == True and PXN == False:
                flags += ['PL0/---', "PL1/RW-"] # XN
            elif XN == True and PXN == True:
                flags += ['PL0/---', "PL1/RW-"] # XN, PXN
        elif "AP=010" in flag_info:
            if XN == False and PXN == False:
                flags += ['PL0/R-X', "PL1/RWX"] #
            elif XN == False and PXN == True:
                flags += ['PL0/R-X', "PL1/RW-"] # PXN
            elif XN == True and PXN == False:
                flags += ['PL0/R--', "PL1/RW-"] # XN
            elif XN == True and PXN == True:
                flags += ['PL0/R--', "PL1/RW-"] # XN, PXN
        elif "AP=011" in flag_info:
            if XN == False and PXN == False:
                flags += ['PL0/RWX', "PL1/RWX"] #
            elif XN == False and PXN == True:
                flags += ['PL0/RWX', "PL1/RW-"] # PXN
            elif XN == True and PXN == False:
                flags += ['PL0/RW-', "PL1/RW-"] # XN
            elif XN == True and PXN == True:
                flags += ['PL0/RW-', "PL1/RW-"] # XN, PXN
        elif "AP=100" in flag_info:
            flags += ['PL0/???', "PL1/???"] # undefined (reserved)
        elif "AP=101" in flag_info:
            if XN == False and PXN == False:
                flags += ['PL0/---', "PL1/R-X"] #
            elif XN == False and PXN == True:
                flags += ['PL0/---', "PL1/R--"] # PXN
            elif XN == True and PXN == False:
                flags += ['PL0/---', "PL1/R--"] # XN
            elif XN == True and PXN == True:
                flags += ['PL0/---', "PL1/R--"] # XN, PXN
        elif "AP=110" in flag_info: # deprecated
            if XN == False and PXN == False:
                flags += ['PL0/R-X', "PL1/R-X"] #
            elif XN == False and PXN == True:
                flags += ['PL0/R-X', "PL1/R--"] # PXN
            elif XN == True and PXN == False:
                flags += ['PL0/R--', "PL1/R--"] # XN
            elif XN == True and PXN == True:
                flags += ['PL0/R--', "PL1/R--"] # XN, PXN
        elif "AP=111" in flag_info:
            if XN == False and PXN == False:
                flags += ['PL0/R-X', "PL1/R-X"] #
            elif XN == False and PXN == True:
                flags += ['PL0/R-X', "PL1/R--"] # PXN
            elif XN == True and PXN == False:
                flags += ['PL0/R--', "PL1/R--"] # XN
            elif XN == True and PXN == True:
                flags += ['PL0/R--', "PL1/R--"] # XN, PXN
        # AP[2:1] access permissions model
        elif "AP=00" in flag_info:
            if XN == False and PXN == False:
                flags += ['PL0/---', "PL1/RWX"] #
            elif XN == False and PXN == True:
                flags += ['PL0/---', "PL1/RW-"] # PXN
            elif XN == True and PXN == False:
                flags += ['PL0/---', "PL1/RW-"] # XN
            elif XN == True and PXN == True:
                flags += ['PL0/---', "PL1/RW-"] # XN, PXN
        elif "AP=01" in flag_info:
            if XN == False and PXN == False:
                flags += ['PL0/RWX', "PL1/RWX"] #
            elif XN == False and PXN == True:
                flags += ['PL0/RWX', "PL1/RW-"] # PXN
            elif XN == True and PXN == False:
                flags += ['PL0/RW-', "PL1/RW-"] # XN
            elif XN == True and PXN == True:
                flags += ['PL0/RW-', "PL1/RW-"] # XN, PXN
        elif "AP=10" in flag_info:
            if XN == False and PXN == False:
                flags += ['PL0/---', "PL1/R-X"] #
            elif XN == False and PXN == True:
                flags += ['PL0/---', "PL1/R--"] # PXN
            elif XN == True and PXN == False:
                flags += ['PL0/---', "PL1/R--"] # XN
            elif XN == True and PXN == True:
                flags += ['PL0/---', "PL1/R--"] # XN, PXN
        elif "AP=11" in flag_info:
            if XN == False and PXN == False:
                flags += ['PL0/R-X', "PL1/R-X"] #
            elif XN == False and PXN == True:
                flags += ['PL0/R-X', "PL1/R--"] # PXN
            elif XN == True and PXN == False:
                flags += ['PL0/R--', "PL1/R--"] # XN
            elif XN == True and PXN == True:
                flags += ['PL0/R--', "PL1/R--"] # XN, PXN

        if "NS" in flag_info:
            flags += ['NS']
        # short description has no `AF` bit
        if "nG" not in flag_info:
            flags += ["GLOBAL"]
        return ' '.join(flags)

    def format_flags_long(self, flag_info):
        flags = []

        # AP/APTable parsing
        if "AP=00" in flag_info:
            disable_write_access = 0
            enable_unpriv_access = 0
        elif "AP=01" in flag_info:
            disable_write_access = 0
            enable_unpriv_access = 1
        elif "AP=10" in flag_info:
            disable_write_access = 1
            enable_unpriv_access = 0
        elif "AP=11" in flag_info:
            disable_write_access = 1
            enable_unpriv_access = 1
        if "APTable2=00" in flag_info:
            pass
        elif "APTable2=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable2=10" in flag_info:
            disable_write_access |= 1
        elif "APTable2=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0
        if "APTable1=00" in flag_info:
            pass
        elif "APTable1=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable1=10" in flag_info:
            disable_write_access |= 1
        elif "APTable1=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0
        AP = (disable_write_access << 1) | enable_unpriv_access

        # XN/XNTable, PXN/PXNTable, NS/NSTable parsing
        XN = "XN" in flag_info
        XN |= "XNTable2" in flag_info
        XN |= "XNTable1" in flag_info
        PXN = "PXN" in flag_info
        PXN |= "PXNTable2" in flag_info
        PXN |= "PXNTable1" in flag_info
        PXN &= self.PXN
        NS = "NS" in flag_info
        NS |= "NSTable2" in flag_info
        NS |= "NSTable1" in flag_info

        # AP[2:1] access permissions model
        if AP == 0b00:
            if XN == False and PXN == False:
                flags += ['PL0/---', "PL1/RWX"] #
            elif XN == False and PXN == True:
                flags += ['PL0/---', "PL1/RW-"] # PXN
            elif XN == True and PXN == False:
                flags += ['PL0/---', "PL1/RW-"] # XN
            elif XN == True and PXN == True:
                flags += ['PL0/---', "PL1/RW-"] # XN, PXN
        elif AP == 0b01:
            if XN == False and PXN == False:
                flags += ['PL0/RWX', "PL1/RWX"] #
            elif XN == False and PXN == True:
                flags += ['PL0/RWX', "PL1/RW-"] # PXN
            elif XN == True and PXN == False:
                flags += ['PL0/RW-', "PL1/RW-"] # XN
            elif XN == True and PXN == True:
                flags += ['PL0/RW-', "PL1/RW-"] # XN, PXN
        elif AP == 0b10:
            if XN == False and PXN == False:
                flags += ['PL0/---', "PL1/R-X"] #
            elif XN == False and PXN == True:
                flags += ['PL0/---', "PL1/R--"] # PXN
            elif XN == True and PXN == False:
                flags += ['PL0/---', "PL1/R--"] # XN
            elif XN == True and PXN == True:
                flags += ['PL0/---', "PL1/R--"] # XN, PXN
        elif AP == 0b11:
            if XN == False and PXN == False:
                flags += ['PL0/R-X', "PL1/R-X"] #
            elif XN == False and PXN == True:
                flags += ['PL0/R-X', "PL1/R--"] # PXN
            elif XN == True and PXN == False:
                flags += ['PL0/R--', "PL1/R--"] # XN
            elif XN == True and PXN == True:
                flags += ['PL0/R--', "PL1/R--"] # XN, PXN

        if NS:
            flags += ['NS']
        if "AF" in flag_info:
            flags += ['ACCESSED']
        if "nG" not in flag_info:
            flags += ["GLOBAL"]
        return ' '.join(flags)

    def do_pagewalk_short(self, table_base, va_base=0):
        self.mappings = []

        def has_next_level(entry):
            return (entry & 0b11) == 0b01
        def is_section(entry):
            return (entry & 0b11) in [0b10, 0b11] and ((entry >> 18) & 1) == 0
        def is_super_section(entry):
            return (entry & 0b11) in [0b10, 0b11] and ((entry >> 18) & 1) == 1
        def is_large_page(entry):
            return (entry & 0b11) == 0b01
        def is_small_page(entry):
            return (entry & 0b11) in [0b10, 0b11]

        # 1st level parse
        if not self.quiet:
            gef_print(titlify("LEVEL 1"))
        LEVEL1 = []; SECTION = []; SUPER_SECTION = []
        COUNT = 0; INVALID = 0
        entries = self.read_physmem_cache(table_base, 4 * (2**(12-self.N)))
        entries = self.slice_unpack(entries, 4)
        COUNT += len(entries)
        for i, entry in enumerate(entries):
            # present flag
            if (entry & 0b11) == 0b00:
                INVALID += 1
                continue

            # calc virtual address
            new_va = va_base + (i << 20)
            new_va_end = new_va + (1 << 20)

            # calc flags
            flags = []
            if has_next_level(entry):
                if ((entry >> 2) & 1) == 1: flags.append("PXN")
                if ((entry >> 3) & 1) == 1: flags.append("NS")
                flags.append("domain={:#x}".format((entry >> 5) & 0b1111))
            elif is_section(entry):
                if ((entry >> 0) & 1) == 1: flags.append("PXN")
                if ((entry >> 2) & 1) == 1: flags.append("B")
                if ((entry >> 3) & 1) == 1: flags.append("C")
                if ((entry >> 4) & 1) == 1: flags.append("XN")
                flags.append("domain={:#x}".format((entry >> 5) & 0b1111))
                ap = (((entry >> 15) & 1) << 2) + ((entry >> 10) & 0b11)
                if self.AFE: # AP[2:1] access permissions model
                    flags.append("AP={:02b}".format(ap >> 1))
                else: # AP[2:0] access permissions model
                    flags.append("AP={:03b}".format(ap))
                flags.append("TEX={:#x}".format((entry >> 12) & 0b111))
                if ((entry >> 16) & 1) == 1: flags.append("S")
                if ((entry >> 17) & 1) == 1: flags.append("nG")
                if ((entry >> 19) & 1) == 1: flags.append("NS")
            elif is_super_section(entry):
                if ((entry >> 0) & 1) == 1: flags.append("PXN")
                if ((entry >> 2) & 1) == 1: flags.append("B")
                if ((entry >> 3) & 1) == 1: flags.append("C")
                if ((entry >> 4) & 1) == 1: flags.append("XN")
                ap = (((entry >> 15) & 1) << 2) + ((entry >> 10) & 0b11)
                if self.AFE: # AP[2:1] access permissions model
                    flags.append("AP={:02b}".format(ap >> 1))
                else: # AP[2:0] access permissions model
                    flags.append("AP={:03b}".format(ap))
                flags.append("TEX={:#x}".format((entry >> 12) & 0b111))
                if ((entry >> 16) & 1) == 1: flags.append("S")
                if ((entry >> 17) & 1) == 1: flags.append("nG")
                if ((entry >> 19) & 1) == 1: flags.append("NS")

            # calc next table (drop the flag bits)
            if has_next_level(entry):
                next_level_table = entry & 0xfffffc00
            elif is_section(entry):
                next_level_table = entry & 0xfff00000
            elif is_super_section(entry):
                next_level_table = entry & 0xff000000         # PA[31:24]
                next_level_table += (entry & 0x00f0000) << 12 # PA[35:32]
                next_level_table += (entry & 0x00001e0) << 31 # PA[39:36]

            # make entry
            if has_next_level(entry):
                LEVEL1.append([new_va, next_level_table, flags])
                entry_type = "TABLE"
            elif is_section(entry):
                virt_addr = new_va
                phys_addr = next_level_table
                page_size = 1 * 1024 * 1024
                page_count = 1
                SECTION.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_short(flags)])
                entry_type = "SECTION"
            elif is_super_section(entry):
                virt_addr = new_va
                phys_addr = next_level_table
                page_size = 16 * 1024 * 1024
                page_count = 1
                SUPER_SECTION.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_short(flags)])
                entry_type = "SUPER_SECTION"

            # dump
            if self.print_each_level:
                if self.is_not_trace_target(new_va, new_va_end):
                    continue
                addr = table_base + i * 4
                fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                if self.is_not_filter_target(line):
                    continue
                gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("Level 1 Entry: {:d}".format(len(LEVEL1)))
            info("PT Entry (supersection; 16MB): {:d}".format(len(SUPER_SECTION)))
            info("PT Entry (section; 1MB): {:d}".format(len(SECTION)))
            info("Invalid entries: {:d}".format(INVALID))
        self.mappings += SECTION + SUPER_SECTION

        # 2nd level parse
        if not self.quiet:
            gef_print(titlify("LEVEL 2"))
        LARGE = []; SMALL = []
        COUNT = 0; INVALID = 0
        for va_base, table_base, parent_flags in LEVEL1:
            entries = self.read_physmem_cache(table_base, 4 * (2**8))
            entries = self.slice_unpack(entries, 4)
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 0b11) == 0b00:
                    INVALID += 1
                    continue

                # calc virtual address
                virt_addr = va_base + (i << 12)
                virt_addr_end = virt_addr + (1 << 12)

                # calc flags
                flags = parent_flags.copy()
                if is_large_page(entry):
                    if ((entry >> 2) & 1) == 1: flags.append("B")
                    if ((entry >> 3) & 1) == 1: flags.append("C")
                    ap = (((entry >> 9) & 1) << 2) + ((entry >> 4) & 0b11)
                    if self.AFE: # AP[2:1] access permissions model
                        flags.append("AP={:02b}".format(ap >> 1))
                    else: # AP[2:0] access permissions model
                        flags.append("AP={:03b}".format(ap))
                    if ((entry >> 10) & 1) == 1: flags.append("S")
                    if ((entry >> 11) & 1) == 1: flags.append("nG")
                    flags.append("TEX={:#x}".format((entry >> 12) & 0b111))
                    if ((entry >> 15) & 1) == 1: flags.append("XN")
                elif is_small_page(entry):
                    if ((entry >> 0) & 1) == 1: flags.append("XN")
                    if ((entry >> 2) & 1) == 1: flags.append("B")
                    if ((entry >> 3) & 1) == 1: flags.append("C")
                    ap = (((entry >> 9) & 1) << 2) + ((entry >> 4) & 0b11)
                    if self.AFE: # AP[2:1] access permissions model
                        flags.append("AP={:02b}".format(ap >> 1))
                    else: # AP[2:0] access permissions model
                        flags.append("AP={:03b}".format(ap))
                    flags.append("TEX={:#x}".format((entry >> 6) & 0b111))
                    if ((entry >> 10) & 1) == 1: flags.append("S")
                    if ((entry >> 11) & 1) == 1: flags.append("nG")

                # calc physical addr (drop the flag bits)
                if is_large_page(entry):
                    phys_addr = entry & 0xffff0000
                elif is_small_page(entry):
                    phys_addr = entry & 0xfffff000

                # make entry
                if is_large_page(entry):
                    page_size = 64 * 1024
                    page_count = 1
                    LARGE.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_short(flags)])
                    entry_type = "LARGE"
                elif is_small_page(entry):
                    page_size = 4 * 1024
                    page_count = 1
                    SMALL.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_short(flags)])
                    entry_type = "SMALL"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(virt_addr, virt_addr_end):
                        continue
                    addr = table_base + i * 4
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, virt_addr, virt_addr_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("PT Entry (large; 64KB): {:d}".format(len(LARGE)))
            info("PT Entry (small; 4KB): {:d}".format(len(SMALL)))
            info("Invalid entries: {:d}".format(INVALID))
        self.mappings += LARGE + SMALL

        if not self.quiet:
            gef_print(titlify("Total"))
            info("PT Entry (Total): {:d}".format(len(self.mappings)))
        self.mappings = sorted(self.mappings)
        return

    def do_pagewalk_long(self, table_base, va_base=0):
        self.mappings = []

        def has_next_level(entry):
            return (entry & 0b11) == 0b11
        def is_1GB_page(entry):
            return (entry & 0b11) == 0b01
        def is_2MB_page(entry):
            return (entry & 0b11) == 0b01

        if not self.quiet:
            gef_print(titlify("LEVEL 1"))
        if self.N < 2:
            # 1st level parse
            LEVEL1 = []; GB = []
            COUNT = 0; INVALID = 0
            entries = self.read_physmem_cache(table_base, 8 * (2**2))
            entries = self.slice_unpack(entries, 8)
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    INVALID += 1
                    continue

                # calc virtual address
                new_va = va_base | (i << 30)
                new_va_end = new_va + (1 << 30)

                # calc flags
                flags = []
                if has_next_level(entry):
                    if ((entry >> 59) & 1) == 1: flags.append("PXNTable1")
                    if ((entry >> 60) & 1) == 1: flags.append("XNTable1")
                    flags.append("APTable1={:02b}".format((entry >> 61) & 0b11))
                    if ((entry >> 63) & 1) == 1: flags.append("NSTable1")
                elif is_1GB_page(entry):
                    flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                    if ((entry >> 5) & 1) == 1: flags.append("NS")
                    flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                    flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                    if ((entry >> 10) & 1) == 1: flags.append("AF")
                    if ((entry >> 11) & 1) == 1: flags.append("nG")
                    if ((entry >> 52) & 1) == 1: flags.append("Contiguous")
                    if ((entry >> 53) & 1) == 1: flags.append("PXN")
                    if ((entry >> 54) & 1) == 1: flags.append("XN")

                # calc next table (drop the flag bits)
                if has_next_level(entry):
                    next_level_table = entry & 0x000000fffffff000
                elif is_1GB_page(entry):
                    next_level_table = entry & 0x000000ffc0000000

                # make entry
                if has_next_level(entry):
                    LEVEL1.append([new_va, next_level_table, flags])
                    entry_type = "TABLE"
                elif is_1GB_page(entry):
                    virt_addr = new_va
                    phys_addr = next_level_table
                    page_size = 1 * 1024 * 1024 * 1024
                    page_count = 1
                    GB.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_long(flags)])
                    entry_type = "1GB-PAGE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * 8
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

            if not self.quiet:
                info("Number of entries: {:d}".format(COUNT))
                info("Level 1 Entry: {:d}".format(len(LEVEL1)))
                info("PT Entry (1GB): {:d}".format(len(GB)))
                info("Invalid entries: {:d}".format(INVALID))
            self.mappings += GB
        else:
            if not self.quiet:
                info("LEVEL 1 is skipped")
            flags = []
            LEVEL1 = [[va_base, table_base, flags]]

        # 2nd level parse
        if not self.quiet:
            gef_print(titlify("LEVEL 2"))
        LEVEL2 = []; MB = []
        COUNT = 0; INVALID = 0
        for va_base, table_base, parent_flags in LEVEL1:
            entries = self.read_physmem_cache(table_base, 8 * (2**9))
            entries = self.slice_unpack(entries, 8)
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    INVALID += 1
                    continue

                # calc virtual address
                new_va = va_base | (i << 21)
                new_va_end = new_va + (1 << 21)

                # calc flags
                flags = parent_flags.copy()
                if has_next_level(entry):
                    if ((entry >> 59) & 1) == 1: flags.append("PXNTable2")
                    if ((entry >> 60) & 1) == 1: flags.append("XNTable2")
                    flags.append("APTable2={:02b}".format((entry >> 61) & 0b11))
                    if ((entry >> 63) & 1) == 1: flags.append("NSTable2")
                elif is_2MB_page(entry):
                    flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                    if ((entry >> 5) & 1) == 1: flags.append("NS")
                    flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                    flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                    if ((entry >> 10) & 1) == 1: flags.append("AF")
                    if ((entry >> 11) & 1) == 1: flags.append("nG")
                    if ((entry >> 52) & 1) == 1: flags.append("Contiguous")
                    if ((entry >> 53) & 1) == 1: flags.append("PXN")
                    if ((entry >> 54) & 1) == 1: flags.append("XN")

                # calc next table (drop the flag bits)
                if has_next_level(entry):
                    next_level_table = entry & 0x000000fffffff000
                elif is_2MB_page(entry):
                    next_level_table = entry & 0x000000ffffe00000

                # make entry
                if has_next_level(entry):
                    LEVEL2.append([new_va, next_level_table, flags])
                    entry_type = "TABLE"
                elif is_2MB_page(entry):
                    virt_addr = new_va
                    phys_addr = next_level_table
                    page_size = 2 * 1024 * 1024
                    page_count = 1
                    MB.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_long(flags)])
                    entry_type = "2MB-PAGE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * 8
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("Level 2 Entry: {:d}".format(len(LEVEL2)))
            info("PT Entry (2MB): {:d}".format(len(MB)))
            info("Invalid entries: {:d}".format(INVALID))
        self.mappings += MB

        # 3rd level parse
        if not self.quiet:
            gef_print(titlify("LEVEL 3"))
        KB = []
        COUNT = 0; INVALID = 0
        for va_base, table_base, parent_flags in LEVEL2:
            entries = self.read_physmem_cache(table_base, 8 * (2**9))
            entries = self.slice_unpack(entries, 8)
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 0b11) != 0b11:
                    INVALID += 1
                    continue

                # calc virtual address
                virt_addr = va_base | (i << 12)
                virt_addr_end = virt_addr + (1 << 12)

                # calc flags
                flags = parent_flags.copy()
                flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                if ((entry >> 5) & 1) == 1: flags.append("NS")
                flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                if ((entry >> 10) & 1) == 1: flags.append("AF")
                if ((entry >> 11) & 1) == 1: flags.append("nG")
                if ((entry >> 52) & 1) == 1: flags.append("Contiguous")
                if ((entry >> 53) & 1) == 1: flags.append("PXN")
                if ((entry >> 54) & 1) == 1: flags.append("XN")

                # calc physical addr (drop the flag bits)
                phys_addr = entry & 0x000000fffffff000

                # make entry
                page_size = 4 * 1024
                page_count = 1
                KB.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_long(flags)])
                entry_type = "1KB-PAGE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(virt_addr, virt_addr_end):
                        continue
                    addr = table_base + i * 8
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, virt_addr, virt_addr_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("PT Entry (4KB): {:d}".format(len(KB)))
            info("Invalid entries: {:d}".format(INVALID))
        self.mappings += KB

        if not self.quiet:
            gef_print(titlify("Total"))
            info("PT Entry (Total): {:d}".format(len(self.mappings)))
        self.mappings = sorted(self.mappings)
        return

    def pagewalk_short(self):
        gef_print(titlify("$TTBR0_EL1{}".format(self.suffix)))

        TTBR0_EL1 = get_register('$TTBR0_EL1{}'.format(self.suffix))
        if TTBR0_EL1 is None:
            err('$TTBR0_EL1{} is not found'.format(self.suffix))
            return

        TTBR1_EL1 = get_register('$TTBR1_EL1{}'.format(self.suffix))
        if TTBR1_EL1 is None:
            err('$TTBR1_EL1{} is not found'.format(self.suffix))
            return

        TTBCR = get_register('$TTBCR{}'.format(self.suffix))
        if TTBCR is None:
            err('$TTBCR{} is not found'.format(self.suffix))
            return

        # pagewalk TTBR0_EL1
        self.N = TTBCR & 0b111
        ml = 14 - self.N
        pl0_base = ((TTBR0_EL1 & ((1<<32)-1)) >> ml) << ml
        if not self.quiet:
            info("$TTBR0_EL1{}: {:#x}".format(self.suffix, TTBR0_EL1))
            info("$TTBCR{}: {:#x}".format(self.suffix, TTBCR))
            info("PL0 base: {:#x}".format(pl0_base))
        self.do_pagewalk_short(pl0_base)
        self.print_page()

        # pagewalk TTBR1_EL1
        gef_print(titlify("$TTBR1_EL1{}".format(self.suffix)))
        if self.suffix:
            pl1_vabase = 0 # I don't know why, but vabase of PL1 seems to be 0x0 when using TTBR1_EL1_S.
        else:
            pl1_vabase = {0:None, 1:0x80000000, 2:0x40000000, 3:0x20000000, 4:0x10000000, 5:0x08000000, 6:0x04000000, 7:0x02000000}[self.N]
        pl1_base = ((TTBR1_EL1 & ((1<<32)-1)) >> ml) << ml
        self.N = 0 # Whenever TTBCR.N is nonzero, the size of the translation table addressed by TTBR1 is 16KB (N=0).
        if pl1_vabase is not None:
            if not self.quiet:
                info("$TTBR1_EL1{}: {:#x}".format(self.suffix, TTBR1_EL1))
                info("$TTBCR{}: {:#x}".format(self.suffix, TTBCR))
                info("PL1 base: {:#x}".format(pl1_base))
                info("PL1 va_base: {:#x}".format(pl1_vabase))
            self.do_pagewalk_short(pl1_base, pl1_vabase)
            self.print_page()
        else:
            if not self.quiet:
                info("$TTBR1_EL1{} is unused".format(self.suffix))
        return

    def pagewalk_long(self):
        gef_print(titlify("$TTBR0_EL1{}".format(self.suffix)))

        TTBR0_EL1 = get_register('$TTBR0_EL1{}'.format(self.suffix))
        if TTBR0_EL1 is None:
            err('$TTBR0_EL1{} is not found'.format(self.suffix))
            return

        TTBR1_EL1 = get_register('$TTBR1_EL1{}'.format(self.suffix))
        if TTBR1_EL1 is None:
            err('$TTBR1_EL1{} is not found'.format(self.suffix))
            return

        TTBCR = get_register('$TTBCR{}'.format(self.suffix))
        if TTBCR is None:
            err('$TTBCR{} is not found'.format(self.suffix))
            return

        # pagewalk TTBR0_EL1
        T0SZ = TTBCR & 0b111
        T1SZ = (TTBCR >> 16) & 0b111
        self.N = T0SZ
        pl0_base = TTBR0_EL1 & ((1<<40)-1)
        if not self.quiet:
            info("$TTBR0_EL1{}: {:#x}".format(self.suffix, TTBR0_EL1))
            info("$TTBCR{}: {:#x}".format(self.suffix, TTBCR))
            info("PL0 base: {:#x}".format(pl0_base))
        self.do_pagewalk_long(pl0_base)
        self.print_page()

        # pagewalk TTBR1_EL1
        gef_print(titlify("$TTBR1_EL1{}".format(self.suffix)))
        if T0SZ != 0 or T1SZ != 0:
            self.N = T1SZ
            pl1_base = TTBR1_EL1 & ((1<<40)-1)
            if T1SZ == 0:
                pl1_vabase = 2**(32-T0SZ)
            else:
                pl1_vabase = 2**32 - 2**(32-T1SZ)
            if not self.quiet:
                info("$TTBR1_EL1{}: {:#x}".format(self.suffix, TTBR1_EL1))
                info("PL1 base: {:#x}".format(pl1_base))
                info("PL1 va_base: {:#x}".format(pl1_vabase))
            self.do_pagewalk_long(pl1_base, pl1_vabase)
            self.print_page()
        else:
            if not self.quiet:
                info("$TTBR1_EL1{} is unused".format(self.suffix))
        return

    def pagewalk(self):
        res = gdb.execute("info registers", to_string=True)
        if not "TTBR" in res:
            err("Not found system registers. Check qemu version (at least: 3.x~, recommend: 5.x~).")
            return

        # check Secure mode
        if self.FORCE_PREFIX_S is None:
            # auto detect
            SCR = get_register('$SCR_S')
            if SCR is None:
                SCR = get_register('$SCR')
            if SCR is not None:
                self.SECURE = (SCR & 0x1) == 0 # NS bit
            else:
                self.SECURE = False
            self.suffix = "_S" if self.SECURE else ""
        elif self.FORCE_PREFIX_S is True:
            # use "_S"
            SCR = get_register('$SCR_S')
            if SCR is not None:
                self.SECURE = (SCR & 0x1) == 0 # NS bit
            else:
                self.SECURE = False
            self.suffix = "_S"
        elif self.FORCE_PREFIX_S is False:
            # do not use "_S"
            SCR = get_register('$SCR')
            if SCR is not None:
                self.SECURE = (SCR & 0x1) == 0 # NS bit
            else:
                self.SECURE = False
            self.suffix = ""
        if not self.quiet:
            info("Secure world: {}".format(self.SECURE))

        # check AFE
        SCTLR = get_register('$SCTLR{}'.format(self.suffix))
        if SCTLR is not None:
            self.AFE = ((SCTLR >> 29) & 0x1) == 1
        else:
            self.AFE = False

        # check enabled LPAE
        TTBCR = get_register('$TTBCR{}'.format(self.suffix))
        if TTBCR is not None:
            self.LPAE = ((TTBCR >> 31) & 0x1) == 1
            self.PTE_SIZE = 8 if self.LPAE else 4
        else:
            self.LPAE = False

        # check PXN supported
        ID_MMFR0 = get_register('$ID_MMFR0{}'.format(self.suffix))
        if ID_MMFR0 is not None:
            self.PXN = ((ID_MMFR0 >> 2) & 0x1) == 1
        else:
            self.PXN = False

        if not self.quiet:
            if self.PXN:
                info("{:s} is supported".format(Color.boldify("PXN")))
            else:
                info("PXN is unsupported")
            info("PAN is unimplemented on all ARMv7")

        # pagewalk
        if self.LPAE:
            if not self.quiet:
                info("{:s} is enabled (using long description)".format(Color.boldify("LPAE")))
            self.pagewalk_long()
        else:
            if not self.quiet:
                info("LPAE is disabled (using short description)")
            self.pagewalk_short()
        return

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if not is_arm32():
            err("Unsupported")
            return

        self.FORCE_PREFIX_S = None
        if "-S" in argv and "-s" in argv:
            self.usage()
            return
        elif "-S" in argv:
            self.FORCE_PREFIX_S = True
            argv.remove("-S")
        elif "-s" in argv:
            self.FORCE_PREFIX_S = False
            argv.remove("-s")

        try:
            argv = self.parse_common_args(argv)
            if argv:
                raise
        except:
            self.usage()
            return
        self.mappings = None
        self.pagewalk()
        self.cache = {}
        return


@register_command
class PagewalkArm64Command(PagewalkCommand):
    """Dump pagetable for ARM64 using qemu-monitor (for ARMv8.3)."""
    _cmdline_ = "pagewalk arm64"
    _syntax_ = "{:s} [-h] [-q] [TARGET_EL] [--print-each-level] [--no-merge] [--filter REGEX] [--vrange ADDR] [--prange ADDR] [--sort-by-phys] [--simple] [--trace ADDR]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} --print-each-level # for current EL, show all level pagetables\n".format(_cmdline_)
    _example_ += "{:s} 1 --no-merge       # for EL1+0, do not merge similar/consecutive address\n".format(_cmdline_)
    _example_ += "{:s} 2 --filter 0xabc   # for EL2, grep by REGEX pattern\n".format(_cmdline_)
    _example_ += "{:s} --vrange 0x7fff00  # filter by map included specific virtual address\n".format(_cmdline_)
    _example_ += "{:s} --prange 0x7fff00  # filter by map included specific physical address\n".format(_cmdline_)
    _example_ += "{:s} --sort-by-phys     # for current EL, sort by physical address\n".format(_cmdline_)
    _example_ += "{:s} --simple           # for current EL, merge with ignoring physical address consecutivness\n".format(_cmdline_)
    _example_ += "{:s} --trace 0x7fff00   # for current EL, show all level pagetables only associated specific address\n".format(_cmdline_)
    _example_ += "{:s} -q                 # show result only (quiet)".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    # If you want to dump the secure world memory map, you need to break in the secure world.
    # This is because unlike ARMv7, TTBR0_EL1_S and TTBR1_EL1_S do not exist.
    # It is difficult to know the correct value of the secure world's system registers while in the normal world,
    # as the secure monitor saves all system registers to memory when the world changes.

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        return

    def read_mem_wrapper(self, addr, size=8):
        """
        When pagewalking EL0/EL1 of the guest OS, gdb pagewalks the physical memory according to $TTBR0_ELx.
        However, even if you try to read the physical memory, access to the address will fail
        because it is actually an intermediate physical memory.
        Therefore, in order to perform a pagewalk of EL0/EL1, EL2 mapping information is required.
        This function is for reading from physical memory with that in mind.
        """

        if self.EL3_M and self.TargetEL == 3:
            return read_memory(addr, size)

        # translate via EL2 mappings
        if self.EL2_VM and self.TargetEL == 1 and self.el2_mappings:
            def search_pa(addr):
                for entry_info in self.el2_mappings:
                    va, entry, sz, cnt, flags = entry_info
                    if isinstance(va, str):
                        va = int(va, 16)
                    pa = entry & 0x0000fffffffff000
                    if va <= addr < va + sz:
                        offset = addr - va
                        return pa + offset, sz - offset
                else: # not found
                    raise
            out = b""
            while size > 0:
                paddr, available_sz = search_pa(addr)
                out += self.read_physmem_cache(paddr, min([size, available_sz]))
                size -= min(size, available_sz)
            return out

        # direct physmem read
        else:
            return self.read_physmem_cache(addr, size)

    def format_flags_stage2(self, flag_info):
        flags = []

        XN1 = "XN1" in flag_info
        XN0 = "XN0" in flag_info
        if "S2AP=00" in flag_info:
            if XN1 == False and XN0 == False:
                flags += ['EL0/---', 'EL1/---']
            elif XN1 == False and XN0 == True:
                flags += ['EL0/---', 'EL1/---']
            elif XN1 == True and XN0 == False:
                flags += ['EL0/---', 'EL1/---']
            elif XN1 == True and XN0 == True:
                flags += ['EL0/---', 'EL1/---']
        elif "S2AP=01" in flag_info:
            if XN1 == False and XN0 == False:
                flags += ['EL0/R-X', 'EL1/R-X']
            elif XN1 == False and XN0 == True:
                flags += ['EL0/R-X', 'EL1/R--']
            elif XN1 == True and XN0 == False:
                flags += ['EL0/R--', 'EL1/R--']
            elif XN1 == True and XN0 == True:
                flags += ['EL0/R--', 'EL1/R-X']
        elif "S2AP=10" in flag_info:
            if XN1 == False and XN0 == False:
                flags += ['EL0/-W-', 'EL1/-W-']
            elif XN1 == False and XN0 == True:
                flags += ['EL0/-W-', 'EL1/-W-']
            elif XN1 == True and XN0 == False:
                flags += ['EL0/-W-', 'EL1/-W-']
            elif XN1 == True and XN0 == True:
                flags += ['EL0/-W-', 'EL1/-W-']
        elif "S2AP=11" in flag_info:
            if XN1 == False and XN0 == False:
                flags += ['EL0/RWX', 'EL1/RWX']
            elif XN1 == False and XN0 == True:
                flags += ['EL0/RWX', 'EL1/RW-']
            elif XN1 == True and XN0 == False:
                flags += ['EL0/RW-', 'EL1/RW-']
            elif XN1 == True and XN0 == True:
                flags += ['EL0/RW-', 'EL1/RWX']
        if "AF" in flag_info:
            flags += ['ACCESSED']
        if "DBM" in flag_info:
            flags += ['DIRTY']
        # stage2 has no `nG` bit
        return ' '.join(flags)

    def format_flags(self, flag_info):
        flags = []

        # AP/APTable parsing
        if "AP=00" in flag_info:
            disable_write_access = 0
            enable_unpriv_access = 0
        elif "AP=01" in flag_info:
            disable_write_access = 0
            enable_unpriv_access = 1
        elif "AP=10" in flag_info:
            disable_write_access = 1
            enable_unpriv_access = 0
        elif "AP=11" in flag_info:
            disable_write_access = 1
            enable_unpriv_access = 1
        if "APTable2=00" in flag_info:
            pass
        elif "APTable2=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable2=10" in flag_info:
            disable_write_access |= 1
        elif "APTable2=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0
        if "APTable1=00" in flag_info:
            pass
        elif "APTable1=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable1=10" in flag_info:
            disable_write_access |= 1
        elif "APTable1=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0
        if "APTable0=00" in flag_info:
            pass
        elif "APTable0=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable0=10" in flag_info:
            disable_write_access |= 1
        elif "APTable0=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0
        if "APTable-1=00" in flag_info:
            pass
        elif "APTable-1=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable-1=10" in flag_info:
            disable_write_access |= 1
        elif "APTable-1=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0

        # UXN/UXNTable, XN/XNTable, PXN/PXNTable, NS/NSTable parsing
        UXN = "UXN" in flag_info
        UXN |= "UXNTable2" in flag_info
        UXN |= "UXNTable1" in flag_info
        UXN |= "UXNTable0" in flag_info
        UXN |= "UXNTable-1" in flag_info
        XN = "XN" in flag_info
        XN |= "XNTable2" in flag_info
        XN |= "XNTable1" in flag_info
        XN |= "XNTable0" in flag_info
        XN |= "XNTable-1" in flag_info
        PXN = "PXN" in flag_info
        PXN |= "PXNTable2" in flag_info
        PXN |= "PXNTable1" in flag_info
        PXN |= "PXNTable0" in flag_info
        PXN |= "PXNTable-1" in flag_info
        NS = "NS" in flag_info
        NS |= "NSTable2" in flag_info
        NS |= "NSTable1" in flag_info
        NS |= "NSTable0" in flag_info
        NS |= "NSTable-1" in flag_info

        if self.TargetEL == 1:
            # always support 2VA ranges
            if UXN == False and PXN == False:
                if disable_write_access == 0 and enable_unpriv_access == 0:
                    if not self.EL1_WXN:
                        flags += ['EL0/--X', 'EL1/RWX']
                    else:
                        flags += ['EL0/--X', 'EL1/RW-']
                elif disable_write_access == 0 and enable_unpriv_access == 1:
                    if not self.EL1_WXN:
                        flags += ['EL0/RWX', 'EL1/RW-']
                    else:
                        flags += ['EL0/RW-', 'EL1/RW-']
                elif disable_write_access == 1 and enable_unpriv_access == 0:
                    flags += ['EL0/--X', 'EL1/R-X']
                elif disable_write_access == 1 and enable_unpriv_access == 1:
                    flags += ['EL0/R-X', 'EL1/R-X']
            elif UXN == False and PXN == True:
                if disable_write_access == 0 and enable_unpriv_access == 0:
                    flags += ['EL0/--X', 'EL1/RW-']
                elif disable_write_access == 0 and enable_unpriv_access == 1:
                    if not self.EL1_WXN:
                        flags += ['EL0/RWX', 'EL1/RW-']
                    else:
                        flags += ['EL0/RW-', 'EL1/RW-']
                elif disable_write_access == 1 and enable_unpriv_access == 0:
                    flags += ['EL0/--X', 'EL1/R--']
                elif disable_write_access == 1 and enable_unpriv_access == 1:
                    flags += ['EL0/R-X', 'EL1/R--']
            elif UXN == True and PXN == False:
                if disable_write_access == 0 and enable_unpriv_access == 0:
                    if not self.EL1_WXN:
                        flags += ['EL0/---', 'EL1/RWX']
                    else:
                        flags += ['EL0/---', 'EL1/RW-']
                elif disable_write_access == 0 and enable_unpriv_access == 1:
                    flags += ['EL0/RW-', 'EL1/RW-']
                elif disable_write_access == 1 and enable_unpriv_access == 0:
                    flags += ['EL0/---', 'EL1/R-X']
                elif disable_write_access == 1 and enable_unpriv_access == 1:
                    flags += ['EL0/R--', 'EL1/R-X']
            elif UXN == True and PXN == True:
                if disable_write_access == 0 and enable_unpriv_access == 0:
                    flags += ['EL0/---', 'EL1/RW-']
                elif disable_write_access == 0 and enable_unpriv_access == 1:
                    flags += ['EL0/RW-', 'EL1/RW-']
                elif disable_write_access == 1 and enable_unpriv_access == 0:
                    flags += ['EL0/---', 'EL1/R--']
                elif disable_write_access == 1 and enable_unpriv_access == 1:
                    flags += ['EL0/R--', 'EL1/R--']
        elif self.TargetEL == 2:
            if self.EL2_M20:
                # support 2VA ranges if HCR_EL2.{TGE,E2H} == {1,1}
                if UXN == False and PXN == False:
                    if disable_write_access == 0 and enable_unpriv_access == 0:
                        if not self.EL2_WXN:
                            flags += ['EL0/--X', 'EL2/RWX']
                        else:
                            flags += ['EL0/--X', 'EL2/RW-']
                    elif disable_write_access == 0 and enable_unpriv_access == 1:
                        if not self.EL2_WXN:
                            flags += ['EL0/RWX', 'EL2/RW-']
                        else:
                            flags += ['EL0/RW-', 'EL2/RW-']
                    elif disable_write_access == 1 and enable_unpriv_access == 0:
                        flags += ['EL0/--X', 'EL2/R-X']
                    elif disable_write_access == 1 and enable_unpriv_access == 1:
                        flags += ['EL0/R-X', 'EL2/R-X']
                elif UXN == False and PXN == True:
                    if disable_write_access == 0 and enable_unpriv_access == 0:
                        flags += ['EL0/--X', 'EL2/RW-']
                    elif disable_write_access == 0 and enable_unpriv_access == 1:
                        if not self.EL2_WXN:
                            flags += ['EL0/RWX', 'EL2/RW-']
                        else:
                            flags += ['EL0/RW-', 'EL2/RW-']
                    elif disable_write_access == 1 and enable_unpriv_access == 0:
                        flags += ['EL0/--X', 'EL2/R--']
                    elif disable_write_access == 1 and enable_unpriv_access == 1:
                        flags += ['EL0/R-X', 'EL2/R--']
                elif UXN == True and PXN == False:
                    if disable_write_access == 0 and enable_unpriv_access == 0:
                        if not self.EL2_WXN:
                            flags += ['EL0/---', 'EL2/RWX']
                        else:
                            flags += ['EL0/---', 'EL2/RW-']
                    elif disable_write_access == 0 and enable_unpriv_access == 1:
                        flags += ['EL0/RW-', 'EL2/RW-']
                    elif disable_write_access == 1 and enable_unpriv_access == 0:
                        flags += ['EL0/---', 'EL2/R-X']
                    elif disable_write_access == 1 and enable_unpriv_access == 1:
                        flags += ['EL0/R--', 'EL2/R-X']
                elif UXN == True and PXN == True:
                    if disable_write_access == 0 and enable_unpriv_access == 0:
                        flags += ['EL0/---', 'EL2/RW-']
                    elif disable_write_access == 0 and enable_unpriv_access == 1:
                        flags += ['EL0/RW-', 'EL2/RW-']
                    elif disable_write_access == 1 and enable_unpriv_access == 0:
                        flags += ['EL0/---', 'EL2/R--']
                    elif disable_write_access == 1 and enable_unpriv_access == 1:
                        flags += ['EL0/R--', 'EL2/R--']
            else:
                # not support 2VA ranges if HCR_EL2.{TGE,E2H} != {1,1}
                if XN == False:
                    if disable_write_access == 0:
                        if not self.EL2_WXN:
                            flags += ['EL2/RWX']
                        else:
                            flags += ['EL2/RW-']
                    elif disable_write_access == 1:
                        flags += ['EL2/R-X']
                elif XN == True:
                    if disable_write_access == 0:
                        flags += ['EL2/RW-']
                    elif disable_write_access == 1:
                        flags += ['EL2/R--']
        elif self.TargetEL == 3:
            if XN == False:
                if disable_write_access == 0:
                    if not self.EL3_WXN:
                        flags += ['EL3/RWX']
                    else:
                        flags += ['EL3/RW-']
                elif disable_write_access == 1:
                    flags += ['EL3/R-X']
            elif XN == True:
                if disable_write_access == 0:
                    flags += ['EL3/RW-']
                elif disable_write_access == 1:
                    flags += ['EL3/R--']
        if NS:
            flags += ['NS']
        if "AF" in flag_info:
            flags += ['ACCESSED']
        if "DBM" in flag_info:
            flags += ['DIRTY']
        if "nG" not in flag_info:
            flags += ["GLOBAL"]
        return ' '.join(flags)

    """
     Stage1                   |     Stage2
    -------------------------------------------------------
    +----------------------+  |   +----------------------+
    | Guest OS table       | -|-> | Virtualization table |
    +----------------------+  |   +----------------------+
      TTBR0_EL1, TTBR1_EL1    |     VTTBR0_EL2
                              |
    +----------------------+  |
    | Hypervisor table     |  |
    +----------------------+  |
      TTBR0_EL2, TTBR1_EL2    |
                              |
    +----------------------+  |
    | Secure monitor table |  |
    +----------------------+  |
      TTBR0_EL3               |
                              |


      TargetEL=1              |    TargetEL=2              |    TargetEL=3
    ---------------------------------------------------------------------------------
    +----------------------+  |  +----------------------+  |  +----------------------+
    | Guest OS table       |  |  | Virtualization table |  |  | Secure monitor table |
    +----------------------+  |  +----------------------+  |  +----------------------+
      TTBR0_EL1, TTBR1_EL1    |    VTTBR0_EL2              |    TTBR0_EL3
                              |                            |
                              |  +----------------------+  |
                              |  | Hypervisor table     |  |
                              |  +----------------------+  |
                              |    TTBR0_EL2, TTBR1_EL2    |
                              |                            |
    """
    def parse_bit_range(self, granule_bits, region_bits):
        IA_LVA_MAX = 52 if self.FEAT_LVA else 48
        if granule_bits == 12: # 4KB granule
            self.LEVELM1_BIT_RANGE = [48,min(IA_LVA_MAX, region_bits)] if region_bits > 48 else None # no block descriptor
            self.LEVEL0_BIT_RANGE = [39,min(48, region_bits)] if region_bits > 39 else None          # 512GB
            self.LEVEL1_BIT_RANGE = [30,min(39, region_bits)] if region_bits > 30 else None          # 1GB
            self.LEVEL2_BIT_RANGE = [21,min(30, region_bits)] if region_bits > 21 else None          # 2MB
            self.LEVEL3_BIT_RANGE = [12,min(21, region_bits)] if region_bits > 12 else None          # 4KB
            self.OFFSET_BIT_RANGE = [ 0,12]
        elif granule_bits == 14: # 16KB granule
            self.LEVELM1_BIT_RANGE = None
            self.LEVEL0_BIT_RANGE = [47,min(IA_LVA_MAX, region_bits)] if region_bits > 47 else None  # no block descriptor
            self.LEVEL1_BIT_RANGE = [36,min(47, region_bits)] if region_bits > 36 else None          # 64GB
            self.LEVEL2_BIT_RANGE = [25,min(36, region_bits)] if region_bits > 25 else None          # 32MB
            self.LEVEL3_BIT_RANGE = [14,min(25, region_bits)] if region_bits > 14 else None          # 16KB
            self.OFFSET_BIT_RANGE = [ 0,14]
        elif granule_bits == 16: # 64KB granule
            self.LEVELM1_BIT_RANGE = None
            self.LEVEL0_BIT_RANGE = None
            self.LEVEL1_BIT_RANGE = [42,min(IA_LVA_MAX, region_bits)] if region_bits > 42 else None  # 4TB
            self.LEVEL2_BIT_RANGE = [29,min(42, region_bits)] if region_bits > 29 else None          # 512MB
            self.LEVEL3_BIT_RANGE = [16,min(29, region_bits)] if region_bits > 16 else None          # 64KB
            self.OFFSET_BIT_RANGE = [ 0,16]
        else:
            if not self.silent:
                err("Unsupported granule_bits")
            return

        if not self.silent and not self.quiet:
            info("granule_bits: {:d}".format(granule_bits))
            info("LEVELM1_BIT_RANGE: " + str(self.LEVELM1_BIT_RANGE))
            info("LEVEL0_BIT_RANGE: " + str(self.LEVEL0_BIT_RANGE))
            info("LEVEL1_BIT_RANGE: " + str(self.LEVEL1_BIT_RANGE))
            info("LEVEL2_BIT_RANGE: " + str(self.LEVEL2_BIT_RANGE))
            info("LEVEL3_BIT_RANGE: " + str(self.LEVEL3_BIT_RANGE))
            info("OFFSET_BIT_RANGE: " + str(self.OFFSET_BIT_RANGE))
        return

    def do_pagewalk(self, table_base, granule_bits, region_start, start_level=0, is_stage2=False, is_2VAranges=False):
        # table_base: The start address of pagewalk
        # granule_bits: One of [12, 14, 16]; It specifies how to separate the bits used for address translation.
        # region_start: The base address of translated address
        # start_level: Only used at stage2. In stage2, the starting level will fluctuate
        # is_stage2: Affects how the bitfield of each entry is interpreted
        self.mappings = []

        is_4k_granule = granule_bits == 12
        is_16k_granule = granule_bits == 14
        is_64k_granule = granule_bits == 16

        def get_entries_per_table(BIT_RANGE):
            entries_per_table = 2 ** (BIT_RANGE[1] - BIT_RANGE[0])
            if not self.silent and not self.quiet:
                info("Entries per table: {:d}".format(entries_per_table))
            return entries_per_table

        def has_next_level(entry): # for Level0, 1, 2 but not Level3
            return (entry & 0b11) == 0b11

        flags = []
        TABLE_BASE = [[region_start, table_base, flags]]

        # level -1 parse for 4KB granule
        if not self.silent and not self.quiet:
            gef_print(titlify("LEVEL -1"))
        if self.LEVELM1_BIT_RANGE is not None and start_level == -1:
            entries_per_table = get_entries_per_table(self.LEVELM1_BIT_RANGE)
            LEVELM1 = []
            COUNT = 0; INVALID = 0
            for va_base, table_base, parent_flags in TABLE_BASE:
                entries = self.read_mem_wrapper(table_base, 8 * entries_per_table)
                entries = self.slice_unpack(entries, 8)
                COUNT += len(entries)
                for i, entry in enumerate(entries):
                    # present flag
                    if entry & 1 == 0:
                        INVALID += 1
                        continue

                    # calc virtual address
                    new_va = va_base + (i << self.LEVELM1_BIT_RANGE[0])
                    new_va_end = new_va + (1 << self.LEVELM1_BIT_RANGE[0])

                    # calc flags
                    flags = parent_flags.copy()
                    if has_next_level(entry):
                        if is_stage2:
                            pass
                        elif is_2VAranges:
                            if ((entry >> 59) & 1) == 1: flags.append("PXNTable-1")
                            if ((entry >> 60) & 1) == 1: flags.append("UXNTable-1")
                            flags.append("APTable-1={:02b}".format((entry >> 61) & 0b11))
                            if ((entry >> 63) & 1) == 1: flags.append("NSTable-1")
                        else:
                            if ((entry >> 60) & 1) == 1: flags.append("XNTable-1") # Use XNTable, not UXNTable # PXNTable is undefined
                            flags.append("APTable-1={:02b}".format((entry >> 61) & 0b11 & 0b10)) # APTable[0] must be 0
                            if ((entry >> 63) & 1) == 1: flags.append("NSTable-1")
                    else:
                        # In ARMv8.7, level -1 has no block descriptors
                        raise

                    # calc next table / output phys addr (drop the flag bits)
                    if has_next_level(entry):
                        next_level_table = (entry & 0x0003fffffffff000) | (((entry >> 8) & 0b11) << 50)
                    else:
                        # In ARMv8.7, level -1 has no block descriptors
                        raise

                    # make entry
                    if has_next_level(entry):
                        LEVELM1.append([new_va, next_level_table, flags])
                        entry_type = "TABLE"
                    else:
                        # In ARMv8.7, level -1 has no block descriptors
                        raise

                    # dump
                    if self.print_each_level:
                        if self.is_not_trace_target(new_va, new_va_end):
                            continue
                        addr = table_base + i * 8
                        fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                        line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                        if self.is_not_filter_target(line):
                            continue
                        gef_print(line)

            if not self.silent and not self.quiet:
                info("Number of entries: {:d}".format(COUNT))
                info("Level -1 Entry: {:d}".format(len(LEVELM1)))
                info("Invalid entries: {:d}".format(INVALID))
            self.mappings += []
        else:
            if not self.silent and not self.quiet:
                info("LEVEL -1 is skipped")
            LEVELM1 = TABLE_BASE

        # level 0 parse for 4KB/16KB granule
        if not self.silent and not self.quiet:
            gef_print(titlify("LEVEL 0"))
        if self.LEVEL0_BIT_RANGE is not None and start_level <= 0:
            entries_per_table = get_entries_per_table(self.LEVEL0_BIT_RANGE)
            LEVEL0 = []; GB512 = []
            COUNT = 0; INVALID = 0
            for va_base, table_base, parent_flags in LEVELM1:
                entries = self.read_mem_wrapper(table_base, 8 * entries_per_table)
                entries = self.slice_unpack(entries, 8)
                COUNT += len(entries)
                for i, entry in enumerate(entries):
                    # present flag
                    if entry & 1 == 0:
                        INVALID += 1
                        continue

                    # calc virtual address
                    new_va = va_base + (i << self.LEVEL0_BIT_RANGE[0])
                    new_va_end = new_va + (1 << self.LEVEL0_BIT_RANGE[0])

                    # calc flags
                    flags = parent_flags.copy()
                    if has_next_level(entry):
                        if is_stage2:
                            pass
                        elif is_2VAranges:
                            if ((entry >> 59) & 1) == 1: flags.append("PXNTable0")
                            if ((entry >> 60) & 1) == 1: flags.append("UXNTable0")
                            flags.append("APTable0={:02b}".format((entry >> 61) & 0b11))
                            if ((entry >> 63) & 1) == 1: flags.append("NSTable0")
                        else:
                            if ((entry >> 60) & 1) == 1: flags.append("XNTable0") # Use XNTable, not UXNTable # PXNTable is undefined
                            flags.append("APTable0={:02b}".format((entry >> 61) & 0b11 & 0b10)) # APTable[0] must be 0
                            if ((entry >> 63) & 1) == 1: flags.append("NSTable0")
                    else:
                        if is_stage2:
                            flags.append("MemAttr={:#x}".format((entry >> 2) & 0b1111))
                            flags.append("S2AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1: flags.append("AF")
                            if ((entry >> 51) & 1) == 1: flags.append("DBM")
                            if ((entry >> 52) & 1) == 1: flags.append("Contiguous")
                            flags.append("XN={:02b}".format((entry >> 53) & 0b11)) # Use XN, not UXN
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        elif is_2VAranges:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1: flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1: flags.append("AF")
                            if ((entry >> 11) & 1) == 1: flags.append("nG")
                            if ((entry >> 16) & 1) == 1: flags.append("nT")
                            if ((entry >> 50) & 1) == 1: flags.append("GP")
                            if ((entry >> 51) & 1) == 1: flags.append("DBM")
                            if ((entry >> 52) & 1) == 1: flags.append("Contiguous")
                            if ((entry >> 53) & 1) == 1: flags.append("PXN")
                            if ((entry >> 54) & 1) == 1: flags.append("UXN")
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        else:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1: flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11 & 0b10)) # AP[0] must be 0
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1: flags.append("AF")
                            if ((entry >> 11) & 1) == 1: flags.append("nG")
                            if ((entry >> 16) & 1) == 1: flags.append("nT")
                            if ((entry >> 50) & 1) == 1: flags.append("GP")
                            if ((entry >> 51) & 1) == 1: flags.append("DBM")
                            if ((entry >> 52) & 1) == 1: flags.append("Contiguous")
                            if ((entry >> 54) & 1) == 1: flags.append("XN") # Use XN, not UXN # PXN is undefined
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))

                    # calc next table / output phys addr (drop the flag bits)
                    if has_next_level(entry):
                        if self.FEAT_LPA:
                            next_level_table = (entry & 0x0003fffffffff000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            next_level_table = entry & 0x0000fffffffff000
                    else:
                        if self.FEAT_LPA:
                            phys_addr = (entry & 0x0003fffffffe0000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            # In ARMv8.7, level 0 + no-FEAT_LPA has no block descriptors
                            raise

                    # make entry
                    if has_next_level(entry):
                        LEVEL0.append([new_va, next_level_table, flags])
                        entry_type = "TABLE"
                    else:
                        virt_addr = new_va
                        page_count = 1
                        flag_string = self.format_flags_stage2(flags) if is_stage2 else self.format_flags(flags)
                        if is_4k_granule:
                            page_size = 512 * 1024 * 1024 * 1024
                            GB512.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "512GB-PAGE"
                        else:
                            raise

                    # dump
                    if self.print_each_level:
                        if self.is_not_trace_target(new_va, new_va_end):
                            continue
                        addr = table_base + i * 8
                        fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                        line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                        if self.is_not_filter_target(line):
                            continue
                        gef_print(line)

            if not self.silent and not self.quiet:
                info("Number of entries: {:d}".format(COUNT))
                info("Level 0 Entry: {:d}".format(len(LEVEL0)))
                info("PT Entry (512GB): {:d}".format(len(GB512)))
                info("Invalid entries: {:d}".format(INVALID))
            self.mappings += GB512
        else:
            if not self.silent and not self.quiet:
                info("LEVEL 0 is skipped")
            LEVEL0 = TABLE_BASE

        # level 1 parse for 4KB/16KB/64KB granule
        if not self.silent and not self.quiet:
            gef_print(titlify("LEVEL 1"))
        if self.LEVEL1_BIT_RANGE is not None and start_level <= 1:
            entries_per_table = get_entries_per_table(self.LEVEL1_BIT_RANGE)
            LEVEL1 = []; GB1 = []; TB4 = []; GB64 = []
            COUNT = 0; INVALID = 0
            for va_base, table_base, parent_flags in LEVEL0:
                entries = self.read_mem_wrapper(table_base, 8 * entries_per_table)
                entries = self.slice_unpack(entries, 8)
                COUNT += len(entries)
                for i, entry in enumerate(entries):
                    # present flag
                    if entry & 1 == 0:
                        INVALID += 1
                        continue

                    # calc virtual address
                    new_va = va_base + (i << self.LEVEL1_BIT_RANGE[0])
                    new_va_end = new_va + (1 << self.LEVEL1_BIT_RANGE[0])

                    # calc flags
                    flags = parent_flags.copy()
                    if has_next_level(entry):
                        if is_stage2:
                            pass
                        elif is_2VAranges:
                            if ((entry >> 59) & 1) == 1: flags.append("PXNTable1")
                            if ((entry >> 60) & 1) == 1: flags.append("UXNTable1")
                            flags.append("APTable1={:02b}".format((entry >> 61) & 0b11))
                            if ((entry >> 63) & 1) == 1: flags.append("NSTable1")
                        else:
                            if ((entry >> 60) & 1) == 1: flags.append("XNTable1") # Use XNTable, not UXNTable # PXNTable is undefined
                            flags.append("APTable1={:02b}".format((entry >> 61) & 0b11 & 0b10)) # APTable[0] must be 0
                            if ((entry >> 63) & 1) == 1: flags.append("NSTable1")
                    else:
                        if is_stage2:
                            flags.append("MemAttr={:#x}".format((entry >> 2) & 0b1111))
                            flags.append("S2AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1: flags.append("AF")
                            if ((entry >> 51) & 1) == 1: flags.append("DBM")
                            if ((entry >> 52) & 1) == 1: flags.append("Contiguous")
                            flags.append("XN={:02b}".format((entry >> 53) & 0b11)) # Use XN, not UXN
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        elif is_2VAranges:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1: flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1: flags.append("AF")
                            if ((entry >> 11) & 1) == 1: flags.append("nG")
                            if ((entry >> 16) & 1) == 1: flags.append("nT")
                            if ((entry >> 50) & 1) == 1: flags.append("GP")
                            if ((entry >> 51) & 1) == 1: flags.append("DBM")
                            if ((entry >> 52) & 1) == 1: flags.append("Contiguous")
                            if ((entry >> 53) & 1) == 1: flags.append("PXN")
                            if ((entry >> 54) & 1) == 1: flags.append("UXN")
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        else:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1: flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11 & 0b10)) # AP[0] must be 0
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1: flags.append("AF")
                            if ((entry >> 11) & 1) == 1: flags.append("nG")
                            if ((entry >> 16) & 1) == 1: flags.append("nT")
                            if ((entry >> 50) & 1) == 1: flags.append("GP")
                            if ((entry >> 51) & 1) == 1: flags.append("DBM")
                            if ((entry >> 52) & 1) == 1: flags.append("Contiguous")
                            if ((entry >> 54) & 1) == 1: flags.append("XN") # Use XN, not UXN # PXN is undefined
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))

                    # calc next table / output phys addr (drop the flag bits)
                    if has_next_level(entry):
                        if self.FEAT_LPA:
                            if is_64k_granule:
                                next_level_table = (entry & 0x0000ffffffff0000) | (((entry >> 12) & 0b1111) << 48)
                            else:
                                next_level_table = (entry & 0x0003fffffffff000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            next_level_table = entry & 0x0000fffffffff000
                    else:
                        if self.FEAT_LPA:
                            if is_64k_granule:
                                phys_addr = (entry & 0x0000fffffffe0000) | (((entry >> 12) & 0b1111) << 48)
                            else:
                                phys_addr = (entry & 0x0003fffffffe0000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            phys_addr = entry & 0x0000fffffffe0000

                    # make entry
                    if has_next_level(entry):
                        LEVEL1.append([new_va, next_level_table, flags])
                        entry_type = "TABLE"
                    else:
                        virt_addr = new_va
                        page_count = 1
                        flag_string = self.format_flags_stage2(flags) if is_stage2 else self.format_flags(flags)
                        if is_64k_granule:
                            page_size = 4 * 1024 * 1024 * 1024 * 1024
                            TB4.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "4TB-PAGE"
                        elif is_4k_granule:
                            page_size = 1 * 1024 * 1024 * 1024
                            GB1.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "1GB-PAGE"
                        elif is_16k_granule:
                            page_size = 64 * 1024 * 1024 * 1024
                            GB64.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "64GB-PAGE"

                    # dump
                    if self.print_each_level:
                        if self.is_not_trace_target(new_va, new_va_end):
                            continue
                        addr = table_base + i * 8
                        fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                        line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                        if self.is_not_filter_target(line):
                            continue
                        gef_print(line)

            if not self.silent and not self.quiet:
                info("Number of entries: {:d}".format(COUNT))
                info("Level 1 Entry: {:d}".format(len(LEVEL1)))
                info("PT Entry (1GB): {:d}".format(len(GB1)))
                info("PT Entry (64GB): {:d}".format(len(GB64)))
                info("PT Entry (4TB): {:d}".format(len(TB4)))
                info("Invalid entries: {:d}".format(INVALID))
            self.mappings += GB1 + GB64 + TB4
        else:
            if not self.silent and not self.quiet:
                info("LEVEL 1 is skipped")
            LEVEL1 = LEVEL0

        # level 2 parse for 4KB/16KB/64KB granule
        if not self.silent and not self.quiet:
            gef_print(titlify("LEVEL 2"))
        if self.LEVEL2_BIT_RANGE is not None and start_level <= 2:
            entries_per_table = get_entries_per_table(self.LEVEL2_BIT_RANGE)
            LEVEL2 = []; MB2 = []; MB32 = []; MB512 = []
            COUNT = 0; INVALID = 0
            for va_base, table_base, parent_flags in LEVEL1:
                entries = self.read_mem_wrapper(table_base, 8 * entries_per_table)
                entries = self.slice_unpack(entries, 8)
                COUNT += len(entries)
                for i, entry in enumerate(entries):
                    # present flag
                    if entry & 1 == 0:
                        INVALID += 1
                        continue

                    # calc virtual address
                    new_va = va_base + (i << self.LEVEL2_BIT_RANGE[0])
                    new_va_end = new_va + (1 << self.LEVEL2_BIT_RANGE[0])

                    # calc flags
                    flags = parent_flags.copy()
                    if has_next_level(entry):
                        if is_stage2:
                            pass
                        elif is_2VAranges:
                            if ((entry >> 59) & 1) == 1: flags.append("PXNTable2")
                            if ((entry >> 60) & 1) == 1: flags.append("UXNTable2")
                            flags.append("APTable2={:02b}".format((entry >> 61) & 0b11))
                            if ((entry >> 63) & 1) == 1: flags.append("NSTable2")
                        else:
                            if ((entry >> 60) & 1) == 1: flags.append("XNTable2") # Use XNTable, not UXNTable # PXNTable is undefined
                            flags.append("APTable2={:02b}".format((entry >> 61) & 0b11 & 0b10)) # APTable[0] must be 0
                            if ((entry >> 63) & 1) == 1: flags.append("NSTable2")
                    else:
                        if is_stage2:
                            flags.append("MemAttr={:#x}".format((entry >> 2) & 0b1111))
                            flags.append("S2AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1: flags.append("AF")
                            if ((entry >> 51) & 1) == 1: flags.append("DBM")
                            if ((entry >> 52) & 1) == 1: flags.append("Contiguous")
                            flags.append("XN={:02b}".format((entry >> 53) & 0b11)) # Use XN, not UXN
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        elif is_2VAranges:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1: flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1: flags.append("AF")
                            if ((entry >> 11) & 1) == 1: flags.append("nG")
                            if ((entry >> 16) & 1) == 1: flags.append("nT")
                            if ((entry >> 50) & 1) == 1: flags.append("GP")
                            if ((entry >> 51) & 1) == 1: flags.append("DBM")
                            if ((entry >> 52) & 1) == 1: flags.append("Contiguous")
                            if ((entry >> 53) & 1) == 1: flags.append("PXN")
                            if ((entry >> 54) & 1) == 1: flags.append("UXN")
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        else:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1: flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11 & 0b10)) # AP[0] must be 0
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1: flags.append("AF")
                            if ((entry >> 11) & 1) == 1: flags.append("nG")
                            if ((entry >> 16) & 1) == 1: flags.append("nT")
                            if ((entry >> 50) & 1) == 1: flags.append("GP")
                            if ((entry >> 51) & 1) == 1: flags.append("DBM")
                            if ((entry >> 52) & 1) == 1: flags.append("Contiguous")
                            if ((entry >> 54) & 1) == 1: flags.append("XN") # Use XN, not UXN # PXN is undefined
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))

                    # calc next table / output phys addr (drop the flag bits)
                    if has_next_level(entry):
                        if self.FEAT_LPA:
                            if is_64k_granule:
                                next_level_table = (entry & 0x0000ffffffff0000) | (((entry >> 12) & 0b1111) << 48)
                            else:
                                next_level_table = (entry & 0x0003fffffffff000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            next_level_table = entry & 0x0000fffffffff000
                    else:
                        if self.FEAT_LPA:
                            if is_64k_granule:
                                phys_addr = (entry & 0x0000fffffffe0000) | (((entry >> 12) & 0b1111) << 48)
                            else:
                                phys_addr = (entry & 0x0003fffffffe0000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            phys_addr = entry & 0x0000fffffffe0000

                    # make entry
                    if has_next_level(entry):
                        LEVEL2.append([new_va, next_level_table, flags])
                        entry_type = "TABLE"
                    else:
                        virt_addr = new_va
                        page_count = 1
                        flag_string = self.format_flags_stage2(flags) if is_stage2 else self.format_flags(flags)
                        if is_64k_granule:
                            page_size = 512 * 1024 * 1024
                            MB512.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "512MB-PAGE"
                        elif is_16k_granule:
                            page_size = 32 * 1024 * 1024
                            MB32.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "32MB-PAGE"
                        elif is_4k_granule:
                            page_size = 2 * 1024 * 1024
                            MB2.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "2MB-PAGE"

                    # dump
                    if self.print_each_level:
                        if self.is_not_trace_target(new_va, new_va_end):
                            continue
                        addr = table_base + i * 8
                        fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                        line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                        if self.is_not_filter_target(line):
                            continue
                        gef_print(line)

            if not self.silent and not self.quiet:
                info("Number of entries: {:d}".format(COUNT))
                info("Level 2 Entry: {:d}".format(len(LEVEL2)))
                info("PT Entry (2MB): {:d}".format(len(MB2)))
                info("PT Entry (32MB): {:d}".format(len(MB32)))
                info("PT Entry (512MB): {:d}".format(len(MB512)))
                info("Invalid entries: {:d}".format(INVALID))
            self.mappings += MB2 + MB32 + MB512
        else:
            if not self.silent and not self.quiet:
                info("LEVEL 2 is skipped")
            LEVEL2 = LEVEL1

        # level 3 parse for 4KB/16KB/64KB granule
        if not self.silent and not self.quiet:
            gef_print(titlify("LEVEL 3"))
        if self.LEVEL3_BIT_RANGE is not None and start_level <= 3:
            entries_per_table = get_entries_per_table(self.LEVEL3_BIT_RANGE)
            KB4 = []; KB16 = []; KB64 = []
            COUNT = 0; INVALID = 0
            for va_base, table_base, parent_flags in LEVEL2:
                entries = self.read_mem_wrapper(table_base, 8 * entries_per_table)
                entries = self.slice_unpack(entries, 8)
                COUNT += len(entries)
                for i, entry in enumerate(entries):
                    # present flag
                    if entry & 1 == 0:
                        INVALID += 1
                        continue

                    # calc virtual address
                    virt_addr = va_base + (i << self.LEVEL3_BIT_RANGE[0])
                    virt_addr_end = virt_addr + (1 << self.LEVEL3_BIT_RANGE[0])

                    # calc flags
                    flags = parent_flags.copy()
                    if (entry & 0b11) == 0b11:
                        if is_stage2:
                            flags.append("MemAttr={:#x}".format((entry >> 2) & 0b1111))
                            flags.append("S2AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1: flags.append("AF")
                            if ((entry >> 51) & 1) == 1: flags.append("DBM")
                            if ((entry >> 52) & 1) == 1: flags.append("Contiguous")
                            flags.append("XN={:02b}".format((entry >> 53) & 0b11)) # Use XN, not UXN
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        elif is_2VAranges:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1: flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1: flags.append("AF")
                            if ((entry >> 11) & 1) == 1: flags.append("nG")
                            if ((entry >> 16) & 1) == 1: flags.append("nT")
                            if ((entry >> 50) & 1) == 1: flags.append("GP")
                            if ((entry >> 51) & 1) == 1: flags.append("DBM")
                            if ((entry >> 52) & 1) == 1: flags.append("Contiguous")
                            if ((entry >> 53) & 1) == 1: flags.append("PXN")
                            if ((entry >> 54) & 1) == 1: flags.append("UXN")
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        else:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1: flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11 & 0b10)) # AP[0] must be 0
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1: flags.append("AF")
                            if ((entry >> 11) & 1) == 1: flags.append("nG")
                            if ((entry >> 16) & 1) == 1: flags.append("nT")
                            if ((entry >> 50) & 1) == 1: flags.append("GP")
                            if ((entry >> 51) & 1) == 1: flags.append("DBM")
                            if ((entry >> 52) & 1) == 1: flags.append("Contiguous")
                            if ((entry >> 54) & 1) == 1: flags.append("XN") # Use XN, not UXN # PXN is undefined
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                    else:
                        # In ARMv8.7, level 3 has no table descriptors
                        raise

                    # calc next table / output phys addr (drop the flag bits)
                    if is_4k_granule:
                        if self.FEAT_LPA:
                            phys_addr = (entry & 0x0003fffffffff000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            phys_addr = entry & 0x0000fffffffff000
                    elif is_16k_granule:
                        if self.FEAT_LPA:
                            phys_addr = (entry & 0x0003ffffffffc000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            phys_addr = entry & 0x0000ffffffffc000
                    elif is_64k_granule:
                        if self.FEAT_LPA:
                            phys_addr = (entry & 0x0000ffffffff0000) | (((entry >> 12) & 0b1111) << 48)
                        else:
                            phys_addr = entry & 0x0000ffffffff0000

                    # make entry
                    page_count = 1
                    flag_string = self.format_flags_stage2(flags) if is_stage2 else self.format_flags(flags)
                    if is_64k_granule:
                        page_size = 64 * 1024
                        KB64.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                        entry_type = "64KB-PAGE"
                    elif is_16k_granule:
                        page_size = 16 * 1024
                        KB16.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                        entry_type = "16KB-PAGE"
                    elif is_4k_granule:
                        page_size = 4 * 1024
                        KB4.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                        entry_type = "4KB-PAGE"

                    # dump
                    if self.print_each_level:
                        if self.is_not_trace_target(virt_addr, virt_addr_end):
                            continue
                        addr = table_base + i * 8
                        fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                        line = fmt.format(addr, entry, virt_addr, virt_addr_end, entry_type, ' '.join(flags))
                        if self.is_not_filter_target(line):
                            continue
                        gef_print(line)

            if not self.silent and not self.quiet:
                info("Number of entries: {:d}".format(COUNT))
                info("PT Entry (4KB): {:d}".format(len(KB4)))
                info("PT Entry (16KB): {:d}".format(len(KB16)))
                info("PT Entry (64KB): {:d}".format(len(KB64)))
                info("Invalid entries: {:d}".format(INVALID))
            self.mappings += KB4 + KB16 + KB64
        else:
            if not self.silent and not self.quiet:
                info("LEVEL 3 is skipped")

        # Finalize
        if not self.silent and not self.quiet:
            gef_print(titlify("Total"))
            info("PT Entry (Total): {:d}".format(len(self.mappings)))
        self.mappings = sorted(self.mappings)
        return

    def switch_el(self):
        self.SAVED_CPSR = 0
        CPSR = get_register('$cpsr') & 0xffffffff
        CurrentEL = int((CPSR >> 2) & 0b11)
        # change EL
        try:
            if self.TargetEL < 1 or self.TargetEL > 3:
                err("Invalid argument (ELx>=1 && ELx<=3)")
                return
            if self.TargetEL != CurrentEL:
                self.SAVED_CPSR = CPSR
                CPSR = CPSR & ~(0b11 << 2) # clear EL
                CPSR |= self.TargetEL << 2 # set desired EL
                gdb.parse_and_eval('$cpsr = 0x%08x' % CPSR)
                if not self.quiet:
                    info('Moving to EL%d' % (self.TargetEL))
        except ValueError:
            err("Invalid argument (ELx integer required)")
            return
        except gdb.error:
            err("Maybe unsupported to change to EL%d" % (self.TargetEL))
            return
        # reload CPSR
        CPSR = get_register('$cpsr') & 0xffffffff
        CurrentEL = int((CPSR >> 2) & 0b11)
        if not self.quiet:
            info('CPSR: EL%d' % (CurrentEL))
        return True

    def revert_el(self):
        if self.SAVED_CPSR:
            gdb.parse_and_eval('$cpsr = 0x%08x' % self.SAVED_CPSR)
            SavedEL = (self.SAVED_CPSR >> 2) & 0b11
            if not self.quiet:
                info('Moving back to EL%d' % (SavedEL))
        return

    def pagewalk_TTBR0_EL1(self):
        gef_print(titlify("$TTBR0_EL1"))

        TTBR0_EL1 = get_register('$TTBR0_EL1')
        TCR_EL1 = get_register('$TCR_EL1')
        if TTBR0_EL1 == 0:
            warn("Maybe unused TTBR0_EL1")
            return

        """ TCR_EL1
        IPS, bits [34:32]
            Intermediate Physical Address Size.
            0b000
                32 bits, 4GB.
            0b001
                36 bits, 64GB.
            0b010
                40 bits, 1TB.
            0b011
                42 bits, 4TB.
            0b100
                44 bits, 16TB.
            0b101
                48 bits, 256TB.
            0b110
                52 bits, 4PB.
            All other values are reserved.
            The reserved values behave in the same way as the 0b101 or 0b110 encoding, but software must not
            rely on this property as the behavior of the reserved values might change in a future revision of the architecture.
            If the translation granule is not 64KB and FEAT_LPA2 is not implemented, the value 0b110 is treated as reserved.
            It is IMPLEMENTATION DEFINED whether an implementation that does not implement FEAT_LPA
            supports setting the value of 0b110 for the 64KB translation granule size or whether setting this value behaves as the 0b101 encoding.
            In an implementation that supports 52-bit PAs, if the value of this field is not 0b110 or a value treated as 0b110,
            then bits[51:48] of every translation table base address for the stage of translation controlled by TCR_EL1 are 0b0000.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.

        TG0, bits [15:14]
            Granule size for the TTBR0_EL1.
            0b00
                4KB
            0b01
                64KB
            0b10
                16KB
            Other values are reserved.
            If the value is programmed to either a reserved value or a size that has not been implemented, then
            the hardware will treat the field as if it has been programmed to an IMPLEMENTATION DEFINED
            choice of the sizes that has been implemented for all purposes other than the value read back from this register.
            It is IMPLEMENTATION DEFINED whether the value read back is the value programmed or the value that corresponds to the size chosen.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.

        T0SZ, bits [5:0]
            The size offset of the memory region addressed by TTBR0_EL1. The region size is 2^(64-T0SZ) bytes.
            The maximum and minimum possible values for T0SZ depend on the level of translation table and
            the memory translation granule size, as described in the AArch64 Virtual Memory System Architecture chapter.
            Note
                For the 4KB translation granule, if FEAT_LPA2 is implemented and this field is less than 16, the translation table walk begins with a level -1 initial lookup.
                For the 16KB translation granule, if FEAT_LPA2 is implemented and this field is less than 17, the translation table walk begins with a level 0 initial lookup.
                On a Warm reset, this field resets to an architecturally UNKNOWN value.
        """
        IPS = (TCR_EL1 >> 32) & 0b111
        TG0 = (TCR_EL1 >> 14) & 0b11
        T0SZ = TCR_EL1 & 0b111111
        try:
            granule_bits = {0b00: 12, 0b01: 16, 0b10: 14}[TG0]
        except:
            err("Unsupported $TCR_EL1.TG0")
            return
        region_start = 0
        region_end = region_start + (2 ** (64-T0SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        intermediate_pa_size = 32 + (IPS * 4)

        """ TTBR0_EL1
        BADDR[47:1], bits [47:1]
            Translation table base address:
            - Bits A[47:x] of the stage 1 translation table base address bits are in register bits[47:x].
            - Bits A[(x-1):0] of the stage 1 translation table base address are zero.
            Address bit x is the minimum address bit required to align the translation table to the size of the table.
            The smallest permitted value of x is 6. The AArch64 Virtual Memory System Architecture chapter describes how x is
            calculated based on the value of TCR_EL1.T0SZ, the translation stage, and the translation granule size.
            Note
                A translation table is required to be aligned to the size of the table. If a table contains fewer than
                eight entries, it must be aligned on a 64 byte address boundary.
            If the value of TCR_EL1.IPS is not 0b110, then:
            - Register bits[(x-1):1] are RES0.
            - If the implementation supports 52-bit PAs and IPAs, then bits A[51:48] of the stage 1 translation table base address are 0b0000.
            If FEAT_LPA is implemented and the value of TCR_EL1.IPS is 0b110, then:
            - Bits A[51:48] of the stage 1 translation table base address bits are in register bits[5:2].
            - Register bit[1] is RES0.
            - When x>6, register bits[(x-1):6] are RES0.
            Note
                TCR_EL1.IPS==0b110 is permitted when:
                - FEAT_LPA is implemented and the 64KB translation granule is used.
                - FEAT_LPA2 is implemented and the 4KB or 16KB translation granule is used.
                When the value of ID_AA64MMFR0_EL1.PARange indicates that the implementation does not
                support a 52 bit PA size, if a translation table lookup uses this register when TCR_EL1.IPS is 0b110
                and the value of register bits[5:2] is nonzero, an Address size fault is generated.
            If any register bit[47:1] that is defined as RES0 has the value 1 when a translation table walk is done
            using TTBR0_EL1, then the translation table base address might be misaligned, with effects that are
            CONSTRAINED UNPREDICTABLE, and must be one of the following:
            - Bits A[(x-1):0] of the stage 1 translation table base address are treated as if all the bits are zero.
              The value read back from the corresponding register bits is either the value written to the register or zero.
            - The result of the calculation of an address for a translation table walk using this register can be corrupted in those bits that are nonzero.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.
        """
        if IPS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR0_EL1 & 0xffffffffffc0) | (((TTBR0_EL1 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and IPS pair")
                return
        else:
            translation_base_addr = TTBR0_EL1 & 0xfffffffffffe

        if not self.quiet:
            info('$TTBR0_EL1: {:#x}'.format(TTBR0_EL1))
            info('$TCR_EL1: {:#x}'.format(TCR_EL1))
            info('Intermediate Physical Address Size: {:d} bits'.format(intermediate_pa_size))
            info('EL1 User Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end-1, region_bits))
            info('EL1 User Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start, is_2VAranges=True)
        self.print_page()
        return

    def pagewalk_TTBR1_EL1(self):
        gef_print(titlify("$TTBR1_EL1"))

        TTBR1_EL1 = get_register('$TTBR1_EL1')
        TCR_EL1 = get_register('$TCR_EL1')
        if TTBR1_EL1 == 0:
            warn("Maybe unused TTBR1_EL1")
            return

        """ TCR_EL1
        IPS, bits [34:32]
            See above.

        TG1, bits [31:30]
            Granule size for the TTBR1_EL1.
            0b01
                16KB.
            0b10
                4KB.
            0b11
                64KB.
            Other values are reserved.
            If the value is programmed to either a reserved value or a size that has not been implemented, then
            the hardware will treat the field as if it has been programmed to an IMPLEMENTATION DEFINED
            choice of the sizes that has been implemented for all purposes other than the value read back from this register.
            It is IMPLEMENTATION DEFINED whether the value read back is the value programmed or the value that corresponds to the size chosen.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.

        T1SZ, bits [21:16]
            The size offset of the memory region addressed by TTBR1_EL1. The region size is 2^(64-T1SZ) bytes.
            The maximum and minimum possible values for T1SZ depend on the level of translation table and
            the memory translation granule size, as described in the AArch64 Virtual Memory System Architecture chapter.
            Note
                For the 4KB translation granule, if FEAT_LPA2 is implemented and this field is less than 16, the translation table walk begins with a level -1 initial lookup.
                For the 16KB translation granule, if FEAT_LPA2 is implemented and this field is less than 17, the translation table walk begins with a level 0 initial lookup.
                On a Warm reset, this field resets to an architecturally UNKNOWN value.
        """
        IPS = (TCR_EL1 >> 32) & 0b111
        TG1 = (TCR_EL1 >> 30) & 0b11
        T1SZ = (TCR_EL1 >> 16) & 0b111111
        try:
            granule_bits = {0b01: 14, 0b10: 12, 0b11: 16}[TG1]
        except:
            err("Unsupported $TCR_EL1.TG1")
            return
        region_end = 2 ** 64
        region_start = region_end - (2 ** (64-T1SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        intermediate_pa_size = 32 + (IPS * 4)

        """ TTBR1_EL1
        BADDR[47:1], bits [47:1]
            Translation table base address:
            - Bits A[47:x] of the stage 1 translation table base address bits are in register bits[47:x].
            - Bits A[(x-1):0] of the stage 1 translation table base address are zero.
            Address bit x is the minimum address bit required to align the translation table to the size of the table.
            The smallest permitted value of x is 6. The AArch64 Virtual Memory System Architecture chapter describes how x is
            calculated based on the value of TCR_EL1.T1SZ, the translation stage, and the translation granule size.
            Note
                A translation table is required to be aligned to the size of the table. If a table contains fewer than
                eight entries, it must be aligned on a 64 byte address boundary.
            If the value of TCR_EL1.IPS is not 0b110, then:
            - Register bits[(x-1):1] are RES0.
            - If the implementation supports 52-bit PAs and IPAs, then bits A[51:48] of the stage 1 translation table base address are 0b0000.
            If FEAT_LPA is implemented and the value of TCR_EL1.IPS is 0b110, then:
            - Bits A[51:48] of the stage 1 translation table base address bits are in register bits[5:2].
            - Register bit[1] is RES0.
            - When x>6, register bits[(x-1):6] are RES0.
            Note
                TCR_EL1.IPS==0b110 is permitted when:
                - FEAT_LPA is implemented and the 64KB translation granule is used.
                - FEAT_LPA2 is implemented and the 4KB or 16KB translation granule is used.
                When the value of ID_AA64MMFR0_EL1.PARange indicates that the implementation does not
                support a 52 bit PA size, if a translation table lookup uses this register when TCR_EL1.IPS is 0b110
                and the value of register bits[5:2] is nonzero, an Address size fault is generated.
            If any register bit[47:1] that is defined as RES0 has the value 1 when a translation table walk is done
            using TTBR1_EL1, then the translation table base address might be misaligned, with effects that are
            CONSTRAINED UNPREDICTABLE, and must be one of the following:
            - Bits A[(x-1):0] of the stage 1 translation table base address are treated as if all the bits are zero.
              The value read back from the corresponding register bits is either the value written to the register or zero.
            - The result of the calculation of an address for a translation table walk using this register can be corrupted in those bits that are nonzero.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.
        """
        if IPS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR1_EL1 & 0xffffffffffc0) | (((TTBR1_EL1 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and IPS pair")
                return
        else:
            translation_base_addr = TTBR1_EL1 & 0xfffffffffffe

        if not self.quiet:
            info('$TTBR1_EL1: {:#x}'.format(TTBR1_EL1))
            info('$TCR_EL1: {:#x}'.format(TCR_EL1))
            info('Intermediate Physical Address Size: {:d} bits'.format(intermediate_pa_size))
            info('EL1 Kernel Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end-1, region_bits))
            info('EL1 Kernel Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start, is_2VAranges=True)
        self.print_page()
        return

    def pagewalk_VTTBR_EL2(self):
        if not self.silent:
            gef_print(titlify("$VTTBR_EL2"))

        VTTBR_EL2 = get_register('$VTTBR_EL2')
        VTCR_EL2 = get_register('$VTCR_EL2')
        if VTTBR_EL2 == 0:
            if not self.silent:
                warn("Maybe unused VTTBR_EL2")
            return

        """ VTCR_EL2
        SL2, bit [33]
            When FEAT_LPA2 is implemented:
                SL2
                Starting level of the stage 2 translation lookup controlled by VTCR_EL2.
                If VTCR_EL2.DS == 1, then VTCR_EL2.SL2, in combination with VTCR_EL2.SL0, gives encodings for the stage 2 translation table walk initial lookup level.
                If VTCR_EL2.DS == 0, then VTCR_EL2.SL2 is RES0.
                If the translation granule size is not 4KB, then this field is RES0.
                On a Warm reset, this field resets to an architecturally UNKNOWN value.
            Otherwise:
                Reserved, RES0.

        PS, bits [18:16]
            Physical address Size for the Second Stage of translation.
            0b000
                32 bits, 4GB.
            0b001
                36 bits, 64GB.
            0b010
                40 bits, 1TB.
            0b011
                42 bits, 4TB.
            0b100
                44 bits, 16TB.
            0b101
                48 bits, 256TB.
            0b110
                52 bits, 4PB.
            All other values are reserved.
            The reserved values behave in the same way as the 0b101 or 0b110 encoding, but software must not
            rely on this property as the behavior of the reserved values might change in a future revision of the architecture.
            If the translation granule is not 64KB and FEAT_LPA2 is not implemented, the value 0b110 is treated as reserved.
            It is IMPLEMENTATION DEFINED whether an implementation that does not implement FEAT_LPA
            supports setting the value of 0b110 for the 64KB translation granule size or whether setting this value behaves as the 0b101 encoding.
            In an implementation that supports 52-bit PAs, if the value of this field is not 0b110 or a value treated
            as 0b110, then bits[51:48] of every translation table base address for the stage of translation controlled by VTCR_EL2 are 0b0000.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.

        TG0, bits [15:14]
            Granule size for the VTTBR_EL2.
            0b00
                4KB.
            0b01
                64KB.
            0b10
                16KB.
            Other values are reserved.
            If FEAT_GTG is implemented, ID_AA64MMFR0_EL1.{TGran4_2, TGran16_2, TGran64_2} indicate which granule sizes are supported for Level 2 translation.
            If FEAT_GTG is not implemented, ID_AA64MMFR0_EL1.{TGran4, TGran16, TGran64} indicate which granule sizes are supported.
            If the value is programmed to either a reserved value or a size that has not been implemented, then
            the hardware will treat the field as if it has been programmed to an IMPLEMENTATION DEFINED
            choice of the sizes that has been implemented for all purposes other than the value read back from this register.
            It is IMPLEMENTATION DEFINED whether the value read back is the value programmed or the value that corresponds to the size chosen.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.

        SL0, bits [7:6]
            When FEAT_TTST is implemented:
                SL0
                Starting level of the stage 2 translation lookup, controlled by VTCR_EL2. The meaning of this field depends on the value of VTCR_EL2.TG0.
                0b00
                    If VTCR_EL2.TG0 is 0b00 (4KB granule):
                    - If FEAT_LPA2 is not implemented, start at level 2.
                    - If FEAT_LPA2 is implemented and VTCR_EL2.SL2 is 0b0, start at level 2.
                    - If FEAT_LPA2 is implemented and VTCR_EL2.SL2 is 0b1, start at level -1.
                    If VTCR_EL2.TG0 is 0b10 (16KB granule) or 0b01 (64KB granule), start at level 3.
                0b01
                    If VTCR_EL2.TG0 is 0b00 (4KB granule):
                    - If FEAT_LPA2 is not implemented, start at level 1.
                    - If FEAT_LPA2 is implemented and VTCR_EL2.SL2 is 0b0, start at level 1.
                    - If FEAT_LPA2 is implemented, the combination of VTCR_EL2.SL0 == 01 and VTCR_EL2.SL2 == 1 is reserved.
                    If VTCR_EL2.TG0 is 0b10 (16KB granule) or 0b01 (64KB granule), start at level 2.
                0b10
                    If VTCR_EL2.TG0 is 0b00 (4KB granule):
                    - If FEAT_LPA2 is not implemented, start at level 0.
                    - If FEAT_LPA2 is implemented and VTCR_EL2.SL2 is 0b0, start at level 0.
                    - If FEAT_LPA2 is implemented, the combination of VTCR_EL2.SL0 == 10 and VTCR_EL2.SL2 == 1 is reserved.
                    If VTCR_EL2.TG0 is 0b10 (16KB granule) or 0b01 (64KB granule), start at level 1.
                0b11
                    If VTCR_EL2.TG0 is 0b00 (4KB granule):
                    - If FEAT_LPA2 is not implemented, start at level 3.
                    - If FEAT_LPA2 is implemented and VTCR_EL2.SL2 is 0b0, start at level 3.
                    - If FEAT_LPA2 is implemented, the combination of VTCR_EL2.SL0 == 11 and VTCR_EL2.SL2 == 1 is reserved.
                    If VTCR_EL2.TG0 is 0b10 (16KB granule) and FEAT_LPA2 is implemented, start at level 0.
                If this field is programmed to a value that is not consistent with the programming of VTCR_EL2.T0SZ, then a stage 2 level 0 Translation fault is generated.
                On a Warm reset, this field resets to an architecturally UNKNOWN value.
            Otherwise:
                SL0
                Starting level of the stage 2 translation lookup, controlled by VTCR_EL2. The meaning of this field depends on the value of VTCR_EL2.TG0.
                0b00
                    If VTCR_EL2.TG0 is 0b00 (4KB granule), start at level 2. If VTCR_EL2.TG0 is 0b10 (16KB granule) or 0b01 (64KB granule), start at level 3.
                0b01
                    If VTCR_EL2.TG0 is 0b00 (4KB granule), start at level 1. If VTCR_EL2.TG0 is 0b10 (16KB granule) or 0b01 (64KB granule), start at level 2.
                0b10
                    If VTCR_EL2.TG0 is 0b00 (4KB granule), start at level 0. If VTCR_EL2.TG0 is 0b10 (16KB granule) or 0b01 (64KB granule), start at level 1.
                All other values are reserved. If this field is programmed to a reserved value, or to a value that is not
                consistent with the programming of VTCR_EL2.T0SZ, then a stage 2 level 0 Translation fault is generated.
                On a Warm reset, this field resets to an architecturally UNKNOWN value.

        T0SZ, bits [5:0]
            The size offset of the memory region addressed by VTTBR_EL2. The region size is 2(64-T0SZ) bytes.
            The maximum and minimum possible values for T0SZ depend on the level of translation table and
            the memory translation granule size, as described in the AArch64 Virtual Memory System Architecture chapter.
            If this field is programmed to a value that is not consistent with the programming of SL0, then a stage 2 level 0 Translation fault is generated.
            Note
                For the 4KB translation granule, if FEAT_LPA2 is implemented and this field is less than 16, the translation table walk begins with a level -1 initial lookup.
                For the 16KB translation granule, if FEAT_LPA2 is implemented and this field is less than 17, the translation table walk begins with a level 0 initial lookup.
                On a Warm reset, this field resets to an architecturally UNKNOWN value.
        """
        SL2 = (VTCR_EL2 >> 33) & 0b1
        PS = (VTCR_EL2 >> 16) & 0b11
        TG0 = (VTCR_EL2 >> 14) & 0b11
        SL0 = (VTCR_EL2 >> 6) & 0b11
        T0SZ = VTCR_EL2 & 0b111111
        try:
            granule_bits = {0b00: 12, 0b01: 16, 0b10: 14}[TG0]
        except:
            if not self.silent:
                err("Unsupported $VTCR_EL2.TG0")
            return
        region_start = 0
        region_end = region_start + (2 ** (64-T0SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        pa_size = 32 + (PS * 4)

        if self.FEAT_TTST:
            if SL0 == 0b00:
                if TG0 == 0b00:
                    if self.FEAT_LPA2 and SL2 == 1:
                        stage2_start_level = -1
                    else:
                        stage2_start_level = 2
                else:
                    stage2_start_level = 3
            elif SL0 == 0b01:
                if TG0 == 0b00:
                    if self.FEAT_LPA2 and SL2 == 1:
                        if not self.silent:
                            err("Unsupported stage2 start level")
                        return
                    else:
                        stage2_start_level = 1
                else:
                    stage2_start_level = 2
            elif SL0 == 0b10:
                if TG0 == 0b00:
                    if self.FEAT_LPA2 and SL2 == 1:
                        if not self.silent:
                            err("Unsupported stage2 start level")
                        return
                    else:
                        stage2_start_level = 0
                else:
                    stage2_start_level = 1
            elif SL0 == 0b11:
                if TG0 == 0b00:
                    if self.FEAT_LPA2 and SL2 == 1:
                        if not self.silent:
                            err("Unsupported stage2 start level")
                        return
                    else:
                        stage2_start_level = 3
                else:
                    stage2_start_level = 0
        else:
            if SL0 == 0b00:
                if TG0 == 0b00:
                    stage2_start_level = 2
                else:
                    stage2_start_level = 3
            elif SL0 == 0b01:
                if TG0 == 0b00:
                    stage2_start_level = 1
                else:
                    stage2_start_level = 2
            elif SL0 == 0b10:
                if TG0 == 0b00:
                    stage2_start_level = 0
                else:
                    stage2_start_level = 1
            else:
                if not self.silent:
                    err("Unsupported stage2 start level")
                return

        """ VTTBR_EL2
        BADDR, bits [47:1]
            Translation table base address, A[47:x] or A[51:x], bits[47:1].
            Note
                A translation table must be aligned to the size of the table, except that when using a translation table
                base address larger than 48 bits the minimum alignment of a table containing fewer than eight entries is 64 bytes.
            In an implementation that includes FEAT_LPA, if the value of VTCR_EL2.PS is 0b110, then:
            - Register bits[47:z] hold bits[47:z] of the stage 1 translation table base address, where z is
            determined as follows:
                — If x >= 6 then z=x.
                — Otherwise, z=6.
            - Register bits[5:2] hold bits[51:48] of the stage 1 translation table base address.
            - When z>x register bits[(z-1):x] are RES0, and bits[(z-1):x] of the translation table base address are zero.
            - When x>6 register bits[(x-1):6] are RES0.
            - Register bit[1] is RES0.
            - Bits[5:2] of the stage 1 translation table base address are zero.
            - In an implementation that includes FEAT_TTCNP, bit[0] of the stage 1 translation table base address is zero.
            Note
                When the value of ID_AA64MMFR0_EL1.PARange indicates that the implementation does not
                support a 52 bit PA size, if a translation table lookup uses this register when the Effective value of
                VTCR_EL2.PS is 0b110 and the value of register bits[5:2] is nonzero, an Address size fault is generated.
                If the Effective value of VTCR_EL2.PS is not 0b110 then:
            - Register bits[47:x] hold bits[47:x] of the stage 1 translation table base address.
            - Register bits[(x-1):1] are RES0.
            - If the implementation supports 52-bit PAs and IPAs then bits[51:48] of the translation table base addresses used in this stage of translation are 0b0000.
            If any VTTBR_EL2[47:0] bit that is defined as RES0 has the value 1 when a translation table walk
            is performed using VTTBR_EL2, then the translation table base address might be misaligned, with
            effects that are CONSTRAINED UNPREDICTABLE, and must be one of the following:
            - Bits[x-1:0] of the translation table base address are treated as if all the bits are zero. The value
            read back from the corresponding register bits is either the value written to the register or zero.
            - The result of the calculation of an address for a translation table walk using this register can be corrupted in those bits that are nonzero.
            The AArch64 Virtual Memory System Architecture chapter describes how x is calculated based on
            the value of VTCR_EL2.T0SZ, the stage of translation, and the translation granule size.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.
        """
        if PS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (VTTBR_EL2 & 0xffffffffffc0) | (((VTTBR_EL2 >> 2) & 0b1111) << 48)
            else:
                if not self.silent:
                    err("Unsupported FEAT_LPA and PS pair")
                return
        else:
            translation_base_addr = VTTBR_EL2 & 0xfffffffffffe

        if not self.silent and not self.quiet:
            info('$VTTBR_EL2: {:#x}'.format(VTTBR_EL2))
            info('$VTCR_EL2: {:#x}'.format(VTCR_EL2))
            info('Physical Address Size: {:d} bits'.format(pa_size))
            info('EL2 Starting Level: {:d}'.format(SL0))
            info('EL2 Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end-1, region_bits))
            info('EL2 Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start, start_level=stage2_start_level, is_stage2=True)
        if not self.silent:
            self.print_page()
        return

    def pagewalk_TTBR0_EL2(self):
        gef_print(titlify("$TTBR0_EL2"))

        TTBR0_EL2 = get_register('$TTBR0_EL2')
        TCR_EL2 = get_register('$TCR_EL2')
        if TTBR0_EL2 == 0:
            warn("Maybe unused TTBR0_EL2")
            return

        """ TCR_EL2
        When HCR_EL2.E2H == 0:
            PS, bits [18:16]
                Physical Address Size.
                0b000
                    32 bits, 4GB.
                0b001
                    36 bits, 64GB.
                0b010
                    40 bits, 1TB.
                0b011
                    42 bits, 4TB.
                0b100
                    44 bits, 16TB.
                0b101
                    48 bits, 256TB.
                0b110
                    52 bits, 4PB.
                All other values are reserved.
                The reserved values behave in the same way as the 0b101 or 0b110 encoding, but software must not
                rely on this property as the behavior of the reserved values might change in a future revision of the architecture.
                If the translation granule is not 64KB and FEAT_LPA2 is not implemented, the value 0b110 is treated as reserved.
                It is IMPLEMENTATION DEFINED whether an implementation that does not implement FEAT_LPA
                supports setting the value of 0b110 for the 64KB translation granule size or whether setting this value behaves as the 0b101 encoding.
                In an implementation that supports 52-bit PAs, if the value of this field is not 0b110 or a value treated
                as 0b110, then bits[51:48] of every translation table base address for the stage of translation controlled by TCR_EL2 are 0b0000.
                On a Warm reset, this field resets to an architecturally UNKNOWN value.
        Otherwise:
            IPS, bits [34:32]
                Intermediate Physical Address Size.
                0b000
                    32 bits, 4GB.
                0b001
                    36 bits, 64GB.
                0b010
                    40 bits, 1TB.
                0b011
                    42 bits, 4TB.
                0b100
                    44 bits, 16TB.
                0b101
                    48 bits, 256TB.
                0b110
                    When FEAT_LPA is implemented 52 bits, 4PB.
                All other values are reserved.
                The reserved values behave in the same way as the 0b101 or 0b110 encoding, but software must not
                rely on this property as the behavior of the reserved values might change in a future revision of the architecture.
                If the translation granule is not 64KB, the value 0b110 is treated as reserved.
                It is IMPLEMENTATION DEFINED whether an implementation that does not implement FEAT_LPA
                supports setting the value of 0b110 for the 64KB translation granule size or whether setting this value behaves as the 0b101 encoding.
                In an implementation that supports 52-bit PAs, if the value of this field is not 0b110 or a value treated
                as 0b110, then bits[51:48] of every translation table base address for the stage of translation controlled by TCR_EL2 are 0b0000.
                On a Warm reset, this field resets to an architecturally UNKNOWN value.

        TG0, bits [15:14]
            Granule size for the TTBR0_EL2.
            0b00
                4KB.
            0b01
                64KB.
            0b10
                16KB.
            Other values are reserved.
            If the value is programmed to either a reserved value or a size that has not been implemented, then
            the hardware will treat the field as if it has been programmed to an IMPLEMENTATION DEFINED
            choice of the sizes that has been implemented for all purposes other than the value read back from this register.
            It is IMPLEMENTATION DEFINED whether the value read back is the value programmed or the value that corresponds to the size chosen.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.

        T0SZ, bits [5:0]
            The size offset of the memory region addressed by TTBR0_EL2. The region size is 2^(64-T0SZ) bytes.
            The maximum and minimum possible values for T0SZ depend on the level of translation table and
            the memory translation granule size, as described in the AArch64 Virtual Memory System Architecture chapter.
            Note
                For the 4KB translation granule, if FEAT_LPA2 is implemented and this field is less than 16, the translation table walk begins with a level -1 initial lookup.
                For the 16KB translation granule, if FEAT_LPA2 is implemented and this field is less than 17, the translation table walk begins with a level 0 initial lookup.
                On a Warm reset, this field resets to an architecturally UNKNOWN value.
        """
        if self.EL2_E2H:
            IPS = (TCR_EL2 >> 32) & 0b111
        else:
            PS = (TCR_EL2 >> 16) & 0b111
        TG0 = (TCR_EL2 >> 14) & 0b11
        T0SZ = TCR_EL2 & 0b111111
        try:
            granule_bits = {0b00: 12, 0b01: 16, 0b10: 14}[TG0]
        except:
            err("Unsupported $TCR_EL2.TG0")
            return
        region_start = 0
        region_end = region_start + (2 ** (64-T0SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        if self.EL2_E2H:
            intermediate_pa_size = 32 + (IPS * 4)
        else:
            pa_size = 32 + (PS * 4)

        """ TTBR0_EL2
        BADDR[47:1], bits [47:1]
            Translation table base address:
            - Bits A[47:x] of the stage 1 translation table base address bits are in register bits[47:x].
            - Bits A[(x-1):0] of the stage 1 translation table base address are zero.
            Address bit x is the minimum address bit required to align the translation table to the size of the table.
            The smallest permitted value of x is 6. The AArch64 Virtual Memory System Architecture chapter describes how x is
            calculated based on the value of TCR_EL2.T0SZ, the translation stage, and the translation granule size.
            Note
                A translation table is required to be aligned to the size of the table. If a table contains fewer than
                eight entries, it must be aligned on a 64 byte address boundary.
            If the value of TCR_EL2.{I}PS is not 0b110, then:
            - Register bits[(x-1):1] are RES0.
            - If the implementation supports 52-bit PAs and IPAs, then bits A[51:48] of the stage 1 translation table base address are 0b0000.
            If FEAT_LPA is implemented and the value of TCR_EL2.{I}PS is 0b110, then:
            • Bits A[51:48] of the stage 1 translation table base address bits are in register bits[5:2].
            • Register bit[1] is RES0.
            • When x>6, register bits[(x-1):6] are RES0.
            Note
                The OA size specified by TCR_EL2.{I}PS is determined as follows:
                - The value of TCR_EL2.PS when the value of HCR_EL2.E2H is 0.
                - The value of TCR_EL2.IPS when the value of HCR_EL2.E2H is 1.
                TCR_EL2.{I}PS==0b110 is permitted when:
                - FEAT_LPA is implemented and the 64KB translation granule is used.
                - FEAT_LPA2 is implemented and the 4KB or 16KB translation granule is used.
                When the value of ID_AA64MMFR0_EL1.PARange indicates that the implementation does not
                support a 52 bit PA size, if a translation table lookup uses this register when TCR_EL2.{I}PS is 0b110
                and the value of register bits[5:2] is nonzero, an Address size fault is generated.
            If any register bit[47:1] that is defined as RES0 has the value 1 when a translation table walk is done
            using TTBR0_EL2, then the translation table base address might be misaligned, with effects that are
            CONSTRAINED UNPREDICTABLE, and must be one of the following:
            - Bits A[(x-1):0] of the stage 1 translation table base address are treated as if all the bits are zero.
              The value read back from the corresponding register bits is either the value written to the register or zero.
            - The result of the calculation of an address for a translation table walk using this register can be corrupted in those bits that are nonzero.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.
        """
        if not self.EL2_E2H and PS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR0_EL2 & 0xffffffffffc0) | (((TTBR0_EL2 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and PS pair")
                return
        elif self.EL2_E2H and IPS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR0_EL2 & 0xffffffffffc0) | (((TTBR0_EL2 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and IPS pair")
                return
        else:
            translation_base_addr = TTBR0_EL2 & 0xfffffffffffe

        if not self.quiet:
            info('$TTBR0_EL2: {:#x}'.format(TTBR0_EL2))
            info('$TCR_EL2: {:#x}'.format(TCR_EL2))
            if self.EL2_E2H:
                info('Intermediate Physical Address Size: {:d} bits'.format(intermediate_pa_size))
            else:
                info('Physical Address Size: {:d} bits'.format(pa_size))
            if self.EL2_M20:
                info('EL2 User Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end-1, region_bits))
                info('EL2 USer Page Size: {:d}KB (per page)'.format(page_size))
            else:
                info('EL2 Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end-1, region_bits))
                info('EL2 Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start, is_2VAranges=self.EL2_M20)
        self.print_page()
        return

    def pagewalk_TTBR1_EL2(self):
        gef_print(titlify("$TTBR1_EL2"))

        TTBR1_EL2 = get_register('$TTBR1_EL2')
        TCR_EL2 = get_register('$TCR_EL2')
        if TTBR1_EL2 == 0:
            warn("Maybe unused TTBR1_EL2")
            return

        """ TCR_EL2
        IPS, bits [34:32]
            See above.

        TG1, bits [31:30]
            Granule size for the TTBR1_EL2.
            0b01
                16KB.
            0b10
                4KB.
            0b11
                64KB.
            Other values are reserved.
            If the value is programmed to either a reserved value, or a size that has not been implemented, then
            the hardware will treat the field as if it has been programmed to an IMPLEMENTATION DEFINED
            choice of the sizes that has been implemented for all purposes other than the value read back from this register.
            It is IMPLEMENTATION DEFINED whether the value read back is the value programmed or the value that corresponds to the size chosen.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.

        T1SZ, bits [21:16]
            The size offset of the memory region addressed by TTBR1_EL2. The region size is 2^(64-T1SZ) bytes.
            The maximum and minimum possible values for T1SZ depend on the level of translation table and
            the memory translation granule size, as described in the AArch64 Virtual Memory System Architecture chapter.
            Note
                For the 4KB translation granule, if FEAT_LPA2 is implemented and this field is less than 16, the translation table walk begins with a level -1 initial lookup.
                For the 16KB translation granule, if FEAT_LPA2 is implemented and this field is less than 17, the translation table walk begins with a level 0 initial lookup.
                On a Warm reset, this field resets to an architecturally UNKNOWN value.
        """
        IPS = (TCR_EL2 >> 32) & 0b111
        TG1 = (TCR_EL2 >> 30) & 0b11
        T1SZ = (TCR_EL2 >> 16) & 0b111111
        try:
            granule_bits = {0b01: 14, 0b10: 12, 0b11: 16}[TG1]
        except:
            err("Unsupported $TCR_EL2.TG1")
            return
        region_end = 2 ** 64
        region_start = region_end - (2 ** (64-T1SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        intermediate_pa_size = 32 + (IPS * 4)

        """ TTBR1_EL2
        BADDR[47:1], bits [47:1]
            Translation table base address:
            - Bits A[47:x] of the stage 1 translation table base address bits are in register bits[47:x].
            - Bits A[(x-1):0] of the stage 1 translation table base address are zero.
            Address bit x is the minimum address bit required to align the translation table to the size of the table.
            The smallest permitted value of x is 6. The AArch64 Virtual Memory System Architecture
            chapter describes how x is calculated based on the value of TCR_EL2.T1SZ, the translation stage, and the translation granule size.
            Note
                A translation table is required to be aligned to the size of the table. If a table contains fewer than
                eight entries, it must be aligned on a 64 byte address boundary
            If the value of TCR_EL2.{I}PS is not 0b110, then:
            - Register bits[(x-1):1] are RES0.
            - If the implementation supports 52-bit PAs and IPAs, then bits A[51:48] of the stage 1 translation table base address are 0b0000.
            If FEAT_LPA is implemented and the value of TCR_EL2.{I}PS is 0b110, then:
            - Bits A[51:48] of the stage 1 translation table base address bits are in register bits[5:2].
            - Register bit[1] is RES0.
            - When x>6, register bits[(x-1):6] are RES0.
            Note
                The OA size specified by TCR_EL2.{I}PS is determined as follows:
                - The value of TCR_EL2.PS when the value of HCR_EL2.E2H is 0.
                - The value of TCR_EL2.IPS when the value of HCR_EL2.E2H is 1.
                TCR_EL2.{I}PS==0b110 is permitted when:
                - FEAT_LPA is implemented and the 64KB translation granule is used.
                - FEAT_LPA2 is implemented and the 4KB or 16KB translation granule is used.
                When the value of ID_AA64MMFR0_EL1.PARange indicates that the implementation does not
                support a 52 bit PA size, if a translation table lookup uses this register when TCR_EL2.{I}PS is 0b110
                and the value of register bits[5:2] is nonzero, an Address size fault is generated.
            If any register bit[47:1] that is defined as RES0 has the value 1 when a translation table walk is done
            using TTBR1_EL2, then the translation table base address might be misaligned, with effects that are
            CONSTRAINED UNPREDICTABLE, and must be one of the following:
            - Bits A[(x-1):0] of the stage 1 translation table base address are treated as if all the bits are zero.
              The value read back from the corresponding register bits is either the value written to the register or zero.
            - The result of the calculation of an address for a translation table walk using this register can be corrupted in those bits that are nonzero.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.
        """
        if IPS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR1_EL2 & 0xffffffffffc0) | (((TTBR1_EL2 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and IPS pair")
                return
        else:
            translation_base_addr = TTBR1_EL2 & 0xfffffffffffe

        if not self.quiet:
            info('$TTBR1_EL2: {:#x}'.format(TTBR1_EL2))
            info('$TCR_EL2: {:#x}'.format(TCR_EL2))
            info('Intermediate Physical Address Size: {:d} bits'.format(intermediate_pa_size))
            info('EL2 Kernel Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end-1, region_bits))
            info('EL2 Kernel Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start, is_2VAranges=self.EL2_M20)
        self.print_page()
        return

    def pagewalk_TTBR0_EL3(self):
        gef_print(titlify("$TTBR0_EL3"))

        TTBR0_EL3 = get_register('$TTBR0_EL3')
        TCR_EL3 = get_register('$TCR_EL3')
        if TTBR0_EL3 == 0:
            warn("Maybe unused TTBR0_EL3")
            return

        """ TCR_EL3
        PS, bits [18:16]
            Physical Address Size.
            0b000
                32 bits, 4GB.
            0b001
                36 bits, 64GB.
            0b010
                40 bits, 1TB.
            0b011
                42 bits, 4TB.
            0b100
                44 bits, 16TB.
            0b101
                48 bits, 256TB.
            0b110
                52 bits, 4PB.
            All other values are reserved.
            The reserved values behave in the same way as the 0b101 or 0b110 encoding, but software must not
            rely on this property as the behavior of the reserved values might change in a future revision of the architecture.
            If the translation granule is not 64KB and FEAT_LPA2 is not implemented, the value 0b110 is treated as reserved.
            It is IMPLEMENTATION DEFINED whether an implementation that does not implement FEAT_LPA
            supports setting the value of 0b110 for the 64KB translation granule size or whether setting this value behaves as the 0b101 encoding.
            In an implementation that supports 52-bit PAs, if the value of this field is not 0b110 or a value treated as 0b110,
            then bits[51:48] of every translation table base address for the stage of translation controlled by TCR_EL3 are 0b0000.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.

        TG0, bits [15:14]
            Granule size for the TTBR0_EL3.
            0b00
                4KB.
            0b01
                64KB.
            0b10
                16KB.
            Other values are reserved.
            If the value is programmed to either a reserved value or a size that has not been implemented, then
            the hardware will treat the field as if it has been programmed to an IMPLEMENTATION DEFINED
            choice of the sizes that has been implemented for all purposes other than the value read back from this register.
            It is IMPLEMENTATION DEFINED whether the value read back is the value programmed or the value that corresponds to the size chosen.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.

        T0SZ, bits [5:0]
            The size offset of the memory region addressed by TTBR0_EL3. The region size is 2^(64-T0SZ) bytes.
            The maximum and minimum possible values for T0SZ depend on the level of translation table and
            the memory translation granule size, as described in the AArch64 Virtual Memory System Architecture chapter
            Note
                For the 4KB translation granule, if FEAT_LPA2 is implemented and this field is less than 16, the translation table walk begins with a level -1 initial lookup.
                For the 16KB translation granule, if FEAT_LPA2 is implemented and this field is less than 17, the translation table walk begins with a level 0 initial lookup.
                On a Warm reset, this field resets to an architecturally UNKNOWN value.
        """
        PS = (TCR_EL3 >> 16) & 0b111
        TG0 = (TCR_EL3 >> 14) & 0b11
        T0SZ = TCR_EL3 & 0b111111
        try:
            granule_bits = {0b00: 12, 0b01: 16, 0b10: 14}[TG0]
        except:
            err("Unsupported $TCR_EL3.TG0")
            return
        region_start = 0
        region_end = region_start + (2 ** (64-T0SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        pa_size = 32 + (PS * 4)

        """ TTBR0_EL3
        BADDR[47:1], bits [47:1]
            Translation table base address:
            - Bits A[47:x] of the stage 1 translation table base address bits are in register bits[47:x].
            - Bits A[(x-1):0] of the stage 1 translation table base address are zero.
            Address bit x is the minimum address bit required to align the translation table to the size of the table.
            The smallest permitted value of x is 6. The AArch64 Virtual Memory System Architecture
            chapter describes how x is calculated based on the value of TCR_EL3.T0SZ, the translation stage, and the translation granule size.
            Note
                A translation table is required to be aligned to the size of the table. If a table contains fewer than
                eight entries, it must be aligned on a 64 byte address boundary.
            If the value of TCR_EL3.PS is not 0b110, then:
            - Register bits[(x-1):1] are RES0.
            - If the implementation supports 52-bit PAs and IPAs, then bits A[51:48] of the stage 1 translation table base address are 0b0000.
            If FEAT_LPA is implemented and the value of TCR_EL3.PS is 0b110, then:
            - Bits A[51:48] of the stage 1 translation table base address bits are in register bits[5:2].
            - Register bit[1] is RES0.
            - When x>6, register bits[(x-1):6] are RES0.
            Note
                TCR_EL3.PS==0b110 is permitted when:
                - FEAT_LPA is implemented and the 64KB translation granule is used.
                - FEAT_LPA2 is implemented and the 4KB or 16KB translation granule is used.
                When the value of ID_AA64MMFR0_EL1.PARange indicates that the implementation does not
                support a 52 bit PA size, if a translation table lookup uses this register when TCR_EL3.PS is 0b110
                and the value of register bits[5:2] is nonzero, an Address size fault is generated.
            If any register bit[47:1] that is defined as RES0 has the value 1 when a translation table walk is done
            using TTBR0_EL3, then the translation table base address might be misaligned, with effects that are
            CONSTRAINED UNPREDICTABLE, and must be one of the following:
            - Bits A[(x-1):0] of the stage 1 translation table base address are treated as if all the bits are zero.
              The value read back from the corresponding register bits is either the value written to the register or zero.
            - The result of the calculation of an address for a translation table walk using this register can be corrupted in those bits that are nonzero.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.
        """
        if PS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR0_EL3 & 0xffffffffffc0) | (((TTBR0_EL3 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and PS pair")
                return
        else:
            translation_base_addr = TTBR0_EL3 & 0xfffffffffffe

        if not self.quiet:
            info('$TTBR0_EL3: {:#x}'.format(TTBR0_EL3))
            info('$TCR_EL3: {:#x}'.format(TCR_EL3))
            info('Physical Address Size: {:d} bits'.format(pa_size))
            info('EL3 Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end-1, region_bits))
            info('EL3 Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start)
        self.print_page()
        return

    def pagewalk_init(self):
        res = gdb.execute("info registers", to_string=True)
        if not "TTBR" in res:
            err("Not found system registers. Check qemu version (at least: 3.x~, recommend: 5.x~).")
            return

        """ SCTLR_EL1
        M, bit [0]
            MMU enable for EL1&0 stage 1 address translation.
            0b0
                EL1&0 stage 1 address translation disabled.
                See the SCTLR_EL1.I field for the behavior of instruction accesses to Normal memory.
            0b1
                EL1&0 stage 1 address translation enabled.
            If the value of HCR_EL2.{DC, TGE} is not {0, 0} then in Non-secure state the PE behaves as if the
            value of the SCTLR_EL1.M field is 0 for all purposes other than returning the value of a direct read of the field.
            When FEAT_VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this bit has no effect on the PE.
            On a Warm reset, in a system where the PE resets into EL1, this field resets to 0.

        WXN, bit [19]
            Write permission implies XN (Execute-never). For the EL1&0 translation regime, this bit can force
            all memory regions that are writable to be treated as XN. The possible values of this bit are:
            0b0
                This control has no effect on memory access permissions.
            0b1
                Any region that is writable in the EL1&0 translation regime is forced to XN for accesses from software executing at EL1 or EL0.
            This bit applies only when SCTLR_EL1.M bit is set.
            The WXN bit is permitted to be cached in a TLB.
            When FEAT_VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this bit has no effect on the PE.
            On a Warm reset, in a system where the PE resets into EL1, this field resets to an architecturally UNKNOWN value.
        """
        SCTLR_EL1 = get_register('$SCTLR_EL1')
        if SCTLR_EL1 is None:
            SCTLR_EL1 = get_register('$SCTLR')
        if SCTLR_EL1 is not None:
            self.EL1_M = (SCTLR_EL1 & 1) == 1
            self.EL1_WXN = ((SCTLR_EL1 >> 19) & 1) == 1
        else:
            self.EL1_M = False
            self.EL1_WXN = False

        """ HCR_EL2
        E2H, bit [34]
            When FEAT_VHE is implemented:
                EL2 Host. Enables a configuration where a Host Operating System is running in EL2, and the Host Operating System's applications are running in EL0.
                0b0
                    The facilities to support a Host Operating System at EL2 are disabled.
                0b1
                    The facilities to support a Host Operating System at EL2 are enabled.
                For information on the behavior of this bit see Behavior of HCR_EL2.E2H on page D5-2764.
                This bit is permitted to be cached in a TLB.
                On a Warm reset, this field resets to an architecturally UNKNOWN value.
            Otherwise:
                Reserved, RES0.

        TGE, bit [27]
            Trap General Exceptions, from EL0.
            0b0
                This control has no effect on execution at EL0.
            0b1
                When EL2 is not enabled in the current Security state, this control has no effect on execution at EL0.
                When EL2 is enabled in the current Security state, in all cases:
                - All exceptions that would be routed to EL1 are routed to EL2.
                - If EL1 is using AArch64, the SCTLR_EL1.M field is treated as being 0 for all purposes other than returning the result of a direct read of SCTLR_EL1.
                - If EL1 is using AArch32, the SCTLR.M field is treated as being 0 for all purposes other than returning the result of a direct read of SCTLR.
                - All virtual interrupts are disabled.
                - Any IMPLEMENTATION DEFINED mechanisms for signaling virtual interrupts are disabled.
                - An exception return to EL1 is treated as an illegal exception return.
                - The MDCR_EL2.{TDRA, TDOSA, TDA, TDE} fields are treated as being 1 for all purposes other than returning the result of a direct read of MDCR_EL2.
                In addition, when EL2 is enabled in the current Security state, if:
                - HCR_EL2.E2H is 0, the Effective values of the HCR_EL2.{FMO, IMO, AMO} fields are 1.
                - HCR_EL2.E2H is 1, the Effective values of the HCR_EL2.{FMO, IMO, AMO} fields are 0.
                For further information on the behavior of this bit when E2H is 1, see Behavior of HCR_EL2.E2H on page D5-2764.
            HCR_EL2.TGE must not be cached in a TLB.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.

        VM, bit [0]
            Virtualization enable. Enables stage 2 address translation for the EL1&0 translation regime, when
            EL2 is enabled in the current Security state.
            0b0
                EL1&0 stage 2 address translation disabled.
            0b1
                EL1&0 stage 2 address translation enabled.
            When the value of this bit is 1, data cache invalidate instructions executed at EL1 perform a data
            cache clean and invalidate. For the invalidate by set/way instruction this behavior applies regardless
            of the value of the HCR_EL2.SWIO bit.
            This bit is permitted to be cached in a TLB.
            When FEAT_VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1}, this field
            behaves as 0 for all purposes other than a direct read of the value of this bit.
            On a Warm reset, this field resets to an architecturally UNKNOWN value.
        """
        HCR_EL2 = get_register('$HCR_EL2')
        if HCR_EL2 is not None:
            self.EL2_TGE = ((HCR_EL2 >> 27) & 1) == 1
            self.EL2_E2H = ((HCR_EL2 >> 34) & 1) == 1
            self.EL2_M20 = self.EL2_TGE and self.EL2_E2H
            self.EL2_VM = (HCR_EL2 & 1) == 1
        else:
            self.EL2_TGE = False
            self.EL2_E2H = False
            self.EL2_M20 = False
            self.EL2_VM = False

        """ SCTLR_EL2
        M, bit [0]
            MMU enable for EL2 or EL2&0 stage 1 address translation.
            0b0
                When HCR_EL2.{E2H, TGE} != {1, 1}, EL2 stage 1 address translation disabled.
                When HCR_EL2.{E2H, TGE} == {1, 1}, EL2&0 stage 1 address translation disabled.
                See the SCTLR_EL2.I field for the behavior of instruction accesses to Normal memory.
            0b1
                When HCR_EL2.{E2H, TGE} != {1, 1}, EL2 stage 1 address translation enabled.
                When HCR_EL2.{E2H, TGE} == {1, 1}, EL2&0 stage 1 address translation enabled.
            On a Warm reset, in a system where the PE resets into EL2, this field resets to 0.

        WXN, bit [19]
            Write permission implies XN (Execute-never). For the EL2 or EL2&0 translation regime, this bit
            can force all memory regions that are writable to be treated as XN.
            0b0
                This control has no effect on memory access permissions.
            0b1
                Any region that is writable in the EL2 or EL2&0 translation regime is forced to XN for
            accesses from software executing at EL2.
            This bit applies only when SCTLR_EL2.M bit is set.
            The WXN bit is permitted to be cached in a TLB.
            On a Warm reset, in a system where the PE resets into EL2, this field resets to an architecturally UNKNOWN value.
        """
        SCTLR_EL2 = get_register('$SCTLR_EL2')
        if SCTLR_EL2 is not None:
            self.EL2_M = (SCTLR_EL2 & 1) == 1
            self.EL2_WXN = ((SCTLR_EL2 >> 19) & 1) == 1
        else:
            self.EL2_M = False
            self.EL2_WXN = False

        """ SCTLR_EL3
        M, bit [0]
            MMU enable for EL3 stage 1 address translation. Possible values of this bit are:
            0b0
                EL3 stage 1 address translation disabled.
                See the SCTLR_EL3.I field for the behavior of instruction accesses to Normal memory.
            0b1
                EL3 stage 1 address translation enabled.
            On a Warm reset, in a system where the PE resets into EL3, this field resets to 0.

        WXN, bit [19]
            Write permission implies XN (Execute-never). For the EL3 translation regime, this bit can force all
            memory regions that are writable to be treated as XN. The possible values of this bit are:
            0b0
                This control has no effect on memory access permissions.
            0b1
                Any region that is writable in the EL3 translation regime is forced to XN for accesses from software executing at EL3.
            This bit applies only when SCTLR_EL3.M bit is set.
            The WXN bit is permitted to be cached in a TLB.
            On a Warm reset, in a system where the PE resets into EL3, this field resets to an architecturally UNKNOWN value.
        """
        SCTLR_EL3 = get_register('$SCTLR_EL3')
        if SCTLR_EL3 is not None:
            self.EL3_M = (SCTLR_EL3 & 1) == 1
            self.EL3_WXN = ((SCTLR_EL3 >> 19) & 1) == 1
        else:
            self.EL3_M = False
            self.EL3_WXN = False

        """
        FEAT_LPA, Large PA and IPA support
            - Allows a larger intermediate physical address (IPA) and PA space of up to 52 bits when using the 64KB translation granule.
            - Allows a level 1 block size where the block covers a 4TB address range for the 64KB translation granule if the implementation support 52 bits of PA.
            This is an OPTIONAL feature in Armv8.2 implementations. It is IMPLEMENTATION DEFINED whether it is implemented.
            This feature is supported in AArch64 state only.
            The ID_AA64MMFR0_EL1.PARange field identifies the presence of FEAT_LPA.

        FEAT_LPA2, Larger physical address for 4KB and 16KB translation granules
            - Allows a larger VA space for each translation table base register of up to 52 bits when using the 4KB or 16KB translation granules.
            - Allows a larger intermediate physical address (IPA) and PA space of up to 52 bits when using the 4KB or 16KB translation granules.
            - Allows a level 0 block size where the block covers a 512GB address range for the 4KB translation granule if the implementation supports 52 bits of PA.
            - Allows a level 1 block size where the block covers a 64GB address range for the 16KB translation granule if the implementation supports 52 bits of PA.
            This feature is supported in AArch64 state only.
            This feature is OPTIONAL in Armv8.7 implementations. This feature requires implementation of FEAT_LPA and FEAT_LVA.
            The ID_AA64MMFR0_EL1.{TGRAN4_2, TGRAN16_2, TGRAN4, TGRAN16} fields identify the presence of FEAT_LPA2.
        """

        """ ID_AA64MMFR0_EL1
        TGran4_2, bits [43:40]
            Indicates support for 4KB memory granule size at stage 2. Defined values are:
            0b0000
                Support for 4KB granule at stage 2 is identified in the ID_AA64MMFR0_EL1.TGran4 field.
            0b0001
                4KB granule not supported at stage 2.
            0b0010
                4KB granule supported at stage 2.
            0b0011
                When FEAT_LPA2 is implemented 4KB granule at stage 2 supports 52-bit input and output addresses.
            All other values are reserved.
            The 0b0000 value is deprecated.

        TGran16_2, bits [35:32]
            Indicates support for 16KB memory granule size at stage 2. Defined values are:
            0b0000
                Support for 16KB granule at stage 2 is identified in the ID_AA64MMFR0_EL1.TGran16 field.
            0b0001
                16KB granule not supported at stage 2.
            0b0010
                16KB granule supported at stage 2.
            0b0011
                When FEAT_LPA2 is implemented 16KB granule at stage 2 supports 52-bit input and output addresses.
            All other values are reserved.
            The 0b0000 value is deprecated.

        TGran4, bits [31:28]
            Indicates support for 4KB memory translation granule size. Defined values are:
            0b0000
                4KB granule supported.
            0b0001
                When FEAT_LPA2 is implemented 4KB granule supports 52-bit input and output addresses.
            0b1111
                4KB granule not supported.
            All other values are reserved.

        TGran16, bits [23:20]
            Indicates support for 16KB memory translation granule size. Defined values are:
            0b0000
                16KB granule not supported.
            0b0001
                16KB granule supported.
            0b0010
                When FEAT_LPA2 is implemented 16KB granule supports 52-bit input and output addresses.
            All other values are reserved.

        PARange, bits [3:0]
            Physical Address range supported. Defined values are:
            0b0000
                32 bits, 4GB.
            0b0001
                36 bits, 64GB.
            0b0010
                40 bits, 1TB.
            0b0011
                42 bits, 4TB.
            0b0100
                44 bits, 16TB.
            0b0101
                48 bits, 256TB.
            0b0110
                52 bits, 4PB.
            All other values are reserved.
            The value 0b0110 is permitted only if the implementation includes FEAT_LPA, otherwise it is reserved.
        """
        ID_AA64MMFR0_EL1 = get_register('$ID_AA64MMFR0_EL1')
        if ID_AA64MMFR0_EL1 is not None:
            TGran4_2 = (ID_AA64MMFR0_EL1 >> 40) & 0b1111
            TGran16_2 = (ID_AA64MMFR0_EL1 >> 32) & 0b1111
            TGran4 = (ID_AA64MMFR0_EL1 >> 28) & 0b1111
            TGran16 = (ID_AA64MMFR0_EL1 >> 20) & 0b1111
            self.FEAT_LPA2 = (TGran4_2 == 0b0011) or (TGran16_2 == 0b0011) or (TGran4 == 0b0001) or (TGran16 == 0b0010)
            self.FEAT_LPA = (ID_AA64MMFR0_EL1 & 0b1111) == 0b0110
        else:
            self.FEAT_LPA2 = False
            self.FEAT_LPA = False

        """
        FEAT_PAN, Privileged access never
            FEAT_PAN adds a bit to PSTATE. When the value of this PAN state bit is 1, any privileged data access from EL1, or EL2
            when HCR_EL2.E2H is 1, to a virtual memory address that is accessible to data accesses at EL0, generates a Permission fault.
            This feature is mandatory in Armv8.1 implementations.
            This feature is supported in both AArch64 and AArch32 states.
            The following fields identify the presence of FEAT_PAN:
            - ID_AA64MMFR1_EL1.PAN.
            - ID_MMFR3_EL1.PAN.
            - ID_MMFR3.PAN
        """

        """ ID_AA64MMFR1_EL1
        PAN, bits [23:20]
            Privileged Access Never. Indicates support for the PAN bit in PSTATE, SPSR_EL1, SPSR_EL2, SPSR_EL3, and DSPSR_EL0. Defined values are:
            0b0000
                PAN not supported.
            0b0001
                PAN supported.
            0b0010
                PAN supported and AT S1E1RP and AT S1E1WP instructions supported.
            0b0011
                PAN supported, AT S1E1RP and AT S1E1WP instructions supported, and SCTLR_EL1.EPAN and SCTLR_EL2.EPAN bits supported.
            All other values are reserved.
            FEAT_PAN implements the functionality identified by the value 0b0001.
            FEAT_PAN2 implements the functionality added by the value 0b0010.
            FEAT_PAN3 implements the functionality added by the value 0b0011.
            In Armv8.1, the permitted values are 0b0001 and 0b0011.
            From Armv8.2, the permitted values are 0b0010 and 0b0011.
            From Armv8.7, the only permitted value is 0b0011.
        """
        ID_AA64MMFR1_EL1 = get_register('$ID_AA64MMFR1_EL1')
        if ID_AA64MMFR1_EL1 is not None:
            self.FEAT_PAN = ((ID_AA64MMFR1_EL1 >> 20) & 0b1111) != 0b0000
        else:
            self.FEAT_PAN = False
        if not self.quiet:
            info("{:s} is supported on all ARMv8".format(Color.boldify("PXN")))
            if self.FEAT_PAN:
                info("{:s} is supported".format(Color.boldify("PAN")))
            else:
                info("PAN is unsupported")

        """
        FEAT_TTST, Small translation tables
            FEAT_TTST relaxes the lower limit on the size of translation tables, by increasing the maximum
            permitted value of the T1SZ and T0SZ fields in TCR_EL1, TCR_EL2, TCR_EL3, VTCR_EL2 and VSTCR_EL2.
            This feature is supported in AArch64 state only.
            This feature is mandatory if FEAT_SEL2 is implemented.
            This feature is OPTIONAL if FEAT_SEL2 is not implemented.
            The ID_AA64MMFR2_EL1.ST field identifies the presence of FEAT_TTST.

        FEAT_LVA, Large VA support
            FEAT_LVA supports a larger VA space for each translation table base register of up to 52 bits when using the 64KB translation granule.
            This feature is supported in AArch64 state only.
            This is an OPTIONAL feature in Armv8.2 implementations. It is IMPLEMENTATION DEFINED whether it is implemented.
            If FEAT_LVA is implemented, then any implemented trace macrocell must be at least ETMv4.2.
            The ID_AA64MMFR2_EL1.VARange field identifies the presence of FEAT_LVA.
        """

        """ ID_AA64MMFR2_EL1
        ST, bits [31:28]
            Identifies support for small translation tables. Defined values are:
            0b0000
                The maximum value of the TCR_ELx.{T0SZ,T1SZ} and VTCR_EL2.T0SZ fields is 39.
            0b0001
                The maximum value of the TCR_ELx.{T0SZ,T1SZ} and VTCR_EL2.T0SZ fields is 48 for 4KB and 16KB granules, and 47 for 64KB granules.
            All other values are reserved.
            FEAT_TTST implements the functionality identified by the value 0b0001.
            If FEAT_SEL2 is implemented, the only permitted value is 0b0001.
            In an implementation which does not support FEAT_SEL2, the permitted values are 0b0000 and 0b0001.

        VARange, bits [19:16]
            Indicates support for a larger virtual address. Defined values are:
            0b0000
                VMSAv8-64 supports 48-bit VAs.
            0b0001
                VMSAv8-64 supports 52-bit VAs when using the 64KB translation granule. The size for other translation granules is not defined by this field.
            All other values are reserved.
            FEAT_LVA implements the functionality identified by the value 0b0001.
            From Armv8.2, the permitted values are 0b0000 and 0b0001.
        """
        ID_AA64MMFR2_EL1 = get_register('$ID_AA64MMFR2_EL1')
        if ID_AA64MMFR2_EL1 is not None:
            self.FEAT_TTST = ((ID_AA64MMFR2_EL1 >> 28) & 0b1111) == 0b0001
            self.FEAT_LVA = ((ID_AA64MMFR2_EL1 >> 16) & 0b1111) == 0b0001
        else:
            self.FEAT_TTST = False
            self.FEAT_LVA = False

        return

    def pagewalk(self):
        # parse system registers
        self.pagewalk_init()

        # TODO implementation for VSTTBR_EL2, VSTCR_EL2 pattern

        # do pagewalk
        if self.TargetEL < 1 or 3 < self.TargetEL:
            warn('No paging in EL{:d}'.format(self.TargetEL))
            return
        if self.TargetEL == 1 and self.EL1_M:
            if self.EL2_VM:
                # el2_mapping is needed because read_mem() uses PA, but not IPA
                self.silent = True
                self.pagewalk_VTTBR_EL2()
                if self.mappings:
                    self.el2_mappings = self.mappings
                self.silent = False
            self.pagewalk_TTBR0_EL1()
            self.pagewalk_TTBR1_EL1()
        if self.TargetEL == 1 and not self.EL1_M:
            if not self.quiet:
                info("EL1/0 translation is unused")
        if self.TargetEL == 2 and self.EL2_VM:
            self.pagewalk_VTTBR_EL2()
        if self.TargetEL == 2 and not self.EL2_VM:
            if not self.quiet:
                info("EL2(as stage2) translation is unused")
        if self.TargetEL == 2 and self.EL2_M:
            self.pagewalk_TTBR0_EL2()
            if self.EL2_M20:
                self.pagewalk_TTBR1_EL2()
        if self.TargetEL == 2 and self.EL2_VM:
            if not self.quiet:
                info("EL2(as stage1) translation is unused")
        if self.TargetEL == 3 and self.EL3_M:
            if not self.switch_el():
                return
            self.pagewalk_TTBR0_EL3()
            self.revert_el()
        if self.TargetEL == 3 and not self.EL3_M:
            if not self.quiet:
                info("EL3 translation is unused")
        return

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if not is_arm64():
            err("Unsupported")
            return

        try:
            argv = self.parse_common_args(argv)
            if argv:
                self.TargetEL = int(argv[-1])
                argv = argv[:-1]
                if argv:
                    raise
            else:
                CPSR = int(gdb.parse_and_eval('$cpsr'))
                self.TargetEL = (CPSR >> 2) & 0b11
        except:
            self.usage()
            return

        self.silent = False
        self.mappings = None
        self.el2_mappings = None
        self.pagewalk()
        self.cache = {}
        return


@register_command
class SwitchELCommand(GenericCommand):
    """Switch EL (Exception Level) on ARM64 architecture."""
    _cmdline_ = "switch-el"
    _syntax_ = "{:s} [-h] [TARGET_EL]".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def switch_el(self):
        # current EL
        CPSR = int(gdb.parse_and_eval('$cpsr')) & 0xffffffff
        CurrentEL = (CPSR >> 2) & 0b11

        # check argv
        if self.target_el is None:
            info('$cpsr = 0x%x (EL%d)' % (CPSR, CurrentEL))
            return

        # check target EL
        try:
            if self.target_el < 0 or self.target_el > 3:
                err("Invalid argument (ELx>=0 && ELx<=3)")
                return
        except ValueError:
            err("Invalid argument (ELx integer required)")
            return

        # change CPSR
        if self.target_el != CurrentEL:
            CPSR = CPSR & ~(0b11 << 2) # clear EL
            CPSR |= self.target_el << 2 # set desired EL
            gdb.parse_and_eval('$cpsr = 0x%08x' % CPSR)
            info('Moving to EL%d' % (self.target_el))
        else:
            info('Already at EL%d' % (self.target_el))

        # reprint CPSR
        CPSR = int(gdb.parse_and_eval('$cpsr')) & 0xffffffff
        CurrentEL = (CPSR >> 2) & 0b11
        info('$cpsr = 0x%x (EL%d)' % (CPSR, CurrentEL))
        return

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return
        if not is_arm64():
            err("Unsupported")
            return
        if argv:
            self.target_el = int(argv[0])
        else:
            self.target_el = None
        self.switch_el()
        return


@register_command
class MemoryHashCommand(GenericCommand):
    """Caluculate memory hash."""
    _cmdline_ = "hash-memory"
    _syntax_ = "{:s} [-h] md5|sha1|sha224|sha256|sha384|sha512|crc16|crc32|crc64 ADDRESS SIZE".format(_cmdline_)
    _category_ = "Misc"

    def calc_hash(self, type, h, start_address, end_address):
        step = 0x400 * gef_getpagesize()
        if is_qemu_system():
            step = gef_getpagesize()

        for chunk_addr in range(start_address, end_address, step):
            if chunk_addr + step > end_address:
                chunk_size = end_address - chunk_addr
            else:
                chunk_size = step

            try:
                mem = read_memory(chunk_addr, chunk_size)
            except gdb.error:
                err("Memory read error")
                return None

            if type == 1:
                h.update(mem)
            elif type == 2:
                h.process(mem)

            del mem
        if type == 1:
            return h.hexdigest()
        elif type == 2:
            return h.finalhex()
        return None

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if len(argv) != 3:
            self.usage()
            return

        if not argv[0] in ["md5", "sha1", "sha224", "sha256", "sha384", "sha512", "crc16", "crc32", "crc64"]:
            self.usage()
            return

        try:
            address = int(argv[1], 0)
            size = int(argv[2], 0)
        except:
            self.usage()
            return

        gef_print("Address: {:#x}".format(address))
        gef_print("Size: {:#x}".format(size))

        if argv[0] == "md5":
            h = self.calc_hash(1, hashlib.md5(), address, address+size)
        elif argv[0] == "sha1":
            h = self.calc_hash(1, hashlib.sha1(), address, address+size)
        elif argv[0] == "sha224":
            h = self.calc_hash(1, hashlib.sha224(), address, address+size)
        elif argv[0] == "sha256":
            h = self.calc_hash(1, hashlib.sha256(), address, address+size)
        elif argv[0] == "sha384":
            h = self.calc_hash(1, hashlib.sha384(), address, address+size)
        elif argv[0] == "sha512":
            h = self.calc_hash(1, hashlib.sha512(), address, address+size)
        else:
            try:
                crccheck = __import__("crccheck")
            except ImportError:
                msg = "Missing `crccheck` package for Python, install with: `pip install crccheck`."
                raise ImportWarning(msg)
            if argv[0] == "crc16":
                h = self.calc_hash(2, crccheck.crc.Crc16(), address, address+size)
            elif argv[0] == "crc32":
                h = self.calc_hash(2, crccheck.crc.Crc32(), address, address+size)
            elif argv[0] == "crc64":
                h = self.calc_hash(2, crccheck.crc.Crc64(), address, address+size)

        if h is None:
            return

        gef_print("{:s} ({:d}-bit)".format(h, len(h)*4))
        return


@register_command
class ExecNextCommand(GenericCommand):
    """Execute until next address. This command is used for rep prefix."""
    _cmdline_ = "exec-next"
    _syntax_ = "{:s}".format(_cmdline_)
    _category_ = "Debugging Support"

    @only_if_gdb_running
    def do_invoke(self, argv):
        if is_arm32() or is_arm64():
            next_addr = gdb_get_nth_next_instruction_address(current_arch.pc, 1)
        else:
            next_addr = gdb_get_nth_next_instruction_address(current_arch.pc, 2)
        # `until` command has a bug(?) because sometimes fail. we use `tbreak` and `continue` instead of `until`.
        gdb.execute("tbreak *{:#x}".format(next_addr))
        gdb.execute("continue")
        return


@register_command
class ExecUntilCommand(GenericCommand):
    """Execute until next call/jmp/syscall/ret/mem-access/specific-keyword instruction."""
    _cmdline_ = "exec-until"
    _syntax_ = "{:s} [-h] call|jmp|syscall|ret|memaccess|keyword|cond [ARGS] [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} call # execute until call instruction\n".format(_cmdline_)
    _example_ += "{:s} jmp # execute until jmp instruction\n".format(_cmdline_)
    _example_ += "{:s} syscall # execute until syscall instruction\n".format(_cmdline_)
    _example_ += "{:s} ret # execute until ret instruction\n".format(_cmdline_)
    _example_ += "{:s} memaccess # execute until '[' is included by the instruction\n".format(_cmdline_)
    _example_ += "{:s} keyword \"call +r[ab]x\" # execute until specific keyword (regex)\n".format(_cmdline_)
    _example_ += "{:s} cond \"$rax==0xdeadbeef && $rbx==0xcafebabe\" # execute until specific condition is filled\n".format(_cmdline_)
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"

    def __init__(self, *args, **kwargs):
        super().__init__(prefix=True, complete=gdb.COMPLETE_NONE)
        return

    def close_stdout_stderr(self):
        self.stdout = 1
        self.stdout_bak = os.dup(self.stdout)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stdout)
        f.close()

        self.stderr = 2
        self.stderr_bak = os.dup(self.stderr)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stderr)
        f.close()
        return

    def revert_stdout_stderr(self):
        os.dup2(self.stdout_bak, self.stdout)
        os.close(self.stdout_bak)
        os.dup2(self.stderr_bak, self.stderr)
        os.close(self.stderr_bak)
        return

    def force_write_stdout(self, msg):
        open("/proc/self/fd/0", "wb").write(msg)
        return

    def is_target_insn(self, insn):
        if self.mode == "call":
            return current_arch.is_call(insn)
        elif self.mode == "jmp":
            return current_arch.is_jump(insn)
        elif self.mode == "indirect-branch":
            if current_arch.is_call(insn) or current_arch.is_jump(insn):
                if "[" in str(insn):
                    return True
                for reg in current_arch.gpr_registers:
                    if reg.replace("$", "") in str(insn):
                        return True
            return False
        elif self.mode == "syscall":
            return current_arch.is_syscall(insn)
        elif self.mode == "ret":
            return current_arch.is_ret(insn)
        elif self.mode == "memaccess":
            return "[" in str(insn)
        elif self.mode == "keyword":
            for k in self.keyword:
                if re.search(k, str(insn)):
                    return True
            return False
        elif self.mode == "cond":
            try:
                v = gdb.parse_and_eval(self.condition)
            except gdb.error:
                return False
            if not v in [0x0, 0x1]:
                self.err = "condition result should be True or False"
                return True
            if v:
                return True
        return False

    def get_breakpoint_list(self):
        lines = gdb.execute("info breakpoints", to_string=True).splitlines()
        if lines[0] == 'No breakpoints or watchpoints.':
            return []

        enable_idx = lines[0].index("Enb")
        addr_idx = lines[0].index("Address")

        bp_list = []
        for line in lines[1:]:
            try:
                if line[0] == "\t":
                    continue
                enable = line[enable_idx]
                addr = int(line[addr_idx:].split()[0], 16)
                if enable == 'y':
                    bp_list.append(addr)
            except:
                pass
        # breakpoint with condition is unsupported
        return bp_list

    def exec_next(self):
        bp_list = self.get_breakpoint_list()
        gef_on_stop_unhook(hook_stop_handler)
        self.close_stdout_stderr()
        self.err = None

        prev_addr = -1
        try:
            count = 0
            while True:
                # progress
                if not self.print_insn and count % 100 == 0:
                    self.force_write_stdout([b"\r|", b"\r/", b"\r-", b"\r\\"][count//100 % 4])

                # backup
                prev_prev_addr = prev_addr
                prev_addr = current_arch.pc

                # execute 1 instruction
                insn = gef_current_instruction(current_arch.pc)
                if self.skip_lib and "@plt>" in str(insn):
                    gdb.execute("nexti")
                else:
                    gdb.execute("stepi")

                # check breakpoint
                insn = gef_current_instruction(current_arch.pc)
                if current_arch.pc in bp_list:
                    break

                # $pc is not changed
                if prev_prev_addr == prev_addr == current_arch.pc: # for faster, repeat insn is skip
                    # infinity self loop
                    if current_arch.is_call(insn) or current_arch.is_jump(insn) or current_arch.is_ret(insn):
                        self.err = "Detected infinity loop prev_addr"
                        break
                    # maybe rep prefix
                    gdb.execute("exec-next")
                    # recheck
                    if prev_prev_addr == prev_addr == current_arch.pc:
                        self.err = "Detected infinity loop prev_addr"
                        break
                    insn = gef_current_instruction(current_arch.pc)

                if self.print_insn:
                    self.force_write_stdout((str(insn) + "\n").encode())

                # found and break
                if current_arch.pc not in self.filter:
                    if self.is_target_insn(insn):
                        if not self.print_insn:
                            self.force_write_stdout(b"\r \r")
                        break

                count += 1

        except KeyboardInterrupt:
            pass

        except:
            if is_alive():
                exc_type, exc_value, exc_traceback = sys.exc_info()
                self.err = exc_value
            else:
                pass

        finally:
            self.revert_stdout_stderr() # anytime needed
            gef_on_stop_hook(hook_stop_handler) # anytime needed
            if self.err:
                err(self.err)
            else:
                gdb.execute("context")
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        if "-h" in argv:
            self.usage()
            return

        self.print_insn = False
        if "--print-insn" in argv:
            argv.remove("--print-insn")
            self.print_insn = True

        self.skip_lib = False
        if "--skip-lib" in argv:
            argv.remove("--skip-lib")
            self.skip_lib = True

        self.filter = []
        while "-v" in argv:
            idx = argv.index("-v")
            filter_address = int(argv[idx + 1], 16)
            self.filter.append(filter_address)
            argv = argv[:idx] + argv[idx+2:]

        if argv:
            self.usage()
            return

        self.exec_next()
        return


@register_command
class ExecUntilCallCommand(ExecUntilCommand):
    """Execute until next call instruction (alias: next-call)."""
    _cmdline_ = "exec-until call"
    _syntax_ = "{:s} [-h] [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "{:s} # execute until call instruction\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"
    _aliases_ = ["next-call",]
    _repeat_ = True

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        self.mode = "call"
        return


@register_command
class ExecUntilJumpCommand(ExecUntilCommand):
    """Execute until next jmp instruction (alias: next-jmp)."""
    _cmdline_ = "exec-until jmp"
    _syntax_ = "{:s} [-h] [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "{:s} # execute until jmp instruction\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"
    _aliases_ = ["next-jmp",]
    _repeat_ = True

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        self.mode = "jmp"
        return


@register_command
class ExecUntilIndirectBranchCommand(ExecUntilCommand):
    """Execute until next indirect call/jmp instruction (x86/x64 only) (alias: next-indirect-branch)."""
    _cmdline_ = "exec-until indirect-branch"
    _syntax_ = "{:s} [-h] [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "{:s} # execute until indirect branch instruction\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"
    _aliases_ = ["next-indirect-branch",]
    _repeat_ = True

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        self.mode = "indirect-branch"
        return

    @only_if_gdb_running
    @only_if_x86_32_64
    def do_invoke(self, argv):
        if "-h" in argv:
            self.usage()
            return

        self.print_insn = False
        if "--print-insn" in argv:
            argv.remove("--print-insn")
            self.print_insn = True

        self.skip_lib = False
        if "--skip-lib" in argv:
            argv.remove("--skip-lib")
            self.skip_lib = True

        self.filter = []
        while "-v" in argv:
            idx = argv.index("-v")
            filter_address = int(argv[idx + 1], 16)
            self.filter.append(filter_address)
            argv = argv[:idx] + argv[idx+2:]

        if argv:
            self.usage()
            return

        self.exec_next()
        return


@register_command
class ExecUntilSyscallCommand(ExecUntilCommand):
    """Execute until next syscall instruction (alias: next-syscall)."""
    _cmdline_ = "exec-until syscall"
    _syntax_ = "{:s} [-h] [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "{:s} # execute until syscall instruction\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"
    _aliases_ = ["next-syscall",]
    _repeat_ = True

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        self.mode = "syscall"
        return


@register_command
class ExecUntilRetCommand(ExecUntilCommand):
    """Execute until next ret instruction (alias: next-ret)."""
    _cmdline_ = "exec-until ret"
    _syntax_ = "{:s} [-h] [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "{:s} # execute until ret instruction\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"
    _aliases_ = ["next-ret",]
    _repeat_ = True

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        self.mode = "ret"
        return


@register_command
class ExecUntilMemaccessCommand(ExecUntilCommand):
    """Execute until next mem-access instruction (alias: next-mem)."""
    _cmdline_ = "exec-until memaccess"
    _syntax_ = "{:s} [-h] [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "{:s} # execute until '[' is included by the instruction\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"
    _aliases_ = ["next-mem",]
    _repeat_ = True

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        self.mode = "memaccess"
        return


@register_command
class ExecUntilKeywordReCommand(ExecUntilCommand):
    """Execute until specific keyword instruction (alias: next-keyword)."""
    _cmdline_ = "exec-until keyword"
    _syntax_ = "{:s} [-h] KEYWORD [KEYWORD ...] [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "\n"
    _example_ += '{:s} "call +r[ab]x" # execute until specific keyword (regex)\n'.format(_cmdline_)
    _example_ += '{:s} "(push|pop) +(r[a-d]x|r[ds]i|r[sb]p|r[89]|r1[0-5])" # another exsample\n'.format(_cmdline_)
    _example_ += '{:s} "mov +rax, QWORD PTR \\\\[" # another exsample (need double escape if use)\n'.format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"
    _aliases_ = ["next-keyword",]
    _repeat_ = True

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        self.mode = "keyword"
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        if "-h" in argv:
            self.usage()
            return

        self.print_insn = False
        if "--print-insn" in argv:
            argv.remove("--print-insn")
            self.print_insn = True

        self.skip_lib = False
        if "--skip-lib" in argv:
            argv.remove("--skip-lib")
            self.skip_lib = True

        self.filter = []
        while "-v" in argv:
            idx = argv.index("-v")
            filter_address = int(argv[idx + 1], 16)
            self.filter.append(filter_address)
            argv = argv[:idx] + argv[idx+2:]

        if len(argv) == 0:
            self.usage()
            return

        self.keyword = argv
        self.exec_next()
        return


@register_command
class ExecUntilCondCommand(ExecUntilCommand):
    """Execute until specific condition is filled (alias: next-cond)."""
    _cmdline_ = "exec-until cond"
    _syntax_ = "{:s} [-h] CONDITION [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "\n"
    _example_ += '{:s} "$rax==0xdeadbeef && $rbx==0xcafebabe" # execute until specific condition is filled\n'.format(_cmdline_)
    _example_ += '{:s} "$rax==0x123 && *(long*)$rbx==0x4" # multiple condition and memory access is supported\n'.format(_cmdline_)
    _example_ += '{:s} "$ALL_REG==0x1234" # is replaced with a comparison for all registers. ex: `($rax==0x1234||$rbx==0x1234||...)`\n'.format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"
    _aliases_ = ["next-cond",]
    _repeat_ = True

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        self.mode = "cond"
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        if "-h" in argv:
            self.usage()
            return

        self.print_insn = False
        if "--print-insn" in argv:
            argv.remove("--print-insn")
            self.print_insn = True

        self.skip_lib = False
        if "--skip-lib" in argv:
            argv.remove("--skip-lib")
            self.skip_lib = True

        self.filter = []
        while "-v" in argv:
            idx = argv.index("-v")
            filter_address = int(argv[idx + 1], 16)
            self.filter.append(filter_address)
            argv = argv[:idx] + argv[idx+2:]

        if len(argv) == 0:
            self.usage()
            return

        condition = argv[0]
        if re.search(r"[^><!=]=[^=]", condition):
            err("Should not use `=` since it will be replace register/memory value. Use `==`.")
            return

        match = re.search(r"\$ALL_REG==(\w+)", condition)
        if match:
            value = match.groups()[0]
            replace_cond = []
            if hasattr(current_arch, "gpr_registers"):
                regs = current_arch.gpr_registers
            else:
                regs = current_arch.all_registers
                if hasattr(current_arch, "flag_register"):
                    if current_arch.flag_register in regs:
                        regs.remove(current_arch.flag_register)
            for regname in regs:
                replace_cond.append("{:s}=={:s}".format(regname, value))
            replace_string = "(" + "||".join(replace_cond) + ")"
            condition = re.sub(r"\$ALL_REG==(\w+)", replace_string, condition)

        info("Condition: {:s}".format(condition))
        self.condition = condition
        self.exec_next()
        return


class CallUsermodehelperSetupBreakpoint(gdb.Breakpoint):
    """Create a breakpoint to print argv information at call_usermodehelper_setup"""
    def __init__(self, loc):
        super().__init__("*{:#x}".format(loc), gdb.BP_BREAKPOINT, internal=False)
        return

    def stop(self):
        ptr1, addr1 = current_arch.get_ith_parameter(0)
        ptr2, addr2 = current_arch.get_ith_parameter(1)
        path = read_cstring_from_memory(addr1)
        argv = []
        while True:
            string_addr = read_int_from_memory(addr2)
            if string_addr == 0:
                break
            string = read_cstring_from_memory(string_addr)
            argv.append("'{:s}'".format(string))
            addr2 += current_arch.ptrsize
        gef_print("{:s}: {:#x} -> '{:s}'".format(ptr1, addr1, path))
        gef_print("{:s}: {:#x} -> [{:s}]".format(ptr2, addr2, ','.join(argv)))
        return False # continue


@register_command
class UsermodehelperHunterCommand(GenericCommand):
    """Collects and displays information that is executed by call_usermodehelper_setup"""
    _cmdline_ = "usermodehelper-hunter"
    _syntax_ = "{:s} [-h]".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        return

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        info("Resolving the function addresses")
        addr = get_ksymaddr("call_usermodehelper_setup")
        if addr is None:
            err("Not found call_usermodehelper_setup")
            return
        CallUsermodehelperSetupBreakpoint(addr)
        info("Do `continue`. If failed, try `vmlinux-to-elf-apply`")
        return


class ThunkBreakpoint(gdb.Breakpoint):
    """Create a breakpoint to print caller address for thunk function"""
    def __init__(self, loc, sym, reg, maps):
        super().__init__("*{:#x}".format(loc), gdb.BP_BREAKPOINT, internal=False)
        self.loc = loc
        self.sym = sym
        self.reg = reg
        self.maps = maps
        self.seen = []
        return

    def search_perm(self, target):
        for m in self.maps:
            addr, size, perm = m
            if addr <= target < addr+size:
                return perm
        return "?"

    def stop(self):
        return_address = gdb.selected_frame().older().pc()
        caller_address = gdb_get_nth_previous_instruction_address(return_address, 1)
        target_address = get_register(self.reg)

        # duplicate, check
        if (caller_address, target_address) in self.seen:
            return False # continue
        else:
            self.seen.append((caller_address, target_address))

        # get caller address, symbol
        caller_symbol = get_symbol_string(caller_address, nosymbol_string=" <NO_SYMBOL>")

        # get callee address, symbol
        target_symbol = get_symbol_string(target_address, nosymbol_string=" <NO_SYMBOL>")

        # print information
        fmt = "{:#x}{:s} -> {:#x} <{:s}> -> {:#x}{:s}"
        info(fmt.format(caller_address, caller_symbol, self.loc, self.sym, target_address, target_symbol))
        # print preferred register condition
        for reg in current_arch.gpr_registers:
            reg_value = get_register(reg)
            try:
                mem_value = read_int_from_memory(reg_value)
            except:
                continue
            if mem_value == target_address:
                perm = self.search_perm(reg_value)
                reg_value_symbol = get_symbol_string(reg_value, nosymbol_string=" <NO_SYMBOL>")
                mem_value_symbol = get_symbol_string(mem_value, nosymbol_string=" <NO_SYMBOL>")
                fmt = "    {:s}: {:#x}{:s} ({:s})  ->  {:#x}{:s}"
                info(fmt.format(reg, reg_value, reg_value_symbol, perm, mem_value, mem_value_symbol))
        return False # continue


@register_command
class ThunkHunterCommand(GenericCommand):
    """Collects and displays the thunk addresses that are called automatically.
    If this address comes from RW area, this is useful for getting RIP.(x64/x86 only)"""
    _cmdline_ = "thunk-hunter"
    _syntax_ = "{:s} [-h]".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_NONE)
        return

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_x86_32_64
    def do_invoke(self, argv):
        self.dont_repeat()

        info("Wait for memory scan")
        maps = KernelbaseCommand.get_maps() # [vaddr, size, perm]
        info("Resolving thunk function addresses")
        for reg in current_arch.gpr_registers:
            sym = "__x86_indirect_thunk_{}".format(reg.replace("$", ""))
            addr = get_ksymaddr(sym)
            if addr is None:
                continue
            ThunkBreakpoint(addr, sym, reg, maps)
        info("Do `continue`. If NO_SYMBOL is in the result, try `vmlinux-to-elf-apply`")
        return


@register_command
class UefiOvmfInfoCommand(GenericCommand):
    """Print UEFI OVMF info.
    https://github.com/tianocore/tianocore.github.io/wiki/OVMF-Boot-Overview
    https://github.com/tianocore/edk2/blob/master/OvmfPkg/Sec/SecMain.c
    https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Core/Pei/PeiMain/PeiMain.c
    https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Core/Dxe/DxeMain/DxeMain.c
    https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Universal/BdsDxe/BdsEntry.c
    https://uefi.org/sites/default/files/resources/UEFI_Spec_2_8_final.pdf"""
    _cmdline_ = "uefi-ovmf-info"
    _syntax_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def pre_load(self):
        try:
            __import__("crccheck")
        except ImportError:
            msg = "Missing `crccheck` package for Python, install with: `pip install crccheck`."
            raise ImportWarning(msg)
        return

    def check_crc32(self, addr):
        size = u32(read_memory(addr + 0xc, 0x4))
        if size <= 0 or size > 0x1000:
            return False
        crc = u64(read_memory(addr + 0x10, 0x8))
        if crc == 0:
            return False
        data = read_memory(addr, 0x10)
        data += p64(0x0) # crc is zero when calculate
        data += read_memory(addr + 0x18, size - 0x18)
        crccheck = sys.modules["crccheck"]
        calculated_crc = crccheck.crc.Crc32().calc(data)
        return calculated_crc == crc

    def read_structure(self, addr, structure):
        d = {}
        d["__addr"] = addr
        for size, name in structure:
            unpack = u32 if size == 4 else u64
            d[name] = unpack(read_memory(addr, size))
            addr += size
        return d

    @lru_cache()
    def get_gPs(self):
        result = gdb.execute("search-pattern 'PEI SERV' --disable-utf16", to_string=True) # EFI_TABLE_HEADER.Signature
        result = filter(lambda x: "->" in x, result.splitlines())
        result = [int(x.split()[0], 16) for x in result]
        for addr in result[::-1]: # Higher address seems more likely
            return addr
        return None

    def read_gPs(self):
        addr = self.get_gPs()
        if addr is None:
            return None
        structure = [
            [8, "Hdr.Signature"],
            [4, "Hdr.Revision"],
            [4, "Hdr.HeaderSize"],
            [4, "Hdr.CRC32"],
            [4, "Hdr.Reserved"],
            [8, "InstallPpi"],
            [8, "ReInstallPpi"],
            [8, "LocatePpi"],
            [8, "NotifyPpi"],
            [8, "GetBootMode"],
            [8, "SetBootMode"],
            [8, "GetHobList"],
            [8, "CreateHob"],
            [8, "FfsFindNextVolume"],
            [8, "FfsFindNextFile"],
            [8, "FfsFindSectionData"],
            [8, "InstallPeiMemory"],
            [8, "AllocatePages"],
            [8, "AllocatePool"],
            [8, "CopyMem"],
            [8, "SetMem"],
            [8, "ReportStatusCode"],
            [8, "ResetSystem"],
            [8, "CpuIo"],
            [8, "PciCfg"],
            [8, "FfsFindFileByName"],
            [8, "FfsGetFileInfo"],
            [8, "FfsGetVolumeInfo"],
            [8, "RegisterForShadow"],
            [8, "FindSectionData3"],
            [8, "FfsGetFileInfo2"],
            [8, "ResetSystem2"],
            [8, "FreePages"],
        ]
        return self.read_structure(addr, structure)

    def dump_gPs(self):
        self.gPs = self.read_gPs()
        if self.gPs is None:
            err("gPs is not found")
            return
        info("gPs: {:#x}".format(self.gPs["__addr"]))
        for k, v in self.gPs.items():
            if k.startswith("__"):
                continue
            gef_print("  {:40s}{:#x}".format(k+":",v))
        return

    @lru_cache()
    def get_mBootServices(self):
        result = gdb.execute("search-pattern BOOTSERV --disable-utf16", to_string=True) # EFI_TABLE_HEADER.Signature
        result = filter(lambda x: "->" in x, result.splitlines())
        result = [int(x.split()[0], 16) for x in result]
        for addr in result[::-1]: # Higher address seems more likely
            if self.check_crc32(addr):
                return addr
        return None

    def read_mBootServices(self):
        addr = self.get_mBootServices()
        if addr is None:
            return None
        structure = [
            [8, "Hdr.Signature"],
            [4, "Hdr.Revision"],
            [4, "Hdr.HeaderSize"],
            [4, "Hdr.CRC32"],
            [4, "Hdr.Reserved"],
            [8, "RaiseTPL"],
            [8, "RestoreTPL"],
            [8, "AllocatePages"],
            [8, "FreePages"],
            [8, "GetMemoryMap"],
            [8, "AllocatePool"],
            [8, "FreePool"],
            [8, "CreateEvent"],
            [8, "SetTimer"],
            [8, "WaitForEvent"],
            [8, "SignalEvent"],
            [8, "CloseEvent"],
            [8, "CheckEvent"],
            [8, "InstallProtocolInterface"],
            [8, "ReinstallProtocolInterface"],
            [8, "UninstallProtocolInterface"],
            [8, "HandleProtocol"],
            [8, "Reserved"],
            [8, "RegisterProtocolNotify"],
            [8, "LocateHandle"],
            [8, "LocateDevicePath"],
            [8, "InstallConfigurationTable"],
            [8, "LoadImage"],
            [8, "StartImage"],
            [8, "Exit"],
            [8, "UnloadImage"],
            [8, "ExitBootServices"],
            [8, "GetNextMonotonicCount"],
            [8, "Stall"],
            [8, "SetWatchdogTimer"],
            [8, "ConnectController"],
            [8, "DisconnectController"],
            [8, "OpenProtocol"],
            [8, "CloseProtocol"],
            [8, "OpenProtocolInformation"],
            [8, "ProtocolsPerHandle"],
            [8, "LocateHandleBuffer"],
            [8, "LocateProtocol"],
            [8, "InstallMultipleProtocolInterfaces"],
            [8, "UninstallMultipleProtocolInterfaces"],
            [8, "CalculateCrc32"],
            [8, "CopyMem"],
            [8, "SetMem"],
            [8, "CreateEventEx"],
        ]
        return self.read_structure(addr, structure)

    def dump_mBootServices(self):
        self.mBootServices = self.read_mBootServices()
        if self.mBootServices is None:
            err("mBootServices is not found")
            return
        info("mBootServices: {:#x}".format(self.mBootServices["__addr"]))
        for k, v in self.mBootServices.items():
            if k.startswith("__"):
                continue
            gef_print("  {:40s}{:#x}".format(k+":",v))
        return

    @lru_cache()
    def get_mDxeServices(self):
        # fastpath maybe mDxeServices is next to mBootServices
        if self.mBootServices:
            addr = self.mBootServices["__addr"] + self.mBootServices["Hdr.HeaderSize"]
            while addr % 0x10:
                addr += 1
            if read_memory(addr, 8) == b"DXE_SERV" and self.check_crc32(addr):
                return addr

        # slowpath
        result = gdb.execute("search-pattern DXE_SERV --disable-utf16", to_string=True) # EFI_TABLE_HEADER.Signature
        result = filter(lambda x: "->" in x, result.splitlines())
        result = [int(x.split()[0], 16) for x in result]
        for addr in result[::-1]: # Higher address seems more likely
            if self.check_crc32(addr):
                return addr
        return None

    def read_mDxeServices(self):
        addr = self.get_mDxeServices()
        if addr is None:
            return None
        structure = [
            [8, "Hdr.Signature"],
            [4, "Hdr.Revision"],
            [4, "Hdr.HeaderSize"],
            [4, "Hdr.CRC32"],
            [4, "Hdr.Reserved"],
            [8, "AddMemorySpace"],
            [8, "AllocateMemorySpace"],
            [8, "FreeMemorySpace"],
            [8, "RemoveMemorySpace"],
            [8, "GetMemorySpaceDescriptor"],
            [8, "SetMemorySpaceAttributes"],
            [8, "GetMemorySpaceMap"],
            [8, "AddIoSpace"],
            [8, "AllocateIoSpace"],
            [8, "FreeIoSpace"],
            [8, "RemoveIoSpace"],
            [8, "GetIoSpaceDescriptor"],
            [8, "GetIoSpaceMap"],
            [8, "Dispatch"],
            [8, "Schedule"],
            [8, "Trust"],
            [8, "ProcessFirmwareVolume"],
            [8, "SetMemorySpaceCapabilities"],
        ]
        return self.read_structure(addr, structure)

    def dump_mDxeServices(self):
        self.mDxeServices = self.read_mDxeServices()
        if self.mDxeServices is None:
            err("mDxeServices is not found")
            return
        info("mDxeServices: {:#x}".format(self.mDxeServices["__addr"]))
        for k, v in self.mDxeServices.items():
            if k.startswith("__"):
                continue
            gef_print("  {:40s}{:#x}".format(k+":",v))
        return

    @lru_cache()
    def get_mEfiSystemTable(self):
        result = gdb.execute("search-pattern 'IBI SYST' --disable-utf16", to_string=True) # EFI_TABLE_HEADER.Signature
        result = filter(lambda x: "->" in x, result.splitlines())
        result = [int(x.split()[0], 16) for x in result]
        for addr in result[::-1]: # Higher address seems more likely
            if self.check_crc32(addr):
                return addr
        return None

    def read_mEfiSystemTable(self):
        addr = self.get_mEfiSystemTable()
        if addr is None:
            return None
        structure = [
            [8, "Hdr.Signature"],
            [4, "Hdr.Revision"],
            [4, "Hdr.HeaderSize"],
            [4, "Hdr.CRC32"],
            [4, "Hdr.Reserved"],
            [8, "FirmwareVendor"],
            [8, "FirmwareRevision"],
            [8, "ConsoleInHandle"],
            [8, "ConIn"],
            [8, "ConsoleOutHandle"],
            [8, "ConOut"],
            [8, "StandardErrorHandle"],
            [8, "StdErr"],
            [8, "RuntimeServices"],
            [8, "BootServices"],
            [8, "NumberOfConfigurationTableEntries"],
            [8, "ConfigurationTable"],
        ]
        return self.read_structure(addr, structure)

    def dump_mEfiSystemTable(self):
        self.mEfiSystemTable = self.read_mEfiSystemTable()
        if self.mEfiSystemTable is None:
            err("*gDxeCoreST(=mEfiSystemTable) is not found")
            return
        info("*gDxeCoreST(=mEfiSystemTable): {:#x}".format(self.mEfiSystemTable["__addr"]))
        for k, v in self.mEfiSystemTable.items():
            if k.startswith("__"):
                continue
            gef_print("  {:40s}{:#x}".format(k+":",v))
        return

    @lru_cache()
    def get_mEfiRuntimeServicesTable(self):
        result = gdb.execute("search-pattern RUNTSERV --disable-utf16", to_string=True) # EFI_TABLE_HEADER.Signature
        result = filter(lambda x: "->" in x, result.splitlines())
        result = [int(x.split()[0], 16) for x in result]
        for addr in result[::-1]: # Higher address seems more likely
            if self.check_crc32(addr):
                return addr
        return None

    def read_mEfiRuntimeServicesTable(self):
        addr = self.get_mEfiRuntimeServicesTable()
        if addr is None:
            return None
        structure = [
            [8, "Hdr.Signature"],
            [4, "Hdr.Revision"],
            [4, "Hdr.HeaderSize"],
            [4, "Hdr.CRC32"],
            [4, "Hdr.Reserved"],
            [8, "GetTime"],
            [8, "SetTime"],
            [8, "GetWakeupTime"],
            [8, "SetWakeupTime"],
            [8, "SetVirtualAddressMap"],
            [8, "ConvertPointer"],
            [8, "GetVariable"],
            [8, "GetNextVariableName"],
            [8, "SetVariable"],
            [8, "GetNextHighMonotonicCount"],
            [8, "ResetSystem"],
            [8, "UpdateCapsule"],
            [8, "QueryCapsuleCapabilities"],
            [8, "QueryVariableInfo"],
        ]
        return self.read_structure(addr, structure)

    def dump_mEfiRuntimeServicesTable(self):
        self.mEfiRuntimeServicesTable = self.read_mEfiRuntimeServicesTable()
        if self.mEfiRuntimeServicesTable is None:
            err("*gDxeCoreRT(=mEfiRuntimeServicesTable) is not found")
            return
        info("*gDxeCoreRT(=mEfiRuntimeServicesTable): {:#x}".format(self.mEfiRuntimeServicesTable["__addr"]))
        for k, v in self.mEfiRuntimeServicesTable.items():
            if k.startswith("__"):
                continue
            gef_print("  {:40s}{:#x}".format(k+":",v))
        return

    @lru_cache()
    def get_gMemoryMap(self):
        # gMemoryMap is just above mDxeServices
        if not self.mDxeServices:
            return None
        addr = self.mDxeServices["__addr"]
        while addr % 0x10:
            addr -= 1
        while self.mDxeServices["__addr"] - 0x1000 < addr:
            try:
                a = u64(read_memory(addr, 8))
                b = u64(read_memory(a + 8, 8))
                asig = u64(read_memory(a - 8, 8))
                c = u64(read_memory(addr + 8, 8))
                d = u64(read_memory(c, 8))
                csig = u64(read_memory(c - 8, 8))
                if addr == b == d and asig == csig == u32(b"mmap"):
                    return addr
            except:
                pass
            addr -= 0x10
        return None

    def read_gMemoryMap(self):
        addr = self.get_gMemoryMap()
        if addr is None:
            return None
        structure = [
            [8, "ForwardLink"],
            [8, "BackLink"],
        ]
        return self.read_structure(addr, structure)

    def read_Entry(self, addr):
        structure = [
            [8, "Signature"],
            [8, "Link.ForwardLink"],
            [8, "Link.BackLink"],
            [4, "FromPages"], # with pad
            [4, "Type"],
            [8, "Start"],
            [8, "End"],
            [8, "VirtualStart"],
            [8, "Attribute"],
        ]
        offset_of_link = 8
        return self.read_structure(addr - offset_of_link, structure)

    def dump_memory_map(self):
        self.gMemoryMap = self.read_gMemoryMap()
        if self.gMemoryMap is None:
            err("gMemoryMap is not found")
            return
        info("gMemoryMap: {:#x}".format(self.gMemoryMap["__addr"]))

        type_names = [
            "EfiReservedMemoryType",
            "EfiLoaderCode",
            "EfiLoaderData",
            "EfiBootServicesCode",
            "EfiBootServicesData",
            "EfiRuntimeServicesCode",
            "EfiRuntimeServicesData",
            "EfiConventionalMemory",
            "EfiUnusableMemory",
            "EfiACPIReclaimMemory",
            "EfiACPIMemoryNVS",
            "EfiMemoryMappedIO",
            "EfiMemoryMappedIOPortSpace",
            "EfiPalCode",
            "EfiPersistentMemory",
            "EfiMaxMemoryType",
        ]

        att_list = {
            0x1: "UC",
            0x2: "WC",
            0x4: "WT",
            0x8: "WB",
            0x10: "UCE",
            0x1000: "WP",
            0x2000: "RP",
            0x4000: "XP",
            0x8000: "NV",
            0x10000: "MORE_RELIABLE",
            0x20000: "RO",
            0x40000: "SPM",
            0x80000: "CPU_CRYPTO",
            0x8000000000000000: "RUNTIME"
        }

        def att2str(att):
            string = []
            for k, v in att_list.items():
                if k & att:
                    string.append(v)
            return ",".join(string)

        fmt = "{:21s} {:10s} {:10s} {:30s} {:s}"
        legend = ["Paddr Start-End", "Vaddr", "Size", "Type:TypeName", "Attribute"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))

        current = self.gMemoryMap["ForwardLink"]
        while current != self.gMemoryMap["__addr"]:
            entry = self.read_Entry(current)

            paddr_s = entry["Start"]
            paddr_e = entry["End"] + 1
            vaddr = entry["VirtualStart"]
            size = paddr_e - paddr_s
            typ = entry["Type"]
            memtype = type_names[entry["Type"]]
            att = entry["Attribute"]
            att_s = att2str(att)
            fmt = "{:#010x}-{:#010x} {:#010x} {:#010x} {:#x}:{:26s} {:#x}:[{:s}]"
            gef_print(fmt.format(paddr_s, paddr_e, vaddr, size, typ, memtype, att, att_s))

            if entry["Signature"] != u32(b"mmap"):
                gef_print("Signature does not match. Corrupted?")
                break
            current = entry["Link.ForwardLink"]

        gef_print("Legend for attribute")
        gef_print("UC: It supports being configured as Un-Cacheable")
        gef_print("WC: It supports being configured as Write-Combining")
        gef_print("WT: It supports being configured as Write-Through")
        gef_print("WB: It supports being configured as Write-Back")
        gef_print("UCE: It supports being configured as Un-Cacheable and Exportable")
        gef_print("WP: It supports being configured as Write-Protected")
        gef_print("RP: It supports being configured as Read-Protected")
        gef_print("XP: It supports being configured as eXecute-Protected")
        gef_print("NV: It refers to persistent memory(Non-Volatile-Memory)")
        gef_print("MORE_RELIABLE: it has higher reliability than other")
        gef_print("RO: It supports being configured as Read-Only")
        gef_print("SP: Specific-Purpose memory")
        gef_print("CPU_CRYPTO: Encrypted and protected by CPU function")
        gef_print("RUNTIME: It will be mapped by OS when SetVirtualAddressMap() is called")
        return

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_x86_32_64
    def do_invoke(self, argv):
        self.dont_repeat()
        gef_print(titlify("SEC (Security) phase variables"))
        gef_print("Unimplemented")
        gef_print(titlify("PEI (Pre EFI Initialization) phase variables"))
        self.dump_gPs()
        gef_print(titlify("DXE (Driver Exectuion Environment) phase variables"))
        self.dump_mBootServices()
        self.dump_mDxeServices()
        self.dump_mEfiSystemTable()
        self.dump_mEfiRuntimeServicesTable()
        gef_print(titlify("Memory map for UEFI"))
        self.dump_memory_map()
        gef_print(titlify("BDS (Boot Device Selection) phase variables"))
        gef_print("gBS: See `mBootServices` in the DXE phase")
        gef_print("gST: See `mEfiSystemTable` in the DXE phase")
        gef_print("gRT: See `mEfiRuntimeServicesTable` in the DXE phase")
        return


@register_command
class AddSymbolTemporaryCommand(GenericCommand):
    """Add symbol from command temporarily"""
    _cmdline_ = "add-symbol-temporary"
    _syntax_ = "{:s} FUNCTION_NAME ADDRESS".format(_cmdline_)
    _category_ = "Misc"

    @staticmethod
    def add_symbol_temp(function_info):
        try:
            gcc = which("gcc")
            objcopy = which("objcopy")
        except FileNotFoundError as e:
            err("{}".format(e))
            return

        cache = {}
        def create_blank_elf(text_base):
            if cache:
                open(cache["fname"], "wb").write(cache["data"])
                return cache["fname"]
            # create light ELF
            fd, fname = tempfile.mkstemp(dir="/tmp", suffix=".c")
            os.fdopen(fd, "w").write("int main() {}")
            os.system(f"{gcc} '{fname}' -no-pie -o '{fname}.debug'")
            os.unlink(f"{fname}")
            # delete unneeded section for faster
            os.system(f"{objcopy} --only-keep-debug '{fname}.debug'")
            os.system(f"{objcopy} --strip-all '{fname}.debug'")
            elf = get_elf_headers(f"{fname}.debug")
            for s in elf.shdrs:
                section_name = s.sh_name
                if section_name == "": # null, skip
                    continue
                if section_name == ".text": # .text is needed, don't remove
                    continue
                if section_name == ".interp": # broken if removed
                    continue
                if section_name == ".rela.dyn": # cannot removed
                    continue
                if section_name == ".dynamic": # cannot removed
                    continue
                if section_name == ".bss": # broken if removed
                    continue
                os.system(f"{objcopy} --remove-section='{section_name}' '{fname}.debug' 2>/dev/null")
            cache["fname"] = fname + ".debug"
            cache["data"] = open(cache["fname"], "rb").read()
            return cache["fname"]

        def apply_symbol(fname, cmd_string_arr, text_base):
            cmd_string = ' '.join(cmd_string_arr)
            os.system(f"{objcopy} {cmd_string} '{fname}'")
            gdb.execute(f"add-symbol-file {fname} {text_base:#x}", to_string=True)
            os.unlink(fname)
            return

        info("{:d} entries will be added".format(len(function_info)))

        if is_64bit():
            text_base = 0xffff000000000000
        else:
            text_base = 0x80000000

        cmd_string_arr = []
        fname = create_blank_elf(text_base)
        for i, (fn, fa, typ) in enumerate(function_info):
            # debug print
            if i > 1 and i % 10000 == 0:
                info("{:d} entries were processed".format(i))

            if typ in ["T", "t", "W", None]:
                type_flag = "function"
            else:
                type_flag = "object"
            if typ and typ in "abcdefghijklmnopqrstuvwxyz":
                global_flag = "local"
            else:
                global_flag = "global"

            if fa < text_base:
                # lower address needs not relative, use absolute
                cmd_string_arr.append(f"--add-symbol '{fn}'={fa:#x},{global_flag},{type_flag}")
            else:
                # higher address needs relative
                relative_addr = fa - text_base
                cmd_string_arr.append(f"--add-symbol '{fn}'=.text:{relative_addr:#x},{global_flag},{type_flag}")

            if i > 1 and i % 1000 == 0:
                # too long, so let's commit
                apply_symbol(fname, cmd_string_arr, text_base)
                # re-init
                fname = create_blank_elf(text_base)
                cmd_string_arr = []

        # commit remain
        if cmd_string_arr:
            apply_symbol(fname, cmd_string_arr, text_base)

        info("{:d} entries were processed".format(i+1))
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) != 2:
            self.usage()
            return

        try:
            function_name = argv[0]
            function_addr = int(gdb.parse_and_eval(argv[1]))
        except:
            self.usage()
            return

        if is_32bit() and function_addr > 0xffffffff:
            err("function address must be 0xffffffff or less")
            return
        if is_64bit() and function_addr > 0xffffffffffffffff:
            err("function address must be 0xffffffffffffffff or less")
            return

        function_info = []
        function_info.append((function_name, function_addr, None))
        self.add_symbol_temp(function_info)
        return


@register_command
class KsymaddrRemoteApplyCommand(GenericCommand):
    """Apply symbol from kallsyms in memory"""
    _cmdline_ = "ksymaddr-remote-apply"
    _syntax_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        info("Wait for memory scan")
        res = gdb.execute("ksymaddr-remote --print-all", to_string=True)
        function_info = []
        for entry in res.splitlines():
            r = re.findall(r"(0x\w+) (\w) (\w+)", entry)
            if not r:
                continue
            addr = int(r[0][0], 16)
            typ = r[0][1]
            func_name = r[0][2]
            if addr == 0:
                continue
            function_info.append((func_name, addr, typ))
        if len(function_info) > 0:
            AddSymbolTemporaryCommand.add_symbol_temp(function_info)
            info("Done. Try `p FUNCTION_NAME`")
        return


@register_command
class LinklistWalkCommand(GenericCommand):
    """Link list walk."""
    _cmdline_ = "linklist-walk"
    _syntax_ = "{:s} [-o OFFSET] ADDRESS".format(_cmdline_)
    _example_ = "{:s} 0xffff9c60800597e0 # walk list_head.next\n".format(_cmdline_)
    _example_ += "{:s} -o 8 0xffff9c60800597e0 # walk list_head.prev".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def walk_link_list(self, head, offset):
        current = head
        walkks = []
        seen = [current]
        idx = 1
        while True:
            try:
                flink = read_int_from_memory(current + offset)
            except:
                err("memory corrupted")
                return
            gef_print("[{:d}]   -> {:#x}".format(idx, flink))
            if flink == 0:
                break
            if flink == head:
                break
            if flink in seen[1:]:
                err("loop detected")
                break
            seen.append(current)
            current = flink
            idx += 1
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        try:
            offset = 0
            if "-o" in argv:
                idx = argv.index("-o")
                offset = int(argv[idx+1], 0)
                argv = argv[:idx] + argv[idx+2:]
            head = parse_address(''.join(argv))
        except:
            self.usage()
            return

        info("head addres: {:#x}".format(head))
        info("list offset: {:#x}".format(offset))
        self.walk_link_list(head, offset)
        return


@register_command
class PeekPointersCommand(GenericCommand):
    """Command to help find pointers belonging to other memory regions helpful in case
    of OOB Read when looking for specific pointers"""
    _cmdline_ = "peek-pointers"
    _syntax_ = "{:s} starting_address <object_name> <all>".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} 0x00007ffffffde000          # begin address of stack region\n".format(_cmdline_)
    _example_ += "{:s} 0x00007ffffffde000 vdso     # grep by `vdso`\n".format(_cmdline_)
    _example_ += "{:s} 0x00007ffffffde000 vdso all # show all found address".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        argc = len(argv)
        if argc not in (1, 2, 3):
            self.usage()
            return

        try:
            addr = lookup_address(int(argv[0], 16))
        except:
            self.usage()
            return
        if (addr.value % DEFAULT_PAGE_SIZE):
            err("<starting_address> must be aligned to a page")
            return
        if addr.section is None:
            err("{:#x} does not exist".format(addr.value))
            return

        unique = True if "all" not in argv else False
        vmmap = get_process_maps()

        if argc >= 2 :
            section_name = argv[1].lower()
            if section_name == "stack":
                sections = [(s.path, s.page_start, s.page_end) for s in vmmap if s.path == "[stack]"]
            elif section_name == "heap":
                sections = [(s.path, s.page_start, s.page_end) for s in vmmap if s.path == "[heap]"]
            elif section_name != "all":
                sections = [(s.path, s.page_start, s.page_end) for s in vmmap if section_name in s.path ]
            else:
                sections = [(s.path, s.page_start, s.page_end) for s in vmmap ]
        else:
            sections = [ (s.path, s.page_start, s.page_end) for s in vmmap ]

        data = read_memory(addr.section.page_start, addr.section.size)
        if current_arch.ptrsize == 8:
            data = [u64(data[i:i+8]) for i in range(0, len(data), 8)]
        else:
            data = [u32(data[i:i+4]) for i in range(0, len(data), 4)]

        for off, addr_value in enumerate(data):
            addr_v = lookup_address(addr_value)
            if not addr_v:
                continue

            for i, section in enumerate(sections):
                name, start_addr, end_addr = section
                if not (start_addr <= addr_value < end_addr):
                    continue
                sym = gdb_get_location_from_symbol(addr_value)
                sym = "<{:s}+{:04x}>".format(*sym) if sym else ''
                if name.startswith("/"):
                    name = os.path.basename(name)
                elif len(name)==0:
                    name = get_filename()
                addr_pos = addr.value + off * current_arch.ptrsize
                perm = str(addr_v.section.permission)
                ok("Found at {:#x} to {:#x} {:s} ('{:s}', perm: {:s})".format(addr_pos, addr_value, sym, name, perm))
                if unique:
                    del sections[i]
                break
        return


@register_command
class CurrentFrameStackCommand(GenericCommand):
    """Show the entire stack of the current frame."""
    _cmdline_ = "current-stack-frame"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}".format(_cmdline_)
    _category_ = "Show/Modify Memory"
    _aliases_ = ["stack", "full-stack",]

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        ptrsize = current_arch.ptrsize
        frame = gdb.selected_frame()

        if not frame.older():
            reason = frame.unwind_stop_reason()
            reason_str = gdb.frame_stop_reason_string( frame.unwind_stop_reason() )
            warn("Cannot determine frame boundary, reason: {:s}".format(reason_str))
            return

        saved_ip = frame.older().pc()
        base_address_color = get_gef_setting("theme.dereference_base_address")
        stack_hi = int(frame.older().read_register("sp"))
        stack_lo = int(frame.read_register("sp"))
        should_stack_grow_down = get_gef_setting("context.grow_stack_down") == True
        results = []

        for offset, address in enumerate(range(stack_lo, stack_hi, ptrsize)):
            pprint_str = DereferenceCommand.pprint_dereferenced(stack_lo, offset)
            if dereference(address) == saved_ip:
                pprint_str += " " + Color.colorify("($savedip)", attrs="gray underline")
            results.append(pprint_str)

        if should_stack_grow_down:
            results.reverse()
            gef_print(titlify("Stack top (higher address)"))
        else:
            gef_print(titlify("Stack top (lower address)"))

        for res in results:
            gef_print(res)

        if should_stack_grow_down:
            gef_print(titlify("Stack bottom (lower address)"))
        else:
            gef_print(titlify("Stack bottom (higher address)"))
        return


@register_command
class XRefTelescopeCommand(SearchPatternCommand):
    """Recursively search for cross-references to a pattern in memory"""
    _cmdline_ = "xref-telescope"
    _syntax_ = "{:s} PATTERN [depth]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} AAAAAAAA\n".format(_cmdline_)
    _example_ += "{:s} 0x555555554000 15".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def xref_telescope_(self, pattern, depth, tree_heading):
        """Recursively search a pattern within the whole userland memory."""
        if depth <= 0:
            return

        if is_hex(pattern):
            if get_endian() == Elf.BIG_ENDIAN:
                pattern = "".join(["\\x"+pattern[i:i+2] for i in range(2, len(pattern), 2)])
            else:
                pattern = "".join(["\\x"+pattern[i:i+2] for i in range(len(pattern)-2, 0, -2)])

        locs = []
        for section in get_process_maps():
            if not section.permission & Permission.READ: continue
            if section.path == "[vvar]": continue

            start = section.page_start
            end = section.page_end

            locs += self.search_pattern_by_address(pattern, start, end)
        if tree_heading == "":
            gef_print(" .")
        for i, loc in enumerate(locs):
            addr_loc_start = lookup_address(loc[0])
            path = addr_loc_start.section.path
            perm = addr_loc_start.section.permission
            if i == len(locs) - 1:
                tree_suffix_pre = " +--"
                tree_suffix_post = "    "
            else:
                tree_suffix_pre = " +--"
                tree_suffix_post = " |  "

            gef_print('{} {:#x} {} {} "{}"'.format(tree_heading + tree_suffix_pre, loc[0], Color.blueify(path), perm, Color.pinkify(loc[2])))
            self.xref_telescope_(hex(loc[0]), depth - 1, tree_heading + tree_suffix_post)

    def xref_telescope(self, pattern, depth):
        self.xref_telescope_(pattern, depth, "")

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        argc = len(argv)
        if argc < 1:
            self.usage()
            return

        pattern = argv[0]
        try:
            depth = int(argv[1])
        except (IndexError, ValueError):
            depth = 3

        info("Recursively searching '{:s}' in memory".format(Color.yellowify(pattern)))
        self.xref_telescope(pattern, depth)
        return


@register_command
class BytearrayCommand(GenericCommand):
    """BytearrayCommand: Generate a bytearray to be compared with possible badchars.
    Function ported from mona.py"""
    _cmdline_ = "bytearray"
    _syntax_ = "{:s} [-b badchars] [-d]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} -b 414243 # exclude 41,42,43\n".format(_cmdline_)
    _example_ += "{:s} -b 41..49 # exclude 41,42,43,...,49\n".format(_cmdline_)
    _example_ += "{:s} -d # dump to ./bytearray.txt, ./bytearray.bin".format(_cmdline_)
    _category_ = "Misc"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        badchars = ""
        bytesperline = 32
        startval = 0
        endval = 255
        dump = False

        try:
            opts, args = getopt.getopt(argv, "b:cdh")
            for o, a in opts:
                if o == "-b":
                    badchars = a
                elif o == "-h":
                    self.usage()
                    return
                elif o == "-d":
                    dump = True
        except:
            self.usage()
            return

        badchars = self.cleanHex(badchars)

        try:
            # see if we need to expand ..
            bpos = 0
            newbadchars = ""
            while bpos < len(badchars):
                curchar = badchars[bpos] + badchars[bpos+1]
                if curchar == "..":
                    pos = bpos
                    if pos > 1 and pos <= len(badchars)-4:
                        # get byte before and after ..
                        bytebefore = badchars[pos-2] + badchars[pos-1]
                        byteafter = badchars[pos+2] + badchars[pos+3]
                        bbefore = int(bytebefore, 16)
                        bafter = int(byteafter, 16)
                        if bbefore > bafter:
                            bbefore, bafter = bafter, bbefore
                        insertbytes = ""
                        bbefore += 1
                        while bbefore < bafter:
                            insertbytes += "%02x" % bbefore
                            bbefore += 1
                        newbadchars += insertbytes
                else:
                    newbadchars += curchar
                bpos += 2
            badchars = newbadchars

            cnt = 0
            excluded = []
            while cnt < len(badchars):
                excluded.append(self.hex2bin(badchars[cnt]+badchars[cnt+1]))
                cnt = cnt+2
        except:
            self.usage()
            return

        info("Generating table, excluding {:d} bad chars...".format(len(excluded)))
        arraytable = []
        binarray = bytearray()

        # handle range() last value
        if endval > startval:
            increment = 1
            endval += 1
        else:
            endval += -1
            increment = -1

        # create bytearray
        for thisval in range(startval,endval,increment):
            hexbyte = "{:02x}".format(thisval)
            binbyte = self.hex2bin(hexbyte)
            intbyte = self.hex2int(hexbyte)
            if not binbyte in excluded:
                arraytable.append(hexbyte)
                binarray.append(intbyte)

        info("Dumping table to file")
        output = ""
        cnt = 0
        outputline = '"'
        totalbytes = len(arraytable)
        tablecnt = 0
        while tablecnt < totalbytes:
            if (cnt < bytesperline):
                outputline += "\\x" + arraytable[tablecnt]
            else:
                outputline += '"\n'
                cnt = 0
                output += outputline
                outputline = '"\\x' + arraytable[tablecnt]
            tablecnt += 1
            cnt += 1
        if (cnt-1) < bytesperline:
            outputline += '"'
        output += outputline
        gef_print(output)

        if dump:
            binfilename = "bytearray.bin"
            arrayfile = "bytearray.txt"
            binfile = open(binfilename,"wb")
            binfile.write(binarray)
            binfile.close()

            txtfile = open(arrayfile,"w+")
            txtfile.write(output)
            txtfile.close()

            info("Done, wrote {:d} bytes to file {:s}".format(len(arraytable),arrayfile))
            info("Binary output saved in {:s}".format(binfilename))
        return

    def hex2bin(self, pattern):
        """Converts a hex string (\\x??\\x??\\x??\\x??) to real hex bytes
        Arguments: pattern - A string representing the bytes to convert
        Return: the bytes"""
        pattern = pattern.replace("\\x", "")
        pattern = pattern.replace("\"", "")
        pattern = pattern.replace("\'", "")
        return binascii.unhexlify(pattern)

    def cleanHex(self, hex):
        return "".join(filter(self.permitted_char, hex))

    def hex2int(self, hex):
        return int(hex,16)

    def permitted_char(self, s):
        if bool(re.match("^[A-Fa-f0-9.]", s)):
            return True
        else:
            return False


@register_command
class BincompareCommand(GenericCommand):
    """BincompareCommand: compare an binary file with the memory position looking for badchars."""
    _cmdline_ = "bincompare"
    _syntax_ = "{:s} [-h] -f FILE -a MEMORY_ADDRESS\n".format(_cmdline_)
    _syntax_ += "  -f FILE            specifies the binary file to be compared.\n"
    _syntax_ += "  -a MEMORY_ADDRESS  sepecifies the memory address."
    _category_ = "Misc"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        filename = None
        start_addr = None
        size = 0
        file_data = None
        memory_data = None

        try:
            opts, args = getopt.getopt(argv, "f:a:ch")
            for o, a in opts:
                if o == "-f":
                    filename = a
                elif o == "-a":
                    start_addr = int(gdb.parse_and_eval(a))
                elif o == "-h":
                    self.usage()
                    return
        except:
            self.usage()
            return

        if not filename or not start_addr:
            err("No file and/or address specified")
            return

        if not os.path.isfile(filename):
            err("Especified file '{:s}' not exists".format(filename))
            return

        f = open(filename, "rb")
        file_data = f.read()
        f.close()

        size = len(file_data)

        if size < 8:
            err("Error - file does not contain enough bytes (min 8 bytes needed)")
            return

        try:
            memory_data = read_memory(start_addr, size)
        except gdb.MemoryError:
            err("Cannot reach memory {:#x}".format(start_addr))
            return

        result_table = []
        badchars = ""
        cnt = 0
        corrupted = -1
        for eachByte in file_data:
            hexchar = "{:02x}".format(eachByte)
            if cnt > len(memory_data):
                result_table.append((hexchar, "--"))
                corrupted = -1
            elif eachByte == memory_data[cnt]:
                result_table.append((hexchar, "  "))
                corrupted = -1
            else:
                result_table.append((hexchar, "{:02x}".format(memory_data[cnt])))
                if len(badchars) == 0:
                    badchars = hexchar
                else:
                    badchars += ", " + hexchar
                if corrupted == -1:
                    corrupted = cnt
            cnt += 1

        line = 0

        info("Comparison result:")
        gef_print("    +-----------------------------------------------+")
        for line in range(0, len(result_table), 16):
            pdata1 = []
            pdata2 = []
            for i in range(line,line+16):
                if i < len(result_table):
                    pdata1.append(result_table[i][0])
                    pdata2.append(result_table[i][1])

            self.print_line("{:02x}".format(line), pdata1, "file")
            self.print_line("  ", pdata2, "memory")

        gef_print("    +-----------------------------------------------+")
        gef_print("")

        if corrupted > -1:
            info("Corruption after {:d} bytes".format(corrupted))

        if badchars == "":
            info("No badchars found!")
        else:
            info("Badchars found: {:s}".format(badchars))
        return

    def print_line(self, line, data, label):
        l = []
        for d in data:
            l.append(d)
        r = 16 - len(l)
        for i in range(0,r):
            l.append("--")

        gef_print(" {:s} |{:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s}| {:s}".format(line, *l, label))
        return


class FtraceEnterBreakpoint(gdb.Breakpoint):
    def __init__(self, location, nb_args, *args, **kwargs):
        super().__init__(location, gdb.BP_BREAKPOINT, internal=True)
        self.silent = True
        self.nb_args = nb_args
        self.retbp = None
        return

    def stop(self):
        regs = collections.OrderedDict()
        for r in current_arch.function_parameters[:self.nb_args]:
            regs[r] = get_register(r)
        self.retbp = FtraceExitBreakpoint(location=self.location, regs=regs)
        return False


class FtraceExitBreakpoint(gdb.FinishBreakpoint):
    def __init__(self, *args, **kwargs):
        super().__init__(gdb.newest_frame(), internal=True)
        self.silent = True
        self.args = kwargs
        return

    def stop(self):
        if self.return_value:
            retval = "{:#x}".format(int(self.return_value))
        else:
            retval = get_register(current_arch.return_register)

        output = get_gef_setting("ftrace.output")
        mode = "a"
        use_color = False

        if output is None:
            output = "/dev/stderr"
            mode = "w"
            use_color = True

        with open(output, "w") as fd:
            if use_color:
                fd.write("{:s}() = {} {{\n".format(Color.yellowify(self.args["location"]), retval))
            else:
                fd.write("{:s}() = {} {{\n".format(self.args["location"], retval))
            for reg in self.args["regs"].keys():
                regval = self.args["regs"][reg]
                fd.write("\t{} {} {}\n".format(reg, RIGHT_ARROW, RIGHT_ARROW.join(dereference_from(regval))))
            fd.write("}\n")
            fd.flush()
        return False


@register_command
class FtraceCommand(GenericCommand):
    """Tracks a function given in parameter for arguments and return code."""
    _cmdline_ = "ftrace"
    _syntax_ = "{:s} <function_name1>,<nb_args1> [<function_name2>,<nb_args2> ...]".format(_cmdline_)
    _category_ = "Debugging Support"

    def do_invoke(self, args):
        self.dont_repeat()

        if len(args) < 1:
            self.usage()
            return

        self.bkps = []

        for item in args:
            funcname, nb_args = item.split(",")
            self.bkps.append(FtraceEnterBreakpoint(funcname, int(nb_args)))
            ok("added '{}()' (with {} args) to tracking list".format(funcname, nb_args))

        gdb.events.exited.connect(self.cleanup)
        return

    def cleanup(self, events):
        for bp in self.bkps:
            if bp.retbp: bp.retbp.delete()
            bp.delete()
        gdb.events.exited.disconnect(self.cleanup)
        return


class GenericFunction(gdb.Function):
    """This is an abstract class for invoking convenience functions, should not be instantiated."""
    __metaclass__ = abc.ABCMeta

    @abc.abstractproperty
    def _function_(self):
        return

    @property
    def _syntax_(self):
        return "${}([offset])".format(self._function_)

    def __init__ (self):
        super().__init__(self._function_)
        return

    def invoke(self, *args):
        if not is_alive():
            raise gdb.GdbError("No debugging session active")
        return int(self.do_invoke(args))

    def arg_to_long(self, args, index, default=0):
        try:
            addr = args[index]
            return int(addr) if addr.address is None else int(addr.address)
        except IndexError:
            return default

    @abc.abstractmethod
    def do_invoke(self, args):
        return


@register_function
class StackOffsetFunction(GenericFunction):
    """Return the current stack base address plus an optional offset."""
    _function_ = "_stack"

    def do_invoke(self, args):
        return self.arg_to_long(args, 0) + get_section_base_address("[stack]")


@register_function
class HeapBaseFunction(GenericFunction):
    """Return the current heap base address plus an optional offset."""
    _function_ = "_heap"

    def do_invoke(self, args):
        base = HeapBaseFunction.heap_base()
        if not base:
            raise gdb.GdbError("Heap not found")

        return self.arg_to_long(args, 0) + base

    @staticmethod
    def heap_base():
        try:
            base = parse_address("mp_->sbrk_base")
            if base != 0:
                return base
        except gdb.error:
            pass
        return get_section_base_address("[heap]")


@register_function
class SectionBaseFunction(GenericFunction):
    """Return the matching section's base address plus an optional offset."""
    _function_ = "_base"

    def do_invoke(self, args):
        try:
            name = args[0].string()
        except IndexError:
            name = get_filename()
        except gdb.error:
            err("Invalid arg: {}".format(args[0]))
            return 0

        try:
            addr = int(get_section_base_address(name))
        except TypeError:
            err("Cannot find section {}".format(name))
            return 0
        return addr


@register_function
class BssBaseFunction(GenericFunction):
    """Return the current bss base address plus the given offset."""
    _function_ = "_bss"

    def do_invoke(self, args):
        return self.arg_to_long(args, 0) + get_zone_base_address(".bss")


@register_function
class GotBaseFunction(GenericFunction):
    """Return the current bss base address plus the given offset."""
    _function_ = "_got"

    def do_invoke(self, args):
        return self.arg_to_long(args, 0) + get_zone_base_address(".got")


@register_command
class GefFunctionsCommand(GenericCommand):
    """List the convenience functions provided by GEF."""
    _cmdline_ = "functions"
    _syntax_ = _cmdline_
    _category_ = "Misc"

    def __init__(self):
        super().__init__()
        self.docs = []
        self.setup()
        return

    def setup(self):
        global __gef__
        for function in __gef__.loaded_functions:
            self.add_function_to_doc(function)
        self.__doc__ = "\n".join(sorted(self.docs))
        return

    def add_function_to_doc(self, function):
        """Add function to documentation."""
        doc = getattr(function, "__doc__", "").lstrip()
        doc = "\n                         ".join(doc.split("\n"))
        syntax = getattr(function, "_syntax_", "").lstrip()
        msg = "{syntax:<25s} -- {help:s}".format(syntax=syntax, help=Color.greenify(doc))
        self.docs.append(msg)
        return

    def do_invoke(self, argv):
        self.dont_repeat()
        gef_print(titlify("GEF - Convenience Functions"))
        gef_print("These functions can be used as arguments to other "
                  "commands to dynamically calculate values, eg: {:s}\n"
                  .format(Color.colorify("deref $_heap(0x20)", "yellow")))
        gef_print(self.__doc__)
        return


class GefCommand(gdb.Command):
    """GEF main command: view all new commands by typing `gef`."""
    _cmdline_ = "gef"
    _syntax_ = "{:s} (missing|config|save|restore|set|run)".format(_cmdline_)
    _category_ = "GEF Maintenance Command"

    def __init__(self):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, True)
        set_gef_setting("gef.follow_child", True, bool, "Automatically set GDB to follow child when forking")
        set_gef_setting("gef.readline_compat", False, bool, "Workaround for readline SOH/ETX issue (SEGV)")
        set_gef_setting("gef.debug", True, bool, "Enable debug mode for gef")
        set_gef_setting("gef.autosave_breakpoints_file", "", str, "Automatically save and restore breakpoints")
        set_gef_setting("gef.extra_plugins_dir", "", str, "Autoload additional GEF commands from external directory")
        set_gef_setting("gef.disable_color", False, bool, "Disable all colors in GEF")
        set_gef_setting("gef.tempdir", GEF_TEMP_DIR, str, "Directory to use for temporary/cache content")
        self.loaded_commands = []
        self.loaded_functions = []
        self.missing_commands = {}
        return

    def setup(self):
        self.load(initial=True)
        # loading GEF sub-commands
        self.doc = GefHelpCommand(self.loaded_commands)
        self.cfg = GefConfigCommand(self.loaded_command_names)
        GefSaveCommand()
        GefRestoreCommand()
        GefMissingCommand()
        GefSetCommand()
        GefRunCommand()

        # load the saved settings
        gdb.execute("gef restore")

        # restore the autosave/autoreload breakpoints policy (if any)
        self.__reload_auto_breakpoints()

        # load plugins from `extra_plugins_dir`
        if self.__load_extra_plugins() > 0:
            # if here, at least one extra plugin was loaded, so we need to restore
            # the settings once more
            gdb.execute("gef restore quiet")
        return

    def __reload_auto_breakpoints(self):
        bkp_fname = __config__.get("gef.autosave_breakpoints_file", None)
        bkp_fname = bkp_fname[0] if bkp_fname else None
        if bkp_fname:
            # restore if existing
            if os.access(bkp_fname, os.R_OK):
                gdb.execute("source {:s}".format(bkp_fname))

            # add hook for autosave breakpoints on quit command
            source = [
                "define hook-quit",
                " save breakpoints {:s}".format(bkp_fname),
                "end",
            ]
            gef_execute_gdb_script("\n".join(source) + "\n")
        return

    def __load_extra_plugins(self):
        nb_added = -1
        try:
            nb_inital = len(self.loaded_commands)
            directories = get_gef_setting("gef.extra_plugins_dir")
            if directories:
                for directory in directories.split(";"):
                    directory = os.path.realpath(os.path.expanduser(directory))
                    if os.path.isdir(directory):
                        sys.path.append(directory)
                        for fname in os.listdir(directory):
                            if not fname.endswith(".py"): continue
                            fpath = "{:s}/{:s}".format(directory, fname)
                            if os.path.isfile(fpath):
                                gdb.execute("source {:s}".format(fpath))
            nb_added = len(self.loaded_commands) - nb_inital
            if nb_added > 0:
                ok("{:s} extra commands added from '{:s}'".format(Color.colorify(nb_added, "bold green"),
                                                                  Color.colorify(directories, "bold blue")))
        except gdb.error as e:
            err("failed: {}".format(str(e)))
        return nb_added

    @property
    def loaded_command_names(self):
        return [x[0] for x in self.loaded_commands]

    def invoke(self, args, from_tty):
        self.dont_repeat()
        gdb.execute("gef help")
        return

    def load(self, initial=False):
        """Load all the commands and functions defined by GEF into GDB."""
        nb_missing = 0
        self.commands = [(x._cmdline_, x) for x in __commands__]

        # load all of the functions
        for function_class_name in __functions__:
            self.loaded_functions.append(function_class_name())

        def is_loaded(x):
            return any(filter(lambda u: x == u[0], self.loaded_commands))

        for cmd, class_name in self.commands:
            if is_loaded(cmd):
                continue

            try:
                self.loaded_commands.append((cmd, class_name, class_name()))

                repeat = False
                if hasattr(class_name,"_repeat_"):
                    repeat = getattr(class_name, "_repeat_")

                if hasattr(class_name, "_aliases_"):
                    aliases = getattr(class_name, "_aliases_")
                    for alias in aliases:
                        GefAlias(alias, cmd, repeat=repeat)

            except Exception as reason:
                self.missing_commands[cmd] = reason
                nb_missing += 1

        # sort by command name
        self.loaded_commands = sorted(self.loaded_commands, key=lambda x: x[1]._cmdline_)

        if initial:
            gef_print("{:s} for {:s} ready, type `{:s}' to start, `{:s}' to configure".format(
                Color.greenify("GEF"),
                get_os(),
                Color.colorify("gef","underline yellow"),
                Color.colorify("gef config", "underline pink")
            ))

            ver = "{:d}.{:d}".format(sys.version_info.major, sys.version_info.minor)
            nb_cmds = len(self.loaded_commands)
            gef_print("{:s} commands loaded for GDB {:s} using Python engine {:s}".format(
                Color.colorify(nb_cmds, "bold green"),
                Color.colorify(gdb.VERSION, "bold yellow"),
                Color.colorify(ver, "bold red")
            ))

            if nb_missing:
                warn("{:s} command{} could not be loaded, run `{:s}` to know why.".format(
                    Color.colorify(nb_missing, "bold red"),
                    "s" if nb_missing > 1 else "",
                    Color.colorify("gef missing", "underline pink")
                ))
        return


class GefHelpCommand(gdb.Command):
    """GEF help sub-command."""
    _cmdline_ = "gef help"
    _syntax_ = _cmdline_
    _category_ = "GEF Maintenance Command"

    def __init__(self, commands, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)
        self.docs = []
        self.generate_help(commands)
        self.refresh()
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        gef_print(titlify("GEF - GDB Enhanced Features"))
        gef_print(self.__doc__)
        return

    def generate_help(self, commands):
        """Generate builtin commands documentation."""
        for command in commands:
            self.add_command_to_doc(command)
        return

    def add_command_to_doc(self, command):
        """Add command to GEF documentation."""
        cmd, class_name, _ = command
        if " " in cmd:
            # do not print subcommands in gef help
            return
        doc = getattr(class_name, "__doc__", "").lstrip()
        doc = "\n                         ".join(doc.split("\n"))
        aliases = " (alias: {:s})".format(", ".join(class_name._aliases_)) if hasattr(class_name, "_aliases_") else ""
        msg = "  {cmd:<23s} -- {help:s}{aliases:s}".format(cmd=cmd, help=Color.greenify(doc), aliases=aliases)
        category = class_name._category_ if hasattr(class_name, "_category_") else "Uncategorized"
        self.docs.append([category, msg])
        return

    def refresh(self):
        """Refresh the documentation."""
        newdoc = ""
        old_category = None
        for category, msg in sorted(self.docs):
            if old_category != category:
                newdoc += "[{:s}]\n".format(Color.colorify(category, "bold yellow"))
            old_category = category
            newdoc += msg + "\n"
        self.__doc__ = newdoc.rstrip()
        return


class GefConfigCommand(gdb.Command):
    """GEF configuration sub-command
    This command will help set/view GEF settings for the current debugging session.
    It is possible to make those changes permanent by running `gef save` (refer
    to this command help), and/or restore previously saved settings by running
    `gef restore` (refer help)."""
    _cmdline_ = "gef config"
    _syntax_ = "{:s} [setting_name] [setting_value]".format(_cmdline_)
    _category_ = "GEF Maintenance Command"

    def __init__(self, loaded_commands, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_NONE, prefix=False)
        self.loaded_commands = loaded_commands
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        argv = gdb.string_to_argv(args)
        argc = len(argv)

        if not (0 <= argc <= 2):
            err("Invalid number of arguments")
            return

        if argc == 0:
            gef_print(titlify("GEF configuration settings"))
            self.print_settings()
            return

        if argc == 1:
            prefix = argv[0]
            names = list(filter(lambda x: x.startswith(prefix), __config__.keys()))
            if names:
                if len(names) == 1:
                    gef_print(titlify("GEF configuration setting: {:s}".format(names[0])))
                    self.print_setting(names[0], verbose=True)
                else:
                    gef_print(titlify("GEF configuration settings matching '{:s}'".format(argv[0])))
                    for name in names: self.print_setting(name)
            return

        self.set_setting(argc, argv)
        return

    def print_setting(self, plugin_name, verbose=False):
        res = __config__.get(plugin_name)
        string_color = get_gef_setting("theme.dereference_string")
        misc_color = get_gef_setting("theme.dereference_base_address")

        if not res:
            return

        _value, _type, _desc = res
        _setting = Color.colorify(plugin_name, "green")
        _type = _type.__name__
        if _type == "str":
            _value = '"{:s}"'.format(Color.colorify(_value, string_color))
        else:
            _value = Color.colorify(_value, misc_color)

        gef_print("{:s} ({:s}) = {:s}".format(_setting, _type, _value))

        if verbose:
            gef_print(Color.colorify("\nDescription:", "bold underline"))
            gef_print("\t{:s}".format(_desc))
        return

    def print_settings(self):
        for x in sorted(__config__):
            self.print_setting(x)
        return

    def set_setting(self, argc, argv):
        global __gef__
        if "." not in argv[0]:
            err("Invalid command format")
            return

        loaded_commands = [ x[0] for x in __gef__.loaded_commands ] + ["gef"]
        plugin_name = argv[0].split(".", 1)[0]
        if plugin_name not in loaded_commands:
            err("Unknown plugin '{:s}'".format(plugin_name))
            return

        _type = __config__.get(argv[0], [None, None, None])[1]
        if _type is None:
            err("Failed to get '{:s}' config setting".format(argv[0],))
            return

        try:
            if _type == bool:
                _newval = True if argv[1].upper() in ("TRUE", "T", "1") else False
            else:
                _newval = _type(argv[1])

        except Exception:
            err("{} expects type '{}'".format(argv[0], _type.__name__))
            return

        reset_all_caches()
        __config__[argv[0]][0] = _newval
        get_gef_setting.cache_clear()
        return

    def complete(self, text, word):
        settings = sorted(__config__)

        if text == "":
            # no prefix: example: `gef config TAB`
            return [s for s in settings if word in s]

        if "." not in text:
            # if looking for possible prefix
            return [s for s in settings if s.startswith(text.strip())]

        # finally, look for possible values for given prefix
        return [s.split(".", 1)[1] for s in settings if s.startswith(text.strip())]


class GefSaveCommand(gdb.Command):
    """GEF save sub-command.
    Saves the current configuration of GEF to disk (by default in file '~/.gef.rc')."""
    _cmdline_ = "gef save"
    _syntax_ = _cmdline_

    def __init__(self, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        cfg = configparser.RawConfigParser()
        old_sect = None

        # save the configuration
        for key in sorted(__config__):
            sect, optname = key.split(".", 1)
            value = __config__.get(key, None)
            value = value[0] if value else None

            if old_sect != sect:
                cfg.add_section(sect)
                old_sect = sect

            cfg.set(sect, optname, value)

        # save the aliases
        cfg.add_section("aliases")
        for alias in __aliases__:
            cfg.set("aliases", alias._alias, alias._command)

        with open(GEF_RC, "w") as fd:
            cfg.write(fd)

        ok("Configuration saved to '{:s}'".format(GEF_RC))
        return


class GefRestoreCommand(gdb.Command):
    """GEF restore sub-command.
    Loads settings from file '~/.gef.rc' and apply them to the configuration of GEF."""
    _cmdline_ = "gef restore"
    _syntax_ = _cmdline_

    def __init__(self, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        if not os.access(GEF_RC, os.R_OK):
            return

        quiet = args.lower() == "quiet"
        cfg = configparser.ConfigParser()
        cfg.read(GEF_RC)

        for section in cfg.sections():
            if section == "aliases":
                # load the aliases
                for key in cfg.options(section):
                    try:
                        GefAlias(key, cfg.get(section, key))
                    except:
                        pass
                continue

            # load the other options
            for optname in cfg.options(section):
                try:
                    key = "{:s}.{:s}".format(section, optname)
                    _type = __config__.get(key)[1]
                    new_value = cfg.get(section, optname)
                    if _type == bool:
                        new_value = True if new_value == "True" else False
                    else:
                        new_value = _type(new_value)
                    __config__[key][0] = new_value
                except Exception:
                    pass

        # ensure that the temporary directory always exists
        gef_makedirs(__config__["gef.tempdir"][0])

        if not quiet:
            ok("Configuration from '{:s}' restored".format(Color.colorify(GEF_RC, "bold blue")))
        return


class GefMissingCommand(gdb.Command):
    """GEF missing sub-command.
    Display the GEF commands that could not be loaded, along with the reason of why
    they could not be loaded."""
    _cmdline_ = "gef missing"
    _syntax_ = _cmdline_

    def __init__(self, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        missing_commands = __gef__.missing_commands.keys()
        if not missing_commands:
            ok("No missing command")
            return
        for missing_command in missing_commands:
            reason = __gef__.missing_commands[missing_command]
            warn("Command `{}` is missing, reason {} {}".format(missing_command, RIGHT_ARROW, reason))
        return


class GefSetCommand(gdb.Command):
    """Override GDB set commands with the context from GEF."""
    _cmdline_ = "gef set"
    _syntax_ = "{:s} [GDB_SET_ARGUMENTS]".format(_cmdline_)

    def __init__(self, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_SYMBOL, False)
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        args = args.split()
        cmd = ["set", args[0],]
        for p in args[1:]:
            if p.startswith("$_gef"):
                c = gdb.parse_and_eval(p)
                cmd.append(c.string())
            else:
                cmd.append(p)

        gdb.execute(" ".join(cmd))
        return


class GefRunCommand(gdb.Command):
    """Override GDB run commands with the context from GEF.
    Simple wrapper for GDB run command to use arguments set from `gef set args`. """
    _cmdline_ = "gef run"
    _syntax_ = "{:s} [GDB_RUN_ARGUMENTS]".format(_cmdline_)

    def __init__(self, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_FILENAME, False)
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        if is_alive():
            gdb.execute("continue")
            return

        argv = args.split()
        gdb.execute("gef set args {:s}".format(" ".join(argv)))
        gdb.execute("run")
        return


class GefAlias(gdb.Command):
    """Simple aliasing wrapper because GDB doesn't do what it should."""
    def __init__(self, alias, command, repeat=False, completer_class=gdb.COMPLETE_NONE, command_class=gdb.COMMAND_NONE):
        p = command.split()
        if not p:
            return

        if list(filter(lambda x: x._alias == alias, __aliases__)):
            return

        self._command = command
        self._alias = alias
        self._repeat = repeat
        c = command.split()[0]
        r = self.lookup_command(c)
        self.__doc__ = "Alias for '{}'".format(Color.greenify(command))
        if r is not None:
            _instance = r[2]
            self.__doc__ += ": {}".format(_instance.__doc__)

            if hasattr(_instance, "complete"):
                self.complete = _instance.complete

        super().__init__(alias, command_class, completer_class=completer_class)
        __aliases__.append(self)
        return

    def invoke(self, args, from_tty):
        if not self._repeat:
            self.dont_repeat()
        gdb.execute("{} {}".format(self._command, args), from_tty=from_tty)
        return

    def lookup_command(self, cmd):
        global __gef__
        for _name, _class, _instance in __gef__.loaded_commands:
            if cmd == _name:
                return _name, _class, _instance
        return None


@register_command
class AliasesCommand(GenericCommand):
    """Base command to add, remove, or list aliases."""
    _cmdline_ = "aliases"
    _syntax_  = "{:s} (add|rm|ls)".format(_cmdline_)
    _category_ = "GEF Maintenance Command"

    def __init__(self):
        super().__init__(prefix=True)
        return

    def do_invoke(self, argv):
        self.dont_repeat()
        self.usage()
        return


@register_command
class AliasesAddCommand(AliasesCommand):
    """Command to add aliases."""
    _cmdline_ = "aliases add"
    _syntax_  = "{:s} [ALIAS] [COMMAND]".format(_cmdline_)
    _example_ = "{:s} scope telescope".format(_cmdline_)
    _category_ = "GEF Maintenance Command"

    def __init__(self):
        super().__init__()
        return

    def do_invoke(self, argv):
        self.dont_repeat()
        if (len(argv) < 2):
            self.usage()
            return
        GefAlias(argv[0], " ".join(argv[1:]))
        return


@register_command
class AliasesRmCommand(AliasesCommand):
    """Command to remove aliases."""
    _cmdline_ = "aliases rm"
    _syntax_ = "{:s} [ALIAS]".format(_cmdline_)
    _category_ = "GEF Maintenance Command"

    def __init__(self):
        super().__init__()
        return

    def do_invoke(self, argv):
        self.dont_repeat()
        global __aliases__
        if len(argv) != 1:
            self.usage()
            return
        try:
            alias_to_remove = next(filter(lambda x: x._alias == argv[0], __aliases__))
            __aliases__.remove(alias_to_remove)
        except (ValueError, StopIteration) as e:
            err("{0} not found in aliases.".format(argv[0]))
            return
        gef_print("You must reload GEF for alias removals to apply.")
        return


@register_command
class AliasesListCommand(AliasesCommand):
    """Command to list aliases."""
    _cmdline_ = "aliases ls"
    _syntax_ = _cmdline_
    _category_ = "GEF Maintenance Command"

    def __init__(self):
        super().__init__()
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        ok("Aliases defined:")
        for a in __aliases__:
            gef_print("{:30s} {} {}".format(a._alias, RIGHT_ARROW, a._command))
        return


class GefTmuxSetup(gdb.Command):
    """Setup a confortable tmux debugging environment."""
    def __init__(self):
        super().__init__("tmux-setup", gdb.COMMAND_NONE, gdb.COMPLETE_NONE)
        GefAlias("screen-setup", "tmux-setup")
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()

        tmux = os.getenv("TMUX")
        if tmux:
            self.tmux_setup()
            return
        screen = os.getenv("TERM")
        if screen is not None and screen == "screen":
            self.screen_setup()
            return
        warn("Not in a tmux/screen session")
        return

    def tmux_setup(self):
        """Prepare the tmux environment by vertically splitting the current pane, and
        forcing the context to be redirected there."""
        try:
            tmux = which("tmux")
        except FileNotFoundError as e:
            err("{}".format(e))
            return

        ok("tmux session found, splitting window...")
        old_ptses = set(os.listdir("/dev/pts"))
        gdb.execute("! {} split-window -h 'clear ; cat'".format(tmux))
        gdb.execute("! {} select-pane -L".format(tmux))
        new_ptses = set(os.listdir("/dev/pts"))
        pty = list(new_ptses - old_ptses)[0]
        pty = "/dev/pts/{}".format(pty)
        ok("Setting `context.redirect` to '{}'...".format(pty))
        gdb.execute("gef config context.redirect {}".format(pty))
        ok("Done!")
        return

    def screen_setup(self):
        """Hackish equivalent of the tmux_setup() function for screen."""
        try:
            screen = which("screen")
        except FileNotFoundError as e:
            err("{}".format(e))
            return

        sty = os.getenv("STY")
        ok("screen session found, splitting window...")
        fd_script, script_path = tempfile.mkstemp()
        fd_tty, tty_path = tempfile.mkstemp()
        os.close(fd_tty)

        with os.fdopen(fd_script, "w") as f:
            f.write("startup_message off\n")
            f.write("split -v\n")
            f.write("focus right\n")
            f.write("screen bash -c 'tty > {}; clear; cat'\n".format(tty_path))
            f.write("focus left\n")

        gdb.execute("""! {} -r {} -m -d -X source {}""".format(screen, sty, script_path))
        # artificial delay to make sure `tty_path` is populated
        time.sleep(0.25)
        with open(tty_path, "r") as f:
            pty = f.read().strip()
        ok("Setting `context.redirect` to '{}'...".format(pty))
        gdb.execute("gef config context.redirect {}".format(pty))
        ok("Done!")
        os.unlink(script_path)
        os.unlink(tty_path)
        return


def __gef_prompt__(current_prompt):
    """GEF custom prompt function."""
    if get_gef_setting("gef.readline_compat") is True: return GEF_PROMPT
    if get_gef_setting("gef.disable_color") is True: return GEF_PROMPT
    if is_alive(): return GEF_PROMPT_ON
    return GEF_PROMPT_OFF


if __name__ == "__main__":

    if sys.version_info[0] == 2:
        err("GEF has dropped Python2 support for GDB when it reached EOL on 2020/01/01.")
        err("If you require GEF for GDB+Python2, use https://github.com/hugsy/gef-legacy.")

    elif GDB_VERSION < GDB_MIN_VERSION:
        err("You're using an old version of GDB. GEF will not work correctly. "
            "Consider updating to GDB {} or higher.".format(".".join(map(str, GDB_MIN_VERSION))))

    else:
        try:
            pyenv = which("pyenv")
            PYENV_ROOT = gef_pystring(subprocess.check_output([pyenv, "root"]).strip())
            PYENV_VERSION = gef_pystring(subprocess.check_output([pyenv, "version-name"]).strip())
            site_packages_dir = os.path.join(PYENV_ROOT, "versions", PYENV_VERSION, "lib",
                                             "python{}".format(PYENV_VERSION[:3]), "site-packages")
            site.addsitedir(site_packages_dir)
        except FileNotFoundError as e:
            pass

        # When using a Python virtual environment, GDB still loads the system-installed Python
        # so GEF doesn't load site-packages dir from environment
        # In order to fix it, from the shell with venv activated we run the python binary,
        # take and parse its path, add the path to the current python process using sys.path.extend

        try:
            pythonbin = which("python3")
            cmds = [pythonbin, '-c', 'import os, sys;print((sys.prefix))']
            PREFIX = gef_pystring(subprocess.check_output(cmds)).strip("\\n")
            if PREFIX != sys.base_prefix:
                cmds = [pythonbin, "-c", "import os, sys;print(os.linesep.join(sys.path).strip())"]
                SITE_PACKAGES_DIRS = subprocess.check_output(cmds).decode("utf-8").split()
                sys.path.extend(SITE_PACKAGES_DIRS)
        except FileNotFoundError as e:
            pass

        # setup prompt
        gdb.prompt_hook = __gef_prompt__

        # setup config
        gdb.execute("set confirm off")
        gdb.execute("set verbose off")
        gdb.execute("set pagination off")
        gdb.execute("set print elements 0")

        # gdb history
        gdb.execute("set history save on")
        gdb.execute("set history filename ~/.gdb_history")

        # gdb input and output bases
        gdb.execute("set output-radix 0x10")

        # pretty print
        gdb.execute("set print pretty on")

        # array print
        gdb.execute("set print array on")
        gdb.execute("set print array-indexes on")

        try:
            # this will raise a gdb.error unless we're on x86
            gdb.execute("set disassembly-flavor intel")
        except gdb.error:
            # we can safely ignore this
            pass

        # SIGALRM will simply display a message, but gdb won't forward the signal to the process
        gdb.execute("handle SIGALRM print nopass")

        # SIGSEGV/SIGTERM/SIG32(for thread creation)
        gdb.execute("handle SIGSEGV print nopass")
        gdb.execute("handle SIGTERM print nopass")
        gdb.execute("handle SIG32 nostop")

        # demangle
        gdb.execute("set print asm-demangle on")

        # frame args
        gdb.execute("set print frame-arguments all")

        # object/vtbl
        gdb.execute("set print object on")
        gdb.execute("set print vtbl on")

        # load GEF
        __gef__ = GefCommand()
        __gef__.setup()

        gdb.execute("save gdb-index {}".format(get_gef_setting("gef.tempdir")))

        # gdb events configuration
        gef_on_continue_hook(continue_handler)
        gef_on_stop_hook(hook_stop_handler)
        gef_on_new_hook(new_objfile_handler)
        gef_on_exit_hook(exit_handler)
        gef_on_memchanged_hook(memchanged_handler)
        gef_on_regchanged_hook(regchanged_handler)

        if gdb.current_progspace().filename is not None:
            # if here, we are sourcing gef from a gdb session already attached
            # we must force a call to the new_objfile handler (see issue #278)
            new_objfile_handler(None)

        GefTmuxSetup()
